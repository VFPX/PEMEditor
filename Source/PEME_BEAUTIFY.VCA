SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2YD0B633A
[CLASS] basecustom
[CLASSLOC] peme_basecontrols.vcx
[BASECLASS] custom
[OBJNAME] basebeautify
[START PROPERTIES]
Name = "basebeautify"
[END PROPERTIES]
[START METHODS]
PROCEDURE addwhitespace
Lparameters lcLine, lnDestColumn

Local laLines(1), llOneAdded, lnColumn, lnI, lnLineCount, lnWithTabs 

lcLine = This.TrimTrailingWhiteSpace (lcLine)
lnColumn = This.CountCharacterWidth (lcLine)

Do While lnColumn < lnDestColumn - 1
	llOneAdded = .T.
	lnWithTabs = lnColumn + This.nTabWidth - lnColumn % This.nTabWidth
	If This.oPrefs.lUseTabs and lnWithTabs < lnDestColumn
		lcLine = lcLine + Tab
		lnColumn = lnWithTabs
	Else
		lcLine = lcLine + ' '
		lnColumn = lnColumn + 1
	Endif
Enddo

Return lcLine + IIF (llOneAdded, '', ' ')


ENDPROC
PROCEDURE countcharacterwidth
Lparameters lcLine

Local laLines(1), lnColumn, lnI, lnLineCount

*** JRN 2010-06-08 : adding a single character at end so trailing tab is not ignored
lnLineCount = Alines (laLines, lcLine + '?', .F., Tab)
lnColumn = 0

For lnI = 1 To lnLineCount
	lnColumn = lnColumn + Len (laLines (lnI))
	If lnI < lnLineCount
		lnColumn = lnColumn + This.nTabWidth - lnColumn % This.nTabWidth
	Endif
Endfor

Return lnColumn - 1
ENDPROC
PROCEDURE countparens
Lparameters lcLine

* Returns incremental count of parenthesis within this line ...
*   add one for each left paren, subtract one for each right paren

Local lcRestLineString, lcThisChar, lnCharPos, lnCharscount, lnClosingCharPosition, lnResult 

lnResult = 0
lnCharscount = Len (lcLine)
For lnCharPos = 1 To lnCharscount

	lcThisChar = Substr (lcLine, lnCharPos, 1)

	Do Case

		Case lcThisChar = ['] Or lcThisChar = ["] Or						;
				(lcThisChar = '[' And Not This.IsNameChar (Right (This.TrimTrailingWhiteSpace (Left (lcLine, lnCharPos - 1)), 1)))
			* Grab entire character string
			lcRestLineString = Substr (lcLine, lnCharPos + 1)
			lnClosingCharPosition = At (IIf (lcThisChar = '[', ']', lcThisChar), lcRestLineString)
			lnCharPos = lnCharPos + lnClosingCharPosition

		Case Substr (lcLine, lnCharPos, 2) = INLINECOMMENTS
			Exit

		Case lcThisChar $ '(['
			lnResult = lnResult + 1

		Case lcThisChar $ '])'
			lnResult = lnResult - 1

	Endcase

Endfor

Return lnResult


ENDPROC
PROCEDURE findbeforeas
Lparameters lcLine
Local lcLeft, lcRight, lnCounter, lnPos

For lnCounter = 1 To 1000
	lnPos = Rat ('AS', Upper (lcLine), lnCounter)
	Do Case
		Case lnPos <= 1
			Return ''
		Case Substr (lcLine, lnPos - 1, 1) $ BLANKS + ')' And Substr (lcLine, lnPos + 2, 1) ISABLANK
			lcLeft = Left (lcLine, lnPos - 1)
			lcRight = Substr (lcLine, lnPos)
			If INLINECOMMENTS $ lcRight
				lcRight = Left (lcRight, At (INLINECOMMENTS, lcRight) - 1)
			Else
				lcRight = lcRight
			Endif

			If Not (')' $ lcRight Or '(' $ lcRight Or '.' $ lcRight)
				Return lcLeft
			Endif
	Endcase
Endfor

ENDPROC
PROCEDURE fixascolumn
Lparameters lcLine, lnDestColumn
Local lcLeft, lcRight, lcRightNoComments

lcLeft = This.FindBeforeAS (lcLine)
If 0 = Len (lcLeft)
	Return lcLine
Endif

lcRight = Substr (lcLine, 1 + Len (lcLeft))
If Not Right (lcLine,1) ISABLANK
	lcLine = lcLine + ' '
Endif

Return This.AddWhiteSpace (lcLeft, lnDestColumn) + lcRight

ENDPROC
PROCEDURE fixsemicoloncolumn
Lparameters lcLine, lnDestColumn
Local lcExecutable, lcRight, lnEOL 

lnEOL = Evl (At (INLINECOMMENTS, lcLine), Len (lcLine) + 1)
lcExecutable = This.TrimTrailingWhiteSpace (Left (lcLine, lnEOL - 1))
If Right (lcExecutable, 1) # ';'
	Return lcLine
Endif

lcRight = Substr (lcLine, Len (lcExecutable))
lcLine = Left (lcLine, Len (lcExecutable) - 1)
lcLine = This.AddWhiteSpace (lcLine, lnDestColumn)
Return lcLine + lcRight

ENDPROC
PROCEDURE getcontinuationchar
Lparameters lcLine, llComment
* Returns:
* 	' ' for no continuation
*	';' for continuation of a code line
*	'*' for continuation of a comment line
Local lnPos 

Do Case
	Case Right (This.TrimTrailingWhiteSpace (lcLine), 1) = ';'
		If llComment Or Getwordnum (lcLine,1) = '*' Or ('&' + '&') $ lcLine
			Return '*'
		Else
			Return ';'
		Endif
	Case  ('&' + '&') $ lcLine
		lnPos = At (('&' + '&'), lcLine)
		lcLine = Left (lcLine, lnPos - 1)
		If Right (This.TrimTrailingWhiteSpace (lcLine), 1) = ';'
			Return ';'
		Else
			Return ' '
		Endif
	Otherwise
		Return ' '
Endcase

ENDPROC
PROCEDURE getindent
Lparameters lcline
Local lcChar, lcIndent, lnI

lcIndent = ''
For lnI = 1 To Len (lcline)
	lcChar = Substr (lcline, lnI, 1)
	If lcChar ISABLANK
		lcIndent = lcIndent + lcChar
	Else
		Exit
	Endif
Endfor

Return lcIndent

ENDPROC
PROCEDURE isnamechar
Lparameters lcChar

Return Isalpha (lcChar) Or Isdigit (lcChar) Or lcChar = '_'

ENDPROC
PROCEDURE lastcharin
Lparameters lcLine
* returns last character, other then whitespace or semi-colon
Local lcRight, lnPos
If INLINECOMMENTS $ lcLine
	lnPos = At (INLINECOMMENTS, lcLine)
	lcLine = Left (lcLine, lnPos - 1)
Endif

lcLine = This.TrimTrailingWhiteSpace (lcLine)
lcRight = Right (lcLine, 1)
If lcRight = ';'
	lcRight = Right (This.TrimTrailingWhiteSpace (Left (lcLine, Len (lcLine) - 1)), 1)
Endif

Return lcRight

ENDPROC
PROCEDURE trimleadingwhitespace
Lparameters lcText

Do While Left (lcText, 1) ISABLANK
	lcText = Right (lcText, Len (lcText) -1)
Enddo

Return lcText

ENDPROC
PROCEDURE trimtrailingwhitespace
Lparameters lcText

Do While Right (lcText, 1) ISABLANK
	lcText = Left (lcText, Len (lcText) -1)
Enddo

Return lcText

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addwhitespace 
*countcharacterwidth 
*countparens 
*findbeforeas Returns portion of the line that precedes AS
*fixascolumn 
*fixsemicoloncolumn 
*getcontinuationchar 
*getindent 
*lastcharin 
*trimleadingwhitespace 
*trimtrailingwhitespace 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
editpropertydialog.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] basebeautify

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2XF1ABDGK
[CLASS] basebeautify
[CLASSLOC] peme_beautify.vcx
[BASECLASS] custom
[OBJNAME] beautify
[START PROPERTIES]
Name = "beautify"
_memberdata =     2009<VFPData><memberdata name="onativebeautify" display="oNativeBeautify"/><memberdata name="oprefs" display="oPrefs"/><memberdata name="oeditorwin" display="oEditorWin"/><memberdata name="outils" display="oUtils"/><memberdata name="geteditorwindowtext" display="GetEditorWindowText"/><memberdata name="nselstart" display="nSelStart"/><memberdata name="nselend" display="nSelEnd"/><memberdata name="getparameterslist" display="GetParametersList"/><memberdata name="getidlist" display="GetIDList"/><memberdata name="idlistsetup" display="IDListSetup"/><memberdata name="parselineforidlist" display="ParseLineForIDList"/><memberdata name="insertidothers" display="InsertIDOthers"/><memberdata name="createidlistsummary" display="CreateIDListSummary"/><memberdata name="createidlistcursors" display="CreateIDListCursors"/><memberdata name="insertid" display="InsertID"/><memberdata name="peme_createidlist" display="PEME_CreateIDList"/><memberdata name="createidlist" display="CreateIDList"/><memberdata name="lfieldreference" display="lFieldReference"/><memberdata name="insertconstants" display="InsertConstants"/><memberdata name="getconstants" display="GetConstants"/><memberdata name="peme_createobjectidlist" display="PEME_CreateObjectIDList"/><memberdata name="doformidlist" display="DoFormIDList"/><memberdata name="addobjectidlist" display="AddObjectIDList"/><memberdata name="insertlocalids" display="InsertLocalIDs"/><memberdata name="getprocedurestartpositions" display="GetProcedureStartPositions"/><memberdata name="converttabsforindent" display="ConvertTabsForIndent"/><memberdata name="doidlisttext" display="DoIDListText"/><memberdata name="laddmdots" display="lAddMDots"/><memberdata name="nmdotsusage" display="nMDotsUsage"/><memberdata name="lreturns" display="lRETURNS"/><memberdata name="beautifyword" display="BeautifyWord"/><memberdata name="lapplyckl" display="lApplyCKL"/><memberdata name="laddtockl" display="lAddtoCKL"/><memberdata name="lautoaddtockl" display="lAutoAddtoCKL"/></VFPData>
cbeautifyoptions = 
ccurrentlocals = 
ccurrentwithendwith = .F.
clocalsplugin = 
clocalstatement = 
cpluginbeautifyselect = 
cpluginisoperator = 
csystemmemoryvariables = 
laddmdots = .F.
laddtockl = .F.
lapplyckl = .F.
lautoaddtockl = .F.
lfieldreference = .F.
lnodotsinassignments = .F.
lreturns = .F.
ltestselect = .F.
nafterwithcolumn = 0
nbeautifyselectiontype = 2
ncharsafterset = .F.
nlocalslist = 
nmdotsusage = 0
nnewlocalscount = 0
nselend = 0
nselstart = 0
ntabwidth = 1
nwithendwithlevel = 0
oeditorwin = .NULL.
onativebeautify = .NULL.
oprefs = .NULL.
oregexp = .F.
outils = .NULL.
[END PROPERTIES]
[START PROTECTED]
Height^
HelpContextID^
Init^
[END PROTECTED]
[START METHODS]
PROCEDURE Init
Lparameters loUtils, loPrefs, loEditorWin, lcSystemMemoryVariables

Local lcDBF, lcPlugIn, loThor

With This
	.oUtils					= loUtils
	.oPrefs					= loPrefs
	.oEditorWin				= loEditorWin
	.cSystemMemoryVariables	= lcSystemMemoryVariables
Endwith

If 'C' = Vartype (_Screen.cThorDispatcher)
	*!* * Removed 12/28/2012 / JRN
	*!* loThor			 = Execscript (_Screen.cThorDispatcher, 'Thor Engine=')
	*!* This.lAddMDots	 = Nvl(loThor.GetOption ('MDots in BeautifyX', 'MDots'), .F.)
	*!* This.nMDotsUsage = Nvl(loThor.GetOption ('MDots Usage', 'MDots'), 1)
	This.lAddMDots	 = This.GetThorOption('MDots in BeautifyX', 'MDots', .F.)
	This.nMDotsUsage = This.GetThorOption('MDots Usage', 'MDots', 1)
	This.lRETURNS    = This.GetThorOption('BeautifyX', 'RETURNs between WITH/ENDWITH', 1)
	This.lAddMDots	 = Not Empty(This.lAddMDots)
	This.lApplyCKL   = This.GetThorOption('ApplyCKL in BeautifyX', 'Apply Custom Keyword List to code window' , .F.)
	This.lAddtoCKL   = This.GetThorOption('AddtoCKL in BeautifyX', 'Add all words in code window' , .F.)
	This.lAutoAddtoCKL   = This.GetThorOption('AutoAddNewtoCKL in BeautifyX', 'Add all words in code window' , .F.)
Endif

If Not Used ('fdkeywrd')
	m.lcDBF = This.whereis ('FDKEYWRD.DBF')
	If Not File (m.lcDBF)
		Return .F.
	Endif
	Use (m.lcDBF) Order token Alias fdkeywrd In 0
Endif

lcPlugIn = This.oUtils.GetPlugInPath ('IsOperator')
If Not Empty (lcPlugIn)
	This.cpluginisoperator = Filetostr (lcPlugIn)
Endif
ENDPROC
PROCEDURE addasphase
Lparameters lcName, lcASPhrase
Local lcSuffix, lcVartype 

lcVartype = Upper(Substr(lcName, 2, 1))

Do Case
	Case Not Empty (lcASPhrase)
		Return lcName + ' as ' + lcASPhrase
	Case lcName # 'l'
		Return lcName
	Case lcVartype = "N"
		lcSuffix = " as Number"
	Case lcVartype = "I"
		lcSuffix = " as Integer"
	Case lcVartype = "O"
		lcSuffix = " as Object"
	Case lcVartype = "L"
		lcSuffix = " as Boolean"
	Case lcVartype = "C"
		lcSuffix = " as String"
	Case lcVartype = "U"
		lcSuffix = " as Variant"
	Case lcVartype = "D"
		lcSuffix = " as Date"
	Case lcVartype = "T"
		lcSuffix = " as DateTime"
	Case lcVartype = "Y"
		lcSuffix = " as Currency"
	Otherwise
		lcSuffix = ''
EndCase

Return lcName + lcSuffix

ENDPROC
PROCEDURE addnewlocal
Lparameters lcNewLocalName, lcASphrase, llArray, llAlreadyLocal, lcArrayDims
Local lcName, lnRow

lcName = Alltrim (lcNewLocalName)
* Remove array dimensions
Do Case
	Case '&' $ lcName
		Return
	Case '(' $ lcName
		lcName = Left (lcName, At ('(', lcName) - 1)
		llArray = .T.
	Case '[' $ lcName
		lcName = Left (lcName, At ('[', lcName) - 1)
		llArray = .T.
	Case ['] $ lcName or ["] $ lcName
		lcName = Chrtran(lcName, ['"], '') 
Endcase

If Lower (Left (lcName, 2)) = 'm.'
	lcName = Substr (lcName,3)
Endif

If '.' $ lcName and This.lNoDotsInAssignments 
	Return
Endif

Do Case

	Case Empty (lcName)

	Case lcName = '_'  and  (Upper (lcName) + '_') $ This.cSystemMemoryVariables

	Case (',' + Lower (lcName) + ',') $ Lower (This.cCurrentLocals)

	Case This.nNewLocalsCount > 0  And Ascan (This.aNewLocals, lcName, -1, -1, 1, 15) # 0
		lnRow = Ascan (This.aNewLocals, lcName, -1, -1, 1, 15)
		This.aNewLocals (lnRow,8) = .T.
		If llArray And llAlreadyLocal
			This.aNewLocals (lnRow,3) = llArray
			This.aNewLocals (lnRow,7) = Evl (lcArrayDims, '1')
		Endif

	Otherwise
		lnRow = This.nNewLocalsCount + 1
		This.nNewLocalsCount = lnRow
		Dimension This.aNewLocals (lnRow, 10)
		This.aNewLocals (lnRow,1) = lcName
		This.aNewLocals (lnRow,2) = Evl (lcASphrase, ' ')
		This.aNewLocals (lnRow,3) = llArray
		This.aNewLocals (lnRow,4) = Not Empty (lcASphrase)
		This.aNewLocals (lnRow,5) = lcName = 'l'
		This.aNewLocals (lnRow,6) = llAlreadyLocal
		This.aNewLocals (lnRow,7) = Evl (lcArrayDims, '1')

Endcase

ENDPROC
PROCEDURE addobjectidlist
Lparameters loObject, llRecursive

Local loControl AS Object
Local laObjectMembers(1), lcCode, lcName, lcObjectName, lnControlCount, lnI, lNonDefault, lnRow

lcObjectName = This.oUtils.GetObjectPath(loObject)

Amembers(laObjectMembers, loObject, 1, 'PHG#')

For lnRow = 1 To Alen(laObjectMembers, 1)
	If Inlist(laObjectMembers(lnRow,2), 'Method', 'Event')
		lNonDefault = 'C' $ laObjectMembers[lnRow, 3]
		If lNonDefault
			lcName = laObjectMembers(lnRow,1)
			lcCode = loObject.ReadMethod(lcName)
			If Not Empty(lcCode)
				This.GetConstants (lcCode)
				Insert Into crsr_IDs_Procs (ProcName, StartLine) Values (lcObjectName + '.' + lcName, 1)
				Alines (This.aCodeLines, lcCode)
				This.CreateIDList ('', 1, Alen (This.aCodeLines))
			Endif
		Endif
	Endif
Endfor

If llRecursive
	lnControlCount = This.oUtils.GetControlCount(loObject)
	If lnControlCount # 0 And "O" = Type("loObject.Objects(1)")
		For lnI = 1 To lnControlCount
			loControl = loObject.Objects(lnI)
			This.AddObjectIDList(loControl, .T.)
		Endfor
	Endif
Endif

ENDPROC
PROCEDURE alignsemicolons
Lparameters lcCodeBlock

Local laLines[1], laPositions[1], lcLine, lnCount
Local lcExecutable, lcResult, lcRight, lnEOL, lnI, lnMaxPosition, lnWidth

lnCount = Alines (laLines, lcCodeBlock + ' ') && but we'll ignore the first line!
Dimension laPositions (lnCount)
lnMaxPosition = 0

For lnI = 2 To lnCount
	lcLine = laLines(lnI)
	lnEOL = Evl (At (INLINECOMMENTS, lcLine), Len (lcLine) + 1)
	lcExecutable = This.TrimTrailingWhiteSpace (Left (lcLine, lnEOL - 1))
	If Right (lcExecutable, 1) # ';'
		laPositions(lnI) = -1
		Loop
	Endif
	lcLine = This.TrimTrailingWhiteSpace (Left (lcLine, Len (lcExecutable) - 1))
	lnWidth = This.CountCharacterWidth (lcLine)
	lnMaxPosition = Max(lnMaxPosition, lnWidth)
	laPositions(lnI) = Len (lcLine)
Endfor

lcResult = ''
lnMaxPosition = Min (This.oPrefs.nSemiColoncolumn, This.CalcColumnOffset (lnMaxPosition + 1, This.oPrefs.nBeforeSemicolons))
For lnI = 2 To lnCount
	lcLine = laLines(lnI)
	lnWidth = laPositions(lnI)
	If lnWidth >= 0
		lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, lnWidth + 1))
		lcLine = Left (lcLine, lnWidth)
		lcLine = This.AddWhiteSpace (lcLine, lnMaxPosition) + lcRight
	Endif
	lcResult = lcResult + LINEEND + This.TrimTrailingWhiteSpace (lcLine)
Endfor

Return lcResult

ENDPROC
PROCEDURE atnew
Lparameters lcSearchfor, lcSearched, lnOccurrence

Return Evl (At (lcSearchfor, lcSearched, Evl(lnOccurrence, 1)), 1 + Len (lcSearched))

ENDPROC
PROCEDURE beautifycodeblock
Lparameters lcCodeSource
Local laCodeSource[1], laLines2[1], laLines[1], laResultLines(1,3)
Local lcCleanedLine, lcCode, lcContinuationBlock, lcContinuationChar, lcFirstWord, lcFW, lcIndent
Local lcLine, lcNewCode, lcNewIndent, lcTextBlockCode, lcThisContinuationChar, lcThisIndent, lcType
Local lnAssignmentLines, lnC, lnCol, lnCount, lnEndParenCount, lnI, lnIndent, lnIndentChange, lnJ
Local lnLinesCount, lnOffset, lnPosition, lnResultLineCount, lnStart, lnW

If This.oPrefs.lNativeBeautify
	lcCode = This.NativeBeautify (lcCodeSource)
Else
	lcCode = lcCodeSource
Endif

If This.lAddMDots
	lcCode = ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_AddMDotsMultipleProcs.PRG', lcCode, This.nMDotsUsage = 3)
Endif

If This.lApplyCKL Or This.lAddToCKL
	Local loAddWordstoCKL
	loAddWordstoCKL = Execscript(_Screen.cThorDispatcher, 'Class= clsAddWordstoCKL from Thor_Proc_AddWordsToCKL.PRG')

	If This.lAddToCKL
		loAddWordstoCKL.ProcessText(lcCode, .F., .T.)
		loAddWordstoCKL.PostProcessing(.F., This.lAutoAddtoCKL)
	Endif

	If This.lApplyCKL
		loAddWordstoCKL.CreateAllKeywordsCursor()
		lcCode = loAddWordstoCKL.ApplyCKL(lcCode)
	Endif

EndIf

Dimension laLines(1)
Alines (laLines, lcCode + ' ', .F.)
Alines (laCodeSource, lcCodeSource + ' ', .F.)
lnLinesCount = Min (Alen (laLines), Alen (laCodeSource))
Dimension laResultLines(lnLinesCount,3)
lnResultLineCount = 0

lcContinuationChar = ' '
lnAssignmentLines = 0

For lnCount = 1 To lnLinesCount
	lcLine = laLines[lnCount]
	lcFirstWord = Upper (Getwordnum (lcLine,1))
	lcThisContinuationChar = This.GetContinuationChar (lcLine)

	Do Case

		Case lcFirstWord == 'TEXT'
			* For Text/EndText, do nothing with initial line
			lcCleanedLine = This.BeautifySingleLine (lcLine)
			lnResultLineCount = lnResultLineCount + 1
			laResultLines (lnResultLineCount, 1) = lcCleanedLine

			lcTextBlockCode = ''
			Do Case
				Case '{PEME:IGNORE}' $ Upper (lcCleanedLine)
					lcType = 'Ignore'
				Case '{PEME:CODE}' $ Upper (lcCleanedLine)
					lcType = 'Code'
				Case '{PEME:SELECT}' $ Upper (lcCleanedLine)
					lcType = 'Select'
				Case This.oPrefs.lBeautifyTEXTasSelect
					For lnI = lnCount + 1 To lnLinesCount
						lcFW = Upper (Getwordnum (laLines[lnI],1))
						Do Case
							Case Empty(lcFW)

							Case 'SELECT ' = lcFW
								lcType = 'Select'
								Exit
							Otherwise
								lcType = 'Ignore'
								Exit
						Endcase
					Endfor
				Otherwise
					lcType = 'Ignore'
			Endcase

			For lnCount = lnCount + 1 To lnLinesCount
				lcLine = laLines[lnCount]
				lcFirstWord = Upper (Getwordnum (lcLine,1))
				If lcFirstWord == 'ENDTEXT'
					Exit
				Endif
				If lcType = 'Select'
					lcTextBlockCode = lcTextBlockCode + LINEEND + This.BeautifySingleLine (laLines[lnCount], This.oPrefs.cIgnoreTextOperators, .T.)
				Else
					lcTextBlockCode = lcTextBlockCode + LINEEND + laCodeSource[lnCount]
				Endif
			Endfor

			Do Case
				Case lcType = 'Select'
					lcTextBlockCode = LINEEND + This.BeautifySelectCode (Substr (lcTextBlockCode, 1 + Len (LINEEND)), .F., This.nTabWidth)
				Case lcType = 'Code'
					lcTextBlockCode = This.BeautifyCodeBlock (lcTextBlockCode)
				Otherwise
			Endcase
			lnResultLineCount = lnResultLineCount + 1
			laResultLines (lnResultLineCount, 1) = Substr (lcTextBlockCode, 1 + Len (LINEEND))

			lnResultLineCount = lnResultLineCount + 1
			laResultLines (lnResultLineCount, 1) = lcLine
			lcContinuationChar = This.GetContinuationChar (lcLine)

		Case lcThisContinuationChar = ' ' Or lnCount >= lnLinesCount
			* simple line, no continuation, nothing special to do.
			If Inlist (lcFirstWord, '*', INLINECOMMENTS)
				lcCleanedLine = This.GetIndent (lcLine) + This.TrimLeadingWhiteSpace (laCodeSource(lnCount))
			Else
				lcCleanedLine = This.BeautifySingleLine (lcLine)
			Endif
			lnResultLineCount = lnResultLineCount + 1

			laResultLines (lnResultLineCount, 1) = lcCleanedLine
			laResultLines (lnResultLineCount, 2) = This.GetAssignmentCol(lcCleanedLine)

		Otherwise
			****************************************************************
			* get the entire continuation block of lines
			lcIndent = This.GetIndent (lcLine)
			lnEndParenCount = 0
			lcContinuationBlock = ''

			Do While .T.
				If lcContinuationChar == '*' Or Inlist (lcFirstWord, '*', INLINECOMMENTS)
					* continuation lines for comments
					lcLine = This.GetIndent (lcLine) + This.TrimLeadingWhiteSpace (laCodeSource(lnCount))
					lcContinuationBlock = lcContinuationBlock + LINEEND + lcLine
					lcContinuationChar = This.GetContinuationChar (lcLine, .T.)
				Else
					* correction for continuation line after in-line comments
					If lcContinuationChar == ';'											;
							and (Not Substr (lcLine, 1 + Len (lcIndent), 1) ISABLANK)		;
							and lcLine = lcIndent											;
							and This.nBeautifyOptions (7) = 1
						lcLine = Stuff (lcLine, 1 + Len (lcIndent), 0, 						;
							IIF (This.nBeautifyOptions(4) = 1, Tab, Space (This.nBeautifyOptions(3))))
					Endif

					If lnEndParenCount # 0 And This.oPrefs.nParenIndent > 0
						lcThisIndent = This.GetIndent (lcLine)
						lcNewIndent = Space (lnEndParenCount * This.oPrefs.nParenIndent)
						lcNewIndent = This.ConvertTabsForIndent(lcNewIndent)
						lcLine = Stuff (lcLine, 1 + Len (lcThisIndent), 0, lcNewIndent)
					Endif
					lnEndParenCount = Max (0, lnEndParenCount + This.CountParens (lcLine))

					lcCleanedLine = This.BeautifySingleLine (lcLine)
					lcContinuationBlock = lcContinuationBlock + LINEEND + lcCleanedLine
					lcContinuationChar = This.GetContinuationChar (lcLine)
				Endif

				If lcContinuationChar # ' ' And lnCount < lnLinesCount
					lnCount = lnCount + 1
					lcLine = laLines[lnCount]
				Else
					Exit
				Endif
			Enddo

			****************************************************************
			Do Case
				Case (lcFirstWord == 'SELECT' Or lcFirstWord == 'UPDATE' Or lcFirstWord == 'DELETE')	;
						and This.oPrefs.nSelectIndentation = 3
					* PEME Custom indentation for SELECTs
					lcContinuationBlock = This.BeautifySelectCode (lcContinuationBlock, .T., This.nTabWidth)

				Case lcFirstWord == 'INSERT' 								;
						and This.oPrefs.nSelectIndentation = 3
					* PEME Custom indentation for REPLACEs
					lcContinuationBlock = This.BeautifyInsertCode (lcContinuationBlock)

				Case lcFirstWord == 'REPLACE' 								;
						and This.oPrefs.nReplaceIndentation = 3
					* PEME Custom indentation for REPLACEs
					lcContinuationBlock = This.BeautifyReplaceCode (lcContinuationBlock)

				Case This.oPrefs.lNativeBeautify And (;
						(This.oPrefs.nSelectIndentation = 2 And (lcFirstWord == 'SELECT' Or lcFirstWord == 'UPDATE' Or lcFirstWord == 'DELETE'));
						Or (This.oPrefs.nReplaceIndentation = 2 And lcFirstWord == 'REPLACE');
						)
					* Ugh.  Keep original indentation;
					* ... need to backtrack thru lines to reinstate, ;
					* but adding back the correct indentation matching the first line
					* This appears indirect at first, but correctly handles inline comments, etc
					lnC = Alines (laLines2, Substr (lcContinuationBlock, 1 + Len (LINEEND)) + ' ')
					lnOffset = lnCount - lnC
					lnIndentChange = This.CountCharacterWidth (This.GetIndent (laLines(lnOffset + 1)));
						- This.CountCharacterWidth (This.GetIndent (laCodeSource(lnOffset + 1)))
					lcContinuationBlock = ''
					For lnI = 1 To lnC
						lnIndent = lnIndentChange + This.CountCharacterWidth (This.GetIndent (laCodeSource(lnI + lnOffset)))
						If lnIndent > 0
							lcIndent = Space (lnIndent)
							lcIndent = This.ConvertTabsForIndent(lcIndent)
						Else
							lcIndent = ''
						Endif
						lcContinuationBlock = lcContinuationBlock + LINEEND + lcIndent ;
							+ This.TrimLeadingWhiteSpace (laLines2 (lnI))
					Endfor

			Endcase

			lnResultLineCount = lnResultLineCount + 1
			Do case
				Case This.oPrefs.lAlignSemicolons
					laResultLines (lnResultLineCount, 1) = Substr (This.AlignSemiColons (lcContinuationBlock), 1 + Len (LINEEND)) 
				Case lcContinuationBlock = LINEEND
					laResultLines (lnResultLineCount, 1) = Substr (lcContinuationBlock, 1 + Len (LINEEND))
				Otherwise
					laResultLines (lnResultLineCount, 1) = Substr (lcContinuationBlock, 2)
			Endcase
	Endcase
Endfor

lnStart = 0
If This.oPrefs.lFixAssignments
	For lnI = 1 To lnResultLineCount
		lnW = laResultLines (lnI, 2)
		If 'N' = Vartype(lnW) And lnW > 0
			If lnStart = 0
				lnStart = lnI
				lnPosition = laResultLines (lnI, 2)
			Else
				lnPosition = Max (lnPosition, lnW)
				For lnJ = lnStart To lnI
					laResultLines (lnJ,3) = lnPosition
				Endfor
			Endif
		Else
			lnStart = 0
		Endif
	Endfor
Endif

lcNewCode = ''
For lnI = 1 To lnResultLineCount
	lcLine = laResultLines (lnI, 1)
	lnCol = At('=', lcLine) - 1
	lnW = laResultLines (lnI, 3)
	If 'N' = Vartype(lnW) And lnW > 0
		lcNewCode = lcNewCode + LINEEND ;
			+ This.AddWhiteSpace(This.TrimTrailingWhiteSpace(Left (lcLine, lnCol)), lnW + 2);
			+ This.TrimLeadingWhiteSpace(Substr (lcLine, lnCol + 1))
	Else
		lcNewCode = lcNewCode + LINEEND + lcLine
	Endif
Endfor

Return Trim(Substr (lcNewCode, 1 + Len (LINEEND)), 1, ' ', Tab)

ENDPROC
PROCEDURE beautifyinsertcode
Lparameters lcCode
Local laLines[1], lcLine, lcResult, lnCount, lnLineCount

lnLineCount = Alines (laLines, lcCode, .F.)
lcResult = ''

For lnCount = 1 To lnLineCount
	lcLine = laLines (lnCount)

	If Upper (Getwordnum (lcLine, 1)) == 'SELECT'
		For lnCount = lnCount + 1 To lnLineCount
			lcLine = lcLine + LINEEND + laLines (lnCount)
		Endfor
		lcLine = This.BeautifySelectCode(lcLine, .T., This.nTabWidth)
	Endif

	lcResult = lcResult + LINEEND + lcLine

Endfor

Return Substr (lcResult, 1 + Len (LINEEND))

ENDPROC
PROCEDURE beautifyreplacecode
Lparameters lcCode

Local laLines(1), laResult(1)
Local lcCurrentKeyWord, lcFirstWord, lcIndent, lcLine, lcNewLine, lcResult, llFixWITH, ln, lnAfterWITH
Local lnBeforeWITH, lnCount, lnEndParenCount, lnHangingIndent, lnIndent, lnIndentAll, lnLineCount
Local lnParenCount, lnTotalIndent, lnWITHCol

lnLineCount = Alines (laLines, lcCode, .F.)
Acopy (laLines, laResult)
lnWITHCol = 0

* find first non-blank line ... it better start with SELECT!
For lnCount = 1 To lnLineCount
	lcLine = laLines (lnCount)
	Do Case
		Case Empty (lcLine)

		Case Inlist (Upper (Getwordnum (lcLine, 1)) + ' ', 'REPLACE ')
			Exit
		Otherwise
			Return lcCode
	Endcase
Endfor

lnIndentAll= This.CountCharacterWidth (This.GetIndent (lcLine))
lcCurrentKeyWord = Upper (Getwordnum (lcLine, 1))
* determine indent to be applied to all lines
lcResult = ''

For lnCount = lnCount To lnLineCount
	lcLine = This.TrimLeadingWhiteSpace (laLines (lnCount))
	lcFirstWord = Upper (Getwordnum (lcLine, 1))
	llFixWITH	= .F.

	Do Case
		Case lcFirstWord == 'REPLACE'
			lnParenCount = 0
			lnEndParenCount = This.CountParens (lcLine)
			lnIndent = 0
			lnHangingIndent = This.oPrefs.nReplaceFieldIndent + This.oPrefs.nSingleREPLACEFieldIndent
			If Upper (Getwordnum (lcLine, 3)) == 'WITH'
				llFixWITH = .T.
				lcLine = This.AddWhiteSpace (Left (lcLine,7), This.oPrefs.nReplaceFieldIndent + 1) + This.TrimLeadingWhiteSpace (Substr (lcLine,8))
			Endif

		Case (' ' + lcFirstWord + ' ') $ ' FOR IN WHILE ' And lnParenCount = 0
			lnParenCount = 0
			lnEndParenCount = This.CountParens (lcLine)
			lnIndent = This.oPrefs.nReplaceKeywords
			lnHangingIndent = lnIndent + This.oPrefs.nReplaceHangingIndent

		Case (Upper (Getwordnum (lcLine, 2)) == 'WITH' Or Upper (Getwordnum (lcLine, 3)) == 'WITH') And lnParenCount = 0
			ln = 0
			lnEndParenCount = This.CountParens (lcLine)
			lnIndent = This.oPrefs.nReplaceFieldIndent - IIf (Upper (Getwordnum (lcLine, 1)) = ',', 2, 0)
			lnHangingIndent = This.oPrefs.nReplaceFieldIndent + This.oPrefs.nSingleREPLACEFieldIndent
			llFixWITH	= .T.

		Otherwise
			lnEndParenCount = Max (0, lnParenCount + This.CountParens (lcLine))
			lnIndent = lnHangingIndent

	Endcase

	lnTotalIndent = lnIndentAll + lnIndent + (This.oPrefs.nParenIndent * lnParenCount)
	lcIndent = Space (lnTotalIndent)
	lcNewIndent = This.ConvertTabsForIndent(lcIndent)

	lcNewLine = lcNewIndent + lcLine
	If llFixWITH And This.oPrefs.lAlignWith
		lnWITHCol = Max (lnWITHCol, This.CalcColumn (lcNewLine, 'WITH'))
	Endif

	laResult (lnCount) = lcNewLine
	lnParenCount = lnEndParenCount

Endfor

lcResult = ''
lnBeforeWITH = This.CalcColumnOffset (lnWITHCol, This.oPrefs.nBeforeWith)
lnAfterWITH = This.CalcColumnOffset (lnBeforeWITH + 3, This.oPrefs.nAfterWith)

For lnCount = 1 To lnLineCount
	lcLine = laResult (lnCount)

	If lnWITHCol # 0
		lcNewLine = This.FixWITH (lcLine, 4, lnBeforeWITH, lnAfterWITH)
	Else
		lcNewLine = lcLine
	Endif

	lcResult = lcResult + LINEEND + lcNewLine

Endfor

Return Substr (lcResult, 1 + Len (LINEEND))

ENDPROC
PROCEDURE beautifyselectcode
Lparameters tcCode, tlSemiColons, tnTabWidth
Local lcCode, lcNewResult, lcResult, lnLastLen, lnTabs, lnTabWidth

lnTabWidth = Evl(tnTabWidth, 1) 
lcCode = Strtran(tcCode, Tab, Space(lnTabWidth)) 
lcResult = This.Beautifyselectx(lcCode, tlSemiColons)

* leading tabs, where approppriate
If lnTabWidth > 1
	lnLastLen = 0
	lcNewResult = ccCR + lcResult
	lnTabs = 0
	Do While Len(lcNewResult) #lnLastLen
		lnLastLen = Len(lcNewResult)
		lcNewResult = Strtran(lcNewResult;
			, ccCR + Replicate(Tab, lnTabs) + Space(lnTabWidth);
			, ccCR + Replicate(Tab, lnTabs + 1))
		lnTabs = lnTabs + 1
	Enddo
	lcResult = Substr(lcNewResult, 2)
Endif

Return lcResult

ENDPROC
PROCEDURE beautifyselectcreatebreakpoints
Lparameters tcText, lcAlias
Local lcClosingChar, lcPattern, lcValue, lnFirstIndex, lnI, lnParens, loMatch, loMatches

lcPattern = [('|"|] + '\[|\]|\(|\)|\&' + '\&)|\r|\,'
loMatches = This.RegExpSearch (lcPattern, tcText)

Create Cursor (lcAlias) (Start N(8), End N(8), Value c(1), nParens N(4), notcode L)
Insert Into (lcAlias) (Start) Values (1)
lnParens = 0
For lnI = 1 To loMatches.Count
	loMatch		 = loMatches.Item (lnI - 1)
	lnFirstIndex = loMatch.FirstIndex
	lcValue		 = loMatch.Value
	Replace End With lnFirstIndex
	lcClosingChar = lcValue
	Do Case
		Case lcValue = '('
			lnParens = lnParens + 1
		Case lcValue = ')'
			lnParens = lnParens - 1
		Case lcValue = '['
			If This.IsNameChar (Right (Trim (Left (tcText, lnFirstIndex)), 1))
				Loop
			Endif
			lcClosingChar = ']'
		Case lcValue = ']'
			Loop
		Case lcValue = '&'
			lcClosingChar = CR
		Case lcValue = CR
			lcClosingChar = '?'
	Endcase
	Insert Into (lcAlias) (Start, Value, nParens) Values (lnFirstIndex + 1, lcValue, lnParens)
	If lcClosingChar $ ['"] + ']' + CR
		Replace notcode With .T.
		For lnI = lnI + 1 To loMatches.Count
			If loMatches.Item (lnI - 1).Value = lcClosingChar
				loMatch		 = loMatches.Item (lnI - 1)
				lnFirstIndex = loMatch.FirstIndex
				lcValue		 = loMatch.Value
				Replace End With lnFirstIndex
				Insert Into (lcAlias) (Start, Value, nParens) Values (lnFirstIndex + 1, lcValue, lnParens)
				Exit
			Endif
		Endfor
	Endif
Endfor
Replace End With Len (tcText)

ENDPROC
PROCEDURE beautifyselectmain
Lparameters lcText, llSemiColons, llCommasBeginLine

* A long procedure, but done this way because it recursive

Local laEndParen[1], laMatch[1], laSELECTS[1], lcAlias, lcBeforeThisLine, lcBreakWords
Local lcEndThisLine, lcNewLine, lcReplaceText, lcResultText, lcSelectText, lcSubQ, lcSubQuery
Local lcThisLine, llAnyFound, llFromFound, lnEndChars, lnFirstIndex, lnI, lnIndent, lnOffset, lnPos
Local lnSubQueries, loMatch, loMatches, lnLeadingBlanks

* our important breakpoints
lcAlias = Sys(2015)
This.BeautifySelectCreateBreakPoints (lcText, lcAlias)

* Our 'SELECT' subquery substitutions, if any
lnSubQueries = 0
llAnyFound	 = .T.

Do While llAnyFound
	llAnyFound = .F.
	loMatches  = This.RegExpSearch ('\bSelect\b', lcText)
	For lnI = 1 To loMatches.Count
		loMatch		 = loMatches.Item (lnI - 1)
		lnFirstIndex = loMatch.FirstIndex
		Select  nParens								  ;
			From (lcAlias)							  ;
			Where Between (lnFirstIndex, Start, End)  ;
			And nParens > 0						  ;
			And Not notcode						  ;
			Into Array laMatch
		If _Tally > 0
			Select  Start					  ;
				From (lcAlias)				  ;
				Where Start > lnFirstIndex	  ;
				And nParens < laMatch[1]  ;
				And Not notcode			  ;
				Into Array laEndParen
			lcSelectText  = Substr (lcText, lnFirstIndex + 1, laEndParen[1] - lnFirstIndex - 1)
			lcReplaceText = '<<' + Sys(2015) + '>>'

			lnSubQueries  = lnSubQueries + 1
			Dimension laSELECTS (lnSubQueries, 2)
			laSELECTS (lnSubQueries, 1) = lcSelectText
			laSELECTS (lnSubQueries, 2) = lcReplaceText

			lcText		= Stuff (lcText, lnFirstIndex + 1, Len (lcSelectText), lcReplaceText)
			This.BeautifySelectCreateBreakPoints (lcText, lcAlias)
			llAnyFound = .T.
			Exit
		Endif
	Endfor
Enddo && while .t.

* Major keyword substitutions, as well as commas for fields
lcResultText = lcText

lcBreakWords = '\Wselect\W|\Wfrom\W|\Wwhere\W|\Wgroup by\W|\Worder by\W|\Whaving\W|\Wunion\W|\Winto\W'

If This.oPrefs.lSelectExpandFields
	lcBreakWords = '\,|' + lcBreakWords
Endif

If This.oPrefs.lSelectExpandJoins
	lcBreakWords = lcBreakWords + '|\Wleft join\W|\Wleft outer join\W|\Wright join\W|\Wright outer join\W|\Wfull join\W' ;
		+ '|\Wfull outer join\W|\Winner join\W|\Wjoin\W'
Endif

If This.oPrefs.lSelectExpandOn
	lcBreakWords = lcBreakWords + '|\Won\W'
Endif

If This.oPrefs.lSelectExpandAndOr
	lcBreakWords = lcBreakWords + '|\W.and.\W|\W.or.\W|\Wand\W|\Wor\W'
Endif

loMatches	= This.RegExpSearch ('(' + lcBreakWords + ')', lcText)
lnOffset	= 1 && because search includes leading blank character!
lcNewLine	= Iif (llSemiColons, ';' + CR, ' ' + CR)
llFromFound	= .F.

For lnI = 1 To loMatches.Count
	loMatch		 = loMatches.Item (lnI - 1)
	lnFirstIndex = loMatch.FirstIndex
	Select  nParens								  ;
		From (lcAlias)							  ;
		Where Between (lnFirstIndex, Start, End)  ;
		And Not notcode						  ;
		Into Array laMatch
	If _Tally > 0
		lnFirstIndex = lnFirstIndex + lnOffset
		If loMatch.Value = ','
			Do Case
				Case llFromFound

				Case laMatch[1] # 0
					* lnFirstIndex points to the comma

				Case llCommasBeginLine
					lcEndThisLine = Substr (lcResultText, lnFirstIndex + 1)
					lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
					If Empty (lcEndThisLine) Or Left (Getwordnum (lcEndThisLine, 1), 1) $ ';*' Or Left (Getwordnum (lcEndThisLine, 1), 2) = '&' + '&'
						* lcResultText = Stuff (lcResultText, lnFirstIndex + 1, 1 + Len (lcEndThisLine), Space(1 + Len (lcEndThisLine)))
						lcResultText = Stuff (lcResultText, lnFirstIndex, 2 + Len (lcEndThisLine), Space(1 + Len (lcEndThisLine)) + ',')
					Else
						lnLeadingBlanks = Len(lcEndThisLine) - Len(Ltrim(lcEndThisLine))
						If lnLeadingBlanks # 1
							lcResultText = Stuff (lcResultText, lnFirstIndex + 1, lnLeadingBlanks, ' ')
							lnOffset	 = lnOffset + 1 - lnLeadingBlanks
						Endif
					Endif
					lcBeforeThisLine = Left (lcResultText, lnFirstIndex - 1)
					lcBeforeThisLine = Substr (lcBeforeThisLine, Rat (CR, lcBeforeThisLine) + 1)
					If Not Empty (lcBeforeThisLine)
						lcResultText = Stuff (lcResultText, lnFirstIndex, 0, lcNewLine)
						lnOffset	 = lnOffset + 2
					Endif

				Otherwise
					lcEndThisLine = Substr (lcResultText, lnFirstIndex + 1)
					lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
					If Empty (lcEndThisLine) Or Left (Getwordnum (lcEndThisLine, 1), 1) $ ';*' Or Left (Getwordnum (lcEndThisLine, 1), 2) = '&' + '&'
						* already at end of line
					Else
						lcResultText = Stuff (lcResultText, lnFirstIndex + 1, 0, lcNewLine)
						lnOffset	 = lnOffset + 2
					Endif

					lcBeforeThisLine = Left (lcResultText, lnFirstIndex - 1)
					lcBeforeThisLine = Substr (lcBeforeThisLine, Rat (CR, lcBeforeThisLine) + 1)
					If Empty (lcBeforeThisLine)
						lnEndChars   = Iif(llSemiColons, 2, 1)
						lcResultText = Stuff (lcResultText, lnFirstIndex - Len (lcBeforeThisLine) - lnEndChars, Len (lcBeforeThisLine) + lnEndChars, '')
						lnOffset	 = lnOffset - (Len (lcBeforeThisLine) + lnEndChars)
					Endif
			Endcase

		Else
			lcThisLine = Left (lcResultText, lnFirstIndex)
			lcThisLine = Substr (lcThisLine, Rat (CR, lcThisLine) + 1)
			If Not Empty (lcThisLine)
				lcEndThisLine = Substr (lcResultText, lnFirstIndex + 1)
				lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
				lcEndThisLine = Strtran(lcEndThisLine, Getwordnum(lcEndThisLine, 1), '')
				If Not Empty (Chrtran(lcEndThisLine, ccCR + ccLF + ccTAB + ';', Space(4)))
					lcResultText = Stuff (lcResultText, lnFirstIndex + 1, 0, lcNewLine)
					lnOffset	 = lnOffset + 2
				Endif
			Endif
			llFromFound = (llFromFound Or 'FROM' $ Upper (loMatch.Value)) And Not 'UNION' $ Upper (loMatch.Value)
		Endif
	Endif
Endfor

* Expand our SELECT subqueries, stuff 'em back in,
*   making sure to expand leading white space.
*   (note the assumption that there are no tabs involved!
lcResultText = Strtran(This.BeautifySelectStandard (lcResultText), LF, '')
For lnI = 1 To lnSubQueries
	lcSubQuery	  = This.BeautifySelectMain (laSELECTS (lnI, 1), llSemiColons, llCommasBeginLine)
	lcReplaceText = laSELECTS (lnI, 2)
	lnPos		  = At (lcReplaceText, lcResultText)
	lnIndent	  = lnPos - Rat (CR, Left (lcResultText, lnPos)) - 1
	lcSubQ		  = Strtran (Strtran(lcSubQuery, LF, ''), CR, CR + Space (lnIndent))
	lcResultText  = Stuff (lcResultText, lnPos, Len (lcReplaceText), lcSubQ)
Endfor

Return lcResultText


ENDPROC
PROCEDURE beautifyselectstandard
Lparameters lcCode
Local laLines[1], laResult[1], lcCurrentKeyWord, lcFirstWord, lcIndent, lcLine, lcNewLine, lcResult
Local llFieldNextLineIndent, llFieldThisLineIndent, lnASCol, lnAfterAS, lnBeforeAS, lnCount
Local lnEndParenCount, lnHangingIndent, lnIndent, lnIndentAll, lnLineCount, lnParenCount
Local lnParentCount, lnPos, lnTotalIndent

lnLineCount = Alines (laLines, lcCode + ' ', .F.)
Acopy (laLines, laResult)

* find first non-blank line ... it better start with SELECT or UPDATE!
For lnCount = 1 To lnLineCount
	lcLine = laLines (lnCount)
	Do Case
		Case Empty (lcLine)

		Case Inlist (Upper (Getwordnum (lcLine, 1)) + ' ', 'SELECT ', 'UPDATE ', 'DELETE ')
			Exit
		Otherwise
			Return lcCode
	Endcase
Endfor

lnIndentAll		 = This.CountCharacterWidth (This.GetIndent (lcLine))
lcCurrentKeyWord = Upper (Getwordnum (lcLine, 1))
lnPos			 = At (lcCurrentKeyWord, Upper (lcLine))
lcLine			 = Left (lcLine, lnPos + 5) + Space (Max (1, This.oPrefs.nCharsAfterSelect)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 6))
laResult (lnCount) = lcLine
If This.oPrefs.lAlignAS
	lnASCol = This.CountCharacterWidth (This.TrimTrailingWhiteSpace (This.FindBeforeAS (lcLine)))
Else
	lnASCol = 0
Endif
*
lnHangingIndent	= This.oPrefs.nFieldIndent
lnParenCount	= This.CountParens (lcLine)
llFieldNextLineIndent = lnParenCount # 0 Or (		;
	  This.LastCharIn (lcLine) # ','				;
	  And Not Inlist (Upper (Getwordnum (lcLine, Getwordcount (lcLine) - 1)), 'SELECT', 'DISTINCT'))

For lnCount = lnCount + 1 To lnLineCount
	lcLine			= This.TrimLeadingWhiteSpace (laLines (lnCount))
	lcFirstWord		= Upper (Getwordnum (lcLine, 1))
	lnEndParenCount	= Max (0, lnParenCount + This.CountParens (lcLine))

	Do Case
		Case (' ' + lcFirstWord + ' ') $ ' FROM WHERE HAVING INTO TO ' And lnParenCount = 0
			lcCurrentKeyWord	  = lcFirstWord
			lnParentCount		  = 0
			lnEndParenCount		  = This.CountParens (lcLine)
			lnIndent			  = This.oPrefs.nKeyWordIndent
			lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
			llFieldThisLineIndent = .F.
			llFieldNextLineIndent = .F.

		Case Inlist (lcFirstWord, 'GROUP', 'ORDER') And Upper (Getwordnum (lcLine, 2)) == 'BY' And lnParenCount = 0
			lcCurrentKeyWord	  = lcFirstWord
			lnParentCount		  = 0
			lnEndParenCount		  = This.CountParens (lcLine)
			lnIndent			  = This.oPrefs.nKeyWordIndent
			lnHangingIndent		  = This.oPrefs.nFieldIndent
			llFieldThisLineIndent = .F.
			llFieldNextLineIndent = lnParenCount # 0 Or This.LastCharIn (lcLine) # ','

		Case (' ' + lcFirstWord + ' ') $ ' INNER OUTER JOIN LEFT RIGHT FULL ' And lnParenCount = 0
			lcCurrentKeyWord	  = lcFirstWord
			lnParentCount		  = 0
			lnEndParenCount		  = This.CountParens (lcLine)
			lnIndent			  = This.oPrefs.nJOINIndent
			lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
			llFieldThisLineIndent = .F.
			llFieldNextLineIndent = .F.

		Case (' ' + lcFirstWord + ' ') $ ' UNION ' And lnParenCount = 0
			lcCurrentKeyWord	  = lcFirstWord
			lnParentCount		  = 0
			lnEndParenCount		  = This.CountParens (lcLine)
			lnIndent			  = This.oPrefs.nUNIONIndent
			lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
			llFieldThisLineIndent = .F.
			llFieldNextLineIndent = .F.

		Case (' ' + lcFirstWord + ' ') $ ' SELECT ' And lnParenCount = 0
			lnPos  = At ('SELECT', Upper (lcLine))
			lcLine = Substr (lcLine, lnPos, 6) + Space (Max (1, This.oPrefs.nCharsAfterSelect)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 6))

			lcCurrentKeyWord	  = lcFirstWord
			lnParentCount		  = 0
			lnEndParenCount		  = This.CountParens (lcLine)
			lnIndent			  = This.oPrefs.nSELECTIndent
			lnHangingIndent		  = This.oPrefs.nFieldIndent
			llFieldThisLineIndent = .F.
			llFieldNextLineIndent = lnParenCount # 0 Or This.LastCharIn (lcLine) # ','

		Case (' ' + lcFirstWord + ' ') $ ' SET ' And lnParenCount = 0
			lnPos  = At ('SET', Upper (lcLine))
			lcLine = Substr (lcLine, lnPos, 3) + Space (Max (1, This.oPrefs.nCharsAfterSET)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 3))

			lcCurrentKeyWord	  = lcFirstWord
			lnParentCount		  = 0
			lnEndParenCount		  = This.CountParens (lcLine)
			lnIndent			  = This.oPrefs.nSETIndent
			lnHangingIndent		  = This.oPrefs.nSETFieldIndent
			llFieldThisLineIndent = .F.
			llFieldNextLineIndent = lnParenCount # 0 Or This.LastCharIn (lcLine) # ','

		Otherwise
			lnIndent = lnHangingIndent
			* additional indentation for fields defs that span multiple lines
			llFieldThisLineIndent = llFieldNextLineIndent
			llFieldNextLineIndent = Inlist (lcCurrentKeyWord + ' ', 'SELECT ', 'GROUP ', 'ORDER ', 'SET ') ;
				And (lnEndParenCount # 0 Or This.LastCharIn (lcLine) # ',')
			*** JRN 2010-05-27 : Correction for lines where leading comma means a new field
			If Inlist (lcCurrentKeyWord + ' ', 'SELECT ', 'GROUP ', 'ORDER ') And lnParenCount = 0 And lcFirstWord = ','
				llFieldThisLineIndent = .F.
				lnIndent			  = lnIndent - 2
			Endif

	Endcase

	lnTotalIndent = lnIndentAll + lnIndent														;
		+ (This.oPrefs.nParenIndent * lnParenCount)												;
		+ IIf (llFieldThisLineIndent And lcFirstWord # '&',										;
		  IIf (lcCurrentKeyWord = 'SET', This.oPrefs.nSingleSETFieldIndent, This.oPrefs.nSingleFieldIndent) ;
		  , 0)
	lcIndent = Space (lnTotalIndent)
	*	lcNewIndent = This.ConvertTabsForIndent(lcIndent)
	lcNewIndent = lcIndent

	lcNewLine = lcNewIndent + lcLine

	If This.oPrefs.lAlignAS
		lnASCol = Max (lnASCol, This.CountCharacterWidth (This.TrimTrailingWhiteSpace (This.FindBeforeAS (lcNewLine))))
	Endif

	laResult (lnCount) = lcNewLine
	lnParenCount = lnEndParenCount

Endfor

lcResult   = ''
lnBeforeAS = This.CalcColumnOffset (lnASCol, This.oPrefs.nBeforeAS)
lnBeforeAS = Min (lnBeforeAS, This.oPrefs.nAsColumn)
lnAfterAS  = This.CalcColumnOffset (lnBeforeAS + 1, This.oPrefs.nAfterAS)

For lnCount = 1 To lnLineCount
	lcLine = laResult (lnCount)

	If lnASCol # 0
		lcNewLine = This.FixASColumn (lcLine, 2, lnBeforeAS, lnAfterAS)
	Else
		lcNewLine = lcLine
	Endif

	lcResult = lcResult + LINEEND + This.TrimTrailingWhiteSpace (lcNewLine)

Endfor

Return Substr (lcResult, 1 + Len (LINEEND))


ENDPROC
PROCEDURE beautifyselectx
Lparameters tcCode, tlSemiColons

This.oRegExp = Createobject ('VBScript.RegExp')
With This.oRegExp
	.IgnoreCase	= .T.
	.Global		= .T.
	.MultiLine	= .T.
Endwith

* we lie about tabs throughout this
lnTabWidth = This.ntabwidth
This.ntabwidth = 1000

lcCode = Strtran (tcCode, LF, '')
lcResult = This.BeautifySelectMain (lcCode, tlSemiColons, This.oPrefs.lSelectCommasBeginLine)

This.ntabwidth = lnTabWidth

Return lcResult

ENDPROC
PROCEDURE beautifysingleline
Lparameters tcCode, tcIgnoreTextOperators, tlTextMerge

Local lcCharsToAdd, lcCode, lcCommaOperators, lcNextChar, lcNot, lcOperators, lcPrevChar
Local lcRestLineString, lcResult, lcStringConstant, lcThisChar, lnCharPos, lnCharscount
Local lnClosingCharPosition, lnOption, llIsOperator

#Define OPERATORS 	'+-*/=$#%<>'
lcOperators = Chrtran (OPERATORS, Evl (tcIgnoreTextOperators, ''), '')
*** JRN 2010-07-06 : Some commands allow wildcards not within string constants
If (' ' + Upper (Getwordnum (tcCode, 1)) + ' ') $ ' APPEND COPY SORT COPY SCATTER GATHER PRIVATE RELEASE SAVE SET ERASE DELETE COMPILE '
	lcOperators = Chrtran (OPERATORS, '*?-', '')
Endif
lcOperators		 = Iif (This.oPrefs.lSpacesAroundOperators, lcOperators, '')
lcCommaOperators = Iif (This.oPrefs.lSpaceBeforeCommas, ',', '') + lcOperators

lcCode = This.TrimTrailingWhiteSpace (tcCode)
If Empty (lcCode) ;
		Or Inlist (Getwordnum (tcCode, 1), '*', '#', INLINECOMMENTS, '\') ;
		or Upper(Getwordnum (tcCode, 1)) == 'RUN'
	Return lcCode
Endif

lcResult = ''

lnCharscount = Len (lcCode)
lcPrevChar	 = ''
For lnCharPos = 1 To lnCharscount

	lcThisChar	 = Substr (lcCode, lnCharPos, 1)
	lcNextChar	 = Substr (lcCode, lnCharPos + 1, 1)
	lcCharsToAdd = lcThisChar
	llIsOperator = .T.

	Do Case

			* database!tablename
		Case lcThisChar = '!'					  ;
				And This.isnamechar (lcPrevChar)  ;
				And This.isnamechar (lcNextChar)
			lcCharsToAdd = lcThisChar + lcNextChar
			lnCharPos	 = lnCharPos + 1

			* !/
		Case lcThisChar = '!'  ;
				And This.TrimLeadingWhiteSpace (Substr (lcCode, lnCharPos + 1)) = '/'
			For lnCharPos = lnCharPos + 1 To lnCharscount
				lcThisChar	 = Substr (lcCode, lnCharPos, 1)
				lcCharsToAdd = lcCharsToAdd + lcThisChar
				If Not (lcThisChar ISABLANK Or lcThisChar = '/')
					Exit
				Endif
			Endfor

			* substitutions for 'NOT' and !
		Case This.oPrefs.nDefinitionForNOT  = 2  ;
				And lcThisChar = '!'	  ;
				And lcNextChar # '='
			lnOption = This.nBeautifyOptions (2)
			lcNot	 = Iif (lnOption = 1, 'NOT', Iif (lnOption = 2, 'not', 'Not'))
			lcCharsToAdd = Iif (lcPrevChar ISABLANK Or lcPrevChar $ '(', '', ' ')  ;
				+ lcNot + Iif (lcNextChar ISABLANK, '', ' ')

		Case This.oPrefs.nDefinitionForNOT  = 3							;
				And Not This.isnamechar (lcPrevChar)				;
				And Upper (Substr (lcCode, lnCharPos, 3)) == 'NOT'	;
				And Not This.isnamechar (Substr (lcCode, lnCharPos + 3, 1))
			lcCharsToAdd = Iif (lcPrevChar $ lcCommaOperators, ' ', '') + '!'
			lnCharPos	 = lnCharPos + 2

		Case This.isnamechar (lcThisChar)
			* Add a space after operators or commas
			If lcPrevChar $ lcCommaOperators
				* But not if this is negative constant
				If Not (lcPrevChar == "-"															;
						And Isdigit (lcThisChar)													;
						And Right (This.TrimTrailingWhiteSpace (Left (lcCode, lnCharPos - 2)), 1) $ '([,' + lcOperators ;
						)
					lcCharsToAdd = " " + lcCharsToAdd
				Endif
			Endif

			* substitutions for  # and != and <>
		Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 2 And Inlist (lcThisChar + lcNextChar, '!=', '<>')
			lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '#'
			lnCharPos	 = lnCharPos + 1

		Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 3 And lcThisChar = '#'
			lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '!='

		Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 3 And lcThisChar + lcNextChar = '<>'
			lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '!='
			lnCharPos	 = lnCharPos + 1

		Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 4 And lcThisChar = '#'
			lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '<>'

		Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 4 And lcThisChar + lcNextChar = '!='
			lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '<>'
			lnCharPos	 = lnCharPos + 1

		Case lcThisChar $ ['"{] Or	;
				(lcThisChar = '[' And Not This.isnamechar (Right (This.TrimTrailingWhiteSpace (lcResult), 1)))
			* Grab entire character string (or date string .. {^2010,10,01}
			lcRestLineString	  = Substr (lcCode, lnCharPos + 1)
			lnClosingCharPosition = At (Iif (lcThisChar = "[", "]", Iif (lcThisChar = "{", "}", lcThisChar)), lcRestLineString)
			lcStringConstant	  = lcThisChar + Left (lcRestLineString, lnClosingCharPosition )
			*** JRN 2010-05-03 : select 'normal' string delimiters
			Do Case
				Case This.oPrefs.nStringDelimiters = 2	 ;
						And lcThisChar = ["]	 ;
						And Not ['] $ lcStringConstant
					lcStringConstant = ['] + Left (lcRestLineString, lnClosingCharPosition - 1) + [']
				Case This.oPrefs.nStringDelimiters = 3	 ;
						And lcThisChar = [']	 ;
						And Not ["] $ lcStringConstant
					lcStringConstant = ["] + Left (lcRestLineString, lnClosingCharPosition - 1) + ["]
				Case This.oPrefs.nStringDelimiters = 4	 ;
						And lcThisChar $ ['"]	 ;
						And Not ('[' $ lcStringConstant Or ']' $ lcStringConstant)
					lcStringConstant = '[' + Left (lcRestLineString, lnClosingCharPosition - 1) + ']'
			Endcase

			lcCharsToAdd = lcStringConstant
			lcThisChar	 = Right (lcStringConstant, 1)
			lnCharPos	 = lnCharPos + lnClosingCharPosition
			* Add a space after operators or commas
			If lcPrevChar $ lcCommaOperators
				lcCharsToAdd = " " + lcCharsToAdd
			Endif

		Case lcPrevChar == "&" And lcThisChar == "&"
			* double && -- trailing comment
			lcResult = lcResult + Substr (lcCode, lnCharPos)
			Exit

		Case lcPrevChar == "(" Or lcThisChar == ")"
			* no spaces after ( or before )

			* Case lcThisChar $ lcOperators And lcPrevChar $ lcOperators

		Case tlTextMerge And lcPrevChar + lcThisChar = '<<'
			* no added space after << within text merging
			lcCharsToAdd = lcThisChar + lcNextChar
			lnCharPos	 = lnCharPos + 1

		Case tlTextMerge And lcThisChar + lcNextChar = '>>'
			* no added space before >> within text merging

		Case lcThisChar + lcNextChar = '->'
			* no added space before >> within text merging
			lcCharsToAdd = lcThisChar + lcNextChar + Substr (lcCode, lnCharPos + 2, 1)
			lnCharPos	 = lnCharPos + 2

		Case Inlist (lcPrevChar + lcThisChar, "<=", ">=", "<>", "==", "!=", "**", ".*", "<<", ">>", "{/", "//", "/:", "/}", "--", "/*", "*/", "=<", "=>")
			* Special cases for  <=   >=   <>   ==   !=  **   .*

		Case lcThisChar == "+" And							;
				(											;
				Upper (Right (lcResult, 3)) == "ALT" Or	;
				Upper (Right (lcResult, 4)) == "CTRL" Or	;
				Upper (Right (lcResult, 5)) == "SHIFT"	;
				)
			* no space for hotkey definitions (CTRL+X, etc)
			lcCharsToAdd = lcThisChar + lcNextChar
			lnCharPos	 = lnCharPos + 1

		Case lcThisChar $ lcOperators And Not (lcPrevChar ISABLANK)
			* space before operators (finally!)
			If lnCharPos > 1

				***********************************************
				If Not Empty (This.cpluginisoperator)
				* 2011.11.22 MarioPeschke
				*            allowed to add spaces, only for specific structures
					Try
						llIsOperator = Execscript (This.cpluginisoperator, lcCode,lnCharPos)
					Catch To loException
						This.ShowErrorMsg (loException, 'IsOperator Failure')
					Endtry
				Endif
				If llIsOperator
					lcCharsToAdd = " " + lcThisChar
				Endif
			Endif

		Case This.oPrefs.nBeforeLeftParens = 3	 ;
				And lcThisChar = '('			 ;
				And (Not (lcPrevChar ISABLANK))	 ;
				And (Not (Isdigit (lcNextChar) Or lcNextChar = ')'))
			* (conditionally) add space before left parenthesis
			lcCharsToAdd = " " + lcThisChar

		Case (lcThisChar == "," And This.oPrefs.lSpaceBeforeCommas) Or (lcThisChar = '(' And This.oPrefs.nBeforeLeftParens = 2)
			* remove spaces or tabs before comma and left parentheses
			If Not Empty (lcResult)
				lcResult = This.TrimTrailingWhiteSpace (lcResult)
			Endif
			* but leave spaces between multiples commas   (a, b, , ,)
			If Right (lcResult, 1) = ','
				lcCharsToAdd = ' ' + lcThisChar
			Endif

			* Add a space after operators or commas
		Case lcPrevChar $ lcCommaOperators And Not lcThisChar ISABLANK
			lcCharsToAdd = " " + lcCharsToAdd

	Endcase

	lcResult   = lcResult + lcCharsToAdd
	If llIsOperator
		lcPrevChar = Right (lcCharsToAdd, 1)
	Else
		lcPrevChar = 'X'
 	EndIf 

Endfor

Return lcResult


ENDPROC
PROCEDURE beautifyword
Lparameters tcWord

Local lcWord
Do Case
	Case This.nBeautifyOptions(2) = 1
		lcWord = Upper(tcWord)
	Case This.nBeautifyOptions(2) = 2
		lcWord = Lower(tcWord)
	Otherwise
		lcWord = Proper(tcWord)
Endcase

Return lcWord
ENDPROC
PROCEDURE calccolumn
Lparameters lcLine, lcText
Local lcLeft, lnPos 

lnPos = 1 + At (' ' + lcText + ' ', Strtran (Upper (lcLine), Tab, ' ', 1, 999))
If lnPos <= 1
	Return lcLine
Endif

lcLeft = Left (lcLine, lnPos - 1)
Return This.CountCharacterWidth (This.TrimTrailingWhiteSpace (lcLeft))




ENDPROC
PROCEDURE calccolumnoffset
Lparameters lnCol, lnOffset

If lnOffset <= 4
	Return lnCol + 1 + lnOffset
Else
	Return (lnCol - lnCol % This.nTabWidth) + This.nTabWidth + 1 + IIf (lnOffset = 5, 0, This.nTabWidth)
Endif

ENDPROC
PROCEDURE converttabsforindent
Lparameters lcNewIndent

If This.oPrefs.lUseTabs
	Return Strtran (lcNewIndent, Space (This.nTabWidth), Tab)
Else
	Return lcNewIndent
Endif

ENDPROC
PROCEDURE createidlist
Lparameters lcProcName, lnStartLine, lnEndLine

Local loRegExp As 'VBScript.RegExp'
Local laLocals[1], laParens[1], lcName, lcNewCode, lcNotNameChars, lcRestLineString, lcSourceLine
Local lcThisChar, lcUpperWord, lcWord, lcWord1, lcWord2, lcWordNew, llAssign, llLongEnough
Local lnCharPos, lnClosingCharPosition, lnI, lnJ, lnLineCount, lnLoop, lnLoopStartValue
Local lnParenCount, lnParenLevel, lnPos, lnType

With This
	.FixWithStatements() && this is for setup only
	.nNewLocalsCount	  = 0
	.cCurrentLocals		  = This.FindCurrentLocals (lnStartLine, lnEndLine)
	.lNoDotsInAssignments = .F.
	.CreateNewLocals (lnStartLine, lnEndLine, .T.)
Endwith

lcNotNameChars = Chrtran (NOTNAMECHARS, '&\(^),', '') + Tab + CR + LF

loRegExp = This.oUtils.GetRegExp()

****************************************************************
For lnLoop = lnStartLine To lnEndLine
	lnLoopStartValue = lnLoop
	lcSourceLine	 = ' ' + This.GetSourceCodeLine (@lnLoop, .T.)

	If Empty (lcSourceLine)
		Loop
	Endif

	With loRegExp
		* replace all white space and sem-colons with simple white space
		.Pattern	 = '(\s+|;)'
		lcSourceLine = .Replace (lcSourceLine, ' ')
	Endwith

	lcWord1		 = Upper (Getwordnum (lcSourceLine, 1))
	lcWord2		 = Getwordnum (lcSourceLine, 2)
	llLongEnough = Len (lcWord1) >= 4

	*** JRN 2010-08-16 : pseudo line allowed to identify tables in use

	If Inlist (lcWord1, '*', '#', INLINECOMMENTS)
		Loop
	Endif

	If llLongEnough And 'EXTERNAL' = lcWord1
		Loop
	Endif

	Insert Into crsr_IDs_Lines				;
		(ProcID, SourceLine, Lineno)		;
		Values								;
		(crsr_IDs_Procs.Id, lcSourceLine, lnLoopStartValue)

	This.lFieldReference = llLongEnough And (											;
		'SELECT' = lcWord1															;
		Or 'UPDATE' = lcWord1															;
		Or 'REPLACE' = lcWord1														;
		Or 'INSERT' = lcWord1															;
		Or ('CREATE' = lcWord1 And Inlist (Upper (lcWord2), 'TABLE', 'CURSOR'))		;
		)

	If lcWord1 == 'DECLARE'
		If 'IN' == Upper (Getwordnum (lcSourceLine, 3))
			This.InsertID (Getwordnum (lcSourceLine, 2), TYPE_Declared)
		Else
			This.InsertID (Getwordnum (lcSourceLine, 3), TYPE_Declared)
		Endif
		Loop
	Endif

	lcNewCode	 = This.ParseLineForIDList (lcSourceLine, lcNotNameChars)
	lnParenLevel = 0

	With loRegExp
		.Pattern  = '(Alt|Shift|Ctrl)\s+\+\s'
		lcNewCode = .Replace (lcNewCode, '$1+')
	Endwith

	If Upper (lcNewCode) = ' *{PEME:TABLES}'
		lcSourceLine = 'From ' + Substr (lcNewCode, 16)
	Endif

	If llLongEnough
		If 'LOCAL' = lcWord1 Or 'PRIVATE' = lcWord1
			This.InsertLocalIDs (lcNewCode, TYPE_Locals, 2)
			Loop
		Endif

		If 'LPARAMETERS' = lcWord1 Or 'PARAMETERS' = lcWord1
			This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 2)
			Loop
		Endif

		If 'PROCEDURE' = lcWord1 Or 'FUNCTION' = lcWord1
			This.InsertID (lcProcName, Iif('.' $ lcProcName, TYPE_Methods, TYPE_Procedures))
			This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 3)
			Loop
		Endif

		If 'HIDDEN' = lcWord1 Or 'PROTECTED' = lcWord1
			This.InsertID (lcProcName, Iif('.' $ lcProcName, TYPE_Methods, TYPE_Procedures))
			This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 4)
			Loop
		Endif

	Endif

	For lnI = 1 To Getwordcount (lcNewCode)
		lcWord		= Getwordnum (lcNewCode, lnI)
		lcUpperWord	= Upper (lcWord)

		Do Case

			Case Left (lcUpperWord, 1) $ '^+'

			Case lcUpperWord = '('
				lnParenLevel = lnParenLevel + 1

			Case lcUpperWord = ')'
				lnParenLevel = lnParenLevel - 1

			Case lcUpperWord == 'DO'
				Do Case
					Case Upper (lcWord2) == 'CASE'
					Case Upper (lcWord2) == 'WHILE'
					Case Upper (lcWord2) == 'FORM'
						lnType = TYPE_Forms
						lcWord = Getwordnum (lcNewCode, lnI + 2)
						This.InsertID (lcWord, lnType)
					Otherwise
						lnType = TYPE_Procedures
						lcWord = Getwordnum (lcNewCode, lnI + 1)
						This.InsertID (lcWord, lnType)
				Endcase

				* Tables
			Case lcUpperWord == 'USE'
				lnType = TYPE_Tables
				lcWord = Getwordnum (lcNewCode, lnI + 1)
				This.InsertID (lcWord, lnType)

			Case lcUpperWord == 'JOIN'
				lnType = TYPE_Tables
				lcWord = Getwordnum (lcNewCode, lnI + 1)
				This.InsertID (lcWord, lnType)
				Do Case
					Case Upper (Getwordnum (lcNewCode, lnI + 2)) == 'AS'
						lcWord = Getwordnum (lcNewCode, lnI + 3)
						This.InsertID (lcWord, lnType)
					Case Not Upper (Getwordnum (lcNewCode, lnI + 2)) == 'ON'
						lcWord = Getwordnum (lcNewCode, lnI + 2)
						This.InsertID (lcWord, lnType)
				Endcase

			Case lcUpperWord == 'FROM'
				lnType = TYPE_Tables
				For lnJ = lnI + 1 To Getwordcount (lcNewCode)
					lcWord = Getwordnum (lcNewCode, lnJ)
					This.InsertID (lcWord, lnType)
					lcWordNew = Getwordnum (lcNewCode, lnJ + 1)
					Do Case
						Case Empty (lcWord)
							Exit
						Case Upper (lcWordNew) == 'AS'
							lnJ = lnJ + 1
						Case lcWordNew = ','
							lnJ = lnJ + 1
						Case This.Iskeyword (lcWordNew)
							Exit
					Endcase
				Endfor

			Case lcUpperWord == 'IN' And lcWord1 # 'FOR'
				lnType = TYPE_Tables
				lcWord = Getwordnum (lcNewCode, lnI + 1)
				If Not Inlist (Upper (lcWord) + ' ', 'SCREEN ', 'WIN32API ', 'KERNEL32 ')
					This.InsertID (lcWord, lnType)
				Endif

			Case lcUpperWord == 'SELECT'
				lnType = TYPE_Tables
				lcWord = Getwordnum (lcNewCode, lnI + 1)
				If Empty (Getwordnum (lcNewCode, lnI + 2))
					This.InsertID (lcWord, lnType)
				Endif

			Case lcUpperWord == 'CREATE' And Inlist (' ' + Upper (Getwordnum (lcNewCode, lnI + 1)), ' TABLE', ' CURSOR')
				lnType = TYPE_Tables
				lcWord = Getwordnum (lcNewCode, lnI + 2)
				This.InsertID (lcWord, lnType)

			Case lcUpperWord == 'INSERT' And Upper (Getwordnum (lcNewCode, lnI + 1)) =  'INTO'
				lnI	   = lnI + 2
				lcWord = Getwordnum (lcNewCode, lnI)

				Do Case
					Case lcWord = '('
						Do While .T.
							lnI		= lnI + 1
							lcWord2	= Getwordnum (lcNewCode, lnI)
							If Empty (lcWord2) Or lcWord2 = ')'
								Exit
							Else
								This.InsertIDOthers (lcWord2, Getwordnum (lcNewCode, lnI + 1))
							Endif
						Enddo
						lcWord = '?Table'
						lnType = TYPE_Tables
						This.InsertID (lcWord, lnType)

					Case lcWord = '^'
						lcWord = '?Table'
						lnType = TYPE_Tables
						This.InsertID (lcWord, lnType)

					Otherwise
						lnType = TYPE_Tables
						This.InsertID (lcWord, lnType)
				Endcase

				lnI		= lnI + 1
				lcWord2	= Getwordnum (lcNewCode, lnI)
				If lcWord2 = '('
					Do While .T.
						lnI		= lnI + 1
						lcWord2	= Getwordnum (lcNewCode, lnI)
						If Empty (lcWord2) Or lcWord2 = ')'
							Exit
						Else
							This.InsertID (lcWord + '.' + lcWord2, TYPE_Objects)
						Endif
					Enddo
				Endif

			Case lcUpperWord == 'INTO' And Inlist (' ' + Upper (Getwordnum (lcNewCode, lnI + 1)), ' TABLE', ' CURSOR')
				lnType = TYPE_Tables
				lcWord = Getwordnum (lcNewCode, lnI + 2)
				This.InsertID (lcWord, lnType)

			Case Inlist (lcUpperWord, 'UPDATE', 'ALIAS')
				lnType = TYPE_Tables
				lcWord = Getwordnum (lcNewCode, lnI + 1)
				This.InsertID (lcWord, lnType)

			Case 1 = Len (lcWord) And lcUpperWord $ ASDATATYPE_CHARS
				* do nothing for single character names that can be used in Cast( AS ...) or Create Cursor or Create Table

			Otherwise
				This.InsertIDOthers (lcWord, Getwordnum (lcNewCode, lnI + 1))

		Endcase
	Endfor

Endfor

Return

ENDPROC
PROCEDURE createidlistcursors
Create Cursor crsr_IDs_Procs (			;
	  Id     		I AutoIncr,			;
	  ProcName   	C(250),				;
	  StartLine	    N(6)				;
	  )

Create Cursor crsr_IDs_Lines (			;
	  Id     		I AutoIncr,			;
	  ProcID        I,					;
	  SourceLine	M,					;
	  Lineno		N(4),				;
	  AnyFound		L					;
	  )

Create Cursor crsr_IDs_Refs (		;
	  ProcID        I,				;
	  LineID		I,				;
	  Name		 	C(100),			;
	  Type      	N(2)			;
	  )

Create Cursor crsr_IDs_Constants  (			;
	  Constant      C(100)				;
	  )
ENDPROC
PROCEDURE createidlistsummary
Lparameters lcProcName
Local laLocals[1], lcName, lnI, lnLineCount

Select  Distinct									;
		Upper (Name)		 As	 UpperName,			;
		TYPE_Tables			 As	 nNewType,			;
		Len (Trim (Name))	 As	 nLength			;
	From crsr_IDs									;
	Where nType = TYPE_Tables						;
	Into Cursor crsr_Tables Readwrite

Select  Upper (Name)				   As  UpperName,											;
		Min (Name)					   As  Name,												;
		Min (Nvl (nNewType, nType))	   As  nType												;
	From crsr_IDs																				;
		Left Join crsr_Tables																	;
			On Left (crsr_Tables.UpperName, nLength) = Upper (Left (crsr_IDs.Name, nLength))	;
			And Substr (crsr_IDs.Name, nLength + 1, 1) $ ' .'									;
	Where Upper (Name) # Upper (Evl (lcProcName, '??'))											;
	Group By 1																					;
	Order By 3, 1																				;
	Into Cursor crsr_Summary


ENDPROC
PROCEDURE createlocalsforcodeblock
Lparameters lcCodeSource, lnWindowType, lnCurrentLine, llLocalsAllProcs
Local lcCode, lcName, lcNewCode, lcType, lnEnd, lnI, lnJ, lnStart 

This.SetBeautifyOptions()
Alines (This.aCodeLines, lcCodeSource + ' ')

Do Case
	Case lnWindowType = 10 && Method Code
		lcNewCode = This.DoLocals (1, Alen (This.aCodeLines))
	Case lnWindowType = 1 && PRG
		This.ParsePRGCodeBlocks ()
		lcNewCode = ''
		For lnI = 1 To Alen (This.aPRGCodeBlocks, 1)
			lcName	= This.aPRGCodeBlocks (lnI, 1)
			lcType	= This.aPRGCodeBlocks (lnI, 2)
			lnStart	= This.aPRGCodeBlocks (lnI, 3)
			lnEnd	= This.aPRGCodeBlocks (lnI, 4)
			If lcType $ 'PF' And (		;
					  llLocalsAllProcs Or Between (lnCurrentLine + 1, lnStart, lnEnd))
				lcCode	  = This.DoLocals (lnStart, lnEnd)
				lcNewCode = IIf (Empty (lcNewCode), '', lcNewCode + LINEEND) + lcCode
			Else
				For lnJ = lnStart To lnEnd
					lcNewCode = IIf (Empty (lcNewCode), '', lcNewCode + LINEEND) + This.aCodeLines (lnJ)
				Endfor
			Endif
		Endfor
	Otherwise
		Return
Endcase

Return lcNewCode

ENDPROC
PROCEDURE createlocalstatements
Local laLocals[1]
Local lcArrayDims, lcASPhrase, lcCode, lcLine, lcLocalName, lcLocalPhrase, lcLocalsPlugIn, lcName
Local lcResult, lcVar, llAlreadyLocal, llArray, llCommasBeforeLocals, llContinuation, llHasASPhrase
Local llStartsWithL, llUseAsPhrase, llUseTabs, lnMaxWidth, lnRow, lnSelectionType, lnType
Local llAssigned, llRemoveOrphanLocals, llSortCreatedLocals  

If This.nNewLocalsCount = 0
	Return ''
Endif

lcLocalsPlugIn = This.oUtils.GetPlugInPath ("CreateLocalsStatements")
If Not Empty (lcLocalsPlugIn)
	Acopy (This.aNewLocals, laLocals)
	lcCode = Execscript (Filetostr (lcLocalsPlugIn), @laLocals)
	Return lcCode
Endif

****************************************************************

This.SetBeautifyOptions()
lcLocalName = This.BeautifyWord('Local ')
llUseTabs = This.nBeautifyOptions(4) = 1

With This.oPrefs
	llContinuation		 = Not .lLocalsMultPerLine
	lnSelectionType		 = .nLocalsSelectionType
	lnMaxWidth			 = .nLocalsLineWidth
	llUseAsPhrase		 = .lLocalsUseAS
	llCommasBeforeLocals = .lCommasBeforeLocals
	llRemoveOrphanLocals = .lRemoveOrphanLocals
	llSortCreatedLocals  = .lSortCreatedLocals 
Endwith

****************************************************************
With This

	If llSortCreatedLocals  
		Asort (.aNewLocals, 1, -1, 0, 0)
	EndIf 

	lcResult = ''
	For lnType = 1 To 4
		lcLine = ''
		For lnRow = 1 To Alen (.aNewLocals, 1)

			lcName		   = .aNewLocals (lnRow, 1)
			lcASPhrase	   = .aNewLocals (lnRow, 2)
			llArray		   = .aNewLocals (lnRow, 3)
			llHasASPhrase  = .aNewLocals (lnRow, 4)
			llStartsWithL  = .aNewLocals (lnRow, 5)
			llAlreadyLocal = .aNewLocals (lnRow, 6)
			lcArrayDims	   = .aNewLocals (lnRow, 7)
			llAssigned     = .aNewLocals (lnRow, 8)

			lcName = lcName + IIf (llArray, '[' + lcArrayDims + ']', '')

			Do Case

					****************************************************************
				Case llRemoveOrphanLocals and llAlreadyLocal and (not llAssigned) and (not llArray)
					Loop
					
				Case llUseAsPhrase And llStartsWithL
					If lnType = 1
						lcVar		  = This.AddASPhase (lcName, lcASPhrase)
						lcLocalPhrase = lcLocalName
					Else
						Loop
					Endif

				Case llUseAsPhrase And lnType = 1 And lnSelectionType = 4
					lcVar		  = This.AddASPhase (lcName, lcASPhrase)
					lcLocalPhrase = lcLocalName

				Case llUseAsPhrase And lnType = 2 And lnSelectionType = 3
					lcVar		  = This.AddASPhase (lcName, lcASPhrase)
					lcLocalPhrase = lcLocalName

				Case llUseAsPhrase And lnType = 3 And lnSelectionType = 2
					lcVar		  = This.AddASPhase (lcName, lcASPhrase)
					lcLocalPhrase = '*:Global '

				Case llUseAsPhrase
					Loop

					****************************************************************
				Case lnSelectionType = 1 And Not llStartsWithL
					Loop

				Case llHasASPhrase And lnType = 1
					lcVar		  = lcName + This.BeautifyWord(' as ') + lcASPhrase
					lcLocalPhrase = lcLocalName
				Case llHasASPhrase
					Loop

				Case llStartsWithL And lnType = 2
					lcVar		  = lcName
					lcLocalPhrase = lcLocalName
				Case llStartsWithL
					Loop

				Case lnSelectionType = 4 And lnType = 2
					lcVar		  = lcName
					lcLocalPhrase = lcLocalName

				Case lnSelectionType = 2 And lnType = 3 And llAlreadyLocal
					lcVar		  = lcName
					lcLocalPhrase = lcLocalName

				Case lnSelectionType = 2 And lnType = 4 And Not llAlreadyLocal
					lcVar		  = lcName
					lcLocalPhrase = '*:Global '
				Case lnSelectionType = 3 And lnType = 4
					lcVar		  = lcName
					lcLocalPhrase = lcLocalName

				Otherwise
					Loop
			Endcase

			Do Case
				Case Empty (lcLine)
					lcLine = lcLocalPhrase  + lcVar
				Case llContinuation Or llUseAsPhrase
					If llCommasBeforeLocals
						lcLine = lcLine + ';' + LINEEND + IIf (llUseTabs, Tab, '') + ', ' + lcVar
					Else
						lcLine = lcLine + ', ;' + LINEEND + IIf (llUseTabs, Tab, '') + lcVar
					Endif
				Case lnType # 1 And (Len (lcLine) + 2 + Len (lcVar)) <= lnMaxWidth
					lcLine = lcLine + ', ' + lcVar
				Otherwise
					lcResult = lcResult + lcLine + LINEEND
					lcLine	 = lcLocalPhrase  + lcVar
			Endcase
		Endfor

		If Not Empty (lcLine)
			lcResult = lcResult + lcLine + LINEEND
		Endif
	Endfor

Endwith

Return Left (lcResult, Len (lcResult) - 2)

ENDPROC
PROCEDURE createnewlocals
Lparameters lnStartLoop, lnEndLoop, llFixWITHs
* This.aNewLocals:
*    Col 1 = Local Name
*    Col 2 = AS blabla
*    Col 3 = Array?
*    Col 4 = Col 2 non-empty
*    Col 5 = Begins with lowercase 'l'
*    Col 6 = Already found in LOCALs
*    Col 7 = Array parameters
*    Col 8 = Actual assignment?
*    Col 9 = <Unused>
*    Col 10 = <Unused>

Local laLocals[1], laWithEndWith[1]
Local lcArrayFunc, lcArrayFunctions, lcArrayLine, lcArrayParse, lcASPhrase, lcChar
Local lcCurrentWithEndWith, lcDims, lcExpression, lcName, lcObjClassLib, lcObjType, lcParams, lcParse
Local lcSourceLine, lcTmp, lcVar, lcWord, lcWord1, lcWord2, llCreateObject, llFirstTimeThru, llNameOK
Local lnI, lnLoop, lnPos, lnWithEndWithLevel, lnWord

llFirstTimeThru = .T.
This.FixWithStatements()

For lnLoop = lnStartLoop To lnEndLoop
	lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
	lcWord1 = Lower (Getwordnum (lcSourceLine, 1))
	lcWord2 = Lower (Getwordnum (lcSourceLine, 2))

	If llFixWITHs
		lcSourceLine = This.FixWithStatements(lcSourceLine)
	Endif

	lcParse = ''
	If Empty (lcSourceLine) Or lcWord1 = '*'
		Loop
	Endif

	Do Case

		Case 'procedure ' = lcWord1 Or 'function ' = lcWord1
			If Not llFirstTimeThru
				Exit
			Endif

		Case ('protected ' = lcWord1 Or 'hidden ' = lcWord1)		;
				And ('procedure ' = lcWord2 Or 'function ' = lcWord2)
			If Not llFirstTimeThru
				Exit
			Endif

		Case ' to array ' $ Lower (lcSourceLine) And (		;
				'copy ' = lcWord1							;
				Or 'scatter ' = lcWord1					;
				Or 'sum ' = lcWord1						;
				Or 'calculate ' = lcWord1					;
				Or 'average ' = lcWord1					;
				)
			lcParse = Substr (lcSourceLine, Rat ([ to ], Lower (lcSourceLine)) + 10)
			For lnWord = 1 To 1000
				lcWord = Alltrim (Getwordnum (lcParse, lnWord, ','))
				If Empty (lcWord)
					Exit
				Else
					This.AddNewLocal (Getwordnum (lcWord, 1), , .T.)
				Endif
			Endfor

		Case ' to ' $ Lower (lcSourceLine) And (		;
				'store ' = lcWord1					;
				Or 'calculate ' = lcWord1				;
				Or 'average ' = lcWord1				;
				Or 'sum ' = lcWord1					;
				Or 'count ' = lcWord1					;
				Or 'wait ' = lcWord1					;
				Or 'catch ' = lcWord1					;
				)
			lcParse = lcSourceLine			
			lcParse = This.RemoveParens(lcParse)
			If ' to ' $ Lower (lcParse)
				lcParse = Substr (lcParse, Rat ([ to ], Lower (lcParse)) + 4)
				lcParse = Strtran(lcParse, ';', ' ')
				For lnWord = 1 To 1000
					lcWord = Alltrim (Getwordnum (lcParse, lnWord, ','))
					If Empty (lcWord) 
						Exit
					Else
						This.AddNewLocal (Getwordnum (lcWord, 1))
						If 1 # GetWordCount(lcWord)
							Exit
						EndIf 
					Endif
				EndFor
			EndIf 

		Case 'dimension ' = lcWord1
			lcSourceLine = Alltrim (lcSourceLine)
			lcParse = Substr (lcSourceLine, At (' ', lcSourceLine) + 1)
			If Not Empty (lcParse)
				Dimension laLocals(1)
				This.ParseCodeLine (lcParse, @laLocals, .T.)

				For lnI = 1 To Alen (laLocals, 1)
					lcName = laLocals (lnI, 1)
					lcDims = laLocals (lnI, 2)
					lcASPhrase = laLocals (lnI, 3)
					This.AddNewLocal (lcName, , .T.)
				Endfor
			Endif

		Case 'catch ' = lcWord1 And 'to ' = lcWord2
			This.AddNewLocal (Getwordnum (lcSourceLine, 3))
		Case 'select ' = lcWord1 And ' into array ' $ Lower (lcSourceLine)
			lcParse = GetWordNum (Substr (lcSourceLine, Rat (' into array ', Lower (lcSourceLine)) + 12), 1)
			This.AddNewLocal (lcParse + '(1)')
		Case 'scatter ' = lcWord1 And ' name ' $ Lower (lcSourceLine)
			lcParse = Strextract (lcSourceLine, ' name ', ' ', 1, 1 + 2)
			This.AddNewLocal (Getwordnum (lcParse, 1))
		Case Lower (Left (lcSourceLine, 9)) = 'for each '
			lcParse = Strextract (lcSourceLine, 'for each ', ' ', 1, 3)
			If ' as ' $ Lower (lcSourceLine)
				lcASPhrase = Strextract (lcSourceLine, ' as ', ' ', 1, 3)
				This.AddNewLocal (Getwordnum (lcParse, 1), Getwordnum (lcASPhrase, 1))
			Else
				This.AddNewLocal (Getwordnum (lcParse, 1))
			Endif
		Case 'for ' = lcWord1
			lcParse = Strextract (lcSourceLine, 'for ', '=', 1, 3)
			This.AddNewLocal (lcParse)
		Case Left (Lower (lcSourceLine), 8) = 'text to '
			lcParse = Getwordnum (lcSourceLine, 3)
			This.AddNewLocal (lcParse)
		Case '=' $ lcSourceLine
			lnPos = At ('=', lcSourceLine)
			lcVar = Alltrim (Left (lcSourceLine, lnPos - 1))
			lcExpression = Alltrim (Substr (lcSourceLine, lnPos + 1))
			llNameOK = .T.
			For lnI = 1 To Len (lcVar)
				lcChar = Substr (lcVar, lnI, 1)
				llNameOK = llNameOK And (This.IsNameChar (lcChar) Or lcChar $ '.()[]')
			Endfor
			If llNameOK
				lcASPhrase = ''
				If Inlist (Lower (Left (lcExpression, 9)), 'newobject', 'createobj')
					llCreateObject = (Lower (Left (lcExpression, 9)) == 'createobj')
					lcExpression = Alltrim (Strextract (lcExpression, [(]))
					If Right (lcExpression, 1) = [)]
						lcExpression = Left (lcExpression, Len (lcExpression) - 1)
					Endif
					lcObjType = Alltrim (Getwordnum (lcExpression, 1, [,]))
					lcObjClassLib = Alltrim (Getwordnum (lcExpression, 2, [,]))
					If Empty (lcObjClassLib) Or llCreateObject
						If Left (lcObjType, 1) $ (['"] + '[')
							lcASPhrase = lcObjType
						Endif
					Else
						If Left (lcObjType, 1) $ (['"] + '[') And Left (lcObjClassLib, 1) $ (['"] + '[')
							lcASPhrase = lcObjType + [ OF ] + lcObjClassLib
						Endif
					Endif
				Endif
				This.AddNewLocal (lcVar, lcASPhrase)
			Endif
	Endcase

	*-- THM 08/31/2006 - Support for inline array functions.
	*Support for array functions - lines may contain more than one of these....
	*-- RCE 01/23/2009 - respect Current Locals
	lcArrayFunctions = 'aclass,acopy,adatabases,adbobjects,adir,adlls,adockstate,aerror,aevents,afields,' ;
		+ 'afont,agetclass,agetfileversion,ainstance,alanguage,alines,amembers,amouseobj,anetresources,aprinters,' ;
		+ 'aprocinfo,aselobj,asessions,asqlhandles,astackinfo,ataginfo,aused,avcxclasses'
	lcArrayParse = ''
	lcArrayLine = Chrtran (lcSourceLine, ' ', '')
	For lnI = 1 To Getwordcount (lcArrayFunctions, ',')
		lcArrayFunc = Getwordnum (lcArrayFunctions, lnI, ',')
		*** JRN 2010-04-21 : check character before reference to make sure it is not part of a name ... laMouseObj, e.g.,
		If lcArrayFunc + '(' $ Lower (lcArrayLine)
			lnPos = At (lcArrayFunc + '(', Lower (lcArrayLine))
			If Not This.IsNameChar (Substr (lcArrayLine, lnPos - 1, 1))
				lcParams = Strextract (Substr (lcArrayLine, lnPos), '(', ')')
				This.AddNewLocal (Getwordnum (lcParams, 1, ','), , .T.)
				If lcArrayFunc = 'acopy'
					This.AddNewLocal (Getwordnum (lcParams, 2, ','), , .T.)
				Endif
			Endif
		Endif
	Endfor

	*-- THM 08/31/06 - Support for 'DO FORM'
	*-- RCE 01/23/09 - Support for WITH clause; respect Current Locals
	If Left (Lower (lcSourceLine), 8) = 'do form '
		If ' to ' $ Lower (lcSourceLine)
			lcTmp = Getwordnum (Substr (lcSourceLine, Rat ([ to ], Lower (lcSourceLine)) + 4), 1)
			This.AddNewLocal (lcTmp)
		Endif

		If ' name ' $ Lower (lcSourceLine)
			lcTmp = Getwordnum (Substr (lcSourceLine, Rat ([ name ], Lower (lcSourceLine)) + 6), 1)
			This.AddNewLocal (lcTmp, 'Form')
		Endif

	Endif
	llFirstTimeThru = .F.
Endfor

ENDPROC
PROCEDURE doformidlist
Lparameters lnHandle, lcSourceFileName, lcClassName

Local loFormIDList As 'FrmIDList' Of 'Source\EditProperty.VCX'
Select  *						;
	From crsr_IDs_Lines			;
	Where AnyFound				;
	Into Cursor crsr_IDS_Lines2

loFormIDList 	 = Newobject ('FrmIDList', 'Source\EditProperty.VCX', ''		;
	  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Procs')						;
	  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Lines2')						;
	  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Refs')						;
	  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Constants')					;
	  , This.oUtils.cApplicationPath											;
	  , This.oUtils																;
	  , lnHandle, lcSourceFileName, lcClassName									;
	  )

loFormIDList.Show()

* following allows this to be kept around after this method ends
* and also to be cleaned up when _oPEMEditor closes
This.oUtils.AddProperty ('o' + Sys(2015), loFormIDList)

ENDPROC
PROCEDURE doidlisttext
Lparameters lcSourceLine, lnLoop, lnLinesCount

Local lcFirstWord, lcLine, lcType, lnI
Do Case
	Case '{PEME:IGNORE}' $ Upper (lcSourceLine)
		lcType = 'Ignore'
	Case '{PEME:CODE}' $ Upper (lcSourceLine)
		lcType = 'Code'
	Case '{PEME:SELECT}' $ Upper (lcSourceLine)
		lcType = 'Select'
	Case This.oPrefs.lBeautifyTEXTasSelect
		For lnI = lnLoop + 1 To lnLinesCount
			lcLine		= This.aCodeLines[lnI]
			lcFirstWord	= Upper (Getwordnum (lcLine, 1))
			Do Case
				Case Empty (lcFirstWord)

				Case 'SELECT ' = lcFirstWord
					lcType = 'Select'
					Exit
				Otherwise
					lcType = 'Ignore'
					Exit
			Endcase
		Endfor lnI = lnLoop + 1 To lnLinesCount
	Otherwise
		lcType = 'Ignore'
Endcase

If lcType = 'Ignore'
	For lnI = lnLoop + 1 To lnLinesCount
		lcLine		= This.aCodeLines[lnI]
		lcFirstWord	= Upper (Getwordnum (lcLine, 1))
		If lcFirstWord == 'ENDTEXT'
			Return lnI
		Endif
	Endfor lnI = lnLoop + 1 To lnLinesCount
Endif lcType = 'Ignore'

Return lnLoop
ENDPROC
PROCEDURE dolocals
Lparameters lnStartLine, lnEndLine
Local lcLocalStatements, lcNewCode, lcSourceLine, lcWord1, llAddTheseLines, llInsertLocalsLater
Local llInsertNewLocals, lnI, lnLoop, lnLoopValueBefore

This.nNewLocalsCount = 0
Dimension This.aNewlocals(1,10)
* This.aNewLocals:
*    Col 1 = Local Name
*    Col 2 = AS blabla
*    Col 3 = Array?
*    Col 4 = Col 2 non-empty
*    Col 5 = Begins with lowercase 'l'
*    Col 6 = Already found in LOCALs
*    Col 7 = Array parameters
*    Col 8 = Actual assignments
*    Col 9 = <Unused>
*    Col 10 = <Unused>

This.cCurrentLocals = This.FindCurrentLocals (lnStartLine, lnEndLine, this.oPrefs.lMovelocals)
This.lNoDotsInAssignments = .T.
This.CreateNewLocals (lnStartLine, lnEndLine)
lcLocalStatements = This.CreateLocalStatements()

lcNewCode = ''
For lnLoop = lnStartLine To lnEndLine
	lnLoopValueBefore = lnLoop
	lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
	lcWord1 = Lower (Getwordnum (lcSourceLine,1))
	llAddTheseLines = .T.
	llInsertNewLocals = .F.

	Do Case
		Case Len (lcWord1) >= 4 And 'local ' = (lcWord1 + ' ')
			If This.oPrefs.lMoveLocals
				llAddTheseLines = .F.
				llInsertNewLocals = .T.
			Else
				llInsertLocalsLater = .T.
			Endif

		Case llInsertLocalsLater
			llInsertNewLocals = .T.

		Case Empty (lcSourceLine)

		Case lcWord1 = '#if'
			llInsertNewLocals = .T.

		Case Inlist (lcWord1, '*', '#', INLINECOMMENTS)

		Case Len (lcWord1) >= 4 And 			;
				('procedure ' 		= lcWord1 	;
				or 'function ' 		= lcWord1 	;
				or 'hidden ' 		= lcWord1 	;
				or 'protected ' 	= lcWord1 	;
				or 'lparameters ' 	= lcWord1 	;
				or 'parameters ' 	= lcWord1 	;
				or 'public ' 		= lcWord1 	;
				or 'private ' 		= lcWord1 	;
				or '*:global ' 		= lcWord1 	;
				)

		Otherwise
			llInsertNewLocals = .T.

	Endcase

	If llInsertNewLocals And Not Empty (lcLocalStatements)
		lcNewCode = Iif (Empty (lcNewCode), '', lcNewCode + LINEEND) + lcLocalStatements
		lcLocalStatements = ''
	Endif

	If llAddTheseLines
		For lnI = lnLoopValueBefore To lnLoop
			lcNewCode = Iif (Empty (lcNewCode), '', lcNewCode + LINEEND) + This.aCodeLines (lnI)
		Endfor
	Endif
Endfor

Return lcNewCode

ENDPROC
PROCEDURE fetchparameterslist
Local lcCodeSource

lcCodeSource = This.GetEditorWindowText (.T.)

If Empty (lcCodeSource)
	Return .F.
Endif

Return This.GetParametersList (lcCodeSource)


ENDPROC
PROCEDURE findcurrentlocals
Lparameters lnStartLoop, lnEndLoop, llMoveLocals
Local laLocals[1], lcASPhrase, lcCurrentLocals, lcDims, lcName, lcSourceLine, lcType, lcWord1
Local llFirstTimeThru, lnI, lnLoop

lcCurrentLocals	= ','
llFirstTimeThru	= .T.
This.nLocalsList	= 0

* Find the existing local declarations
For lnLoop = lnStartLoop To lnEndLoop
	* Add SourceLine to previous if continuation line
	lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)

	lcSourceLine = IIf (Lower (Left (lcSourceLine, 7)) == 'hidden ', Alltrim (Substr (lcSourceLine, 8)), lcSourceLine)
	lcSourceLine = IIf (Lower (Left (lcSourceLine, 10)) == 'protected ', Alltrim (Substr (lcSourceLine, 11)), lcSourceLine)

	*--------------------------------------------------
	*  GLR 8-29-2006 : add Private, Public, and Dimension to the list of possible declaration statements
	*--------------------------------------------------
	*-- GLR 8/31/2006 : added 'Define' to list
	*-- THM 8/31/2006 : removed 'dimens' from list.
	lcWord1 = Lower (Getwordnum (lcSourceLine, 1))
	If Inlist (lcWord1, 'local', 'privat', 'public', 'parame', 'lparam', '*:glob',		;
			  'proced', 'functi', 'endpro', 'endfun', 'define')
		lcType = 'other'
		Do Case
				*--------------------------------------------------
				*  standard declarations
				*--------------------------------------------------
			Case 'local ' = lcWord1						;
					Or 'private ' = lcWord1				;
					Or 'public ' = lcWord1				;
					Or 'parameters ' = lcWord1			;
					Or 'lparameters ' = lcWord1			;
					Or '*:global ' = lcWord1
				lcType		 = lcWord1
				lcSourceLine = Substr (lcSourceLine, 1 + Len (lcWord1))

				If Lower (Getwordnum (lcSourceLine, 1)) == 'array'
					lcSourceLine = Alltrim (lcSourceLine)
					lcSourceLine = Substr (lcSourceLine, 7)
				Endif
				*--------------------------------------------------
				*  if start procedure, get arguments
				*--------------------------------------------------
			Case 'procedure ' = lcWord1 Or 'function ' = lcWord1
				lcSourceLine = Strtran(lcSourceLine, '()', '')
				Do Case
					Case Not llFirstTimeThru
						Exit
					Case '(' $ lcSourceLine
						lcType		 = 'lparameters'
						lcSourceLine = Strtran (Substr (lcSourceLine, At ('(', lcSourceLine) + 1), ')', '')
					Otherwise
						Loop
				Endcase

			Otherwise
				Loop
		Endcase

		*--------------------------------------------------
		*  Parse declarations
		*--------------------------------------------------

		If Not Empty (lcSourceLine)
			Dimension laLocals(1)
			This.ParseCodeLine (lcSourceLine, @laLocals, .F.)

			For lnI = 1 To IIf (Alen (laLocals) # 1, Alen (laLocals, 1), 0)
				lcName	   = Alltrim (laLocals (lnI, 1))
				lcDims	   = laLocals (lnI, 2)
				lcASPhrase = laLocals (lnI, 3)

				Do Case
					Case 'local ' = (lcWord1 + ' ') And llMoveLocals
						This.AddNewLocal (lcName, lcASPhrase, Not Empty (lcDims), .T., lcDims)
					Case Not Lower (',' + lcName + ',') $ Lower (lcCurrentLocals)
						lcCurrentLocals = lcCurrentLocals + lcName + ','
				Endcase

				This.nLocalsList = This.nLocalsList + 1
				Dimension This.aLocalsList (This.nLocalsList, 2)
				This.aLocalsList (This.nLocalsList, 1) = lcName
				This.aLocalsList (This.nLocalsList, 2) = lcType

			Endfor
		Endif
	Endif
	llFirstTimeThru = .F.
Endfor

Return lcCurrentLocals

ENDPROC
PROCEDURE findlocalslinenumber
Lparameters lnStartLoop, llFirst
Local lcSourceLine, lcWord1, lnLineNumber, lnLocalLineNumber, lnLoopValueBefore, lnLoop

lnLineNumber = lnStartLoop
lnLocalLineNumber = 100000

For lnLoop = lnStartLoop To Alen (This.aCodeLines)
	lnLoopValueBefore = lnLoop
	lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
	lcWord1 = Lower (Getwordnum (lcSourceLine,1))

	Do Case
		Case Empty (lcSourceLine)
			lnLineNumber = lnLoop

		Case Inlist (lcWord1, '*', '#', INLINECOMMENTS)
			lnLineNumber = lnLoop + 1

		Case Len (lcWord1) >= 4 And 'local ' = lcWord1
			Do Case
				Case llFirst
					Return lnLoopValueBefore 
				Case lnLineNumber <= lnLocalLineNumber
					lnLineNumber = lnLoop + 1
					lnLocalLineNumber = lnLineNumber
			Endcase

		Case Len (lcWord1) >= 4 And 			;
				('procedure ' = lcWord1 		;
				or 'function ' = lcWord1 		;
				or 'hidden ' = lcWord1 			;
				or 'protected ' = lcWord1 		;
				or 'lparameters ' = lcWord1 	;
				or 'parameters ' = lcWord1 		;
				or 'public ' = lcWord1 			;
				or 'private ' = lcWord1 		;
				or '*:global ' = lcWord1 		;
				)
			lnLineNumber = lnLoop + 1

		Otherwise
			Return Min (lnLineNumber, lnLocalLineNumber)

	Endcase
Endfor

Return lnLineNumber

ENDPROC
PROCEDURE findprocstartline
Lparameters lnCurrentLine
Local lcSourceLine, lcWord1, lcWord2, lnCounter, lnCounterNow, lnProcStart 

lnProcStart = 1
For lnCounter = 1 To lnCurrentLine
	lnCounterNow = lnCounter
	lcSourceLine = This.GetSourceCodeLine (@lnCounter)
	lcWord1 = Lower (Getwordnum (lcSourceLine,1))
	lcWord2 = Lower (Getwordnum (lcSourceLine,2))

	If Len (lcWord1) >= 4											;
			and ('procedure ' = lcWord1 or 'function ' = lcWord1)
		lnProcStart = lnCounterNow
	Endif

	If Len (lcWord1) >= 4											;
			and ('protected ' = lcWord1 or 'hidden ' = lcWord1)	;
			and Len (lcWord2) >= 4 									;
			and ('procedure ' = lcWord2 or 'function ' = lcWord2)
		lnProcStart = lnCounterNow
	Endif
Endfor

Return lnProcStart 
ENDPROC
PROCEDURE fixascolumn
Lparameters lcLine, lnWordWidth, lnWITHColumn, lnAfterWITHColumn
Local lcLeft, lcNewLeft, lcNewLine, lcRight, lnPos

lcLeft = This.FindBeforeAS (lcLine)
If 0 = Len (lcLeft)
	Return lcLine
Endif

lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, 1 + Len (lcLeft) + lnWordWidth))
If Not Right (lcLine,1) ISABLANK
	lcLine = lcLine + ' '
Endif

lcNewLeft = This.AddWhiteSpace (lcLeft, lnWITHColumn) + Substr (lcLine, 1 + Len (lcLeft), lnWordWidth)
lcNewLine = This.AddWhiteSpace (lcNewLeft, lnAfterWITHColumn) + lcRight

Return lcNewLine

ENDPROC
PROCEDURE fixwith
Lparameters lcLine, lnWordWidth, lnWITHColumn, lnAfterWITHColumn
Local lcLeft, lcNewLeft, lcNewLine, lcRight, lnPos

lnPos = 1 + At (' WITH ', Strtran (Upper (lcLine), Tab, ' ', 1, 999))

If lnPos <= 1
	Return lcLine
Endif

lcLeft = Left (lcLine, lnPos - 1)
lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + lnWordWidth)) 

lcNewLeft = This.AddWhiteSpace (lcLeft, lnWITHColumn) + Substr (lcLine, lnPos, lnWordWidth)
lcNewLine = This.AddWhiteSpace (lcNewLeft, lnAfterWITHColumn) + lcRight

Return lcNewLine



ENDPROC
PROCEDURE fixwithstatements
Lparameters lcSourceLine

Local lcWord1, lcWord2, lnJ, lnPos

If Pcount() = 0
	With This
		.nWithEndWithLevel = 0
		.aWithEndWith = ' '
		.cCurrentWithEndWith = ''
	Endwith
	Return
Endif

lcWord1 = Upper (Getwordnum (lcSourceLine,1))

Do Case
	Case lcWord1 == 'WITH'
		lcWord2 = Alltrim (Substr (Alltrim (lcSourceLine), 5))
		If lcWord2 = '.'
			lcWord2 = This.cCurrentWithEndWith + lcWord2
			lcSourceLine = 'With ' + lcWord2
		Endif
		This.nWithEndWithLevel = This.nWithEndWithLevel + 1
		Dimension This.aWithEndWith(This.nWithEndWithLevel)
		This.aWithEndWith(This.nWithEndWithLevel) = lcWord2
		This.cCurrentWithEndWith = lcWord2

	Case lcWord1 == 'ENDWITH'
		If This.nWithEndWithLevel > 1
			This.nWithEndWithLevel = This.nWithEndWithLevel - 1
			This.cCurrentWithEndWith = This.aWithEndWith(This.nWithEndWithLevel)
		Else
			This.nWithEndWithLevel = 0
			This.cCurrentWithEndWith = ''
		Endif

	Case Not Empty (This.cCurrentWithEndWith)
		lcSourceLine = ' ' + lcSourceLine
		For lnJ = 1 To 999
			lnPos = At (' .', lcSourceLine, lnJ)
			Do Case
				Case lnPos = 0
					Exit
				Case Isdigit (Substr (lcSourceLine, lnPos + 2, 1))
				Case Inlist (Upper (Substr (lcSourceLine, lnPos + 1)), '.T.', '.F.', '.NULL.')
				Otherwise
					lcSourceLine = Left (lcSourceLine, lnPos) + This.cCurrentWithEndWith + Substr (lcSourceLine, lnPos + 1)
					If This.cCurrentWithEndWith # '.'
						lnJ = lnJ - 1
					Endif
			Endcase
		Endfor
Endcase

Return lcSourceLine

ENDPROC
PROCEDURE getassignmentcol
Lparameters lcLine
Local lcLeft, lcLeftBracket, lcRightBracket, lcText, lnPos 

lnPos = At ('=', lcLine)
If lnPos = 0 Or Not This.oPrefs.lFixAssignments
	Return 0
Endif

lcLeft = This.TrimTrailingWhiteSpace (Left (lcLine, lnPos - 1))
lcText = This.TrimLeadingWhiteSpace (lcLeft)

* 02/22/2012 -- added to handle assignments of arrays
If Right(lcText,1) $ '])'
	lcRightBracket = Right(lcText,1)
	lcLeftBracket = IIF(lcRightBracket = ']', '[', '(') 
	If Occurs(lcLeftBracket, lcText) = Occurs(lcRightBracket, lcText)
		lcText = This.TrimTrailingWhiteSpace (Left(lcText, At(lcLeftBracket, lcText) - 1)) 
	Endif
Endif && Right(lcText,1) $ '])'
	
If Len (lcText) # Len (Chrtran (lcText, Chrtran(NOTNAMECHARS, '&', '') + CR + LF, '')) or Empty (lcText)
	Return 0
Endif

Return This.CountCharacterWidth (lcLeft)

ENDPROC
PROCEDURE getconstants
Lparameters lcSourceText, tcIncludeFileName

Local lcIncludeFile, lcValue, lnI, loIncludeFiles, loRegExp, loResults

*   #Defines
loRegExp = This.oUtils.GetRegExp()
With loRegExp
	.Pattern  = '^\s*#Defi(|n|ne)\s+\w+'
	loResults = .Execute (lcSourceText)
Endwith

For lnI = 0 To loResults.Count - 1
	lcValue  = Chrtran (loResults.Item (lnI).Value, Chr(13) + Chr(10), '')
	Insert Into crsr_IDs_Constants Values (Upper (Getwordnum (lcValue, 2)))
Endfor

*   #Includes
loIncludeFiles = This.oUtils.GetIncludeFiles (lcSourceText)
For Each lcIncludeFile In loIncludeFiles FoxObject
	If Empty (tcIncludeFileName)
		lcIncludeFile = Fullpath (lcIncludeFile)
	Else
		lcIncludeFile = Fullpath (lcIncludeFile, tcIncludeFileName)
	Endif

	If File (lcIncludeFile)
		This.GetConstants (Filetostr (lcIncludeFile), lcIncludeFile)
	Endif

EndFor 


ENDPROC
PROCEDURE geteditorwindowtext
Lparameters llAllText

Local lcCodeSource, lnSelEnd, lnSelStart

If 0 >= This.oEditorWin.FindWindow()
	Return ''
Endif

With This.oEditorWin
	lnSelStart = .GetSelStart()
	lnSelEnd   = .GetSelEnd()
	If llAllText Or lnSelStart = lnSelEnd
		lnSelStart = 0
		lnSelEnd   = .GetEnvironment(2)
	Endif
	lcCodeSource   = .GetString (lnSelStart, lnSelEnd - 1)
Endwith

This.nSelStart = lnSelStart
This.nSelEnd   = lnSelEnd

Return lcCodeSource
ENDPROC
PROCEDURE getindentation
Lparameters lcText

Return Left(lcText, Len(lcText) - Len(Ltrim(lcText, 1, ' ', Chr(9)))) 

ENDPROC
PROCEDURE getparameterslist
Lparameters lcCodeSource

Local lcName, lcResult, lcType, lnI

Alines (This.aCodeLines, lcCodeSource + ' ')
This.FindCurrentLocals(1, Alen (This.aCodeLines))

lcResult = ''
For lnI = 1 To This.nLocalslist
	lcName = This.aLocalslist (lnI, 1)
	lcType = This.aLocalslist (lnI, 2)
	If lcType = 'para' Or lcType = 'lpara'
		lcResult = lcResult + IIf (Empty (lcResult), '', ', ') + lcName
	Endif
Endfor

Return lcResult

ENDPROC
PROCEDURE getsourcecodeline
Lparameters lnCounter, llIgnoreTextMerge, llIgnoreHashIF
Local lcLine, lcSourceLine, llHashIFBlock, llTextBlock

lcSourceLine  = ''
llTextBlock	  = .F.
llHashIFBlock = .F.
Do While lnCounter <= Alen (This.aCodeLines)
	lcLine		 = This.aCodeLines (lnCounter)
	lcSourceLine = Evl (lcSourceLine + ' ', '') + Alltrim (Chrtran (lcLine, Tab + CR + LF, '   '))
	lnCounter	 = lnCounter + 1

	Do Case
		Case llTextBlock And Upper (Getwordnum (lcLine, 1)) == 'ENDTEXT'
			Exit
		Case llTextBlock
			Loop
		Case Upper (Getwordnum (lcLine, 1)) == 'TEXT'
			If llIgnoreTextMerge
				lnCounter = This.DoIDListText(lcSourceLine, lnCounter, Alen (This.aCodeLines))
				Exit
			Else
				llTextBlock = .T.
			Endif
			Loop

		Case llHashIFBlock And Upper (Getwordnum (lcLine, 1)) == '#ENDIF'
			Exit
		Case llHashIFBlock
			Loop
		Case llIgnoreHashIF And Upper (Getwordnum (lcLine, 1)) == '#IF'
			llHashIFBlock = .T.
			Loop

		Case ';' == Right (lcSourceLine, 1)
			Loop
		Case INLINECOMMENTS $ lcSourceLine
			lcSourceLine = Alltrim (Left (lcSourceLine, At (INLINECOMMENTS, lcSourceLine) - 1))
			If ';' = Right (lcSourceLine, 1)
				Loop
			Endif
	Endcase

	lnCounter = lnCounter - 1
	Exit

Enddo
Return lcSourceLine

ENDPROC
PROCEDURE getvariableslist
Lparameters tcCodeSource, tcType

Local laResult[1], lcKey, lcName, lcType, lcVarType, lnCount, lnI, lnRow, loResult

Alines (This.aCodeLines, tcCodeSource + ' ')

This.nNewLocalsCount = 0
Dimension This.aNewlocals(1, 10)
* This.aNewLocals:
*    Col 1 = Local Name
*    Col 2 = AS blabla
*    Col 3 = Array?
*    Col 4 = Col 2 non-empty
*    Col 5 = Begins with lowercase 'l'
*    Col 6 = Already found in LOCALs
*    Col 7 = Array parameters
*    Col 8 = Actual assignments
*    Col 9 = <Unused>
*    Col 10 = <Unused>

This.FindCurrentLocals(1, Alen (This.aCodeLines))
This.lNoDotsInAssignments = .T.
This.CreateNewLocals (1, Alen (This.aCodeLines))

lcType = Evl(tcType, 'PL!')

Do Case
	Case '#' $ lcType
		loResult = Createobject('Empty')
		AddProperty(loResult, 'aList[1]')
		Acopy(This.aLocalsList, loResult.aList)
		Return loResult
	Case '*' $ lcType
		lnCount = Alen(This.aLocalsList, 1)
		Dimension laResult(lnCount, 3)
		For lnI = 1 To lnCount
			If not Empty(This.aLocalsList[lnI, 1])
				laResult[lnI, 1] = This.aLocalsList[lnI, 1]
				laResult[lnI, 2] = This.aLocalsList[lnI, 2]
			EndIf 
		Endfor

		lnCount = Alen(This.aNewlocals, 1)
		For lnI = 1 To lnCount
			lcName = This.aNewlocals[lnI, 1]
			If Empty(lcName)
				Loop
			EndIf 
			If (This.aNewlocals[lnI, 6] = .F.) Or (This.aNewlocals[lnI, 8] = .T.)

				lnRow = Ascan(laResult, lcName, 1, -1, 1, 15)
				If lnRow # 0
					laResult[lnRow, 3] = .T.
				Else
					lnRow = Alen(laResult, 1) + 1
					Dimension laResult[lnRow, 3]
					laResult[lnRow, 1] = lcName
					laResult[lnRow, 2] = '?'
					laResult[lnRow, 3] = .T.
				Endif && lnRow # 0
			Endif && This.aNewlocals[lnI,6]  or This.aNewlocals[lnI,8]
		Endfor
		loResult = Createobject('Empty')
		AddProperty(loResult, 'aList[1]')
		Acopy(laResult, loResult.aList)
		Return loResult
Endcase

loResult		 = Createobject('Collection')
loResult.KeySort = 2
For lnI = 1 To This.nLocalsList
	lcName	  = This.aLocalsList(lnI, 1)
	lcKey	  = Upper(lcName)
	lcVarType = This.aLocalsList(lnI, 2)
	If ('P' $ lcType And 'para' $ lcVarType)		;
			Or ('L' $ lcType And Inlist(lcVarType, 'local', 'private', 'public'))
		If 0 = loResult.GetKey(lcKey)
			loResult.Add(lcName, lcKey)
		Endif
	Endif
Endfor

If '!' $ lcType
	For lnI = 1 To This.nNewLocalsCount
		lcName = This.aNewlocals(lnI, 1)
		If Ascan(This.aLocalsList, lcName, 1, -1, 1, 15) # 0
			Loop
		Endif
		lcKey  = Upper(lcName)
		If 0 = loResult.GetKey(lcKey)
			loResult.Add(lcName, lcKey)
		Endif
	Endfor
Endif

If '=' $ lcType
	For lnI = 1 To This.nNewLocalsCount
		lcName = This.aNewlocals(lnI, 1)
		lcKey  = Upper(lcName)
		If 0 = loResult.GetKey(lcKey) And This.aNewlocals(lnI, 8)
			loResult.Add(lcName, lcKey)
		Endif
	Endfor
Endif

Return loResult

ENDPROC
PROCEDURE getwindowhandle
Set Library To (Home() + "FoxTools.fll") Additive
Return _WonTop ()

ENDPROC
PROCEDURE insertconstants
Lparameters loConstants

For each lcConstant in loConstants FoxObject
	This.InsertID(lcConstant, TYPE_Constants)
EndFor 

ENDPROC
PROCEDURE insertid
Lparameters lcWord, lnType

Do Case
	Case Empty (lcWord)

	Case Left (lcWord, 1) $ ['^+(,0123456789)]

	Case lcWord = '&' And Not '.' $ lcWord

	Case lcWord = '.' And Isdigit (Substr (lcWord, 2, 1))

	Case Inlist (Upper (lcWord) + ' '		;
			  , '.T. ', '.F. ', '.OR. ', '.NOT. ', '.AND. ', '.NULL. ', '( ', '^ ')

		*Case This.IsKeyWord (Substr (lcWord, 1 + Rat ('.', lcWord)))
	Case This.IsKeyWord (lcWord)

	Otherwise
		Insert Into crsr_IDs_Refs Values (crsr_IDs_Procs.Id, crsr_IDs_Lines.Id, lcWord, lnType)
		Replace AnyFound With .T. In crsr_IDs_Lines

Endcase

ENDPROC
PROCEDURE insertidothers
Lparameters lcWord, lcNextWord

Local llAssign, lnType

llAssign = 0 # Ascan (This.aNewlocals, lcWord, 1, -1, 1, 15)
Do Case

	Case lcNextWord = '('
		If '.' $ lcWord
			lnType = TYPE_Methods
		Else
			lnType = TYPE_Procedures
		Endif

	Case llAssign And Not '.' $ lcWord
		lnType = TYPE_Assignments
	Case llAssign
		lnType = TYPE_PropAssign
	Case '.' $ lcWord
		lnType = TYPE_Objects
	Case This.lFieldReference 
		lnType = TYPE_Fields
	Otherwise
		lnType = TYPE_Others
Endcase

If Upper (lcWord) = 'M.'
	lcWord = Substr (lcWord, 3)
	lnType = TYPE_Others
Endif

This.InsertID (lcWord, lnType)

ENDPROC
PROCEDURE insertlocalids
Lparameters lcNewCode, lnType, lnStartWord

Local lcWord2, lnI
For lnI = lnStartWord To Getwordcount (lcNewCode)
	lcWord2		= Getwordnum (lcNewCode, lnI)
	If Upper (lcWord2) == 'AS' Or Upper (lcWord2) == 'OF'
		lnI = lnI + 1
	Endif
	This.InsertID (lcWord2, lnType)
Endfor

ENDPROC
PROCEDURE iskeyword
Lparameters lcWord

Return Indexseek (Upper (lcWord) + ' ', .F., 'FDKEYWRD')
ENDPROC
PROCEDURE movelocalstotop
Lparameters lnHandle, lnProcStart

Local laLocals(1), laOthers(1)
Local lcLine, lcNewCode, lcOldClipText, lcSourceLine, lcWord1, lnDestIndex, lnEndPosPos, lnI
Local lnInsertLineNumber, lnLocalsCount, lnLoop, lnLoopNow, lnOthersCount, lnStartPos

lnLocalsCount = 0
lnOthersCount = 0

lnInsertLineNumber = This.FindLocalsLineNumber (lnProcStart, .T.)

* Find the existing local declarations
For lnLoop = lnInsertLineNumber To Alen (This.aCodeLines)
	lnLoopNow = lnLoop
	lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)

	lcSourceLine = IIf (Lower (Left (lcSourceLine, 7)) == 'hidden ', Alltrim (Substr (lcSourceLine, 8)), lcSourceLine)
	lcSourceLine = IIf (Lower (Left (lcSourceLine, 10)) == 'protected ', Alltrim (Substr (lcSourceLine, 11)), lcSourceLine)

	lcWord1 = Lower (Getwordnum (lcSourceLine,1))

	Do Case
		Case Len (lcWord1) >= 4 And 'local ' = lcWord1
			For lnI = lnLoopNow To lnLoop
				lnLocalsCount = lnLocalsCount + 1
				Dimension laLocals (lnLocalsCount)
				laLocals (lnLocalsCount) = This.aCodeLines (lnI)
			Endfor

		Case Len (lcWord1) >= 4 And (				;
				'procedure ' = lcWord1  			;
				or 'function ' = lcWord1  			;
				or 'endproc ' = lcWord1 			;
				Or 'endfunc ' = lcWord1)
			Exit

		Case Left (Lower (lcSourceLine), 13) == 'define class '
			Exit

		Otherwise
			For lnI = lnLoopNow To Min (lnLoop, Alen (This.aCodeLines)) 
				lnOthersCount = lnOthersCount + 1
				Dimension laOthers (lnOthersCount)
				laOthers (lnOthersCount) = This.aCodeLines (lnI)
			Endfor

	Endcase

Endfor

If lnLocalsCount = 0
	Return lnInsertLineNumber
Endif

lnDestIndex = lnInsertLineNumber
lcNewCode = ''
*!*	For lnI = 1 To lnLocalsCount
*!*		lcLine = laLocals (lnI)
*!*		This.aCodeLines (lnDestIndex) = lcLine
*!*		lnDestIndex = lnDestIndex + 1
*!*		lcNewCode = lcNewCode + lcLine + LINEEND
*!*	Endfor

For lnI = 1 To lnOthersCount
	lcLine = laOthers (lnI)
	This.aCodeLines (lnDestIndex) = lcLine
	lnDestIndex = lnDestIndex + 1
	lcNewCode = lcNewCode + lcLine + LINEEND
Endfor

lnStartPos = _EdGetLPos(lnHandle, lnInsertLineNumber - 1)
lnEndPosPos = _EdGetLPos(lnHandle, lnLocalsCount + lnDestIndex - 1)
_EdSelect (lnHandle, lnStartPos, lnEndPosPos)

lcOldClipText = _Cliptext
_Cliptext = lcNewCode
_EdPaste (lnHandle)
_Cliptext = lcOldClipText

_EdSelect (lnHandle, lnStartPos, lnStartPos)
_EdSetPos (lnHandle, lnStartPos)
_EdStoPos (lnHandle, lnStartPos, .T.)

Return lnInsertLineNumber
ENDPROC
PROCEDURE nativebeautify
Lparameters lcSourceCode, llSkipIndentation

This.SetBeautifyOptions()
lcOptions = This.cBeautifyOptions 

*** JRN 2010-05-09 : conditionally turn off indentation (for SELECT statements)
If llSkipIndentation
	lcOptions = Stuff (lcOptions, 13, 1, Chr(0)) 
EndIf 

If "O" # Vartype (This.oBeautify)
	This.oNativeBeautify = peme_newsessionobject("cbeautify", "peme_beautifycode.vcx")
EndIf 

lcNewCode = lcSourceCode
This.oNativeBeautify.Execute (@lcNewCode, lcOptions, 3, '')

Return lcNewCode

ENDPROC
PROCEDURE parsecodeline
* Parses a single code line into an array:
*    Col 1 = Name
*    Col 2 = Array Dimensions, if any
*    Col 3 = AS phrase

* All this tomfoolery because of confusion with commas:  they are separators between names
* and also between dimensions of a name.
* For example:
* 	Dimension laResult[ALEN (laResult, 1) + 1], laTemp(3)

Lparameters tcCodeLine, laResult, llAssignment

#Define FILLER Chr(31)
Local laExtras(1), lcArrayDims, lcChar, lcCode, lcMatchChar, lcName, lnDepth, lnExtraCounter, lnExtras, lnI
Local lnMatchPos, lnPos

lcCode = Chrtran (tcCodeLine, ';', ' ')
lnExtras = 0

Do While '(' $ lcCode Or '[' $ lcCode
	lnPos = Min (This.ATNew('(', lcCode), This.ATNew('[', lcCode))
	lcChar = Substr(lcCode, lnPos, 1)
	lcMatchChar = Iif (lcChar ='(', ')', ']')
	lnDepth = 1
	Do While .T.
		lnMatchPos = At (lcMatchChar, lcCode, lnDepth)
		lnMatchPos = Evl (lnMatchPos, 1 + Len (lcCode))
		If 0 = At (lcChar, Left (lcCode, lnMatchPos), lnDepth + 1)
			lnExtras = lnExtras + 1
			Dimension laExtras (lnExtras, 2)
			laExtras (lnExtras, 1) = Alltrim (Substr (Left (lcCode, lnMatchPos - 1), lnPos + 1))
			laExtras (lnExtras, 2) = Alltrim (Substr (Left (lcCode, lnMatchPos), lnPos))
			lcCode = Stuff (lcCode, lnPos, 1 + lnMatchPos - lnPos, FILLER)
			Exit
		Else
			lnDepth = lnDepth + 1
		Endif
	Enddo
Enddo

lnExtraCounter = 0
For lnI = 1 To 1000
	lcName = Getwordnum (lcCode, lnI, ',')
	If Empty (lcName)
		Exit
	Endif

	Dimension laResult (lnI, 3)

	If ' as ' $ Lower (lcName)
		lnPos = At (' as ' , Lower (lcName))
		lcAsPhrase = Alltrim (Substr (lcName, lnPos + 4))
		lcName = Alltrim (Left (lcName, lnPos))
	Else
		lcAsPhrase = ''
	Endif

	If FILLER $ lcName
		lnExtraCounter = lnExtraCounter + 1
		lcArrayDims = laExtras [lnExtraCounter, 1]
		laResult (lnI, 1) = Strtran (lcName, FILLER, '')
		laResult (lnI, 2) = lcArrayDims
	Else
		laResult (lnI, 1) = lcName
		laResult (lnI, 2) = ''
	Endif

	If FILLER $ lcAsPhrase
		lnExtraCounter = lnExtraCounter + 1
		lcAsPhrase = laExtras [lnExtraCounter, 2]
	Endif
	laResult (lnI, 3) = lcAsPhrase
Endfor

ENDPROC
PROCEDURE parselineforidlist
* Parse a single line of code (that is, a line including continuation lines, with ; removed
*      (1) WITH/ENDWITH ... replace names beginning with dot with the WITH that precedes them
*      (2) Character constants are replaced with '^' (for historical reasons .. s.b. ')
*      (3) All other none-name characters with '+'

Lparameters lcSourceLine, lcNotNameChars

Local lcNewCode, lcRestLineString, lcThisChar, lnCharPos, lnClosingCharPosition

lcSourceLine = This.FixWithStatements (lcSourceLine)
lcSourceLine = Strtran (lcSourceLine, '.*', ' ')

lcNewCode = ''
For lnCharPos = 1 To Len (lcSourceLine)
	lcThisChar = Substr (lcSourceLine, lnCharPos, 1)
	Do Case
		Case lcThisChar $ ' ' + TAB
			lcThisChar = ' '
		Case lcThisChar $ ['"{] Or		;
				(lcThisChar = '[' And Not This.IsNameChar (Right (This.TrimTrailingWhiteSpace (lcNewCode), 1)))
			lcRestLineString	  = Substr (lcSourceLine, lnCharPos + 1)
			lnClosingCharPosition = At (IIf (lcThisChar = '[', ']', IIf (lcThisChar = '{', '}', lcThisChar)), lcRestLineString)
			lnCharPos			  = lnCharPos + lnClosingCharPosition
			lcThisChar			  = [ ^ ]
		Case lcThisChar = ';'
			lcThisChar = ' '
		Case lcThisChar $ lcNotNameChars + '^'
			lcThisChar = ' + '
		Case lcThisChar $ '(),+'
			lcThisChar = ' ' + lcThisChar + ' '
	Endcase
	lcNewCode = lcNewCode + lcThisChar
Endfor

Return lcNewCode
ENDPROC
PROCEDURE parseprgcodeblocks
Local lcClassName, lcName, lcSourceLine, lcWord1, lcWord2, lcWord3, lnCount, lnCounterNow, lnCurrentRow
Local lnLineCount

lnCurrentRow = 1
Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
This.aPRGCodeBlocks (lnCurrentRow, 1) = ''
This.aPRGCodeBlocks (lnCurrentRow, 2) = 'P'
This.aPRGCodeBlocks (lnCurrentRow, 3) = 1
This.aPRGCodeBlocks (lnCurrentRow, 4) = 1

lnLineCount	= Alen (This.aCodeLines)
lcClassName	= ''

For lnCount = 1 To lnLineCount
	lnCounterNow = lnCount
	lcSourceLine = This.GetSourceCodeLine (@lnCount)
	lcWord1 = Lower (Getwordnum (lcSourceLine,1))
	lcWord2 = Lower (Getwordnum (lcSourceLine,2))
	lcWord3 = Lower (Getwordnum (lcSourceLine,3))

	Do Case
		Case Empty (lcSourceLine)

		Case Len (lcWord1) >= 4											;
				and ('procedure ' = lcWord1 Or 'function ' = lcWord1)
			If lnCounterNow > 1
				This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
				lnCurrentRow = lnCurrentRow + 1
				Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
			Endif
			lcName = Getwordnum (lcSourceLine,2)
			If '(' $ lcName
				lcName = Left (lcName, At('(', lcName) - 1)
			Endif
			This.aPRGCodeBlocks (lnCurrentRow, 1) = lcClassName + lcName
			This.aPRGCodeBlocks (lnCurrentRow, 2) = Upper (Left (lcWord1,1))
			This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
			This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow

		Case Len (lcWord1) >= 4											;
				and ('protected ' = lcWord1 Or 'hidden ' = lcWord1)	;
				and Len (lcWord2) >= 4 									;
				and ('procedure ' = lcWord2 Or 'function ' = lcWord2)
			If lnCounterNow > 1
				This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
				lnCurrentRow = lnCurrentRow + 1
				Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
			Endif
			lcName = Getwordnum (lcSourceLine,3)
			If '(' $ lcName
				lcName = Left (lcName, At('(', lcName) - 1)
			Endif
			This.aPRGCodeBlocks (lnCurrentRow, 1) = lcClassName + lcName
			This.aPRGCodeBlocks (lnCurrentRow, 2) = Upper (Left (lcWord2,1))
			This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
			This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow

		Case Len (lcWord1) >= 4											;
				and ('define ' = lcWord1)	;
				and Len (lcWord2) >= 4 									;
				and ('class ' = lcWord2)
			If lnCounterNow > 1
				This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
				lnCurrentRow = lnCurrentRow + 1
				Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
			Endif
			This.aPRGCodeBlocks (lnCurrentRow, 1) = Getwordnum (lcSourceLine,3)
			This.aPRGCodeBlocks (lnCurrentRow, 2) = 'C'
			This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
			This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow
			lcClassName	= This.aPRGCodeBlocks (lnCurrentRow, 1) + '.'

		Case Len (lcWord1) >= 4											;
				and ('enddefine ' = lcWord1   ;
				or 'endproc ' = lcWord1   ;
				or 'endfunc ' = lcWord1   ;
				)
			If lnCounterNow > 1
				This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow
				lnCurrentRow = lnCurrentRow + 1
				Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
			Endif
			This.aPRGCodeBlocks (lnCurrentRow, 1) = ''
			This.aPRGCodeBlocks (lnCurrentRow, 2) = ' '
			This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow + 1
			This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow + 1
			If 'enddefine ' = lcWord1
				lcClassName	= ''
			EndIf 

	Endcase
Endfor

This.aPRGCodeBlocks (lnCurrentRow, 4) = lnLineCount

ENDPROC
PROCEDURE peme_beautify
Local laEnv[25]
Local lcCodeSource, lcIndent, lcNewCode, lcOldClipText, lcPrompt, llAnyOptions, llLocalsAllProcs
Local llSelectedText, lnCurrentLine, lnHandle, lnOriginalCursor, lnResult, lnSelEnd, lnSelStart
Local lnThisLine

With This.oPrefs
	llAnyOptions = .lSettingsChanged	;
		or .lNativeBeautify 			;
		or .lBeautifyLocals 			;
		or .lFixAssignments				;
		or .lAlignSemicolons			;
		or .nSelectIndentation = 3 		;
		or .nParenIndent       # 2 		;
		or .nBeforeLeftParens  # 1		;
		or .nStringDelimiters  # 1		;
		or .nDefinitionForNOT  # 1		;
		or .nDefinitionForNOTEQUAL # 1
Endwith

If Not llAnyOptions
	Text to lcPrompt NoShow
BeautifyX has not been activated yet. By default, none of its settings are activated.

Do you want to be taken to the settings form?
	EndText
	If MESSAGEBOX(lcPrompt, 68, "BeautifyX not activated.", 0) = 6
		ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_OpenOptionsPage', 'BeautifyX')
	EndIf
	Return
Endif

* Get the whandle for the current window
lnHandle = This.GetWindowHandle()
lnResult = _EdGetEnv (lnHandle, @laEnv )
If (lnResult = 0 Or laEnv[25] = 0)
	Return ''
Endif

* Get the current cursor position
lcOldClipText = _Cliptext

This.SetBeautifyOptions()

lnSelStart		 = laEnv[17]
lnSelEnd		 = laEnv[18]
lnOriginalCursor = laEnv[17]
lnCurrentLine	 = _EdGetLNum (lnHandle, lnSelStart)
This.nTabWidth	 = laEnv[21]
If lnSelStart = lnSelEnd && if nothing highlighted, select all
	_EdSelect (lnHandle, 0, 1000000)
	lnResult   = _EdGetEnv (lnHandle, @laEnv )
	lnSelStart = laEnv[17]
	lnSelEnd   = laEnv[18]
	llLocalsAllProcs = This.oPrefs.lLocalsAllProcs
	llSelectedText = .F.
Else
	llLocalsAllProcs = .T.
	llSelectedText = .T.
Endif

lcCodeSource = _EdGetStr (lnHandle, lnSelStart, lnSelEnd - 1)
lcIndent = This.GetIndentation(lcCodeSource)

****************************************************************
****************************************************************

If This.oPrefs.lBeautifyLocals
	lcCodeSource = This.CreateLocalsForCodeBlock(lcCodeSource, laEnv[25], lnCurrentLine, llLocalsAllProcs)
Endif

lcNewCode = This.BeautifyCodeBlock (lcCodeSource)

If llSelectedText
	If Len(lcIndent) # 0
		lcNewCode = Iif(lcNewCode # lcIndent, lcIndent, ' ') + Strtran(lcNewCode, LINEEND, LINEEND + lcIndent, 1, 1000, 3)
	Endif
Endif

If Right (lcCodeSource, 1) $ LINEEND
	lcNewCode = lcNewCode + LINEEND
Endif

****************************************************************
****************************************************************

_Cliptext = lcNewCode
_EdPaste (lnHandle)

If this.lRETURNS 
	_WSelect(lnHandle)
	If ExecScript(_screen.Cthordispatcher, 'Thor_Proc_CheckWindowForReturns', 2) && prompt if any found
		_Cliptext = lcOldClipText
		Return
	EndIf 
EndIf 

* Try to go back to where we started
lnThisLine = _EdGetLPos (lnHandle, lnCurrentLine)
_EdSelect (lnHandle, lnThisLine, lnThisLine)
_EdSetPos (lnHandle, lnThisLine)
_EdStoPos (lnHandle, lnThisLine, .T.)

_Cliptext = lcOldClipText


ENDPROC
PROCEDURE peme_createidlist
Lparameters llAllText

Local loFormIDList As 'FrmIDList' Of  'Source\EditProperty.VCX'
Local lcCodeSource, lcInclude, lcName, lcPRGTitle, lcType, lnBlocks, lnEnd, lnEndByte, lnI, lnLines
Local lnStart, lnStartByte, lnStartLine, loProcs

lcCodeSource = This.GetEditorWindowText(llAllText)

If Empty (lcCodeSource)
	Return .F.
Endif

This.CreateIDListCursors()
This.GetConstants (lcCodeSource)

* for a single method
If This.oEditorWin.GetEnvironment(25) = 10

	Alines (This.aCodeLines, lcCodeSource)
	Insert Into crsr_IDs_Procs (StartLine) Values (1)
	This.CreateIDList ('', 1, Alen (This.aCodeLines))
	lcInclude	 = This.oUtils.GetCurrentIncludeFile()
	If File (lcInclude)
		This.GetConstants (Filetostr (lcInclude), lcInclude)
	Endif

Else

	* or a PRG with no embedded PROCs or FUNCs
	loProcs	   = This.oUtils.GetProcedureStartPositions (lcCodeSource)

	If 0 = loProcs.Count

		Alines (This.aCodeLines, lcCodeSource)
		Insert Into crsr_IDs_Procs (StartLine) Values (1)
		This.CreateIDList ('', 1, Alen (This.aCodeLines))

	Else

		lnStartLine = 1
		* for a PRG with PROCs and FUNCs
		For lnI = 0 To loProcs.Count
			Do Case
				Case lnI = 0
					lnStartByte	= 0
					lnEndByte	= loProcs(1).StartByte
					If lnEndByte = 0
						Loop
					Endif
					lcName = This.oEditorWin.GetTitle()
					lcType = 'Procedure'
				Case lnI < loProcs.Count
					lcName		= loProcs (lnI).Name
					lnStartByte	= loProcs (lnI).StartByte
					lnEndByte	= loProcs (lnI + 1).StartByte
					lcType		= loProcs (lnI).Type
				Otherwise
					lcName		= loProcs (lnI).Name
					lnStartByte	= loProcs (lnI).StartByte
					lnEndByte	= This.oEditorWin.GetEnvironment(2)
					lcType		= loProcs (lnI).Type
			Endcase

			lnLines = Alines (This.aCodeLines, Substr (lcCodeSource, lnStartByte + 1, lnEndByte - lnStartByte)) 
			If Inlist (lcType, 'Procedure', 'Method')
				Insert Into crsr_IDs_Procs (ProcName, StartLine) Values (lcName, lnStartLine)
				This.CreateIDList (lcName, 1, lnLines)
			Endif
			lnStartLine = lnStartLine + lnLines
		Endfor

	Endif

Endif

This.DoFormIDList (This.oEditorWin.nHandle)

ENDPROC
PROCEDURE peme_createlocals
Local laEnv[25]
Local lcCodeSource, lcIndent, lcNewCode, lcOldClipText, llLocalsAllProcs, llSelectedText, lnCurrentLine
Local lnHandle, lnOriginalCursor, lnResult, lnSelEnd, lnSelStart, lnThisLine

* Get the whandle for the current window
lnHandle = This.GetWindowHandle()
lnResult = _EdGetEnv (lnHandle, @laEnv )
If (lnResult = 0 Or laEnv[25] = 0)
	Return ''
Endif

* Get the current cursor position
lcOldClipText = _Cliptext

This.SetBeautifyOptions()

lnSelStart		 = laEnv[17]
lnSelEnd		 = laEnv[18]
lnOriginalCursor = laEnv[17]
lnCurrentLine	 = _EdGetLNum (lnHandle, lnSelStart)
This.nTabWidth	 = laEnv[21]
If lnSelStart = lnSelEnd && if nothing highlighted, select all
	_EdSelect (lnHandle, 0, 1000000)
	lnResult   = _EdGetEnv (lnHandle, @laEnv )
	lnSelStart = laEnv[17]
	lnSelEnd   = laEnv[18]
	llLocalsAllProcs = This.oPrefs.lLocalsAllProcs
	llSelectedText = .F.
Else
	llLocalsAllProcs = .T.
	llSelectedText = .T.
Endif

lcCodeSource = _EdGetStr (lnHandle, lnSelStart, lnSelEnd - 1)

****************************************************************
****************************************************************

lcNewCode = This.CreateLocalsForCodeBlock(lcCodeSource, laEnv[25], lnCurrentLine, llLocalsAllProcs)

If llSelectedText
	lcIndent = This.GetIndentation(lcCodeSource)
	If Len(lcIndent) # 0
		lcNewCode = Iif(lcNewCode # lcIndent, lcIndent, ' ') + Strtran(lcNewCode, LINEEND + 'L', LINEEND + lcIndent + 'L', 1, 1000, 3)
	Endif
Endif

****************************************************************
****************************************************************

_Cliptext = lcNewCode
_EdPaste (lnHandle)

* Try to go back to where we started
lnThisLine = _EdGetLPos (lnHandle, lnCurrentLine)
_EdSelect (lnHandle, lnThisLine, lnThisLine)
_EdSetPos (lnHandle, lnThisLine)
_EdStoPos (lnHandle, lnThisLine, .T.)

_Cliptext = lcOldClipText

ENDPROC
PROCEDURE peme_createobjectidlist
Lparameters loObject, llRecursive, lcSourceFileName, lcClassName
Local lcIncludeFile

With This
	.CreateIDListCursors()

	lcIncludeFile = This.oUtils.GetCurrentIncludeFile()
	If Not Empty (lcIncludeFile)
		.GetConstants (Filetostr (lcIncludeFile), lcIncludeFile)
	Endif

	.AddObjectIDList (loObject, llRecursive)

Endwith

If Lower (loObject.BaseClass) == 'form'
	Select  Distinct Id							;
		From crsr_IDs_Procs						;
		Where 1 = Occurs ('.', ProcName)		;
		Into Cursor crsr_ThisForm_IDs
	Index on ID tag ID 

	Select crsr_IDs_Refs
	Set Relation To ProcID Into crsr_ThisForm_IDs

	Replace	Name  With	'Thisform.' + Substr (Name, 6)		;
		For Found ('crsr_ThisForm_IDs')						;
			And Upper (Left (Name, 5)) == 'THIS.'

Endif

This.DoFormIDList(0, lcSourceFileName, lcClassName)

ENDPROC
PROCEDURE regexpsearch
Lparameters tcPattern, tcText
This.oRegExp.Pattern = tcPattern
Return This.oRegExp.Execute (tcText)


ENDPROC
PROCEDURE removeparens
Lparameters lcText

Local lcThisChar, lnEndPos, lnStartPos 
lcText = Chrtran(lcText, '()', '[]')
Do While .T.
	lnStartPos = Min (This.AtNew(['], lcText), This.AtNew(["], lcText), This.AtNew(']', lcText))
	If lnStartPos > Len(lcText)
		Return lcText
	Endif

	lcThisChar = Substr (lcText, lnStartPos, 1)
	If lcThisChar $ ['"]
		lnEndPos = This.AtNew(lcThisChar, lcText, 2)
		lcText	 = Left (lcText, lnStartPos - 1) + ' ' + Substr (lcText, lnEndPos + 1)
	Else
		lnEndPos   = lnStartPos
		lnStartPos = Rat('[', Left(lcText, lnEndPos))
		lcText	   = Left (lcText, lnStartPos - 1) + '( ' + Substr (lcText, lnEndPos + 1)
	Endif
Enddo && While .T.
ENDPROC
PROCEDURE setbeautifyoptions
*    Options:
*        1 = Variable case - 4 = no change, 3 = use 1st
*        2 = command Case - 3 = mixed, 2 = lower, 1 = upper
*        3 = number of spaces if option 4 (below) is 2
*        4 = tabs/spaces, 						1 - use tabs, 2 - use spaces, 3 = no change
*        5 =  ??
*        6 = comments - 						1 = include comments, 0 = no
*        7 = Line continuation 					1 = include, 0 = no
*        8 = Extra indent beneath procedures 	1 = yes, 0 = no
*        9 = Extra indent beneath Do Case 		1 = yes, 0 = no

Local lcOptions, lnI, lnSelect

lnSelect = Select()
Select 0

lcOptions =								 ;
	Chr(3) + Chr(0) + Chr(0) + Chr(0) +	 ;
	Chr(3) + Chr(0) + Chr(0) + Chr(0) +	 ;
	Chr(4) + Chr(0) + Chr(0) + Chr(0) +	 ;
	Chr(1) + Chr(0) + Chr(0) + Chr(0) +	 ;
	Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
	Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
	Chr(1) + Chr(0) + Chr(0) + Chr(0) +	 ;
	Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
	Chr(0) + Chr(0) + Chr(0) + Chr(0)

If Set ('Resource') = 'ON'
	Use (Set ('Resource', 1)) Again Shared Alias Resource
	Locate For Id = 'BEAUTIFY'
	If Found()
		lcOptions = Right (Data, 36)
	Endif
	Use
Endif

For lnI = 1 To 9
	This.nBeautifyOptions (lnI) = Asc (Substr (lcOptions, (4 * lnI) - 3, 1))
Endfor

Select (lnSelect)

This.cBeautifyOptions = lcOptions

ENDPROC
PROCEDURE whereis
Lparameters mfile
Local mtemp

If File (m.mfile)
	Return m.mfile
Endif

mtemp = 'fd3fll\' + m.mfile
If File (m.mtemp)
	Return m.mtemp
Endif

mtemp = Sys(2004) + m.mfile
If File (m.mtemp)
	Return m.mtemp
Endif

mtemp = Sys(2004) + 'wizards\' + m.mfile
If File (m.mtemp)
	Return m.mtemp
Endif

Return ''

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addasphase 
*addnewlocal 
*addobjectidlist 
*alignsemicolons 
*atnew 
*beautifycodeblock 
*beautifyinsertcode 
*beautifyreplacecode 
*beautifyselectcode 
*beautifyselectcreatebreakpoints 
*beautifyselectmain 
*beautifyselectstandard 
*beautifyselectx 
*beautifysingleline 
*beautifyword 
*calccolumn 
*calccolumnoffset Given a starting column, offsets it; primarily for handling tabs
*converttabsforindent 
*createidlist 
*createidlistcursors 
*createidlistsummary 
*createlocalsforcodeblock 
*createlocalstatements 
*createnewlocals 
*doformidlist 
*doidlisttext 
*dolocals 
*fetchparameterslist 
*findcurrentlocals 
*findlocalslinenumber 
*findprocstartline 
*fixwith 
*fixwithstatements 
*formatidlist 
*getassignmentcol 
*getconstants 
*geteditorwindowtext 
*getindentation 
*getparameterslist 
*getsourcecodeline 
*getvariableslist 
*getwindowhandle 
*insertconstants 
*insertid 
*insertidothers 
*insertlocalids 
*iskeyword 
*movelocalstotop 
*nativebeautify 
*parsecodeline 
*parselineforidlist 
*parseprgcodeblocks 
*peme_beautify 
*peme_createidlist 
*peme_createlocals 
*peme_createobjectidlist 
*regexpsearch 
*removeparens 
*setbeautifyoptions 
*whereis 
^acodelines[1,0] 
^alocalslist[1,0] 
^anewlocals[1,0] 
^aprgcodeblocks[1,0] 
^awithendwith[1,0] 
^nbeautifyoptions[9,0] 
cbeautifyoptions
ccurrentlocals
ccurrentwithendwith
clocalsplugin
clocalstatement
cpluginbeautifyselect
cpluginisoperator
csystemmemoryvariables
laddmdots
laddtockl
lapplyckl
lautoaddtockl
lfieldreference
lnodotsinassignments
lreturns
ltestselect
nafterwithcolumn
nbeautifyselectiontype
ncharsafterset
nlocalslist
nmdotsusage
nnewlocalscount
nselend
nselstart
ntabwidth
nwithendwithlevel
oeditorwin
onativebeautify
oprefs
oregexp
outils
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
editpropertydialog.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] beautify
[EOF]
