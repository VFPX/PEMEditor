*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="peme_basecontrols.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basecheckbox AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: nanchor
	*</DefinedPropArrayMethod>

	Alignment = 0
	AutoSize = .T.
	BackStyle = 0
	Caption = "Check1"
	FontSize = 8
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	Name = "basecheckbox"
	nanchor = 0
	Value = .F.
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method
		
	ENDPROC

	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
			if .lUpdateControlSourceOnChange
				.UpdateControlSource()
			endif .lUpdateControlSourceOnChange
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			.UpdateControlSource()
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecollection AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	Height = 23
	Name = "basecollection"
	Width = 23

ENDDEFINE

DEFINE CLASS basecombobox AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: lsaveanchor_assign
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*p: conkeylabeldot
		*p: lgotdot
		*p: lsaveanchor
		*p: lupdatecontrolsourceonchange		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseintellisensex
		*p: nanchor
		*p: nsavedanchor
		*a: aitems[1,0]		&& An array of items for the RowSource if RowSourceType is set to 5-Array
	*</DefinedPropArrayMethod>

	conkeylabeldot = .F.
	FontSize = 8
	Height = 22
	ItemTips = .T.
	lgotdot = .F.
	lsaveanchor = .F.
	lupdatecontrolsourceonchange = .F.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseintellisensex = .F.
	Name = "basecombobox"
	nanchor = 0
	nsavedanchor = 0
	SelectOnEntry = .T.
	Style = 2
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE Init
		* Initialize aItems.
		
		This.aItems = ''
		
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
			if .lUpdateControlSourceOnChange
				.UpdateControlSource()
			endif .lUpdateControlSourceOnChange
			.AnyChange()
		endwith
		
		If This.lGotDot and This.lUseIntellisenseX
			This.PEME_IntellisenseX("TABLE,OBJ,THOR", ".")
		Endif
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			NoDefault
		endif tnKeyCode = asc('0') ...
		
		This.lGotDot= tnKeyCode = 46 and tnShiftAltCtrl	= 0
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			Case not PEME_IsVersion9()
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			.UpdateControlSource()
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecommandbutton AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*p: nanchor
	*</DefinedPropArrayMethod>

	Caption = "Command1"
	FontSize = 8
	Height = 23
	Name = "basecommandbutton"
	nanchor = 0
	Width = 75
	
	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecontainer AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: enabled_assign
		*m: lsaveanchor_assign
		*p: lsaveanchor
		*p: nanchor
		*p: nsavedanchor
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Enabled = .T.
	lsaveanchor = .F.
	Name = "basecontainer"
	nanchor = 0
	nsavedanchor = 0
	Style = 3
	
	PROCEDURE enabled_assign
		lparameters tlEnabled
		This.Enabled = tlEnabled
		This.SetAll('Enabled', tlEnabled)
		
	ENDPROC

	PROCEDURE Init
		If PEME_IsVersion9()
			This.Anchor = this.nAnchor 
		EndIf 
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			Case not PEME_IsVersion9()
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecustom AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addmrufile		&& Adds a file (or class within a file) to its appropriate VFP MRU list.  The last parameter is optional (can be inferred from the filename, after all)
		*m: atspecial
		*m: browsefile
		*m: checkoutscc
		*m: diskfilename		&& Returns the file name with the same case (upper/lower) as it is on disk.
		*m: editsourcex		&& Enhanced version of VFP's EditSource: maintains case of file name, adds to MRU list, optionally checks out from source control.  For classes, opens up class browser.  For PRGs and text files, start and end points of text to be selected may be supplied.
		*m: getcontrolcount		&& Returns the number of child objects in a container object
		*m: getmousecoordinates
		*m: getmruid		&& Returns the name of the MRU list associated with a file name or extension)
		*m: getmrulist		&& Returns (as a collection) the list of all items for a particular MRU list.  <lcMRU_ID> may be the actual MRU name, a file name, or a file extension
		*m: getpemstatus
		*m: getpluginpath
		*m: getrelativepath
		*m: getthoroption
		*m: isnamechar
		*m: openurl
		*m: pix2fox
		*m: release		&& Releases a FormSet or Form from memory.
		*m: showerrormsg
		*m: showhelp
		*m: striptabs
		*p: lreleaseondestroy
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN Height,HelpContextID
	lreleaseondestroy = .F.
	Name = "basecustom"
	_memberdata = <VFPData>
		<memberdata name="release" display="Release"/>
		<memberdata name="addmrufile" display="AddMRUFile"/>
		<memberdata name="diskfilename" display="DiskFileName"/>
		<memberdata name="getcontrolcount" display="GetControlCount"/>
		<memberdata name="getpemstatus" display="GetPEMStatus"/>
		<memberdata name="getrelativepath" display="GetRelativePath"/>
		<memberdata name="isnamechar" display="IsNameChar"/>
		<memberdata name="openurl" display="OpenURL"/>
		<memberdata name="showerrormsg" display="ShowErrorMsg"/>
		<memberdata name="showhelp" display="ShowHelp"/>
		<memberdata name="striptabs" display="StripTabs"/>
		<memberdata name="getmrulist" display="GetMRUList"/>
		<memberdata name="editsourcex" display="EditSourceX"/>
		<memberdata name="getmruid" display="GetMRUID"/>
		<memberdata name="checkoutscc" display="CheckOutSCC"/>
		<memberdata name="atspecial" type="method" display="AtSpecial"/>
		<memberdata name="getpluginpath" display="GetPlugInPath"/>
		<memberdata name="browsefile" display="BrowseFile"/>
		<memberdata name="getthoroption" type="method" display="GetThorOption"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addmrufile		&& Adds a file (or class within a file) to its appropriate VFP MRU list.  The last parameter is optional (can be inferred from the filename, after all)
		Lparameters lcFileName, lcClassName, lcMRU_ID
		
		#Define DELIMITERCHAR  Chr(0)
		#Define MAXITEMS       24
		#Define ResourceAlias  crsr_MRU_Resource_Add
		
		Local lcData, lcLine25, lcNewData, lcSearchString, lcSourceFile, lnPos, lnSelect
		
		If 'ON' # Set ('Resource')
			Return
		Endif
		
		If lcFileName # '\-'
			lcFileName = This.DiskFileName(FullPath(lcFileName))
		EndIf
		
		lcSourceFile = Set ('Resource', 1)
		
		If Empty (lcMRU_ID)
			lcMRU_ID = This.GetMRUID (lcFileName)
			If '?' $ lcMRU_ID
				Return
			Endif
		Endif
		
		If lcMRU_ID = 'MRUI'
			If Empty (lcClassName) && Class library (artificial)
				lcMRU_ID	   = 'MRU2'
				lcSearchString = lcFileName + DELIMITERCHAR
			Else
				lcSearchString = lcFileName + '|' + Lower (lcClassName) + DELIMITERCHAR
				This.AddMRUFile(lcFileName, , 'MRU2')
			Endif
		Else
			lcSearchString = lcFileName + DELIMITERCHAR
		Endif
		
		lnSelect = Select()
		Select 0
		Use (lcSourceFile) Again Shared Alias ResourceAlias
		
		Locate For Id = lcMRU_ID
		If Found()
			lcData = DELIMITERCHAR + Substr (Data, 3)
			lnPos  = Atcc (DELIMITERCHAR + lcSearchString, lcData)
			Do Case
				Case lnPos = 1
					* already tops of the list
					lcNewData = Data
				Case lnPos = 0
					* must add to list
					lcNewData = Stuff (Data, 3, 0, lcSearchString)
					* note that GetWordNum won't accept CHR(0) as a delimiter
					lcLine25  = Getwordnum (Chrtran (Substr (lcNewData, 3), DELIMITERCHAR, CR), MAXITEMS + 1, CR)
					If Not Empty (lcLine25)
						lcNewData = Strtran (lcNewData, DELIMITERCHAR + lcLine25 + DELIMITERCHAR, DELIMITERCHAR, 1, 1, 1)
					Endif
				Otherwise
					lcNewData = Stuff (Data, lnPos + 1, Len (lcSearchString), '')
					lcNewData = Stuff (lcNewData, 3, 0, lcSearchString)
			Endcase
			Replace																;
					Data	 With  lcNewData									;
					ckval	 With  Val (Sys(2007, Substr (lcNewData, 3)))		;
					Updated	 With  Date()
		Else
			lcNewData = Chr(4) + DELIMITERCHAR + lcSearchString
			Insert Into ResourceAlias					;
				(Type, Id, ckval, Data, Updated)		;
				Values									;
				('PREFW', lcMRU_ID, Val (Sys(2007, Substr (lcNewData, 3))), lcNewData, Date())
		
			****************************************************************
		Endif
		
		Use
		Select (lnSelect)
		
		Return
		
	ENDPROC

	PROCEDURE atspecial
		Lparameters lcSearchExpr, lcSearched
		
		Return Evl ( At (lcSearchExpr, lcSearched), 1 + Len (lcSearched))
	ENDPROC

	PROCEDURE browsefile
		Lparameters lcFileName, lnRecno
		Local lcAlias, llSuccess, lnDataSession, lnSelect
		
		lnDataSession = Set("Datasession")
		Set DataSession To 1
		lnSelect = Select()
		
		Try
			Select 0
			Use (lcFileName) Again Shared
			lcAlias = Alias()
		
			If !Empty(lnRecno)
				Goto lnRecno
			Endif
		
			llSuccess = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_SuperBrowse', lcAlias)
		Catch To loException
			This.ShowErrorMsg (loException)
			llSuccess = .F.
		Endtry
		
		Select (lnSelect)
		Set DataSession To (lnDataSession)
		Return llSuccess
		
	ENDPROC

	PROCEDURE checkoutscc
		Lparameters lcFileName
		
		Local lnSelect 
		
		*** JRN 11/17/2010 : Bhavbhuti: Source Control
		* Select 0 -- used because it appears that CheckOut may kill current work area
		If 'O' = Type ('This.oPrefs') And This.oPrefs.lCheckOutSCC And 0 # _vfp.Projects.Count
			lnSelect = Select()
			Select 0
			Try
				If Not Inlist (_vfp.ActiveProject.Files (m.lcFileName).SCCStatus, 0, 2)
					If Not _vfp.ActiveProject.Files (m.lcFileName).CheckOut()
		
					Endif
				Endif
		    Catch to loException
		        Do Case
		            Case loException.ErrorNo = 1943 && if not found in this project
		            Case loException.ErrorNo = 1426 && OLE error code 0x85ff012e: Unknown COM status code
		                _vfp.ActiveProject.Files (m.lcFileName).CheckOut()
		        Otherwise
		            This.ShowErrorMsg(loException)
		        EndCase
		    EndTry
		    Select (lnSelect)
		Endif
		
		
	ENDPROC

	PROCEDURE Destroy
		This.Release()
		
	ENDPROC

	PROCEDURE diskfilename		&& Returns the file name with the same case (upper/lower) as it is on disk.
		Lparameters lcFileName
		
		#Define MAX_PATH 260
		
		Local lnFindFileData, lnHandle, lcXXX
		Declare Integer FindFirstFile In win32api String @, String @
		Declare Integer FindNextFile In win32api Integer, String @
		Declare Integer FindClose In win32api Integer
		
		Do Case
			Case ( Right (lcFileName, 1) == '\' )
				Return Addbs (This.DiskFileName (Left (lcFileName, Len (lcFileName) - 1)))
		
			Case Empty (lcFileName)
				Return ''
		
			Case ( Len (lcFileName) == 2 ) And ( Right (lcFileName, 1) == ':' )
				Return Upper (lcFileName)	&& win2k gives curdir() for C:
		Endcase
		
		lnFindFileData = Space(4 + 8 + 8 + 8 + 4 + 4 + 4 + 4 + MAX_PATH + 14)
		lnHandle		 = FindFirstFile (@lcFileName, @lnFindFileData)
		
		If ( lnHandle < 0 )
			If ( Not Empty (Justfname (lcFileName)) )
				lcXXX = Justfname (lcFileName)
			Else
				lcXXX = lcFileName
			Endif
		Else
			= FindClose (lnHandle)
			lcXXX	= Substr (lnFindFileData, 45, MAX_PATH)
			lcXXX	= Left (lcXXX, At (Chr(0), lcXXX) - 1)
		Endif
		
		
		Do Case
			Case Empty (Justpath (lcFileName))
				Return lcXXX
			Case ( Justpath (lcFileName) == '\' ) Or (Left (lcFileName, 2) == '\\')	&& unc
				Return '\\' + lcXXX
			Otherwise
				Return Addbs (This.DiskFileName (Justpath (lcFileName))) + lcXXX
		Endcase
		
		Return
		
	ENDPROC

	PROCEDURE editsourcex		&& Enhanced version of VFP's EditSource: maintains case of file name, adds to MRU list, optionally checks out from source control.  For classes, opens up class browser.  For PRGs and text files, start and end points of text to be selected may be supplied.
		Lparameters tcFileName, tcClass, tcMethod, tnStartRange, tnEndRange, tlCheckOutSCC
		
		Local lcClass, lcCustomPRG, lcExpression, lcExt, lcFileName, lcMethod, lcNewName, lcParams
		Local llSuccess, lnEndRange, lnSelect, lnStartRange, loException
		
		lcFileName	 = This.DiskFileName(Trim(tcFileName))
		lcClass		 = Trim(Evl(tcClass, ''))
		lnStartRange = Evl(tnStartRange, 0)
		lnEndRange	 = Evl(tnEndRange, 1)
		lcMethod	 = Evl(tcMethod, '')
		lcExt		 = Upper (Justext (lcFileName))
		
		This.AddMRUFile (lcFileName, lcClass)
		
		Try
			If lcExt = 'PJX'
				Modify Project (lcFileName) Nowait
			Else
				If Pcount() < 6 Or tlCheckOutSCC
					lnSelect = Select()
					Select 0
					This.CheckOutSCC (lcFileName)
					Select (lnSelect)
				Endif
				Do Case
					Case lcExt = 'VCX' And Empty(lcClass)
						lcCustomPRG =  This.GetPlugInPath ('OpenVCXFile')
						If Not Empty (lcCustomPRG)
							Try
								lcNewName = Execscript(Filetostr(lcCustomPRG), lcFileName)
							Catch To loException
								This.ShowErrorMsg(loException, 'Open VCX File Failure', lcCustomPRG)
							Endtry
						Else
							Do(_Browser) With (lcFileName)
						Endif
					Case lcExt $ ' SCX VCX FRX LBX MNX DBC '
						lcParams	 = 'lcFileName, lnStartRange, lcClass, lcMethod'
						lcExpression = 'lParameters ' + lcParams + ccCR + 'Editsource(' + lcParams + ')'
						Execscript(lcExpression, &lcParams)
					Case lcExt == 'PRG'
						If lnStartRange # 0
							Modify Command(lcFileName) Range lnStartRange, lnEndRange Nowait
						Else
							Modify Command(lcFileName) Nowait
						Endif
					Case (' ' + lcExt + ' ') $ ccTextFileExtensions
						If lnStartRange # 0
							Modify File(lcFileName) Range lnStartRange, lnEndRange Nowait
						Else
							Modify File(lcFileName) Nowait
						Endif
					Case lcExt == 'DBF'
						llSuccess = This.BrowseFile(lcFileName, tnStartRange)
					Case (' ' + lcExt + ' ') $ ' DBC '
						*** can't open of these files
						Return .F.
					Otherwise
						lcCustomPRG = This.GetPlugInPath ('EditSourceX')
						If Not Empty (lcCustomPRG)
							Try
								lcNewName = Execscript(Filetostr(lcCustomPRG), lcFileName)
							Catch To loException
								This.ShowErrorMsg(loException, 'EditSourceX plug-in failure', lcCustomPRG)
							Endtry
						Else
							This.OpenURL (lcFileName)
						Endif
				Endcase
			Endif
			llSuccess = .T.
		Catch To loException
			This.ShowErrorMsg (loException)
			llSuccess = .F.
		Endtry
		
		Return llSuccess
		*!*	Try
		*!*		Do Case
		*!*			Case lcExt = 'PJX'
		*!*				Modify Project (lcFileName) Nowait
		*!*			Case lcExt = 'VCX' And Empty (lcClass)
		*!*				This.CheckOutSCC (lcFileName)
		*!*				Do (_Browser) With (lcFileName)
		*!*			Otherwise
		*!*				This.CheckOutSCC (lcFileName)
		*!*				Do Case
		*!*					Case Not Empty (lcClass)
		*!*						Editsource (lcFileName, 0, lcClass)
		*!*					Case 'N' = Vartype (lnStartRange)
		*!*						If 'PRG' == lcExt
		*!*							Modify Command (lcFileName) Range lnStartRange, lnEndRange Nowait
		*!*						Else
		*!*							Modify File (lcFileName) Range lnStartRange, lnEndRange Nowait
		*!*						Endif
		*!*					Case (' ' + lcExt + ' ') $ ' PRG MPR QPR TXT H INI SCX VCX FRX LBX MNX DBC '
		*!*						Editsource (lcFileName)
		*!*					Otherwise
		*!*						This.OpenURL (lcFileName)
		*!*				Endcase
		*!*		Endcase
		*!*	Catch To loException
		*!*		This.ShowErrorMsg (loException)
		*!*	Endtry
		
		
	ENDPROC

	PROCEDURE getcontrolcount		&& Returns the number of child objects in a container object
		Lparameters loObject
		Local lnCount
		
		With loObject
			Do Case
				Case Not This.GetPEMStatus(loObject, 'Objects', 5)
					lnCount = 0
				Case This.GetPEMStatus(loObject, 'ControlCount', 5)
					lnCount = .ControlCount
				Case Inlist(Lower(.BaseClass),[pageframe])
					lnCount = .PageCount
				Case Inlist(Lower(.BaseClass),[grid])
					lnCount = .ColumnCount
				Case Inlist(Lower(.BaseClass),[optiongroup],[commandgroup])
					lnCount = .ButtonCount
				Case Inlist(Lower(.BaseClass),[formset])
					lnCount = .FormCount
				Case Inlist(Lower(.BaseClass),[dataenvironment])
					lnCount = 0
					Do While 'O' = Type(".Objects(lnCount + 1)")
						lnCount = lnCount + 1
					Enddo
				Otherwise
					lnCount = 0
			Endcase
		Endwith
		
		Return lnCount
		
	ENDPROC

	PROCEDURE getmousecoordinates
		Local loWas, lcPoint, loResult, lnSMCol, lnSMRow
		
		loWas = Newobject("WinApiSupport", "PEME_WinApiSupport.PRG")
		Declare Long GetCursorPos In WIN32API String @lpPoint
		Declare Long ScreenToClient In WIN32API Long HWnd, String @lpPoint
		
		lcPoint = Replicate(Chr(0), 8)
		&& Get mouse location in Windows desktop coordinates (pixels)
		= GetCursorPos(@lcPoint)
		&& Convert to VFP Desktop (_Screen) coordinates
		= ScreenToClient(_Screen.HWnd, @lcPoint)
		*!*	&& Covert the coordinates to foxels
		
		*!*	lnSMCol = This.Pix2Fox(loWas.Long2Num(Left(lcPoint,4)), .F., _Screen.FontName, _Screen.FontSize)
		*!*	lnSMRow = This.Pix2Fox(loWas.Long2Num(Right(lcPoint,4)), .T., _Screen.FontName, _Screen.FontSize)
		lnSMCol = loWas.Long2Num(Left(lcPoint,4))
		lnSMRow = loWas.Long2Num(Right(lcPoint,4))
		
		loResult = Createobject("Empty")
		AddProperty (loResult, 'Left',   lnSMCol)
		AddProperty (loResult, 'Top',    lnSMRow)
		AddProperty (loResult, 'Source', 'Mouse')
		Return loResult
		
	ENDPROC

	PROCEDURE getmruid		&& Returns the name of the MRU list associated with a file name or extension)
		Lparameters lcFileName
		
		Local lcExt, lcList, lcMRU_ID, lnPos
		lcExt = Upper (Justext ('.' + lcFileName))
		
		lcList = ',VCX=MRUI,PRG=MRUB,MPR=MRUB,QPR=MRUB,SCX=MRUH,MNX=MRUE,FRX=MRUG,DBF=MRUS,DBC=???,LBX=???,PJX=MRUL'
		lnPos  = At (',' + lcExt + '=', lcList)
		If lnPos = 0
			lcMRU_ID = 'MRUC'
		Else
			lcMRU_ID = Substr (lcList, lnPos + 5, 4)
		Endif
		
		Return lcMRU_ID 
	ENDPROC

	PROCEDURE getmrulist		&& Returns (as a collection) the list of all items for a particular MRU list.  <lcMRU_ID> may be the actual MRU name, a file name, or a file extension
		Lparameters lcMRU_ID
		
		#Define DELIMITERCHAR Chr(0)
		
		Local loCollection As 'Collection'
		Local laItems(1), lcData, lcList, lcSourceFile, lnI, lnPos, lnSelect
		
		loCollection = Createobject ('Collection')
		
		If 'ON' # Set ('Resource')
			Return loCollection
		Endif
		
		lnSelect	 = Select()
		lcSourceFile = Set ('Resource', 1)
		Select 0
		Use (lcSourceFile) Again Shared Alias MRU_Resource
		
		If lcMRU_ID # 'MRU'
			lcMRU_ID = This.GetMRUID (lcMRU_ID)
			If '?' $ lcMRU_ID
				Return
			Endif
		Endif
		
		Locate For Id = lcMRU_ID
		If Found()
			lcData = Data
			Alines (laItems, Substr (lcData, 3), 0, DELIMITERCHAR)
			For lnI = 1 To Alen (laItems)
				If Not Empty (laItems (lnI))
					loCollection.Add (laItems (lnI))
				Endif
			Endfor
		Endif
		
		Use
		Select (lnSelect)
		Return loCollection
		
		
	ENDPROC

	PROCEDURE getpemstatus
		Lparameters loObject, lcPEM, nAttribute
		
		If Upper(loObject.BaseClass) = 'OLE'
		
			Local laMembers(1), lnRow
			Amembers(laMembers, loObject, 1, 'PHG#')
			lnRow = Ascan(laMembers, lcPEM, -1, -1, 1, 15)
		
			Do Case
				Case lnRow = 0
					Return .F.
				Case nAttribute = 0 && changed
					Return 'C' $ laMembers(lnRow,3)
				Case nAttribute = 1 && readonly
					Return 'R' $ laMembers(lnRow,3)
				Case nAttribute = 2 && protected
					Return 'P' $ laMembers(lnRow,3)
				Case nAttribute = 3 && type
					Return laMembers(lnRow,2)
				Case nAttribute = 4 && user-defined
					Return 'U' $ laMembers(lnRow,3)
				Case nAttribute = 5 && defined
					Return .T.
				Case nAttribute = 6 && inherited
					Return 'I' $ laMembers(lnRow,3)
			Endcase
		
		Else
		
			Return Pemstatus (loObject, lcPEM, nAttribute)
		
		Endif
		
	ENDPROC

	PROCEDURE getpluginpath
		Lparameters tcPRGFileName
		
		Local lcFileName, lcPRGFileName
		
		lcPRGFileName = tcPRGFileName + IIf ('.' $ tcPRGFileName, '', '.PRG')
		
		lcFileName = FullPath('PEME_' + lcPRGFileName)
		If File (lcFileName)
			Return (lcFileName)
		Endif
		
		lcFileName = This.cPlugInPath + lcPRGFileName
		If File (lcFileName)
			Return (lcFileName)
		Endif
		
		lcFileName = This.cApplicationPath + lcPRGFileName
		If File (lcFileName)
			Return (lcFileName)
		Endif
		
		Return ExecScript(_Screen.cThorDispatcher, 'Full Path=PEME_' + lcPRGFileName)
		
	ENDPROC

	PROCEDURE getrelativepath
		Lparameters lcName, lcPath
		Local lcNew, lnPos
		Try 
			If Empty (lcPath)
				lcNew = Sys(2014, lcName)
			Else
				lcNew = Sys(2014, lcName, lcPath)
			Endif
		Catch to loException
			lcNew = lcName
		EndTry
		
		If Len (lcNew) < Len (lcName)
			lnPos = Rat ('..\', lcNew)
			If lnPos # 0
				lnPos = lnPos + 2
			Endif
			Return Left (lcNew, lnPos) + Right (lcName, Len (lcNew) - lnPos)
		Else
			Return lcName
		EndIf 
		
	ENDPROC

	PROCEDURE getthoroption
		Lparameters lcThorKey, lcThorTool, lxDefaultValue
		Return Nvl(Execscript (_Screen.cThorDispatcher, 'Get Option=', lcThorKey, lcThorTool), lxDefaultValue)
	ENDPROC

	PROCEDURE isnamechar
		Lparameters lcChar
		
		Return Isalpha (lcChar) Or Isdigit (lcChar) Or lcChar = '_'
		
	ENDPROC

	PROCEDURE openurl
		******************
		***    Author: Rick Strahl
		***            (c) West Wind Technologies, 1996
		***   Contact: rstrahl@west-wind.com
		***  Modified: 03/14/96
		***  Function: Starts associated Web Browser
		***            and goes to the specified URL.
		***            If Browser is already open it
		***            reloads the page.
		***    Assume: Works only on Win95 and NT 4.0
		***      Pass: tcUrl  - The URL of the site or
		***                     HTML page to bring up
		***                     in the Browser
		***    Return: 2  - Bad Association (invalid URL)
		***            31 - No application association
		***            29 - Failure to load application
		***            30 - Application is busy 
		***
		***            Values over 32 indicate success
		***            and return an instance handle for
		***            the application started (the browser) 
		****************************************************
		LPARAMETERS tcUrl, tcAction, tcDirectory, tcParms
		
		IF EMPTY(tcUrl)
		   RETURN -1
		ENDIF
		IF EMPTY(tcAction)
		   tcAction = "OPEN"
		ENDIF
		IF EMPTY(tcDirectory)
		   tcDirectory = SYS(2023) 
		ENDIF
		
		DECLARE INTEGER ShellExecute ;
		    IN SHELL32.dll ;
		    INTEGER nWinHandle,;
		    STRING cOperation,;
		    STRING cFileName,;
		    STRING cParameters,;
		    STRING cDirectory,;
		    INTEGER nShowWindow
		IF EMPTY(tcParms)
		   tcParms = ""
		ENDIF
		
		DECLARE INTEGER FindWindow ;
		   IN WIN32API ;
		   STRING cNull,STRING cWinName
		
		RETURN ShellExecute(0,;
		                    tcAction,tcUrl,;
		                    tcParms,tcDirectory,1)
		
	ENDPROC

	PROCEDURE pix2fox
		LPARAMETER tnPixels, tlVertical, tcFontName, tnFontSize
		&& tnPixels - pixels to convert
		&& tlVertical - .F./.T. convert horizontal/vertical coordinates
		&& tcFontName, tnFontSize - use specified font/size 
		&&         or current form (active output window) font/size, if not specified 
		LOCAL lnFoxels
		 
		IF PCOUNT() > 2
			lnFoxels = tnPixels/FONTMETRIC(IIF(tlVertical, 1, 6), tcFontName, tnFontSize)
		ELSE
			lnFoxels = tnPixels/FONTMETRIC(IIF(tlVertical, 1, 6))
		ENDIF	
		 
		RETURN lnFoxels
	ENDPROC

	PROCEDURE release		&& Releases a FormSet or Form from memory.
		Local laMembers(1), lcMember
		Amembers (laMembers, This, 0)
		For Each lcMember In laMembers
			lcMember = Upper (lcMember)
			If Pemstatus(This, lcMember, 4) And 'O' = Vartype (Getpem (This, lcMember))
				If This.lReleaseOnDestroy
					Try
						This.&lcMember..Release()
					Catch
					Endtry
				Endif
				This.&lcMember. = .Null.
			Endif
		Endfor
		
	ENDPROC

	PROCEDURE showerrormsg
		Lparameters loException, lcTitleBar, lcPRGName, lcAddlInfo
		
		Messagebox ('Error: ' + Transform (loException.ErrorNo) 	+ ccCRLF +							;
			  'Message: ' + loException.Message 					+ ccCRLF +							;
			  'Procedure: ' + IIf (Empty (lcPRGName), loException.Procedure, Justfname (lcPRGName)) + ccCRLF + ;
			  'Line: ' + Transform (loException.Lineno) 			+ ccCRLF +							;
			  'Code: ' + loException.LineContents														;
			  + IIf (Empty (lcAddlInfo), '', ccCRLF + 'NOTES: ' + lcAddlInfo)							;
			  , MB_OK + MB_ICONEXCLAMATION, Evl (lcTitleBar, 'Error'))
		
	ENDPROC

	PROCEDURE showhelp
		Lparameters lnHelpID
		
		Local lcCurrentHelpFile, lcHelpFile, lcPath
		
		lcCurrentHelpFile = Set("Help",1)
		
		lcPath = This.cApplicationPath
		lcHelpFile = lcPath + "PemEditor.CHM"
		
		*** JRN 2010-05-06 : Remove security warning; from http://www.foxpert.com/knowlbits_200906_1.htm
		If File(lcHelpFile)
			PEME_RemSecurityWarning(lcHelpFile)
		
			Set Help To (lcHelpFile)
		
			If Empty (lnHelpID)
				Help
			Else
				Help Id (lnHelpID)
			Endif
		Endif
		
		Set Help To (lcCurrentHelpFile)
		
	ENDPROC

	PROCEDURE striptabs
		Lparameters cAbstract
		
		* Abstract:
		*   Replace all tabs with spaces; also removes leading / trailing blanks
		*
		* Parameters:
		*	<cAbstract> = string to strip tabs/spaces from
		Return Alltrim (Chrtran (m.cAbstract, ccTab, ' '))
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseeditbox AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: lsaveanchor_assign
		*m: peme_intellisensex
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& Custom validation code
		*p: conkeylabeldot
		*p: lgotdot
		*p: lsaveanchor
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: luseintellisensex
		*p: nanchor
		*p: nsavedanchor
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	conkeylabeldot = .F.
	FontSize = 8
	IntegralHeight = .T.
	lgotdot = .F.
	lsaveanchor = .F.
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	luseintellisensex = .F.
	Name = "baseeditbox"
	nanchor = 0
	nsavedanchor = 0
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="luseintellisensex" type="property" display="lUseIntellisenseX"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE GotFocus
		Push Key
		On Key Label .
		On Key Label =
		
	ENDPROC

	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method, and restore the current cursor position in case
		* This.Refresh got called from AnyChange.
		
		Local lnSelStart, lcExec
		With This
			lnSelStart = .SelStart
			If .lUpdateControlSourceOnChange
				.UpdateControlSource()
			Endif .lUpdateControlSourceOnChange
			.AnyChange()
			.SelStart = lnSelStart
		Endwith
		
		If This.lGotDot and This.lUseIntellisenseX
			This.PEME_IntellisenseX("TABLE,OBJ,THOR", ".")
		Endif
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			NoDefault
		endif tnKeyCode = asc('0') ...
		
		This.lGotDot= tnKeyCode = 46 and tnShiftAltCtrl	= 0
		
	ENDPROC

	PROCEDURE LostFocus
		Pop Key
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			Case not PEME_IsVersion9()
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE peme_intellisensex
		Lparameters tcProviders, tcInvocation, tlForceThor
		
		PEME_ISX(This, Thisform.oTopofForm, Thisform.oObject, tcProviders, tcInvocation, tlForceThor)
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			.UpdateControlSource()
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		* If we're not canceling, call the Validation method to do the actual
		* validation.
		
		local luReturn
		with This
			if lastkey() <> 27
				luReturn = .Validation()
			else
				luReturn = .T.
			endif lastkey() <> 27
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE validation		&& Custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Store the current value into the Tag property so it can be restored if Valid
		* fails.
		
		This.Tag = This.Value
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ChangeFontSize" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addmrufile
		*m: calculateshortcutmenuposition
		*m: createcontextmenu
		*m: diskfilename
		*m: get1value
		*m: getdisplayrelativepath
		*m: getmrulist
		*m: getpemstatus
		*m: getputsetting
		*m: getputsettings
		*m: getrelativepath
		*m: getsetting
		*m: getvalue
		*m: justpem
		*m: pix2fox
		*m: putsetting
		*m: refreshform		&& Refreshes the form with the LockScreen .T.
		*m: restorecolumninfo
		*m: restoresettings		&& Restores saved settings from FOXUSER
		*m: savecolumninfo
		*m: savesettings		&& Saves settings to FOXUSER
		*m: update1property
		*m: updateselectedcontrols
		*p: cfoxuserid		&& The FOXUSER ID to save/restore settings to
		*p: cfoxusername		&& The FOXUSER NAME to save/restore settings to
		*p: cpreferencesfile
		*p: lpemeditorform		&& Indicates that this is a PEM Editor form
		*p: lpersistsizeposition		&& .T. to persist the size and position of the form
		*p: lsavesettings		&& .T. to save and restore settings
		*p: nfontsize
		*p: nhighlightbackcolor
		*p: nhighlightforecolor
		*p: opersist		&& A reference to a FoxResource object
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	Caption = "Form"
	cfoxuserid = 		&& The FOXUSER ID to save/restore settings to
	cfoxusername = 		&& The FOXUSER NAME to save/restore settings to
	cpreferencesfile = (Home(7) + "PEMEditor_Preferences.DBF")
	DataSession = 2
	DoCreate = .T.
	FontSize = 8
	lpemeditorform = .T.		&& Indicates that this is a PEM Editor form
	lpersistsizeposition = .T.		&& .T. to persist the size and position of the form
	lsavesettings = .T.		&& .T. to save and restore settings
	Name = "baseform"
	nfontsize = 8
	nhighlightbackcolor = 0
	nhighlightforecolor = 0
	opersist = .NULL.		&& A reference to a FoxResource object
	ShowTips = .T.

	ADD OBJECT 'ChangeFontSize' AS changefontsize WITH ;
		Height = 17, ;
		Left = 16, ;
		Name = "ChangeFontSize", ;
		Top = 16, ;
		Width = 20
		*< END OBJECT: ClassLib="changefontsize.vcx" BaseClass="custom" />
	
	PROCEDURE addmrufile
		Lparameters lcFileName, lcClassName, lcMRU_ID
		
		#Define DELIMITERCHAR Chr(0)
		#Define MAXITEMS      24
		
		Local lcData, lcExt, lcLine25, lcList, lcNewData, lcSearchString, lcSourceFile, lnPos
		Local lnSelect
		
		If 'ON' # Set ('Resource')
			Return
		Endif
		
		lcSourceFile = Set ('Resource', 1)
		lcExt		 = Upper (Justext (lcFileName))
		
		If Empty (lcMRU_ID)
			lcList = ',VCX=MRUI,PRG=MRUB,MPR=MRUB,QPR=MRUB,SCX=MRUH,MNX=MRUE,FRX=MRUG,DBC=???,LBX=???,PJX=MRUL'
			lnPos  = At (',' + lcExt + '=', lcList)
			If lnPos = 0
				lcMRU_ID = 'MRUC'
			Else
				lcMRU_ID = Substr (lcList, lnPos + 5, 4)
				If lcMRU_ID = '?'
					Return
				Endif
			Endif
		Endif
		
		If lcMRU_ID = 'MRUI'
			If Empty (lcClassName)
				lcMRU_ID	   = 'MRU2'
				lcSearchString = lcFileName + DELIMITERCHAR
			Else
				lcSearchString = lcFileName + '|' + Lower (lcClassName) + DELIMITERCHAR
			Endif
		Else
			lcSearchString = lcFileName + DELIMITERCHAR
		Endif
		
		lnSelect = Select()
		Select 0
		Use (lcSourceFile) Again Shared Alias MRU_Resource_Add
		
		Locate For Id = lcMRU_ID
		If Found()
			lcData = DELIMITERCHAR + Substr (Data, 3)
			lnPos  = Atcc (DELIMITERCHAR + lcSearchString, lcData)
			Do Case
				Case lnPos = 1
					* already tops of the list
					lcNewData = Data
				Case lnPos = 0
					* must add to list
					lcNewData = Stuff (Data, 3, 0, lcSearchString)
					* note that GetWordNum won't accept CHR(0) as a delimiter
					lcLine25  = Getwordnum (Chrtran (Substr (lcNewData, 3), DELIMITERCHAR, CR), MAXITEMS + 1, CR)
					If Not Empty (lcLine25)
						lcNewData = Strtran (lcNewData, DELIMITERCHAR + lcLine25 + DELIMITERCHAR, DELIMITERCHAR, 1, 1, 1)
					Endif
				Otherwise
					lcNewData = Stuff (Data, lnPos + 1, Len (lcSearchString), '')
					lcNewData = Stuff (lcNewData, 3, 0, lcSearchString)
			Endcase
			Replace															;
				Data	 With  lcNewData									;
				ckval	 With  Val (Sys(2007, Substr (lcNewData, 3)))		;
				Updated	 With  Date()
		Else
			lcNewData = Chr(4) + DELIMITERCHAR + lcSearchString
			Insert Into MRU_Resource_Add			;
				(Type, Id, ckval, Data, Updated)	;
				values 								;
				('PREFW', lcMRU_ID, Val (Sys(2007, Substr (lcNewData, 3))), lcNewData, Date())
		
			****************************************************************
		Endif
		
		Use
		Select (lnSelect)
		
		Return
		
	ENDPROC

	PROCEDURE calculateshortcutmenuposition
		Local loWas, lcPoint, loResult, lnSMCol, lnSMRow
		
		loWas = Newobject("WinApiSupport", "PEME_WinApiSupport.PRG")
		Declare Long GetCursorPos In WIN32API String @lpPoint
		Declare Long ScreenToClient In WIN32API Long HWnd, String @lpPoint
		
		lcPoint = Replicate(Chr(0), 8)
		&& Get mouse location in Windows desktop coordinates (pixels)
		= GetCursorPos(@lcPoint)
		&& Convert to VFP Desktop (_Screen) coordinates
		= ScreenToClient(_Screen.HWnd, @lcPoint)
		&& Covert the coordinates to foxels
		
		lnSMCol = This.Pix2Fox(loWas.Long2Num(Left(lcPoint,4)), .F., _Screen.FontName, _Screen.FontSize)
		lnSMRow = This.Pix2Fox(loWas.Long2Num(Right(lcPoint,4)), .T., _Screen.FontName, _Screen.FontSize)
		
		loResult = Createobject("Empty")
		AddProperty (loResult, 'Column', lnSMCol )
		AddProperty (loResult, 'Row', lnSMRow )
		Return loResult
		
	ENDPROC

	PROCEDURE createcontextmenu
		Lparameters lcMenuName
		Local loPosition
		
		loPosition = This.CalculateShortcutMenuPosition()
		
		*** JRN 2010-11-10 : Following is an attempt to solve the problem
		* when there is another form already open; apparently, if the 
		* focus is on the screen, the positioning of the popup still works OK
		_Screen.Show()
		
		Define Popup (lcMenuName)						;
			shortcut									;
			Relative									;
			From loPosition.Row, loPosition.Column
		
	ENDPROC

	PROCEDURE Destroy
		* Save the current settings
		
		if This.lSaveSettings
			This.SaveSettings()
		endif This.lSaveSettings
		
		* Nuke member objects.
		
		This.oPersist = .NULL.
		
	ENDPROC

	PROCEDURE diskfilename
		Lparameters lcFileName
		
		#Define MAX_PATH 260
		
		Local lnFindFileData, lnHandle, lcXXX
		Declare Integer FindFirstFile In win32api String @, String @
		Declare Integer FindNextFile In win32api Integer, String @
		Declare Integer FindClose In win32api Integer
		
		Do Case
			Case ( Right (lcFileName, 1) == '\' )
				Return Addbs (This.DiskFileName (Left (lcFileName, Len (lcFileName) - 1)))
		
			Case Empty (lcFileName)
				Return ''
		
			Case ( Len (lcFileName) == 2 ) And ( Right (lcFileName, 1) == ':' )
				Return Upper (lcFileName)	&& win2k gives curdir() for C:
		Endcase
		
		lnFindFileData = Space(4 + 8 + 8 + 8 + 4 + 4 + 4 + 4 + MAX_PATH + 14)
		lnHandle		 = FindFirstFile (@lcFileName, @lnFindFileData)
		
		If ( lnHandle < 0 )
			If ( Not Empty (Justfname (lcFileName)) )
				lcXXX = Justfname (lcFileName)
			Else
				lcXXX = lcFileName
			Endif
		Else
			= FindClose (lnHandle)
			lcXXX	= Substr (lnFindFileData, 45, MAX_PATH)
			lcXXX	= Left (lcXXX, At (Chr(0), lcXXX) - 1)
		Endif
		
		
		Do Case
			Case Empty (Justpath (lcFileName))
				Return lcXXX
			Case ( Justpath (lcFileName) == '\' ) Or (Left (lcFileName, 2) == '\\')	&& unc
				Return '\\' + lcXXX
			Otherwise
				Return Addbs (This.DiskFileName (Justpath (lcFileName))) + lcXXX
		Endcase
		
		Return
		
	ENDPROC

	PROCEDURE get1value
		Lparameters loObject, lcPem
		Local lcResult
		
		Try
			lcResult = Evaluate( [loObject.] + lcPem)
		Catch
			lcResult = ''
		Endtry
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getdisplayrelativepath
		Lparameters lcFileName, lcFolder, lcClass
		* returns the display form of a file name
		Local lcFileDisplayName, lcFName, lcQuote, lcResult
		
		lcFileDisplayName = Thisform.GetRelativePath (This.DiskFileName(lcFileName), Evl (lcFolder, Curdir()))
		lcFName = Justfname (lcFileDisplayName)
		lcQuote = Iif (" " $ lcFName, ['], '')
		If lcFName == lcFileDisplayName
			lcResult = lcQuote + lcFName + lcQuote
		Else
			lcResult = lcQuote + lcFName + lcQuote + "  from  " + Justpath (lcFileDisplayName)
		Endif
		
		Return lcResult 
		
	ENDPROC

	PROCEDURE getmrulist
		Lparameters lcMRU_ID
		
		#Define DELIMITERCHAR Chr(0)
		
		Local loCollection As 'Collection'
		Local laItems(1), lcData, lcList, lcSourceFile, lnI, lnPos, lnSelect
		
		loCollection = Createobject ('Collection')
		
		If 'ON' # Set ('Resource')
			Return loCollection
		Endif
		
		lnSelect	 = Select()
		lcSourceFile = Set ('Resource', 1)
		Select 0
		Use (lcSourceFile) Again Shared Alias MRU_Resource
		
		If lcMRU_ID # 'MRU'
			lcList = ',VCX=MRUI,PRG=MRUB,MPR=MRUB,QPR=MRUB,SCX=MRUH,MNX=MRUE,FRX=MRUG,DBC=???,LBX=???,PJX=MRUL,DBF=MRUS'
			lnPos  = At (',' + Upper (JustExt ('.' + lcMRU_Id)) + '=', lcList)
			If lnPos = 0
				lcMRU_ID = 'MRUC'
			Else
				lcMRU_ID = Substr (lcList, lnPos + 5, 4)
				If lcMRU_ID = '?'
					Return
				Endif
			Endif
		Endif
		
		Locate For Id = lcMRU_ID
		If Found()
			lcData = Data
			Alines (laItems, Substr (lcData, 3), 0, DELIMITERCHAR)
			For lnI = 1 To Alen (laItems)
				If Not Empty (laItems (lnI))
					loCollection.Add (laItems (lnI))
				Endif
			Endfor
		Endif
		
		Use
		Select (lnSelect)
		Return loCollection
		
		
	ENDPROC

	PROCEDURE getpemstatus
		Lparameters loObject, lcPEM, nAttribute
		
		If Upper(loObject.BaseClass) = 'OLE'
		
			Local laMembers(1), lnRow
			Amembers(laMembers, loObject, 1, 'PHG#')
			lnRow = Ascan(laMembers, lcPEM, -1, -1, 1, 15)
		
			Do Case
				Case lnRow = 0
					Return .F.
				Case nAttribute = 0 && changed
					Return 'C' $ laMembers(lnRow,3)
				Case nAttribute = 1 && readonly
					Return 'R' $ laMembers(lnRow,3)
				Case nAttribute = 2 && protected
					Return 'P' $ laMembers(lnRow,3)
				Case nAttribute = 3 && type
					Return laMembers(lnRow,2)
				Case nAttribute = 4 && user-defined
					Return 'U' $ laMembers(lnRow,3)
				Case nAttribute = 5 && defined
					Return .T.
				Case nAttribute = 6 && inherited
					Return 'I' $ laMembers(lnRow,3)
			Endcase
		
		Else
		
			Return Pemstatus (loObject, lcPEM, nAttribute)
		
		Endif
		
	ENDPROC

	PROCEDURE getputsetting
		*  Routine to either save or restore a setting (based on flag parameter)
		*  Allows a single calling routine to handle all settings,
		*  insuring that all are saved and restored consistently
		
		Lparameters tcPropertyName, tcSettingName, txDefaultValue, tlPutFlag
		
		Local lxCurrentValue, lxCurrentSetting
		
		If tlPutFlag
			lxCurrentValue = Getpem (Thisform, tcPropertyName)
			This.PutSetting (tcSettingName, lxCurrentValue, txDefaultValue)
		Else
			lxCurrentSetting = This.GetSetting (tcSettingName, txDefaultValue)
			Thisform.AddProperty (tcPropertyName, lxCurrentSetting)
		Endif
		
	ENDPROC

	PROCEDURE getputsettings
		Lparameters lbPutFlag
		
		*  Routine to either save (lbPutFlag = .T.) or get (lbPutFlag = .F.) settings
		*  Structured this way so a single method call is this routine can be used
		*  both ways, insuring that all settings are handled consistently between
		*  saving and restoring.  Improved legibility as well.
		
		With This
			.GetPutSetting ('Top', 		'Top', 		.Top + 1, 	lbPutFlag)
			.GetPutSetting ('Left', 	'Left', 	.Left + 1, 	lbPutFlag)
			.GetPutSetting ('Height', 	'Height', 	.Height + 1, lbPutFlag)
			.GetPutSetting ('Width', 	'Width', 	.Width + 1, lbPutFlag)
		Endwith
		
	ENDPROC

	PROCEDURE getrelativepath
		Lparameters lcName, lcPath
		Local lcNew, lnPos
		Try 
			If Empty (lcPath)
				lcNew = Sys(2014, lcName)
			Else
				lcNew = Sys(2014, lcName, lcPath)
			Endif
		Catch to loException
			lcNew = lcName
		EndTry
		
		If Len (lcNew) < Len (lcName)
			lnPos = Rat ('..\', lcNew)
			If lnPos # 0
				lnPos = lnPos + 2
			Endif
			Return Left (lcNew, lnPos) + Right (lcName, Len (lcNew) - lnPos)
		Else
			Return lcName
		EndIf 
	ENDPROC

	PROCEDURE getsetting
		Lparameters tcSettingName, txDefaultValue
		
		Return Nvl( This.oPersist.Get (tcSettingName), txDefaultValue)
		
	ENDPROC

	PROCEDURE getvalue
		Lparameters lcName, tbNative, tcResultType, tnObjNumber
		
		Local lcPem, lbFirst, lcValue, lxValue, lcNewValue, lxNewValue, lnRed, lnGreen, lnBlue
		Local loObject, lbTransform, loResult, lcTypes, lcNewType, lnI, lnJ, lnK
		
		lcPem = Thisform.JustPEM(lcName)
		lbTransform = .T.
		
		*** JRN 03/18/2009 : modifications to handle multiple objects
		Do Case
			Case Not Empty(tnObjNumber)
				loObject = Thisform.aSelectedObjects(tnObjNumber)
				lcPem = Thisform.cEditPropertyName
				lcValue = loObject.ReadExpression (lcPem)
				lxValue = This.Get1Value (loObject, lcPem)
				lcTypes = Vartype (lxValue)
		
			Case (Thisform.lUseCSO) And Thisform.nSelectedObjects > 1
				lbFirst = .T.
				For lnI = 1 to Alen ( Thisform.aSelectedObjects)
					loObject = Thisform.aSelectedObjects(lnI)
					Do Case
						Case Not Thisform.GetPEMStatus(loObject, lcPem, 5)
		
						Case lbFirst
							lcValue = loObject.ReadExpression (lcPem)
							lxValue = This.Get1Value (loObject, lcPem)
							lbFirst = .F.
							lcTypes = Vartype (lxValue)
						Otherwise
							lcNewValue = loObject.ReadExpression (lcPem)
							lxNewValue = This.Get1Value (loObject, lcPem)
							lcNewType  = Vartype (lxValue)
							If lbTransform
								If (Not lcValue == lcNewValue)							;
										or Vartype (lxValue) # Vartype (lxNewValue)		;
										or lxValue # lxNewValue
									lcValue = ' '
									lbTransform = .F.
									lcTypes = lcTypes + Iif (lcNewType $ lcTypes, '', lcNewType)
								Endif
							Else
								lcTypes = lcTypes + Iif (lcNewType $ lcTypes, '', lcNewType)
							Endif
					Endcase
				Endfor
			Otherwise
				lcValue = Thisform.oObject.ReadExpression (lcPem)
				lxValue = This.Get1Value (Thisform.oObject, lcPem)
				lcTypes = Vartype (lxValue)
		Endcase
		
		If lbTransform And Empty (lcValue)
			Do Case
					* handle null values
				Case Isnull(lxValue)
					lcValue = '.NULL.'
					* Special handling for native colors
				Case 'N' = Vartype (lxValue) And Thisform.IsNativeColor(lcPem, tbNative)
					lnRed   = Bitand(lxValue, 255)
					lnGreen = Bitrshift(Bitand(lxValue, 256 * 255), 8)
					lnBlue  = Bitrshift(Bitand(lxValue, 256 * 256 * 255), 16)
					lcValue = Transform(lnRed) + ',' + Transform(lnGreen) + ',' + Transform(lnBlue)
				Case 'C' = Vartype (lxValue) And 0 = Len(lxValue) and tcResultType= 'Display'
					lcValue = '(None)'
				Case 'D' # Vartype (lxValue)
					lcValue = Transform( lxValue )
				Case Empty (lxValue)
					lcValue = '{}'
				Otherwise
					lcValue = '{^' + Transform(Year(lxValue)) + "/" + Transform(Month(lxValue)) + "/" + Transform(Day(lxValue)) + "}"
			Endcase
		Endif
		
		Do Case
			Case tcResultType= 'Display'
				Return Left (lcValue, 100)
			Case tcResultType= 'Full Value'
				Return lcValue
			Case tcResultType= 'For Editing'
				loResult = Createobject("Empty")
				AddProperty (loResult, "Value", lxValue)
				AddProperty (loResult, "CharValue", lcValue)
				AddProperty (loResult, "Type", lcTypes)
				AddProperty (loResult, "SingleValue", lbTransform)
				Return loResult
		Endcase
		
	ENDPROC

	PROCEDURE Init
		Local lcLibrary, lcMyFile, lcResourceFile, loData
		With This
		
			* Restore saved options and the size and position of the form.
		
			If .lSaveSettings
				lcLibrary = 'PEME_FoxResource.prg'
				.oPersist = Newobject ('FoxResource', lcLibrary)
		
				*** JRN 02/10/2009 : Use own resource file, rather than FoxUser
				lcResourceFile = .cPreferencesFile
				lcMyFile	   = 'PEMEditor_Preferences'
				If File (lcMyFile + '.DBF')
					Try
						Use (lcMyFile) Shared Again In 0 Alias My_Resources
						lcResourceFile = Dbf('My_Resources')
						Use in My_Resources
						.cPreferencesFile = lcResourceFile
					Catch
					EndTry
				EndIf 
		
				Do Case
					Case File (lcResourceFile)
						.oPersist.UseResourceFile (lcResourceFile)
					Otherwise
						.oPersist.CreateResourceFile (lcResourceFile)
				Endcase
		
				.RestoreSettings()
			Endif .lSaveSettings
		
			DoDefault()
		
		Endwith
		
	ENDPROC

	PROCEDURE justpem
		* Strip any index off the member name and convert it to lower case if necessary.
		
		Lparameters tcPEM, ;
			tlLowerCase
		Local lcPem
		lcPem = Trim(tcPEM)
		Do Case
			Case '[' $ lcPem
				lcPem = Left(lcPem, At('[', lcPem) - 1)
			Case '(' $ lcPem
				lcPem = Left(lcPem, At('(', lcPem) - 1)
		Endcase
		Return Iif(tlLowerCase, Lower(lcPem), lcPem)
		
	ENDPROC

	PROCEDURE Load
		* Set up the environment.
		
		Set Deleted On
		Set Exact Off
		Set Exclusive Off
		Set Multilocks On
		Set Safety Off
		Set Talk Off
		Sys(3054, 0)
		
		With This
			Declare Integer GetSysColor In "user32" Integer nIndex
			.nHighlightBackColor  = GetSysColor (13)
			.nHighlightForeColor  = GetSysColor (14)
		
		Endwith
		
	ENDPROC

	PROCEDURE pix2fox
		LPARAMETER tnPixels, tlVertical, tcFontName, tnFontSize
		&& tnPixels - pixels to convert
		&& tlVertical - .F./.T. convert horizontal/vertical coordinates
		&& tcFontName, tnFontSize - use specified font/size 
		&&         or current form (active output window) font/size, if not specified 
		LOCAL lnFoxels
		 
		IF PCOUNT() > 2
			lnFoxels = tnPixels/FONTMETRIC(IIF(tlVertical, 1, 6), tcFontName, tnFontSize)
		ELSE
			lnFoxels = tnPixels/FONTMETRIC(IIF(tlVertical, 1, 6))
		ENDIF	
		 
		RETURN lnFoxels
	ENDPROC

	PROCEDURE putsetting
		Lparameters tcSettingName, lxCurrentValue, txDefaultValue
		Local lxCurrentSetting
		
		lxCurrentSetting = This.GetSetting(tcSettingName, txDefaultValue)
		
		If Vartype (lxCurrentValue) = Vartype (lxCurrentSetting)	;
				and lxCurrentValue == lxCurrentSetting
			* do nothing
		Else
			This.oPersist.Set (tcSettingName, lxCurrentValue)
		Endif
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form with the LockScreen .T.
		* Lock for form while refreshing.
		
		This.LockScreen = .T.
		This.Refresh()
		This.LockScreen = .F.
		
	ENDPROC

	PROCEDURE restorecolumninfo
		Lparameters loGrid
		Local loColumn AS Object
		Local laColumnOrder[1], laColumnWidths[1], lcColumnOrder, lcColumnWidths, lnColumnOrder, lnColumnWidths
		Local lnI 
		
		With loGrid
		
			lcColumnWidths = Nvl(Thisform.oPersist.Get('ColumnWidths'), [])
			lnColumnWidths = Alines(laColumnWidths, Alltrim (lcColumnWidths), .T., " ")
		
			lcColumnOrder = Nvl(Thisform.oPersist.Get('ColumnOrder'), [])
			lnColumnOrder = Alines(laColumnOrder, Alltrim(lcColumnOrder), .T., " ")
		
			For lnI = 1 To .ColumnCount
				loColumn = .Columns(lnI)
				If lnI <= lnColumnWidths And Val(laColumnWidths[lnI]) > 0
					loColumn.Width = Val(laColumnWidths[lnI])
				Else
					loColumn.Width = loColumn.nWidth
				Endif lnI <= lnColumnWidths ...
		
				If .ColumnCount = lnColumnOrder And Val(laColumnOrder[lnI]) > 0
					loColumn.ColumnOrder = Val(laColumnOrder[lnI])
				Endif lnI <= lnColumnOrder ...
			Next lnI
		
		Endw
		
	ENDPROC

	PROCEDURE restoresettings		&& Restores saved settings from FOXUSER
		* Restore saved settings from FOXUSER.
		* Put code for settings into .GetPutSettings
		With This
			.oPersist.Load(.cFoxUserID, .cFoxUserName)
			.GetPutSettings(.F.)
		Endwith
		
		
	ENDPROC

	PROCEDURE savecolumninfo
		Lparameters loGrid
		Local loColumn AS Object
		Local lcColumnOrder, lcColumnWidths, lnI 
		With this
			lcColumnWidths 	= []
			lcColumnOrder 	= []
			For lnI = 1 To loGrid.ColumnCount
				loColumn       = loGrid.Columns[lnI]
				lcColumnWidths = lcColumnWidths + ' ' + Transform(loColumn.Width)
				lcColumnOrder  = lcColumnOrder  + ' ' + Transform(loColumn.ColumnOrder)
			Next lnI
		
			.PutSetting('ColumnWidths', Trim(lcColumnWidths))
			.PutSetting('ColumnOrder' , Trim(lcColumnOrder))
		EndWith 
	ENDPROC

	PROCEDURE savesettings		&& Saves settings to FOXUSER
		* Save settings to FOXUSER.
		* Put code for settings into .GetPutSettings
		
		With This
			.GetPutSettings(.T.)
			.oPersist.Save(.cFoxUserID, .cFoxUserName)
		Endwith
		
	ENDPROC

	PROCEDURE update1property
		Lparameters toObject, tcPem, tuVal
		Local loException, lcExpression
		
		*** JRN 12/21/2008 : for some native properties, not all values entered are valid
		* See also editpropertydialog.ApplyChanges
		If Not Thisform.GetPEMStatus (toObject, tcPem, 5)
			Return
		Endif
		
		Try && for some native properties, not all values entered are valid
			Do Case
				Case Vartype(tuVal) = 'C' And tuVal = ['] And Not ['] $ Substr(tuVal,2)
					toObject.WriteExpression (tcPem, [='] + Substr(tuVal,2) + [']) 
				Case Vartype(tuVal) = 'C' And tuVal = '='
					toObject.WriteExpression (tcPem, tuVal)
				Otherwise
					If Not Empty(toObject.ReadExpression (tcPem))
						toObject.WriteExpression (tcPem, '') && clear out all expression, if any.
					Endif
					*** JRN 12/23/2008 : assignment rather than AddProperty, since that fails on OLEs
					With toObject
						lcExpression = "." + tcPem + " = tuVal"
						&lcExpression && note that macro expansion works here
					Endwith
			Endcase
		
		Catch To loException
			Messagebox(ccLOC_AddProperty_Failed + ccCRLF + ;
				'Message: ' + loException.Message + ccCRLF,  ;
				MB_OK + MB_ICONEXCLAMATION, 'Set Property!! Failure')
		Endtry
		
	ENDPROC

	PROCEDURE updateselectedcontrols
		*** JRN 03/17/2009 : use ASelObj to determine which objects, unless explicitly told to use the supplied object
		Lparameters toObject, tcPem, tuVal, tlOnlyOne
		
		Local Array laSelected[1]
		Local lnSelected, lnI
		
		With This
			If tlOnlyOne
				.Update1Property(toObject, tcPem, tuVal)
			Else
				lnSelected = Aselobj(laSelected)
				If lnSelected > 0
					For lnI = 1 To lnSelected
						.Update1Property(laSelected[lnI], tcPem, tuVal)
					Next lnI
				Else
					.Update1Property(toObject, tcPem, tuVal)
				Endif lnSelected > 0
			Endif
		Endwith
		
		If Used("csrMembers")
			Replace lNonDefault With .T. In csrMembers
			Thisform.Refresh()
		Endif
		
		Return
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseformnew AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ChangeFontSize" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addmrufile
		*m: calculateshortcutmenuposition
		*m: changefont
		*m: checkfornewproperty
		*m: createcontextmenu
		*m: diskfilename
		*m: get1value
		*m: getdisplayrelativepath
		*m: getmrulist
		*m: getpemstatus
		*m: getputsettings
		*m: getrelativepath
		*m: getvalue
		*m: insurevisible
		*m: justpem
		*m: loadcolumninfo
		*m: loadsettings
		*m: pix2fox
		*m: refreshform		&& Refreshes the form with the LockScreen .T.
		*m: restorefont
		*m: savecolumninfo
		*m: savedockinginfo
		*m: savesettings		&& Saves settings to FOXUSER
		*m: setdefaults
		*m: update1property
		*m: updateselectedcontrols
		*p: cfoxuserid		&& The FOXUSER ID to save/restore settings to
		*p: cfoxusername		&& The FOXUSER NAME to save/restore settings to
		*p: lbindcontrols
		*p: lpemeditorform		&& Indicates that this is a PEM Editor form
		*p: lpersistsizeposition		&& .T. to persist the size and position of the form
		*p: lsavesettings		&& .T. to save and restore settings
		*p: nfontsize
		*p: nhighlightbackcolor
		*p: nhighlightforecolor
		*p: omysettings
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	BindControls = .F.
	Caption = "Form"
	cfoxuserid = 		&& The FOXUSER ID to save/restore settings to
	cfoxusername = 		&& The FOXUSER NAME to save/restore settings to
	DataSession = 2
	DoCreate = .T.
	FontSize = 8
	lbindcontrols = .T.
	lpemeditorform = .T.		&& Indicates that this is a PEM Editor form
	lpersistsizeposition = .T.		&& .T. to persist the size and position of the form
	lsavesettings = .T.		&& .T. to save and restore settings
	Name = "baseformnew"
	nfontsize = 8
	nhighlightbackcolor = 0
	nhighlightforecolor = 0
	omysettings = .NULL.
	ShowTips = .T.
	_memberdata = <VFPData>
		<memberdata name="omysettings" display="oMySettings"/>
		<memberdata name="lpersistsizeposition" display="lPersistSizePosition"/>
		<memberdata name="setdefaults" display="SetDefaults"/>
		<memberdata name="changefont" display="ChangeFont"/>
		<memberdata name="restorefont" display="RestoreFont"/>
		<memberdata name="loadsettings" display="LoadSettings"/>
		<memberdata name="cfoxuserid" display="cFoxUserID"/>
		<memberdata name="savecolumninfo" display="SaveColumnInfo"/>
		<memberdata name="loadcolumninfo" display="LoadColumnInfo"/>
		<memberdata name="savesettings" display="SaveSettings"/>
		<memberdata name="lbindcontrols" display="lBindControls"/>
		<memberdata name="savedockinginfo" display="SaveDockingInfo"/>
		<memberdata name="insurevisible" display="InsureVisible"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'ChangeFontSize' AS changefontsize WITH ;
		Height = 17, ;
		Left = 16, ;
		Name = "ChangeFontSize", ;
		Top = 16, ;
		Width = 20
		*< END OBJECT: ClassLib="changefontsize.vcx" BaseClass="custom" />
	
	PROCEDURE addmrufile
		Lparameters lcFileName, lcClassName, lcMRU_ID
		
		#Define DELIMITERCHAR Chr(0)
		#Define MAXITEMS      24
		
		Local lcData, lcExt, lcLine25, lcList, lcNewData, lcSearchString, lcSourceFile, lnPos
		Local lnSelect
		
		If 'ON' # Set ('Resource')
			Return
		Endif
		
		lcSourceFile = Set ('Resource', 1)
		lcExt		 = Upper (Justext (lcFileName))
		
		If Empty (lcMRU_ID)
			lcList = ',VCX=MRUI,PRG=MRUB,MPR=MRUB,QPR=MRUB,SCX=MRUH,MNX=MRUE,FRX=MRUG,DBC=???,LBX=???,PJX=MRUL'
			lnPos  = At (',' + lcExt + '=', lcList)
			If lnPos = 0
				lcMRU_ID = 'MRUC'
			Else
				lcMRU_ID = Substr (lcList, lnPos + 5, 4)
				If lcMRU_ID = '?'
					Return
				Endif
			Endif
		Endif
		
		If lcMRU_ID = 'MRUI'
			If Empty (lcClassName)
				lcMRU_ID	   = 'MRU2'
				lcSearchString = lcFileName + DELIMITERCHAR
			Else
				lcSearchString = lcFileName + '|' + Lower (lcClassName) + DELIMITERCHAR
			Endif
		Else
			lcSearchString = lcFileName + DELIMITERCHAR
		Endif
		
		lnSelect = Select()
		Select 0
		Use (lcSourceFile) Again Shared Alias MRU_Resource_Add
		
		Locate For Id = lcMRU_ID
		If Found()
			lcData = DELIMITERCHAR + Substr (Data, 3)
			lnPos  = Atcc (DELIMITERCHAR + lcSearchString, lcData)
			Do Case
				Case lnPos = 1
					* already tops of the list
					lcNewData = Data
				Case lnPos = 0
					* must add to list
					lcNewData = Stuff (Data, 3, 0, lcSearchString)
					* note that GetWordNum won't accept CHR(0) as a delimiter
					lcLine25  = Getwordnum (Chrtran (Substr (lcNewData, 3), DELIMITERCHAR, CR), MAXITEMS + 1, CR)
					If Not Empty (lcLine25)
						lcNewData = Strtran (lcNewData, DELIMITERCHAR + lcLine25 + DELIMITERCHAR, DELIMITERCHAR, 1, 1, 1)
					Endif
				Otherwise
					lcNewData = Stuff (Data, lnPos + 1, Len (lcSearchString), '')
					lcNewData = Stuff (lcNewData, 3, 0, lcSearchString)
			Endcase
			Replace															;
				Data	 With  lcNewData									;
				ckval	 With  Val (Sys(2007, Substr (lcNewData, 3)))		;
				Updated	 With  Date()
		Else
			lcNewData = Chr(4) + DELIMITERCHAR + lcSearchString
			Insert Into MRU_Resource_Add			;
				(Type, Id, ckval, Data, Updated)	;
				values 								;
				('PREFW', lcMRU_ID, Val (Sys(2007, Substr (lcNewData, 3))), lcNewData, Date())
		
			****************************************************************
		Endif
		
		Use
		Select (lnSelect)
		
		Return
		
	ENDPROC

	PROCEDURE calculateshortcutmenuposition
		Local loWas, lcPoint, loResult, lnSMCol, lnSMRow
		
		loWas = Newobject("WinApiSupport", "PEME_WinApiSupport.PRG")
		Declare Long GetCursorPos In WIN32API String @lpPoint
		Declare Long ScreenToClient In WIN32API Long HWnd, String @lpPoint
		
		lcPoint = Replicate(Chr(0), 8)
		&& Get mouse location in Windows desktop coordinates (pixels)
		= GetCursorPos(@lcPoint)
		&& Convert to VFP Desktop (_Screen) coordinates
		= ScreenToClient(_Screen.HWnd, @lcPoint)
		&& Covert the coordinates to foxels
		
		lnSMCol = This.Pix2Fox(loWas.Long2Num(Left(lcPoint,4)), .F., _Screen.FontName, _Screen.FontSize)
		lnSMRow = This.Pix2Fox(loWas.Long2Num(Right(lcPoint,4)), .T., _Screen.FontName, _Screen.FontSize)
		
		loResult = Createobject("Empty")
		AddProperty (loResult, 'Column', lnSMCol )
		AddProperty (loResult, 'Row', lnSMRow )
		Return loResult
		
	ENDPROC

	PROCEDURE changefont
		Lparameters loObject
		Local laFont[1], lcFont, lcStyle
		
		With Thisform
			lcStyle	= IIf (loObject.FontBold, 'B', '') + IIf (loObject.FontItalic, 'I', '')
			lcFont	= Getfont (loObject.FontName, loObject.FontSize, lcStyle)
			If Not Empty (lcFont)
				Alines (laFont, lcFont, .T., ',')
				With loObject
					.FontName	= laFont[1]
					.FontSize	= Val (laFont[2])
					.FontBold	= 'B' $ laFont[3]
					.FontItalic	= 'I' $ laFont[3]
				Endwith
		
				With Thisform.oMySettings
					.cFontName	= loObject.FontName
					.nFontSize	= loObject.FontSize
					.cFontStyle	= IIf (loObject.FontBold, 'B', '') + IIf (loObject.FontItalic, 'I', '')
				Endwith
		
			Endif Not Empty (lcFont)
		Endwith
		
	ENDPROC

	PROCEDURE checkfornewproperty
		Lparameters lxValue, lcPem, loObject, loTopOfForm
		
		Local lcObjectName, lcPropertyName, lnLastDot, lnMsgBoxAns, loThis, lxNewValue
		Do Case
			Case 'C' # Vartype (lxValue)
				Return .T.
		
			Case Upper (lxValue) = 'THISFORM.' and 2 = GetWordCount(lxValue, '.')
				lcPropertyName = Getwordnum (lxValue, 2, '.')
				Do Case
					Case Lower(loTopOfForm.BaseClass) # 'form'
						Return .T.
					Case Len (Alltrim (lcPropertyName)) # Len (lcPropertyName)
						Return .T.
					Case Pemstatus (loTopOfForm, lcPropertyName, 5)
						Return .T.
					Otherwise
						Do Form AskAddPemNew With lcPropertyName, .F., 'P' To llResult
						Return llResult
				Endcase
		
			Case Upper (lxValue) = 'THIS.'
			
				lnLastDot	   = RAt ('.', lxValue)
				lcPropertyName = Substr (lxValue, lnLastDot + 1)
				lcObjectName   = 'lo' + Left (lxValue, lnLastDot - 1)
				loThis		   = loObject
				If 'O' # Type (lcObjectName) Or loTopOfForm # Evaluate (lcObjectName)
					Return .T.
				Endif
		
				Do Case
					Case Len (Alltrim (lcPropertyName)) # Len (lcPropertyName)
						Return .T.
					Case Pemstatus (loTopOfForm, lcPropertyName, 5)
						Return .T.
					Otherwise
						Do Form AskAddPemNew With lcPropertyName, .F., 'P' To llResult
						Return llResult
				Endcase
		
			Otherwise
				Return .T.
		
		Endcase
		
		
		
	ENDPROC

	PROCEDURE createcontextmenu
		Lparameters lcMenuName
		Local loPosition
		
		loPosition = This.CalculateShortcutMenuPosition()
		
		*** JRN 2010-11-10 : Following is an attempt to solve the problem
		* when there is another form already open; apparently, if the 
		* focus is on the screen, the positioning of the popup still works OK
		_Screen.Show()
		
		Define Popup (lcMenuName)						;
			shortcut									;
			Relative									;
			From loPosition.Row, loPosition.Column
		
	ENDPROC

	PROCEDURE Destroy
		With This.oMySettings
			This.SaveSettings()
		Endwith
		
		This.oMySettings = .Null.
		
	ENDPROC

	PROCEDURE diskfilename
		Lparameters lcFileName
		
		#Define MAX_PATH 260
		
		Local lnFindFileData, lnHandle, lcXXX
		Declare Integer FindFirstFile In win32api String @, String @
		Declare Integer FindNextFile In win32api Integer, String @
		Declare Integer FindClose In win32api Integer
		
		Do Case
			Case ( Right (lcFileName, 1) == '\' )
				Return Addbs (This.DiskFileName (Left (lcFileName, Len (lcFileName) - 1)))
		
			Case Empty (lcFileName)
				Return ''
		
			Case ( Len (lcFileName) == 2 ) And ( Right (lcFileName, 1) == ':' )
				Return Upper (lcFileName)	&& win2k gives curdir() for C:
		Endcase
		
		lnFindFileData = Space(4 + 8 + 8 + 8 + 4 + 4 + 4 + 4 + MAX_PATH + 14)
		lnHandle		 = FindFirstFile (@lcFileName, @lnFindFileData)
		
		If ( lnHandle < 0 )
			If ( Not Empty (Justfname (lcFileName)) )
				lcXXX = Justfname (lcFileName)
			Else
				lcXXX = lcFileName
			Endif
		Else
			= FindClose (lnHandle)
			lcXXX	= Substr (lnFindFileData, 45, MAX_PATH)
			lcXXX	= Left (lcXXX, At (Chr(0), lcXXX) - 1)
		Endif
		
		
		Do Case
			Case Empty (Justpath (lcFileName))
				Return lcXXX
			Case ( Justpath (lcFileName) == '\' ) Or (Left (lcFileName, 2) == '\\')	&& unc
				Return '\\' + lcXXX
			Otherwise
				Return Addbs (This.DiskFileName (Justpath (lcFileName))) + lcXXX
		Endcase
		
		Return
		
	ENDPROC

	PROCEDURE get1value
		Lparameters loObject, lcPem
		Local lcResult
		
		Try
			lcResult = Evaluate( [loObject.] + lcPem)
		Catch
			lcResult = ''
		Endtry
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getdisplayrelativepath
		Lparameters lcFileName, lcFolder, lcClass
		* returns the display form of a file name
		Local lcFileDisplayName, lcFName, lcQuote, lcResult
		
		lcFileDisplayName = Thisform.GetRelativePath (This.DiskFileName(lcFileName), Evl (lcFolder, Curdir()))
		lcFName = Justfname (lcFileDisplayName)
		lcQuote = Iif (" " $ lcFName, ['], '')
		If lcFName == lcFileDisplayName
			lcResult = lcQuote + lcFName + lcQuote
		Else
			lcResult = lcQuote + lcFName + lcQuote + "  from  " + Justpath (lcFileDisplayName)
		Endif
		
		Return lcResult 
		
	ENDPROC

	PROCEDURE getmrulist
		Lparameters lcMRU_ID
		
		#Define DELIMITERCHAR Chr(0)
		
		Local loCollection As 'Collection'
		Local laItems(1), lcData, lcList, lcSourceFile, lnI, lnPos, lnSelect
		
		loCollection = Createobject ('Collection')
		
		If 'ON' # Set ('Resource')
			Return loCollection
		Endif
		
		lnSelect	 = Select()
		lcSourceFile = Set ('Resource', 1)
		Select 0
		Use (lcSourceFile) Again Shared Alias MRU_Resource
		
		If lcMRU_ID # 'MRU'
			lcList = ',VCX=MRUI,PRG=MRUB,MPR=MRUB,QPR=MRUB,SCX=MRUH,MNX=MRUE,FRX=MRUG,DBC=???,LBX=???,PJX=MRUL,DBF=MRUS'
			lnPos  = At (',' + Upper (JustExt ('.' + lcMRU_Id)) + '=', lcList)
			If lnPos = 0
				lcMRU_ID = 'MRUC'
			Else
				lcMRU_ID = Substr (lcList, lnPos + 5, 4)
				If lcMRU_ID = '?'
					Return
				Endif
			Endif
		Endif
		
		Locate For Id = lcMRU_ID
		If Found()
			lcData = Data
			Alines (laItems, Substr (lcData, 3), 0, DELIMITERCHAR)
			For lnI = 1 To Alen (laItems)
				If Not Empty (laItems (lnI))
					loCollection.Add (laItems (lnI))
				Endif
			Endfor
		Endif
		
		Use
		Select (lnSelect)
		Return loCollection
		
		
	ENDPROC

	PROCEDURE getpemstatus
		Lparameters loObject, lcPEM, nAttribute
		
		If Upper(loObject.BaseClass) = 'OLE'
		
			Local laMembers(1), lnRow
			Amembers(laMembers, loObject, 1, 'PHG#')
			lnRow = Ascan(laMembers, lcPEM, -1, -1, 1, 15)
		
			Do Case
				Case lnRow = 0
					Return .F.
				Case nAttribute = 0 && changed
					Return 'C' $ laMembers(lnRow,3)
				Case nAttribute = 1 && readonly
					Return 'R' $ laMembers(lnRow,3)
				Case nAttribute = 2 && protected
					Return 'P' $ laMembers(lnRow,3)
				Case nAttribute = 3 && type
					Return laMembers(lnRow,2)
				Case nAttribute = 4 && user-defined
					Return 'U' $ laMembers(lnRow,3)
				Case nAttribute = 5 && defined
					Return .T.
				Case nAttribute = 6 && inherited
					Return 'I' $ laMembers(lnRow,3)
			Endcase
		
		Else
		
			Return Pemstatus (loObject, lcPEM, nAttribute)
		
		Endif
		
	ENDPROC

	PROCEDURE getputsettings
		Lparameters lbPutFlag
		
		*  Routine to either save (lbPutFlag = .T.) or get (lbPutFlag = .F.) settings
		*  Structured this way so a single method call is this routine can be used
		*  both ways, insuring that all settings are handled consistently between
		*  saving and restoring.  Improved legibility as well.
		
		With This
			.GetPutSetting ('Top', 		'Top', 		.Top + 1, 	lbPutFlag)
			.GetPutSetting ('Left', 	'Left', 	.Left + 1, 	lbPutFlag)
			.GetPutSetting ('Height', 	'Height', 	.Height + 1, lbPutFlag)
			.GetPutSetting ('Width', 	'Width', 	.Width + 1, lbPutFlag)
		Endwith
		
	ENDPROC

	PROCEDURE getrelativepath
		Lparameters lcName, lcPath
		Local lcNew, lnPos
		Try 
			If Empty (lcPath)
				lcNew = Sys(2014, lcName)
			Else
				lcNew = Sys(2014, lcName, lcPath)
			Endif
		Catch to loException
			lcNew = lcName
		EndTry
		
		If Len (lcNew) < Len (lcName)
			lnPos = Rat ('..\', lcNew)
			If lnPos # 0
				lnPos = lnPos + 2
			Endif
			Return Left (lcNew, lnPos) + Right (lcName, Len (lcNew) - lnPos)
		Else
			Return lcName
		EndIf 
	ENDPROC

	PROCEDURE getvalue
		Lparameters lcName, tbNative, tcResultType, tnObjNumber
		
		Local lcPem, lbFirst, lcValue, lxValue, lcNewValue, lxNewValue, lnRed, lnGreen, lnBlue
		Local loObject, lbTransform, loResult, lcTypes, lcNewType, lnI, lnJ, lnK
		
		lcPem = Thisform.JustPEM(lcName)
		lbTransform = .T.
		
		*** JRN 03/18/2009 : modifications to handle multiple objects
		Do Case
			Case Not Empty(tnObjNumber)
				loObject = Thisform.aSelectedObjects(tnObjNumber)
				lcPem = Thisform.cEditPropertyName
				lcValue = loObject.ReadExpression (lcPem)
				lxValue = This.Get1Value (loObject, lcPem)
				lcTypes = Vartype (lxValue)
		
			Case (Thisform.lUseCSO) And Thisform.nSelectedObjects > 1
				lbFirst = .T.
				For lnI = 1 to Alen ( Thisform.aSelectedObjects)
					loObject = Thisform.aSelectedObjects(lnI)
					Do Case
						Case Not Thisform.GetPEMStatus(loObject, lcPem, 5)
		
						Case lbFirst
							lcValue = loObject.ReadExpression (lcPem)
							lxValue = This.Get1Value (loObject, lcPem)
							lbFirst = .F.
							lcTypes = Vartype (lxValue)
						Otherwise
							lcNewValue = loObject.ReadExpression (lcPem)
							lxNewValue = This.Get1Value (loObject, lcPem)
							lcNewType  = Vartype (lxValue)
							If lbTransform
								If (Not lcValue == lcNewValue)							;
										or Vartype (lxValue) # Vartype (lxNewValue)		;
										or lxValue # lxNewValue
									lcValue = ' '
									lbTransform = .F.
									lcTypes = lcTypes + Iif (lcNewType $ lcTypes, '', lcNewType)
								Endif
							Else
								lcTypes = lcTypes + Iif (lcNewType $ lcTypes, '', lcNewType)
							Endif
					Endcase
				Endfor
			Otherwise
				lcValue = Thisform.oObject.ReadExpression (lcPem)
				lxValue = This.Get1Value (Thisform.oObject, lcPem)
				lcTypes = Vartype (lxValue)
		Endcase
		
		If lbTransform And Empty (lcValue)
			Do Case
					* handle null values
				Case Isnull(lxValue)
					lcValue = '.NULL.'
					* Special handling for native colors
				Case 'N' = Vartype (lxValue) And Thisform.IsNativeColor(lcPem, tbNative)
					lnRed   = Bitand(lxValue, 255)
					lnGreen = Bitrshift(Bitand(lxValue, 256 * 255), 8)
					lnBlue  = Bitrshift(Bitand(lxValue, 256 * 256 * 255), 16)
					lcValue = Transform(lnRed) + ',' + Transform(lnGreen) + ',' + Transform(lnBlue)
				Case 'C' = Vartype (lxValue) And 0 = Len(lxValue) and tcResultType= 'Display'
					lcValue = '(None)'
				Case 'D' # Vartype (lxValue)
					lcValue = Transform( lxValue )
				Case Empty (lxValue)
					lcValue = '{}'
				Otherwise
					lcValue = '{^' + Transform(Year(lxValue)) + "/" + Transform(Month(lxValue)) + "/" + Transform(Day(lxValue)) + "}"
			Endcase
		Endif
		
		Do Case
			Case tcResultType= 'Display'
				Return Left (lcValue, 100)
			Case tcResultType= 'Full Value'
				Return lcValue
			Case tcResultType= 'For Editing'
				loResult = Createobject("Empty")
				AddProperty (loResult, "Value", lxValue)
				AddProperty (loResult, "CharValue", lcValue)
				AddProperty (loResult, "Type", lcTypes)
				AddProperty (loResult, "SingleValue", lbTransform)
				Return loResult
		Endcase
		
	ENDPROC

	PROCEDURE Init
		DoDefault()
		
		With This
			.oMySettings = Newobject ('PEME_BasePreferences', 'Peme_Preferences.VCX')
			With .oMySettings
				.LoadValues (This.cFoxUserID, 'Settings')
				.UseDefaults()
		
				With .oDefaults
					.nTop		   = This.Top
					.nLeft		   = This.Width
					.nHeight	   = This.Height
					.nWidth		   = This.Width
					.nDockable	   = 2
					.lDocked	   = .F.
					.nDockPosition = -1
					.cDockWindow   = ''
					This.SetDefaults()
				Endwith
		
				This.LoadSettings()
		
				If This.Dockable # 0
					.nStartingTop = This.Top
					.Top = -2000
				Endif
		
			Endwith
		
			If .lBindControls
				.BindControls = .T.
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE insurevisible
		Local loObject As Object
		Local lnMaxHeight, lnMaxLeft, lnMaxTop, lnMaxWidth
		
		loObject = Thisform
		*** JRN 2009-09-14 : Following code courtesy of Doug Hennig's blog
		#Define SM_XVIRTUALSCREEN  76     && virtual left
		#Define SM_YVIRTUALSCREEN  77     && virtual top
		#Define SM_CXVIRTUALSCREEN 78   && virtual width
		#Define SM_CYVIRTUALSCREEN 79   && virtual height
		* #Define SM_CXFULLSCREEN    16     && screen width accounting for taskbar
		* #Define SM_CYFULLSCREEN    17     && screen height accounting for taskbar
		
		Do Case
			Case Pemstatus(loObject, 'Dockable', 5) And loObject.Dockable = 1
				Declare Integer GetSystemMetrics In Win32API Integer
				lnMaxLeft   = GetSystemMetrics(SM_XVIRTUALSCREEN)
				lnMaxTop    = GetSystemMetrics(SM_YVIRTUALSCREEN)
				lnMaxWidth  = GetSystemMetrics(SM_CXVIRTUALSCREEN)
				lnMaxHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN)
			Case Pemstatus(loObject, 'Desktop', 5) And (loObject.Desktop Or loObject.ShowWindow = 2)
				Declare Integer GetSystemMetrics In Win32API Integer
				lnMaxLeft   = GetSystemMetrics(SM_XVIRTUALSCREEN)
				lnMaxTop    = GetSystemMetrics(SM_YVIRTUALSCREEN)
				lnMaxWidth  = GetSystemMetrics(SM_CXFULLSCREEN)
				lnMaxHeight = GetSystemMetrics(SM_CYFULLSCREEN)
			Otherwise
				lnMaxLeft   = 0
				lnMaxTop    = 0
				lnMaxWidth  = _Screen.Width
				lnMaxHeight = _Screen.Height - ;
					Iif(Pemstatus(loObject, 'TitleBar', 5) And ;
					loObject.TitleBar = 1, Sysmetric(9), 0)
				&& account for the title bar height if necessary
		Endcase
		
		loObject.Width = Min(Max(loObject.Width, 0, loObject.MinWidth), ;
			lnMaxWidth)
		loObject.Height = Min(Max(loObject.Height, 0, loObject.MinHeight), ;
			lnMaxHeight)
		
		Do Case
		
				* If we're past the left edge, move it to the left edge.
		
			Case loObject.Left < lnMaxLeft
				loObject.Left = lnMaxLeft
		
				* If we're past the right edge of the screen, move it to the right edge.
		
			Case loObject.Left + loObject.Width > lnMaxWidth + lnMaxLeft
				loObject.Left = lnMaxWidth + lnMaxLeft - loObject.Width
		Endcase
		Do Case
		
				* If we're past the top edge, move it to the top edge.
		
			Case loObject.Top < lnMaxTop
				loObject.Top = lnMaxTop
		
				* If we're past the bottom edge of the screen, move it to the bottom edge.
		
			Case loObject.Top + loObject.Height > lnMaxHeight + lnMaxTop
				loObject.Top = lnMaxHeight + lnMaxTop - loObject.Height
		Endcase
		****************************************************************
		****************************************************************
		
	ENDPROC

	PROCEDURE justpem
		* Strip any index off the member name and convert it to lower case if necessary.
		
		Lparameters tcPEM, ;
			tlLowerCase
		Local lcPem
		lcPem = Trim(tcPEM)
		Do Case
			Case '[' $ lcPem
				lcPem = Left(lcPem, At('[', lcPem) - 1)
			Case '(' $ lcPem
				lcPem = Left(lcPem, At('(', lcPem) - 1)
		Endcase
		Return Iif(tlLowerCase, Lower(lcPem), lcPem)
		
	ENDPROC

	PROCEDURE Load
		* Set up the environment.
		
		Set Deleted On
		Set Exact Off
		Set Exclusive Off
		Set Multilocks On
		Set Safety Off
		Set Talk Off
		Sys(3054, 0)
		
		With This
			Declare Integer GetSysColor In 'user32' Integer nIndex
			.nHighlightBackColor = GetSysColor (13)
			.nHighlightForeColor = GetSysColor (14)
		Endwith
		
	ENDPROC

	PROCEDURE loadcolumninfo
		Lparameters loGrid
		Local loColumn As Object
		Local laColumnOrder[1], laColumnWidths[1], lcColumnOrder, lcColumnWidths, lnColumnOrder
		Local lnColumnWidths, lnI
		
		lcColumnWidths = .cColumnWidths
		lcColumnOrder  = .cColumnOrder
		
		With loGrid
		
			lnColumnWidths = Alines (laColumnWidths, Alltrim (lcColumnWidths), .T., ' ')
			lnColumnOrder  = Alines (laColumnOrder, Alltrim (lcColumnOrder), .T., ' ')
		
			For lnI = 1 To .ColumnCount
				loColumn = .Columns (lnI)
				If lnI <= lnColumnWidths And Val (laColumnWidths[lnI]) > 0
					loColumn.Width = Val (laColumnWidths[lnI])
				Endif lnI <= lnColumnWidths ...
		
				If .ColumnCount = lnColumnOrder And Val (laColumnOrder[lnI]) > 0
					loColumn.ColumnOrder = Val (laColumnOrder[lnI])
				Endif lnI <= lnColumnOrder ...
			Next lnI
		
		Endw
		
	ENDPROC

	PROCEDURE loadsettings
		If This.lPersistSizePosition
			This.Top  = .nTop
			This.Left = .nLeft
			If This.BorderStyle = 3
				This.Height	= .nHeight
				This.Width	= .nWidth
			Endif
		Endif
		
		
	ENDPROC

	PROCEDURE pix2fox
		LPARAMETER tnPixels, tlVertical, tcFontName, tnFontSize
		&& tnPixels - pixels to convert
		&& tlVertical - .F./.T. convert horizontal/vertical coordinates
		&& tcFontName, tnFontSize - use specified font/size 
		&&         or current form (active output window) font/size, if not specified 
		LOCAL lnFoxels
		 
		IF PCOUNT() > 2
			lnFoxels = tnPixels/FONTMETRIC(IIF(tlVertical, 1, 6), tcFontName, tnFontSize)
		ELSE
			lnFoxels = tnPixels/FONTMETRIC(IIF(tlVertical, 1, 6))
		ENDIF	
		 
		RETURN lnFoxels
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form with the LockScreen .T.
		* Lock for form while refreshing.
		
		This.LockScreen = .T.
		This.Refresh()
		This.LockScreen = .F.
		
	ENDPROC

	PROCEDURE restorefont
		Lparameters loObject
		
		Local lcStyle
		
		With loObject
			.FontName = This.oMySettings.cFontName
			.FontSize = This.oMySettings.nFontSize
		
			lcStyle		= This.oMySettings.cFontStyle
			.FontBold	= 'B' $ lcStyle
			.FontItalic	= 'I' $ lcStyle
		Endw
		
	ENDPROC

	PROCEDURE savecolumninfo
		Lparameters loGrid
		Local lcColumnOrder, lcColumnWidths, lnI, loColumn
		
		With This
			lcColumnWidths = []
			lcColumnOrder  = []
			For lnI = 1 To loGrid.ColumnCount
				loColumn	   = loGrid.Columns[lnI]
				lcColumnWidths = lcColumnWidths + ' ' + Transform (loColumn.Width)
				lcColumnOrder  = lcColumnOrder  + ' ' + Transform (loColumn.ColumnOrder)
			Next lnI
		
		Endwith
		
		.cColumnWidths = Trim(lcColumnWidths)
		.cColumnOrder = Trim(lcColumnOrder)
		
		.oDefaults.cColumnWidths = ''
		.oDefaults.cColumnOrder = ''
		
	ENDPROC

	PROCEDURE savedockinginfo
		*** JRN 12/24/2008 : Save all docking info; called by AfterDock and UnDock
		
		Local laDock[1], lcDockWindow, lnRow, lnRowDocked, loSettings
		
		If Not PEME_IsVersion9()
			Return
		Endif
		
		With This
		
			* Persist the docking information.
			If .Dockable # 0
				loSettings			 = This.oMySettings
				loSettings.nDockable = .Dockable
				loSettings.lDocked	 = .Docked
				If .Docked
					Adockstate (laDock)
					lnRow = Ascan (laDock, .Caption, -1, -1, 1, 15)
					*** JRN 12/24/2008 : Remember window that we're docked to
					lcDockWindow = ''
					If lnRow > 0
						loSettings.nDockPosition = laDock[lnRow, 3]
						If laDock[lnRow, 4] # _Screen.Caption And Not Empty (laDock[lnRow, 4])
							lcDockWindow = laDock[lnRow, 4]
						Else
							lnRowDocked = Ascan (laDock, .Caption, -1, -1, 4, 15)
							If lnRowDocked > 0
								lcDockWindow = laDock[lnRowDocked, 1]
							Endif
						Endif
					Endif lnRow > 0
					loSettings.cDockWindow = lcDockWindow
					*** JRN 12/24/2008
				Endif .Docked
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE savesettings		&& Saves settings to FOXUSER
		With This.oMySettings
			.nTop	 = This.Top
			.nLeft	 = This.Left
			.nHeight = This.Height
			.nWidth	 = This.Width
			This.SaveDockingInfo()
			.SaveValues()
		Endwith
		
		
	ENDPROC

	PROCEDURE setdefaults
		*
	ENDPROC

	PROCEDURE Show
		* Restore the Dockable setting if we're not being invoked modally. We have to
		* do it here because the form becomes visible as soon as Dockable is set to 1,
		* so we don't want this done earlier.
		Lparameters tnStyle
		
		Local lcDockWindow, llDocked, lnDockPosition, lnLeft
		Declare Integer GetSystemMetrics In user32 Integer nIndex
		
		If This.Dockable # 0
			With This
				lnLeft         = .Left
				If PEME_IsVersion9() And (Vartype (tnStyle) # 'N' Or tnStyle # 1)
					loSettings	   = This.oMySettings
					.Dockable	   = loSettings.nDockable
					llDocked	   = loSettings.lDocked
					lnDockPosition = loSettings.nDockPosition
					If .Dockable = 1 And llDocked
						*** JRN 12/24/2008 : Tab docking
						lcDockWindow = loSettings.cDockWindow
						Do Case
							Case Not Empty (lcDockWindow)
								Try
									Dock Name Thisform position 4 Window &lcDockWindow
								Catch
		
								Endtry
							Case  Between (lnDockPosition, 0, 3)
								.Dock (lnDockPosition)
						Endcase
						*** JRN 12/24/2008
					Endif .Dockable = 1 ...
		
				Endif PEME_IsVersion9() And (Vartype (tnStyle) # 'N' Or tnStyle # 1)
		
				.Left = lnLeft
				.Top  = loSettings.nStartingTop
				.InsureFormVisible()
		
			Endwith
		Endif
		
		DoDefault (tnStyle)
		
		
	ENDPROC

	PROCEDURE update1property
		Lparameters toObject, tcPem, tuVal
		Local loException, lcExpression
		
		*** JRN 12/21/2008 : for some native properties, not all values entered are valid
		* See also editpropertydialog.ApplyChanges
		If Not Thisform.GetPEMStatus (toObject, tcPem, 5)
			Return
		Endif
		
		Try && for some native properties, not all values entered are valid
			Do Case
				Case Vartype(tuVal) = 'C' And tuVal = ['] And Not ['] $ Substr(tuVal,2)
					toObject.WriteExpression (tcPem, [='] + Substr(tuVal,2) + [']) 
				Case Vartype(tuVal) = 'C' And tuVal = '='
					toObject.WriteExpression (tcPem, tuVal)
				Otherwise
					If Not Empty(toObject.ReadExpression (tcPem))
						toObject.WriteExpression (tcPem, '') && clear out all expression, if any.
					Endif
					*** JRN 12/23/2008 : assignment rather than AddProperty, since that fails on OLEs
					With toObject
						*** JRN 2011-05-25 : remove erroneous characters from ControlSource or RecordSource
						If Upper(tcPEM) == 'CONTROLSOURCE' or Upper(tcPEM) == 'RECORDSOURCE'
							If 'C' = Vartype(tuVal)
								tuVal = Chrtran(tuVal, ' ' + ccCR + ccLF + ccTAB, '')
							EndIf
						EndIf 
						lcExpression = "." + tcPem + " = tuVal"
						&lcExpression && note that macro expansion works here
					Endwith
			Endcase
		
		Catch To loException
			Messagebox(ccLOC_AddProperty_Failed + ccCRLF + ;
				'Message: ' + loException.Message + ccCRLF,  ;
				MB_OK + MB_ICONEXCLAMATION, 'Set Property!! Failure')
		Endtry
		
	ENDPROC

	PROCEDURE updateselectedcontrols
		*** JRN 03/17/2009 : use ASelObj to determine which objects, unless explicitly told to use the supplied object
		Lparameters toObject, tcPem, tuVal, tlOnlyOne
		
		Local Array laSelected[1]
		Local lnSelected, lnI
		
		With This
			If tlOnlyOne
				.Update1Property(toObject, tcPem, tuVal)
			Else
				lnSelected = Aselobj(laSelected)
				If lnSelected > 0
					For lnI = 1 To lnSelected
						.Update1Property(laSelected[lnI], tcPem, tuVal)
					Next lnI
				Else
					.Update1Property(toObject, tcPem, tuVal)
				Endif lnSelected > 0
			Endif
		Endwith
		
		If Used("csrMembers")
			Replace lNonDefault With .T. In csrMembers
			Thisform.Refresh()
		Endif
		
		Return
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basegrid AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: lsaveanchor_assign
		*m: setbmp
		*p: lsaveanchor
		*p: nanchor
		*p: nsavedanchor
	*</DefinedPropArrayMethod>

	AllowCellSelection = .F.
	ColumnCount = 0
	DeleteMark = .F.
	GridLines = 0
	lsaveanchor = .F.
	Name = "basegrid"
	nanchor = 0
	nsavedanchor = 0
	Panel = 1
	RecordMark = .F.
	SplitBar = .F.
	TabIndex = 1
	ZOrderSet = 0
	
	PROCEDURE Init
		* Setup grid highlighting.
		Local loColumn As Object
		Local lnI
		
		For lnI = 1 To This.ColumnCount
			loColumn = This.Columns(lnI)
			loColumn.AddProperty ("nWidth", loColumn.Width)
		Endfor
		
		With This
			.HighlightBackColor = Thisform.nHighlightBackColor
			.HighlightForeColor = Thisform.nHighlightForeColor
		
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If This.GridLines= 0
				.RowHeight  = .RowHeight - 1
			Endif
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		*** JRN 2010-03-26 : Changing FontSize (above) resizes all columns
		For lnI = 1 To This.ColumnCount
			loColumn = This.Columns(lnI)
			loColumn.Width = loColumn.nWidth
		Endfor
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			Case not PEME_IsVersion9()
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE setbmp
	ENDPROC

ENDDEFINE

DEFINE CLASS baseimage AS image 
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*p: nanchor
	*</DefinedPropArrayMethod>

	Height = 17
	Name = "baseimage"
	nanchor = 0
	Width = 100
	
	PROCEDURE Init
		If PEME_IsVersion9()
			This.Anchor = this.nAnchor 
		EndIf 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baselabel AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*p: nanchor
	*</DefinedPropArrayMethod>

	AutoSize = .T.
	BackStyle = 0
	Caption = "Label1"
	FontSize = 8
	Name = "baselabel"
	nanchor = 0
	
	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baselabelledbox AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpBox" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBox" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: height_assign
		*m: width_assign
		*p: builder		&& Specifies the builder for this object
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	builder = BaseLabelledBoxBuilder.PRG		&& Specifies the builder for this object
	Height = 133
	Name = "baselabelledbox"
	Style = 3
	Width = 168

	ADD OBJECT 'lblBox' AS baselabel WITH ;
		BackStyle = 1, ;
		Left = 10, ;
		Name = "lblBox", ;
		Style = 3
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'shpBox' AS baseline3d WITH ;
		Height = 124, ;
		Name = "shpBox", ;
		Top = 7, ;
		Width = 166
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="shape" />
	
	PROCEDURE height_assign
		* When the height of the container is resized, resize the shape.
		
		lparameters tnHeight
		This.Height = tnHeight
		This.shpBox.Height = tnHeight - This.shpBox.Top
		
	ENDPROC

	PROCEDURE width_assign
		* When the width of the container is resized, resize the shape.
		
		lparameters tnWidth
		store tnWidth to This.Width, This.shpBox.Width
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseline AS line 
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: nanchor
	*</DefinedPropArrayMethod>

	Height = 17
	Name = "baseline"
	nanchor = 0
	Width = 100
	
	PROCEDURE Init
		With This
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseline3d AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*p: nanchor
	*</DefinedPropArrayMethod>

	BackStyle = 0
	Height = 1
	Name = "baseline3d"
	nanchor = 0
	SpecialEffect = 0
	Style = 3
	Width = 100
	
	PROCEDURE Init
		If PEME_IsVersion9()
			This.Anchor = this.nAnchor 
		EndIf 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baselistbox AS listbox 
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*p: lupdatecontrolsourceonchange		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: nanchor
	*</DefinedPropArrayMethod>

	FontSize = 8
	IntegralHeight = .T.
	ItemTips = .T.
	lupdatecontrolsourceonchange = .F.		&& .T. if UpdateControlSource should be called from InteractiveChange
	Name = "baselistbox"
	nanchor = 0
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
			if .lUpdateControlSourceOnChange
				.UpdateControlSource()
			endif .lUpdateControlSourceOnChange
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			.UpdateControlSource()
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoletreeview AS olecontrol 
 	*< CLASSDATA: Baseclass="olecontrol" Timestamp="" Scale="Pixels" Uniqueid="" Nombre="baseoletreeview" Parent="" ObjName="baseoletreeview" OLEObject="C:\WINDOWS\system32\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBDiqQ3pcsBAwAAAEABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAagAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAIAAAD+/////v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAMDwKDYoIUM0EggAAABWCgAAVgoAALE8wWoBAAYAIgAAANwAbwDoAwAASABuAAElGwAB782rXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTFMAEwAAABEAEwATAAAADAAMwAzAFwARgBQAEUAWABUAC4ATQABAACAAABjAAAAYQBpAGwAYgBvAHgAIABtAGUAdABoAG8AZABzAC4AAAAtADQAMQAxAEwAQAAKAQADFQAAAxUAAAAFANAmGwAGAAAAAAAAAAUAAIBw6xIAAQAAAFwAH97svQEABQC06xIANQA0ADUAMwAyADUAMQAwAC0ANAAxADAAMwA4ADEAOQA1ADEAMAAtADMANwA1ADUANQA3ADcANQA2ADgALQAxADAAMAA1AF8AQwBsAGEAIABBAGUAcwF4AhUAeAIVAEkARABcAHsAMgA5AEEAQgA3AEEAMQAyAC0AQgA1ADMAMQAtADQANQAwAEUALQA4AEYANwBBAC0ARQBBADkANABDADIARgAzAEMAMAA1AEYAfQAAADEALQEYAhUAcE9AAxIAKQA1ADEBCAIVAAgCFQAwADMAOAAxAA==" />

	*<DefinedPropArrayMethod>
		*m: lsaveanchor_assign
		*p: lsaveanchor
		*p: nanchor
		*p: nmousebutton
		*p: nmouseshift
		*p: nsavedanchor
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Height = 100
	lsaveanchor = .F.
	Name = "baseoletreeview"
	nanchor = 0
	nmousebutton = 0
	nmouseshift = 0
	nsavedanchor = 0
	Width = 100
	_memberdata = <VFPData>
		<memberdata name="lsaveanchor_assign" display="lsaveanchor_Assign"/>
		<memberdata name="nmousebutton" display="nMouseButton"/>
		<memberdata name="nmouseshift" display="nMouseShift"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Init
		If PEME_IsVersion9()
			This.Anchor = this.nAnchor 
		EndIf 
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			Case not PEME_IsVersion9()
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE MouseDown
		*** ActiveX Control Event ***
		Lparameters tnButton, ;
			tnShift, ;
			tnX, ;
			tnY
		
		With This
			.nMouseButton = tnButton
			.nMouseShift = tnShift
		EndWith 
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoptionbutton AS optionbutton 
 	*< CLASSDATA: Baseclass="optionbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*p: nanchor
	*</DefinedPropArrayMethod>

	AutoSize = .T.
	BackStyle = 0
	Caption = "Option1"
	FontSize = 8
	Name = "baseoptionbutton"
	nanchor = 0
	
	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoptiongroup AS optiongroup 
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: enabled_assign
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*p: lupdatecontrolsourceonchange		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: nanchor
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderStyle = 0
	ButtonCount = 0
	Height = 46
	lupdatecontrolsourceonchange = .F.		&& .T. if UpdateControlSource should be called from InteractiveChange
	MemberClass = "baseoptionbutton"
	MemberClassLibrary = peme_basecontrols.vcx
	Name = "baseoptiongroup"
	nanchor = 0
	Value = 0
	Width = 71
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE enabled_assign
		lparameters tlEnabled
		This.Enabled = tlEnabled
		This.SetAll('Enabled', tlEnabled)
		
	ENDPROC

	PROCEDURE Init
		With This
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
			if .lUpdateControlSourceOnChange
				.UpdateControlSource()
			endif .lUpdateControlSourceOnChange
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			.UpdateControlSource()
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basepage AS page 
 	*< CLASSDATA: Baseclass="page" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*p: nhelpid
	*</DefinedPropArrayMethod>

	Caption = "Page1"
	FontSize = 8
	Height = 135
	Name = "basepage"
	nhelpid = 0
	Width = 135
	
	PROCEDURE Activate
		* Refresh all controls.
		
		Local llLockScreen
		With This
			Thisform.nHelpID = This.nHelpID
			llLockScreen = Thisform.LockScreen
			If Not llLockScreen
				Thisform.LockScreen = .T.
			Endif Not llLockScreen
		
			.FontBold = .T.
			.Refresh()
		
			If Not llLockScreen
				Thisform.LockScreen = .F.
			Endif Not llLockScreen
		Endwith
		
	ENDPROC

	PROCEDURE Deactivate
		With This
			.FontBold =.F.
		Endwith
		
	ENDPROC

	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
		Endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basepageframe AS pageframe 
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: activepage_assign
		*p: nanchor
	*</DefinedPropArrayMethod>

	ActivePage = 0
	ErasePage = .T.
	Height = 248
	MemberClass = "basepage"
	MemberClassLibrary = peme_basecontrols.vcx
	Name = "basepageframe"
	nanchor = 0
	PageCount = 0
	TabStyle = 1
	
	PROCEDURE activepage_assign
		lparameters tActivePage
		This.ActivePage = tActivePage
		
	ENDPROC

	PROCEDURE Init
		If PEME_IsVersion9()
			This.Anchor = this.nAnchor 
		EndIf 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseshape AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: lsaveanchor_assign
		*p: lsaveanchor
		*p: nanchor
		*p: nsavedanchor
	*</DefinedPropArrayMethod>

	BackStyle = 0
	Height = 17
	lsaveanchor = .F.
	Name = "baseshape"
	nanchor = 0
	nsavedanchor = 0
	Width = 100
	
	PROCEDURE Init
		If PEME_IsVersion9()
			This.Anchor = this.nAnchor 
		EndIf 
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			Case not PEME_IsVersion9()
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basespinner AS spinner 
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*p: nanchor
	*</DefinedPropArrayMethod>

	FontSize = 8
	Height = 22
	Name = "basespinner"
	nanchor = 0
	SelectOnEntry = .T.
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		do case
		
		* Spinners bound to object properties seem to have a problem when invalid
		* values are entered from the keyboard: the Error method fires with error 1469
		* (property value is out of bounds) with tcMethod being "ControlSource" rather
		* than the Valid method catching it.
		
			case tnError = 1469
				return
		
		* Ignore "property is read-only" errors.
		
			case tnError = 1743
				return
		
		* All other errors get passed on to the form.
		
			otherwise
				Thisform.Error(tnError, This.Name + '.' + tcMethod, tnLine)
		endcase
		
	ENDPROC

	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method, and restore the current cursor position in case
		* This.Refresh is called from AnyChange.
		
		local lnSelStart
		with This
			do case
				case not between(.Value, .SpinnerLowValue, .SpinnerHighValue)
					nodefault
				case not .lUpdateControlSourceOnChange
				case not .UpdateControlSource()
					nodefault
				otherwise
					lnSelStart = .SelStart
					.AnyChange()
					.SelStart = lnSelStart
			endcase
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method. Note: if the value is invalid, don't do anything.
		
		with This
			do case
				case not between(.Value, .SpinnerLowValue, .SpinnerHighValue)
					nodefault
				case not .UpdateControlSource()
					nodefault
				otherwise
					.AnyChange()
			endcase
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		local lnPos, ;
			luValue, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				luValue = iif(vartype(.Value) = 'C', trim(.Value), .Value)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with luValue in (lcAlias)
				else
					store luValue to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basetextbox AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& Custom validation code
		*p: conkeylabeldot
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: nanchor
	*</DefinedPropArrayMethod>

	conkeylabeldot = .F.
	FontSize = 8
	Format = "T"
	Height = 22
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	Name = "basetextbox"
	nanchor = 0
	SelectOnEntry = .T.
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE GotFocus
		Push Key
		On Key Label .
		On Key Label =
		
	ENDPROC

	PROCEDURE Init
		With This
			.FontName = ccFontSizeName
			.FontSize = ccFontSizeMedium
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), then
		* call the AnyChange method, and restore the current cursor position in case
		* This.Refresh got called from AnyChange.
		
		local lnSelStart
		with This
			do case
				case not .lUpdateControlSourceOnChange
				case not .UpdateControlSource()
					nodefault
				otherwise
					lnSelStart = .SelStart
					.AnyChange()
					.SelStart = lnSelStart
			endcase
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE LostFocus
		Pop Key
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			.UpdateControlSource()
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		local lnPos, ;
			luValue, ;
			lcAlias, ;
			lcField, ;
			llReturn
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				luValue = iif(vartype(.Value) = 'C', trim(.Value), .Value)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				try
					if used(lcAlias)
						replace (lcField) with luValue in (lcAlias)
					else
						store luValue to (.ControlSource)
					endif used(lcAlias)
					llReturn = .T.
				catch
				endtry
			endif lnPos > 0 ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE Valid
		* If we're not canceling, call the Validation method to do the actual
		* validation.
		
		local luReturn
		with This
			if lastkey() <> 27
				luReturn = .Validation()
			else
				luReturn = .T.
			endif lastkey() <> 27
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE validation		&& Custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Store the current value into the Tag property so it can be restored if Valid
		* fails.
		
		This.Tag = This.Value
		
	ENDPROC

ENDDEFINE
