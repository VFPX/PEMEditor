*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="editproperty.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS apirefreshtimer AS apitimer OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: resetinterval
		*p: iregularinterval
		*p: itraceinterval
	*</DefinedPropArrayMethod>

	iregularinterval = 1000
	itraceinterval = 15000
	Name = "apirefreshtimer"
	Width = 51
	
	PROCEDURE resetinterval
		If Wvisible(ccLOC_WINDOW_TRACE) Or  ;
				WVISIBLE(ccLOC_WINDOW_DEBUGGER) Or ;
				WVISIBLE(ccLOC_WINDOW_CALL_STACK) Or ;
				WVISIBLE(ccLOC_WINDOW_WATCH) Or ;
				WVISIBLE(ccLOC_WINDOW_LOCALS)
		
			If This.Interval # This.iTraceInterval
				This.iRegularInterval = This.Interval
				This.Interval = This.iTraceInterval
			Endif
		
		Else
		
			If This.Interval = This.iTraceInterval
				This.Interval = This.iRegularInterval
			Endif
			This.iRegularInterval = This.Interval
		
		Endif
		
		
	ENDPROC

	PROCEDURE timer
		This.ResetInterval()
	ENDPROC

ENDDEFINE

DEFINE CLASS apitimer AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: active_assign
		*m: cleartimer
		*m: enabled_assign
		*m: initializetimer
		*m: interval_assign
		*m: ontimerinterval
		*m: timer		&& Occurs when the number of milliseconds specified in the Interval property has elapsed.
		*p: active		&& -- Indicates that the timer is active
		*p: hwnd		&& -- Handle to Timer
		*p: interval		&& -- Interval of timer; value assigned in seconds and displayed in milliseconds; default is 30min
		*p: timerid		&& -- Numeric Timer ID
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED Destroy,Init
	active = .F.		&& -- Indicates that the timer is active
	AutoSize = .T.
	BackStyle = 0
	Caption = "apiTimer"
	Enabled = .T.
	Height = 17
	hwnd = 0		&& -- Handle to Timer
	interval = 180000		&& -- Interval of timer; value assigned in seconds and displayed in milliseconds; default is 30min
	Name = "apitimer"
	timerid = 0		&& -- Numeric Timer ID
	Visible = .F.
	Width = 51
	_memberdata = <VFPData>
		<memberdata name="active" display="Active"/>
		<memberdata name="active_assign" display="Active_Assign"/>
		<memberdata name="timerid" display="TimerID"/>
		<memberdata name="cleartimer" display="ClearTimer"/>
		<memberdata name="initializetimer" display="InitializeTimer"/>
		<memberdata name="interval_assign" display="Interval_Assign"/>
		<memberdata name="ontimerinterval" display="OnTimerInterval"/>
		<memberdata name="timer" display="Timer"/>
		<memberdata name="enabled" display="Enabled"/>
		<memberdata name="enabled_assign" display="Enabled_Assign"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE active_assign
		LPARAMETERS tlActive
		If this.Active = tlActive
		Return
		EndIf
		
		this.Active = tlActive
		IF tlActive
			this.InitializeTimer()
		ELSE
			this.ClearTimer()
		ENDIF
	ENDPROC

	PROCEDURE cleartimer
		*-- Clears the timer function
		Declare Long KillTimer In User32 As apiKillTimer Long nhWnd, Long nIDEvent
		apiKillTimer(This.HWnd, This.TimerID)
		If Pemstatus(Thisform, 'apiTimerCount', 5)
			Thisform.apiTimerCount = Thisform.apiTimerCount - 1
			If Thisform.apiTimerCount = 0
				Unbindevents(This.HWnd)
			Endif
		Endif
	ENDPROC

	PROTECTED PROCEDURE Destroy
		This.ClearTimer()
	ENDPROC

	PROCEDURE enabled_assign
		Lparameters tEnabled
		This.Enabled = tEnabled
		This.Active	 = tEnabled
	ENDPROC

	PROTECTED PROCEDURE Init
		This.HWnd = Thisform.HWnd
		If Empty(This.TimerID)
			This.TimerID = This.HWnd
		Endif
		
	ENDPROC

	PROCEDURE initializetimer
		#Define WM_TIMER                        0x0113
		
		*-- Initializes the timer
		Local lnTimerID
		If Not Pemstatus(Thisform, 'apiTimerCount', 5)
			AddProperty(Thisform, 'apiTimerCount', 0)
		Endif
		
		If This.Active
			Thisform.apiTimerCount = Thisform.apiTimerCount + 1
			Bindevent(This.HWnd, WM_TIMER, This, 'OnTimerInterval')
		
			Declare Long SetTimer In User32 As apiSetTimer Long nhWnd, Long nIDEvent, Long uElapse, Long pTimerFunc
			lnTimerID = This.TimerID
			apiSetTimer(This.HWnd, lnTimerID, This.Interval, 0)
		Endif
	ENDPROC

	PROCEDURE interval_assign
		Lparameters tnInterval
		
		#Define USER_TIMER_MINIMUM      10
		#Define USER_TIMER_MAXIMUM      0x7FFFFFFF
		
		If tnInterval = 0
			This.Interval = 0
			This.Active	  = .F.
			Return
		Endif
		
		Do Case
			Case tnInterval < USER_TIMER_MINIMUM
				This.Interval = USER_TIMER_MINIMUM
		
			Case tnInterval > USER_TIMER_MAXIMUM
				This.Interval = USER_TIMER_MAXIMUM
		
			Otherwise
				This.Interval = tnInterval
		Endcase
		
		If This.Enabled
			This.Active	= .F.
			This.Active	= .T.
		Endif
		
	ENDPROC

	PROCEDURE ontimerinterval
		*-- Occurs when the Timer interval completes
		Lparameters thWnd, tnMsg, tnTimerID, tlParam
		If This.HWnd = thWnd .And. This.TimerID = tnTimerID
			This.Timer()
		Endif
		Return 0
	ENDPROC

	PROCEDURE Refresh
		If This.Enabled And Not This.Active and This.Interval > 0
			This.Active = .T.
		Endif
		
	ENDPROC

	PROCEDURE timer		&& Occurs when the number of milliseconds specified in the Interval property has elapsed.
		*
	ENDPROC

ENDDEFINE

DEFINE CLASS askaddpem AS baseform OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblTitle" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddasProperty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddasMethod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddasMethod2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baseline1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.edtDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblnnn255" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNewName" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: return
		*p: cdescription
		*p: cnewname
		*p: cvalue
		*p: laskaddpem
		*p: nresult
		*p: oprefs
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BindControls = .F.
	BorderStyle = 2
	Caption = "Add New PEM?"
	cdescription = 
	cfoxuserid = AddNew2
	cfoxusername = AddNew2
	cnewname = 
	cvalue = 
	DoCreate = .T.
	Height = 130
	laskaddpem = .F.
	MinHeight = 130
	Name = "askaddpem"
	nresult = 0
	oprefs = .F.
	Visible = .T.
	Width = 246
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="cdescription" display="cDescription"/>
		<memberdata name="laskaddpem" display="lAskAddPEM"/>
		<memberdata name="cvalue" display="cValue"/>
		</VFPData>		&& XML Metadata for customizable properties
	changefontsize.Left = 208
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 14

	ADD OBJECT 'Baseline1' AS baseline WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "Baseline1", ;
		nanchor = 10, ;
		Top = 64, ;
		Width = 286
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="line" />

	ADD OBJECT 'cmdAddasMethod' AS cmdaddnewpem WITH ;
		AutoSize = .T., ;
		Caption = "Add \<Method", ;
		Left = 71, ;
		Name = "cmdAddasMethod", ;
		nresult = 2, ;
		TabIndex = 3, ;
		Top = 36
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdAddasMethod2' AS cmdaddnewpem WITH ;
		AutoSize = .T., ;
		Caption = "Add/\<Edit Method", ;
		Left = 147, ;
		Name = "cmdAddasMethod2", ;
		nresult = 3, ;
		TabIndex = 4, ;
		Top = 36
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdAddasProperty' AS cmdaddnewpem WITH ;
		AutoSize = .T., ;
		Caption = "Add \<Prop.", ;
		Height = 25, ;
		Left = 6, ;
		Name = "cmdAddasProperty", ;
		nresult = 1, ;
		TabIndex = 2, ;
		Top = 36, ;
		Width = 64
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntDescription' AS basecontainer WITH ;
		Height = 57, ;
		Left = 12, ;
		Name = "cntDescription", ;
		nanchor = 15, ;
		TabIndex = 6, ;
		Top = 68, ;
		Width = 222, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntDescription.edtDescription' AS editpropertyeditbox WITH ;
		Height = 36, ;
		IntegralHeight = .F., ;
		Left = 0, ;
		Name = "edtDescription", ;
		nanchor = 15, ;
		SelectOnEntry = .F., ;
		TabIndex = 14, ;
		Top = 16, ;
		Width = 222, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="editbox" />

	ADD OBJECT 'cntDescription.lblDescription' AS baselabel WITH ;
		Caption = "Description", ;
		Left = 3, ;
		Name = "lblDescription", ;
		TabIndex = 13, ;
		Top = 1, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntDescription.lblnnn255' AS baselabel WITH ;
		Caption = "0/254", ;
		Height = 16, ;
		Left = 165, ;
		Name = "lblnnn255", ;
		TabIndex = 13, ;
		Top = 1, ;
		Width = 29, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblTitle' AS baselabel WITH ;
		Alignment = 1, ;
		AutoSize = .F., ;
		Caption = "Name:", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 10, ;
		Name = "lblTitle", ;
		TabIndex = 7, ;
		Top = 15, ;
		Width = 36
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'txtNewName' AS basetextbox WITH ;
		ControlSource = "Thisform.cNewName", ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		Height = 22, ;
		Left = 49, ;
		Name = "txtNewName", ;
		nanchor = 10, ;
		TabIndex = 1, ;
		Top = 11, ;
		Width = 183
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		Lparameters loPrefs, lcNewName
		
		Local lnChg, lnCurWidth
		
		*!* * Removed 5/6/2012 
		*!* This.MinHeight = This.Height
		This.MinWidth = This.Width
		
		DoDefault()
		
		With This
			.oPrefs = loPrefs
			.cNewName = lcNewName 
			.BindControls = .T.
			.Refresh()
		Endwith
	ENDPROC

	PROCEDURE KeyPress
		*** DougHennig 11/03/2008: set KeyPreview to .T. and added this code to close on Esc
		Lparameters tnKeyCode, ;
			tnShiftAltCtrl
		
		Do Case
				*** Esc closes form
			Case tnKeyCode = 27
				Thisform.Release()
		
		Endcase
		
	ENDPROC

	PROCEDURE return
		Lparameters lnResult
		
		This.nResult = lnResult
		This.Release
		
	ENDPROC

	PROCEDURE Unload
		Local loResult AS 'Empty'
		
		DoDefault()
		
		If This.nResult = 0 Or Empty(This.cDescription)
			Return This.nResult
		Else
			loResult = Createobject('Empty')
			AddProperty(loResult, 'Value', This.nResult)
			AddProperty(loResult, 'Description', This.cDescription)
			Return loResult
		Endif
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.InteractiveChange
		Thisform.cDescription = This.Value
		This.Parent.lblnnn255.Refresh()
		DoDefault()
	ENDPROC

	PROCEDURE cntDescription.edtDescription.KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = 13
			nodefault
		else
			dodefault(tnKeyCode, tnShiftAltCtrl)
		endif
		
	ENDPROC

	PROCEDURE cntDescription.lblDescription.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_DESCRIPTION
		
	ENDPROC

	PROCEDURE cntDescription.lblnnn255.Refresh
		Local lnLength
		With This
			lnLength = Len (Thisform.cDescription)
			.Caption = Transform (lnLength) + [/ccMaxDescriptionLength]
			.Visible = lnLength >= 128
			.FontBold = lnLength >= 200
			.ForeColor = Iif(lnLength <= ccMaxDescriptionLength, Rgb(0,0,0), Rgb(255,0,0))
		Endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS askaddpemnew AS baseform OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblTitle" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddasProperty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddasMethod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddasMethod2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNewName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baseline1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.edtDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblnnn255" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Check2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmdaddnewpem1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addtockl
		*m: cleanup
		*m: getthoroption
		*m: newmethod
		*m: newproperty
		*m: return
		*p: cdescription
		*p: cmethodtext
		*p: cnewname
		*p: cpemtype
		*p: cvalue
		*p: laccess
		*p: laskaddpem
		*p: lassign
		*p: lrefreshgrid
		*p: lreturnvalue
		*p: lstayopen
		*p: nresult
		*p: oprefs
		*p: otopofform
		*p: otopoffrom
		*p: outils
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BindControls = .F.
	BorderStyle = 3
	Caption = "Add New PEM?"
	cdescription = 
	cfoxuserid = AddNew2
	cfoxusername = AddNew2
	cmethodtext = 
	cnewname = 
	cpemtype = 
	cvalue = 
	Desktop = .T.
	DoCreate = .T.
	Height = 215
	laccess = .F.
	laskaddpem = .T.
	lassign = .F.
	lrefreshgrid = .F.
	lreturnvalue = .F.
	lstayopen = .F.
	MaxHeight = 350
	MaxWidth = 350
	MinHeight = 215
	MinWidth = 246
	Name = "askaddpemnew"
	nresult = 0
	oprefs = .F.
	otopofform = .F.
	otopoffrom = .NULL.
	outils = .NULL.
	Width = 246
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="cdescription" display="cDescription"/>
		<memberdata name="cvalue" display="cValue"/>
		<memberdata name="laskaddpem" display="lAskAddPEM"/>
		<memberdata name="outils" display="oUtils"/>
		<memberdata name="otopoffrom" display="oTopOfFrom"/>
		<memberdata name="lreturnvalue" display="lReturnValue"/>
		<memberdata name="cleanup" display="Cleanup"/>
		<memberdata name="lrefreshgrid" display="lRefreshGrid"/>
		<memberdata name="lstayopen" display="lStayOpen"/>
		<memberdata name="laccess" display="lAccess"/>
		<memberdata name="lassign" display="lAssign"/>
		<memberdata name="cpemtype" display="cPEMType"/>
		<memberdata name="cmethodtext" display="cMethodText"/>
		<memberdata name="minwidth" display="MinWidth"/>
		<memberdata name="addtockl" display="AddtoCKL"/>
		</VFPData>		&& XML Metadata for customizable properties
	changefontsize.Left = 200
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 24

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		Alignment = 1, ;
		AutoSize = .F., ;
		Caption = "\<Value:", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 12, ;
		Name = "Baselabel1", ;
		TabIndex = 10, ;
		Top = 32, ;
		Width = 36
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Baseline1' AS baseline WITH ;
		Anchor = 14, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Baseline1", ;
		nanchor = 14, ;
		Top = 181, ;
		Width = 286
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="line" />

	ADD OBJECT 'Check1' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 4, ;
		Caption = "A\<ccess", ;
		ControlSource = "Thisform.lAccess", ;
		Height = 17, ;
		Left = 13, ;
		Name = "Check1", ;
		TabIndex = 7, ;
		Top = 158, ;
		Width = 60
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'Check2' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 4, ;
		Caption = "A\<ssign", ;
		ControlSource = "Thisform.lAssign", ;
		Height = 17, ;
		Left = 83, ;
		Name = "Check2", ;
		TabIndex = 8, ;
		Top = 158, ;
		Width = 60
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdAddasMethod' AS cmdaddnewpem WITH ;
		Anchor = 4, ;
		AutoSize = .T., ;
		Caption = "Add \<Method", ;
		Left = 71, ;
		Name = "cmdAddasMethod", ;
		nanchor = 4, ;
		nresult = 2, ;
		TabIndex = 3, ;
		Top = 185
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdAddasMethod2' AS cmdaddnewpem WITH ;
		Anchor = 4, ;
		AutoSize = .T., ;
		Caption = "Add/\<Edit Method", ;
		Left = 147, ;
		Name = "cmdAddasMethod2", ;
		nanchor = 4, ;
		nresult = 3, ;
		TabIndex = 2, ;
		Top = 185
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdAddasProperty' AS cmdaddnewpem WITH ;
		Anchor = 4, ;
		AutoSize = .T., ;
		Caption = "Add \<Prop.", ;
		Default = .T., ;
		Height = 25, ;
		Left = 6, ;
		Name = "cmdAddasProperty", ;
		nanchor = 4, ;
		nresult = 1, ;
		TabIndex = 1, ;
		Top = 185, ;
		Width = 64
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cmdaddnewpem1' AS cmdaddnewpem WITH ;
		Anchor = 4, ;
		AutoSize = .T., ;
		Caption = "Do \<Not Add", ;
		Left = 170, ;
		Name = "Cmdaddnewpem1", ;
		nanchor = 4, ;
		nresult = 3, ;
		TabIndex = 2, ;
		Top = 155
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntDescription' AS basecontainer WITH ;
		Anchor = 15, ;
		Height = 69, ;
		Left = 12, ;
		Name = "cntDescription", ;
		nanchor = 15, ;
		TabIndex = 6, ;
		Top = 87, ;
		Width = 222, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntDescription.edtDescription' AS editpropertyeditbox WITH ;
		Anchor = 15, ;
		Height = 50, ;
		IntegralHeight = .F., ;
		Left = 0, ;
		Name = "edtDescription", ;
		nanchor = 15, ;
		SelectOnEntry = .F., ;
		TabIndex = 14, ;
		Top = 16, ;
		Width = 222, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="editbox" />

	ADD OBJECT 'cntDescription.lblDescription' AS baselabel WITH ;
		Caption = "\<Description", ;
		Left = 3, ;
		Name = "lblDescription", ;
		TabIndex = 13, ;
		Top = 1, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntDescription.lblnnn255' AS baselabel WITH ;
		Caption = "0/254", ;
		Height = 16, ;
		Left = 165, ;
		Name = "lblnnn255", ;
		TabIndex = 13, ;
		Top = 1, ;
		Width = 29, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblTitle' AS baselabel WITH ;
		Alignment = 1, ;
		AutoSize = .F., ;
		Caption = "\<Name:", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 10, ;
		Name = "lblTitle", ;
		TabIndex = 9, ;
		Top = 12, ;
		Width = 36
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'txtNewName' AS basetextbox WITH ;
		Anchor = 10, ;
		ControlSource = "Thisform.cNewName", ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		Height = 22, ;
		Left = 49, ;
		Name = "txtNewName", ;
		nanchor = 10, ;
		TabIndex = 4, ;
		Top = 8, ;
		Width = 185
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtValue' AS basetextbox WITH ;
		Anchor = 10, ;
		ControlSource = "Thisform.cValue", ;
		DisabledForeColor = 0,0,0, ;
		Height = 36, ;
		Left = 12, ;
		Name = "txtValue", ;
		nanchor = 10, ;
		TabIndex = 5, ;
		Top = 47, ;
		Width = 222
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		This.oTopOfForm	= This.oUtils.FindTopMostParent()
		This.Refresh()
		
	ENDPROC

	PROCEDURE addtockl
	ENDPROC

	PROCEDURE cleanup
		Lparameters lcName
		
		Local llAddtoCKL, llAutoAddtoCKL, loAddWordstoCKL, loPEMEditor
		
		If Thisform.lRefreshGrid
			loPEMEditor = This.oUtils.oPEMEditor
			If Not Isnull(m.loPEMEditor)
				m.loPEMEditor.RefreshGrid()
				*!* * Removed 2/18/2013 / JRN
				*!* loPEMEditor.SetCurrentObjectProperty (This.otopofform, lcName)
			Endif
		Endif
		
		If Thisform.lStayOpen
			Thisform.cnewname							 = ''
			Thisform.cValue								 = ''
			Thisform.cntDescription.edtDescription.Value = ''
		
			Thisform.lAccess = .F.
			Thisform.lAssign = .F.
		
			Thisform.Refresh()
			Thisform.txtNewName.SetFocus()
		
		Else
			This.lReturnValue = .T.
			This.Release()
		Endif
		
		
	ENDPROC

	PROCEDURE getthoroption
		Lparameters lcThorKey, lcThorTool, lxDefaultValue
		Return Nvl(Execscript (_Screen.cThorDispatcher, 'Get Option=', lcThorKey, lcThorTool), lxDefaultValue)
	ENDPROC

	PROCEDURE Init
		Lparameters lcNewName, llRefreshGrid, lcPEMType, llStayOpen, lcMethodText
		
		This.MinWidth = This.Width
		
		Execscript(_Screen.cThorDispatcher, 'PEMEditor_StartIDETools')
		This.oUtils		= _oPEMEditor.oUtils
		This.oTopOfForm	= This.oUtils.FindTopMostParent()
		
		Do Case
			Case Empty(lcNewName)
				lcNewName = ''
			Case 'P' $ Evl(lcPEMType, 'PM')
				This.cValue	= Transform(This.oUtils.GetDefaultValue(lcNewName))
		Endcase
		
		DoDefault()
		
		With This
		
			.cNewName	  = lcNewName
			.lStayOpen	  = llStayOpen
			.cPEMType	  = Evl(lcPEMType, 'PM')
			.lRefreshGrid = llRefreshGrid
			.cMethodText  = Evl(lcMethodText, '')
		
			Do Case
				Case Not 'P' $ .cPEMType
					.Caption = 'Add new method?'
				Case Not 'M' $ .cPEMType
					.Caption = 'Add new property?'
			Endcase
		
			.BindControls  = .T.
			.Refresh()
		Endwith
		
	ENDPROC

	PROCEDURE KeyPress
		*** DougHennig 11/03/2008: set KeyPreview to .T. and added this code to close on Esc
		Lparameters tnKeyCode, ;
			tnShiftAltCtrl
		
		Do Case
				*** Esc closes form
			Case tnKeyCode = 27
				Thisform.Release()
		
		Endcase
		
	ENDPROC

	PROCEDURE newmethod
		Lparameters llEditMethod
		
		Local lcDescription, lcNewName, lcType, lxValue
		
		lcNewName	  = Alltrim(Thisform.cNewname)
		lcDescription = Thisform.cDescription
		lcType		  = 'M'
		
		If This.oUtils.CreateNewPEM (lcType, lcNewName, This.cMethodText, This.oTopOfForm, lcDescription)
			If llEditMethod
				This.oUtils.EditLocalMethodCode (This.oUtils.cSourceFileName, This.oTopOfForm, This.oTopOfForm, lcNewName, This.oUtils.lClass)
			Endif
		Endif
		
		If llEditMethod
			Thisform.Cleanup('')
		Else
			Thisform.Cleanup(lcNewName)
		Endif
	ENDPROC

	PROCEDURE newproperty
		Local lcAccessCode, lcAccessName, lcAssignCode, lcAssignName, lcDescription, lcNewName, lcType
		Local lxValue
		
		lcNewName	  = Alltrim(Thisform.cNewname)
		lcDescription = Thisform.cDescription
		lcType		  =  'P'
		
		lxValue	= This.oUtils.Str2Val(This.cValue)
		
		If This.oUtils.CreateNewPEM (lcType, lcNewName, lxValue, This.oTopOfForm, lcDescription)
			If Thisform.lAccess
				lcAccessCode = This.oUtils.GetAccessMethodCode(lcNewName, 'ACCESS')
				lcAccessName = This.oUtils.JustPEM(lcNewName) + '_Access'
				This.oUtils.CreateNewPEM ('M', lcAccessName, lcAccessCode, This.oTopOfForm, '')
			Endif
			If Thisform.lAssign
				lcAssignCode = This.oUtils.GetAccessMethodCode(lcNewName, 'ASSIGN')
				lcAssignName = This.oUtils.JustPEM(lcNewName) + '_Assign'
				This.oUtils.CreateNewPEM ('M', lcAssignName, lcAssignCode, This.oTopOfForm, '')
			Endif
		Endif
		
		Thisform.Cleanup(lcNewName)
		
	ENDPROC

	PROCEDURE return
	ENDPROC

	PROCEDURE Unload
		Return This.lReturnValue 
		
	ENDPROC

	PROCEDURE Check1.Refresh
		This.Enabled = 'P' $ Thisform.cPEMType and not IsNull(Thisform.otopofform)
		
	ENDPROC

	PROCEDURE Check2.Refresh
		This.Enabled = 'P' $ Thisform.cPEMType and not IsNull(Thisform.otopofform)
		
	ENDPROC

	PROCEDURE cmdAddasMethod.Click
		Thisform.NewMethod(.F.)
	ENDPROC

	PROCEDURE cmdAddasMethod.Refresh
		This.Enabled = ('M' $ Thisform.cPEMType) and not IsNull(Thisform.otopofform)
		
	ENDPROC

	PROCEDURE cmdAddasMethod2.Click
		Thisform.NewMethod(.T.)
	ENDPROC

	PROCEDURE cmdAddasMethod2.Refresh
		This.Enabled = ('M' $ Thisform.cPEMType) and not IsNull(Thisform.otopofform)
		
	ENDPROC

	PROCEDURE cmdAddasProperty.Click
		Thisform.NewProperty()
	ENDPROC

	PROCEDURE cmdAddasProperty.Refresh
		This.Enabled = ('P' $ Thisform.cPEMType) and not IsNull(Thisform.otopofform)
		
	ENDPROC

	PROCEDURE Cmdaddnewpem1.Click
		Thisform.lReturnValue = .T.
		Thisform.Release()
		
	ENDPROC

	PROCEDURE Cmdaddnewpem1.Refresh
		This.Visible = Not Thisform.lStayOpen
	ENDPROC

	PROCEDURE cntDescription.edtDescription.InteractiveChange
		Thisform.cDescription = This.Value
		This.Parent.lblnnn255.Refresh()
		DoDefault()
	ENDPROC

	PROCEDURE cntDescription.edtDescription.KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = 13
			nodefault
		else
			dodefault(tnKeyCode, tnShiftAltCtrl)
		endif
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.Refresh
		This.Enabled = not IsNull(Thisform.otopofform)
		
	ENDPROC

	PROCEDURE cntDescription.lblDescription.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_DESCRIPTION
		
	ENDPROC

	PROCEDURE cntDescription.lblnnn255.Refresh
		Local lnLength
		With This
			lnLength = Len (Thisform.cDescription)
			.Caption = Transform (lnLength) + [/ccMaxDescriptionLength]
			.Visible = lnLength >= 128
			.FontBold = lnLength >= 200
			.ForeColor = Iif(lnLength <= ccMaxDescriptionLength, Rgb(0,0,0), Rgb(255,0,0))
		Endwith
		
	ENDPROC

	PROCEDURE txtNewName.Refresh
		*!* ******************** Removed 10/13/2013 ********************
		*!* This.Enabled = Thisform.lStayOpen and not IsNull(Thisform.otopofform)
		This.Enabled = not IsNull(Thisform.otopofform)
		*!* ******************** End of duplicated text ********************
		
		
	ENDPROC

	PROCEDURE txtNewName.Valid
		Thisform.cValue	= Transform(Thisform.oUtils.GetDefaultValue (This.Value))
		thisform.txtvalue.Refresh()
		
	ENDPROC

	PROCEDURE txtValue.Refresh
		This.Enabled = 'P' $ Thisform.cPEMType and not IsNull(Thisform.otopofform)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS askaddpemnewstayopen AS askaddpemnew OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	cfoxuserid = AddNew40
	cfoxusername = AddNew40
	Desktop = .F.
	DoCreate = .T.
	Name = "askaddpemnewstayopen"
	WindowType = 0
	changefontsize.Name = "changefontsize"
	lblTitle.Name = "lblTitle"
	cmdAddasProperty.Name = "cmdAddasProperty"
	cmdAddasMethod.Name = "cmdAddasMethod"
	cmdAddasMethod2.Name = "cmdAddasMethod2"
	txtNewName.Name = "txtNewName"
	Baseline1.Name = "Baseline1"
	Baselabel1.Name = "Baselabel1"
	txtValue.Name = "txtValue"
	cntDescription.edtDescription.Name = "edtDescription"
	cntDescription.lblDescription.Name = "lblDescription"
	cntDescription.lblnnn255.Name = "lblnnn255"
	cntDescription.Name = "cntDescription"

ENDDEFINE

DEFINE CLASS basegridmembers AS basegrid OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: colorpicker
		*m: dopepropertyeditors
		*m: editoneproperty
		*m: editpem
		*m: getcurrentobject
		*m: getexpr
		*m: getfile
		*m: handlemouseup
		*m: handlerightclick
		*m: headerrightclick
		*m: intrinsicpropertyeditors
		*m: iscustomfunctioncall
		*m: listzoom
		*m: memberdatastats
		*m: nativepropertyhandler
		*m: oldstylepropertyhandler
		*m: pluginprg
		*m: refreshcontrols
		*m: setcolumnheadings
		*m: setfont
		*m: toggleeditor
		*m: zoom
		*p: lfirsttime
		*p: ncurrentrecno
	*</DefinedPropArrayMethod>

	Height = 276
	HighlightStyle = 2
	lfirsttime = .T.
	Name = "basegridmembers"
	nanchor = 15
	ncurrentrecno = 0
	RecordSource = "csrMembers"
	RecordSourceType = 1
	RowHeight = 18
	TabIndex = 1
	Width = 873
	ZOrderSet = 0
	
	PROCEDURE colorpicker
		Lparameters lcPEM, lcAssignPem, loValue
		
		Local Array laMembers[1]
		Local loObject, lnColor, lnNewColor, lnRow, lnVisibility, lcDescrip, luVal
		
		lnColor = IIF (loValue.SingleValue, loValue.Value, 0)
		
		lnNewColor = Getcolor(lnColor)
		If lnNewColor < 0
			Return
		Endif lnNewColor < 0
		
		Thisform.AssignSelectedControls(lcAssignPem, lnNewColor)
		*!*	If Not Thisform.lEditingOneProperty
		*!*		Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, lnNewColor, Thisform.nSelectedObjects <= 1)
		*!*	Else
		*!*		Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPem, lnNewColor, .T.)
		*!*	Endif
		
	ENDPROC

	PROCEDURE dopepropertyeditors
		Lparameters lcPem, lcAssignPem, loValue, tcDescript
		
		Local laValues(1), lnI, lcPath, lbFound, lbChanged, lnColor, lxResult
		Local lnPos, lnCount, lnMin, lnMax, lnInterval, lnValue, lcLine, lcExec, lcSourcePem
		Local lcSourceExec, lcMethod, lcParams, lcMethodCode, lcMethodName, loObject, loCodeObject, laDescription(1)
		* following made private so it is available for later used within ExecuteMethod
		Private luValue
		
		Thisform.lDontDisableMe = .T.
		
		Do Case
		
			Case This.IsCustomFunctionCall(tcDescript)
				lcExec = 'lxResult = ' + ThisForm.GetDOPEText (tcDescript, '=')
				luValue = loValue.Value
				Try
					&lcExec
					lbFound = .T.
					lbChanged = 'O' # Vartype(lxResult)
				Catch to loException
					Thisform.ShowErrorMsg (loException)
					lbChanged = .T.
					lxResult  = luValue
				Endtry
		
			Case Not Empty (ThisForm.GetDOPEText (tcDescript, '&'))
				lcSourceExec = ThisForm.GetDOPEText (tcDescript, '&')
				loObject = Thisform.oObject
				luValue = loValue.Value
				&lcSourceExec
				lbChanged = .T.
		
			Case Not Empty (ThisForm.GetDOPEText (tcDescript, '.'))
				lcSourceExec = ThisForm.GetDOPEText (tcDescript, '.')
				lnPos = At ("(", lcSourceExec)
				lcMethod = Alltrim(Left (lcSourceExec, lnPos - 1))
				lcParams = Alltrim(Substr (lcSourceExec, lnPos))
		
				Do Case
					Case Not '.' $ lcMethod
						lcMethodName = lcMethod
						loCodeObject = Thisform.oObject
					Case Lower(lcMethod) = 'thisform.'
						lcMethodName = Justext (lcMethod)
						lcPath = Substr (Juststem (lcMethod), 9)
						loCodeObject = Thisform.oTopOfForm&lcPath.
					Otherwise
						lcMethodName = Justext (lcMethod)
						lcPath = Juststem (lcMethod)
						loCodeObject = Thisform.oObject.&lcPath.
				Endcase
				****************************************************************
				luValue = loValue.Value
				If Thisform.GetPEMStatus (loCodeObject, lcMethodName, 5)
					lcMethodCode = Thisform.GetParentCode(lcMethodName, "First Code", loCodeObject)
				Else
					lcMethodCode = ''
				EndIf
				
				lbFound = .T.
				If Not Empty (lcMethodCode)
					If Thisform.oPrefs.lDebugMode
						lxResult = Thisform.ExecuteMethod(Thisform.oObject, lcMethodName, lcParams, loCodeObject)
						lbChanged = 'O' # Vartype(lxResult)
					Else
						Try
							lxResult = Thisform.ExecuteMethod(Thisform.oObject, lcMethodName, lcParams, loCodeObject)
							lbChanged = 'O' # Vartype(lxResult)
						Catch To loException
							Thisform.ShowErrorMsg (loException)
							lbFound = .T.
							lbChanged = .F.
						Endtry
					Endif
				Else
					lcChange = .T.
				Endif
		
			Case Thisform.GetCustomComboValues (@laValues, lcPem, tcDescript)
				lbFound = .T.
				lcPath = Justpath (Thisform.ClassLibrary)
				Do Form lcPath + '\ListZoomDialog' 				;
					With lcPem, laValues, loValue.Value			;
					, Thisform.nFontSize, tcDescript			;
					To lxResult
		
				lbChanged = 'L' # Vartype(lxResult)
		
			Case Thisform.IsCustomColor(tcDescript)
				lbFound = .T.
				lnColor = Iif (loValue.SingleValue, loValue.Value, 0)
				If 'N' # Vartype (lnColor)
					Try
						lnColor = Rgb(&lnColor)
					Catch
						lnColor = 0
					Endtry
				Endif
		
				lxResult= Getcolor(lnColor)
				lbChanged = lxResult >= 0
		
			Case Thisform.IsCustomSpinner(tcDescript)
				****************************************************************
				lcExec = ThisForm.GetDOPEText (tcDescript, 'Spinner')
				Alines (laValues, Strtran (lcExec, '\n', ',', 1, 999, 1), .T., " ", ",")
				lnCount = 0
				lnMin = 0
				lnMax = 100
				lnInterval = 1
				For Each lcLine In laValues
					If ThisForm.oUtils.IsNumber (lcLine)
						lnValue = Val (lcLine)
						lnCount = lnCount + 1
						Do Case
							Case lnCount = 1
								lnMin = lnValue
							Case lnCount = 2
								lnMax = lnValue
							Case lnCount = 3
								lnInterval = lnValue
						Endcase
					Endif
				Endfor
		
				****************************************************************
				lbFound = .T.
				lcPath = Justpath (Thisform.ClassLibrary)
				lnValue = loValue.Value
				Do Case
					Case 'N' # Vartype (lnValue)
						lnValue = lnMin
					Case lnValue < lnMin
						lnValue = lnMin
					Case lnValue > lnMax
						lnValue = lnMax
				Endcase
				Do Form lcPath + '\SpinnerZoomDialog' 				;
					With lcPem, lnValue, lnMin, lnMax, lnInterval 	;
					, Thisform.nFontSize, tcDescript				;
					To lxResult
		
				lbChanged = "N" = Vartype(lxResult)
		
		
		Endcase
		
		If lbChanged
			Thisform.AssignSelectedControls(lcAssignPem, lxResult)
			*!*		If Not Thisform.lEditingOneProperty
			*!*			Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, lxResult, Thisform.nSelectedObjects <= 1)
			*!*		Else
			*!*			Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPem, lxResult, .T.)
			*!*		Endif
		
			This.RefreshControls()
		Endif
		
		Thisform.lDontDisableMe = .F.
		
		Return lbFound
		
	ENDPROC

	PROCEDURE editoneproperty
		Local lcPem
		
		lcPem = Thisform.JustPem(cName)
		Thisform.lEditingOneProperty = .T.
		Thisform.cEditPropertyName = lcPem
		Select * From csrMultMembers 			;
			where Lower(cName) = Lower (lcPem)	;
			into Cursor csrMults Readwrite
		Replace All cName With cObjName
		
		Thisform.ZapMembersCursor()
		
		Append From (Dbf("csrMults"))
		Thisform.SetFilter()
		Locate
		This.SetColumnHeadings()
		This.Refresh()
		
	ENDPROC

	PROCEDURE editpem
		Local lcPem, lcExpression, loValue
		lcPem = Trim (cName)
		
		If Empty(lcPem)
			Return
		Endif
		
		If Not Thisform.lEditingOneProperty
			lcPem = Thisform.JustPem(cName)
		Else
			lcPem = Trim(Thisform.cEditPropertyName)
		Endif
		
		loValue = Thisform.GetValue (lcPem, lNative, 'For Editing', Thisform.nObjNumber)
		
		Do Case
		
			Case Thisform.oMember.cType $ 'ME'
				If Thisform.lEditingOneProperty
					Thisform.EditMethodCode(lcPem, ThisForm.GetCurrentObject(ThisForm.nObjNumber))
				Else
					Thisform.EditMethodCode()
				Endif
		
			Case '[' $ lcPem Or '(' $ lcPem && Array
		
				****************************************************************
				* Cases where there is nothing to do, either not a property or is read only
		
			Case Thisform.nSelectedObjects = 1 And Thisform.oMember.lReadOnly
		
				****************************************************************
				* Various varieties of editors; order is important
		
			Case This.DOPEPropertyEditors (lcPem, lcPem, loValue, cDescript)
		
			Case This.PlugInPrg(lcPem, lcPem, loValue)
		
			Case This.IntrinsicPropertyEditors(lcPem, lcPem, loValue) && toggle and anchor editors
		
			Case This.NativePropertyHandler(lcPem, lcPem, lNative, loValue, cDescript)
		
			Case This.OldStylePropertyHandler(lcPem, loValue, cScript)  && not recommended, but still available
		
			Otherwise
				This.Zoom(lcPem, Thisform.nObjNumber, cDescript)
				This.RefreshControls()
		
		Endcase
		
		
	ENDPROC

	PROCEDURE getcurrentobject
		Lparameters tnObjNumber
		
		If Between (tnObjNumber, 1, Alen (Thisform.aSelectedObjectNames))
			Return Thisform.aSelectedObject (tnObjNumber)
		Endif
		
	ENDPROC

	PROCEDURE getexpr
		Lparameters lcPEM
		
		Local loObject, lcExpression, lcNewExpression, loException
		
		loObject = Thisform.oObject
		lcExpression = Substr( loObject.ReadExpression(lcPEM), 2)
		
		Getexpr (lcPEM) To lcNewExpression Default (lcExpression)
		
		Try
			loObject.WriteExpression(lcPEM, lcNewExpression)
		Catch To loException
		
		Endtry
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE getfile
		Lparameters lcPem, loValue, lcGetFileParams
		
		Local lcResult
		
		lcResult = Getfile (lcGetFileParams)
		If Empty (lcResult)
			Return
		EndIf
		
		Thisform.AssignSelectedControls(lcPem, lcResult)
		
		*!*	If Not Thisform.lEditingOneProperty
		*!*		Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, lcResult, Thisform.nSelectedObjects <= 1)
		*!*	Else
		*!*		Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPem, lcResult, .T.)
		*!*	Endif
		
	ENDPROC

	PROCEDURE handlemouseup
		*** JRN 11/11/2008 : Edit Method Code on shift or ctrl-Click
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		Local loObject As Object
		Local laValues(1), lcPem, lnCycleValue, lnI, lnValue
		
		Do Case
		
				* Ctrl-Click  -- editing one property
			Case nButton = 1 And nShift = 2 And Thisform.nSelectedObjects # 1 && And Not Thisform.lEditingOneProperty
				Thisform.oUtils.OpenSearchResults(Thisform.JustPem(cName), .T., Transform (Thisform.nSelectedObjects) + ' Selected Objects')
		
				* shift click
			Case nButton = 1 And nShift = 1
				lcPem = Thisform.JustPem(cName)
				loObject = Thisform.oObject
		
				If Indexseek (lcPem + ' ', .T., 'PropertyList')			;
						And PropertyList.Editor = 'Combo'				;
						and Not (PropertyList.Editor = 'ComboMult' And Thisform.nSelectedObjects # 1)
		
					If Thisform.nSelectedObjects = 1 && Or Thisform.lEditingOneProperty
						Thisform.GetComboValues (@laValues, lcPem, PropertyList.Editor, loObject.BaseClass)
						lnValue = Thisform.Get1Value (loObject, lcPem)
					Else
						For lnI = 1 To Alen ( Thisform.aSelectedObjects)
							loObject = Thisform.aSelectedObjects(lnI)
							If Thisform.GetPEMStatus (loObject, lcPem, 5)
								Thisform.GetComboValues (@laValues, lcPem, PropertyList.Editor, loObject.BaseClass)
								lnValue = Thisform.Get1Value (loObject, lcPem)
								Exit
							Endif
						Endfor
					Endif
		
					If _Tally > 0
						lnCycleValue = laValues(1,1)
						For lnI = 1 To Alen (laValues,1)
							If lnValue = laValues(lnI,1)
								If lnI < Alen (laValues,1)
									lnCycleValue = laValues(lnI+1,1)
								Else
									lnCycleValue = laValues(1,1)
								Endif
							Endif
						Next lnI
		
						Thisform.AssignSelectedControls(lcPem, lnCycleValue)
						*!*					If Not Thisform.lEditingOneProperty
						*!*						Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, lnCycleValue , Thisform.nSelectedObjects <= 1)
						*!*					Else
						*!*						Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPem, lnCycleValue , .T.)
						*!*					Endif
		
					Endif
				Endif
		
				* Nothing to do from here on if >1 selected objects
			Case Thisform.nSelectedObjects # 1
		
				* ctrl click
			Case nButton = 1 And nShift = 2 And csrMembers.cType $ 'ME'
				Thisform.ViewParentCode(csrMembers.cName, 'Code')
		
			Case nButton = 1 And nShift = 2 And csrMembers.cType $ 'P'
				Thisform.ViewParentCode(csrMembers.cName, 'Value')
		
				* alt click
			Case nButton = 1 And nShift = 4
				Thisform.ViewParentCode('', 'Parentage')
		
		EndCase
		
		
	ENDPROC

	PROCEDURE handlerightclick
		Private loForm, loThis, lcPem
		loForm = Thisform
		loThis = This
		
		If Not Thisform.lEditingOneProperty
			lcPem = Thisform.JustPem(cName)
		Else
			lcPem = Trim(Thisform.cEditPropertyName)
		Endif
		
		Local lcChoice, lnBar, lbResetAllowed, lbRemoveAllowed, nXCoord_In, nYCoord_In, nWhere_Out
		Local nRelRow_Out, nRelCol_Out, nView_Out, lnBar2, lnBar3, loObject
		Local lnMsgBox, loException, lcPrompt, lnValue, lnCycleValue, lcValue
		
		lcChoice = 'None'
		lnBar = 0
		lbResetAllowed = .T.
		lbRemoveAllowed = Not (csrMembers.lNative Or csrMembers.lInherited)
		
		Thisform.CreateContextMenu("GridContextMenu")
		
		* find out what row we're over
		nXCoord_In = Mcol(Thisform.Name,3)
		nYCoord_In = Mrow(Thisform.Name,3)
		Store 0 To nWhere_Out , nRelRow_Out , nRelCol_Out , nView_Out
		This.GridHitTest(nXCoord_In, nYCoord_In, @nWhere_Out, @nRelRow_Out, @nRelCol_Out)
		
		* over a cell
		If nWhere_Out = 3
		
			Do Case
		
				Case Empty(lcPem)
		
				Case Thisform.oMember.cType $ 'ME' And Thisform.nSelectedObjects = 1
		
					lnBar = lnBar + 1
					Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_EDIT_METHOD
					On Selection Bar (lnBar) Of GridContextMenu loForm.EditMethodCode()
		
				Case Thisform.oMember.lReadOnly
					lbResetAllowed = .F.
		
				Otherwise
					If Thisform.nSelectedObjects # 1
						lnBar = lnBar + 1
						Define Bar (lnBar) Of GridContextMenu Prompt (IIf('O' = Vartype(Thisform.oSearchResults), ccLOC_CMG_EditByControl2, ccLOC_CMG_EditByControl1))
						On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Edit for each control'
					Endif
		
					If Thisform.oMember.cType $ 'ME'
						lbResetAllowed = .F.
					Else
						* handling of values for combos
						If Indexseek (lcPem + ' ', .T., 'PropertyList') 		;
								And PropertyList.Editor = 'Combo'				;
								and Not (PropertyList.Editor = 'ComboMult' And Thisform.nSelectedObjects # 1)
		
							Local laValues(1), lnI
							If Thisform.nSelectedObjects = 1
								Thisform.GetComboValues (@laValues, lcPem, PropertyList.Editor, Thisform.oObject.BaseClass)
								lnValue = Thisform.Get1Value (Thisform.oObject, lcPem)
							Else
								lnBar = lnBar + 1
								Define Bar (lnBar) Of GridContextMenu Prompt "\-"
		
								If Thisform.lEditingOneProperty
									loObject = ThisForm.GetCurrentObject(ThisForm.nObjNumber)
									Thisform.GetComboValues (@laValues, lcPem, PropertyList.Editor, loObject.BaseClass)
									lnValue = Thisform.Get1Value (loObject, lcPem)
								Else
									For lnI = 1 To Alen ( Thisform.aSelectedObjects)
										loObject = Thisform.aSelectedObjects(lnI)
										If Thisform.GetPEMStatus (loObject, lcPem, 5)
											Thisform.GetComboValues (@laValues, lcPem, PropertyList.Editor, loObject.BaseClass)
											lnValue = Thisform.Get1Value (loObject, lcPem)
											Exit
										Endif
									Endfor
								Endif
							Endif
		
							If _Tally > 0
								lnCycleValue = laValues(1,1)
								For lnI = 1 To Alen (laValues,1)
									lnBar = lnBar + 1
									Define Bar (lnBar) Of GridContextMenu Prompt Alltrim(laValues(lnI,2))
									lcValue = 'Combo ' + Transform(laValues(lnI,1))
									On Selection Bar (lnBar) Of GridContextMenu lcChoice = '&lcValue'
									If lnValue = laValues(lnI,1)
										Set Mark Of Bar (lnBar) Of GridContextMenu To .T.
										If lnI < Alen (laValues,1)
											lnCycleValue = laValues(lnI+1,1)
										Else
											lnCycleValue = laValues(1,1)
										Endif
									Endif
								Next lnI
		
								lnBar = lnBar + 1
								Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_Cycle
								lcValue = 'Combo ' + Transform(lnCycleValue )
								On Selection Bar (lnBar) Of GridContextMenu lcChoice = '&lcValue'
		
								lnBar = lnBar + 1
								Define Bar (lnBar) Of GridContextMenu Prompt "\-"
							Endif
						Endif
		
						lnBar = lnBar + 1
						Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_PropertyEditor
						On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Property Editor'
		
						lnBar = lnBar + 1
						Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_ZoomBox
						On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Zoom'
		
						If Thisform.nSelectedObjects = 1
							lnBar = lnBar + 1
							Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_GetExpr
							On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Expression Builder'
						Endif
					Endif
		
			Endcase
		
			If lbResetAllowed
				lnBar = lnBar + 1
				Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_ResetToDefault
				On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'ResetToDefault'
			Endif
		
			If lbRemoveAllowed
				lnBar = lnBar + 1
				Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_REMOVE
				On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Remove'
			Endif
		
			If Upper(lcPem) == 'PARENTCLASS'
				llOK = Thisform.ThisControlDeletable(Thisform.oObject)				;
					And 0 = Thisform.GetControlCount(Thisform.oObject)		;
					and Upper(Thisform.oObject.BaseClass) # 'OLE'
				lnBar = lnBar + 1
				Define Bar (lnBar) Of GridContextMenu Prompt IIf(llOK, '', '\') + ccLOC_CMG_ChangeClass
				On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Change Parent Class'
			Endif
		
		Endif nWhere_Out = 3
		
		****************************************************************
		If lnBar # 0
			lnBar = lnBar + 1
			Define Bar (lnBar) Of GridContextMenu Prompt "\-"
		Endif
		
		****************************************************************
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_Exports
		On Bar (lnBar) Of GridContextMenu Activate Popup GridContextExports
		
		If .T. && indents sub-menu
			Define Popup GridContextExports SHORTCUT Relative
			lnBar2 = 1
		
			If nWhere_Out = 3 						;
					And Thisform.oMember.lInherited 	;
					And Thisform.nSelectedObjects = 1
		
				Do Case
					Case Thisform.oMember.cType = 'P'
						lnBar2 = lnBar2 + 1
						Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_VIEW_PARENT_Values
						On Selection Bar (lnBar2) Of GridContextExports loForm.ViewParentCode(csrMembers.cName, 'Value')
		
					Case Thisform.oMember.cType $ 'ME'
						lnBar2 = lnBar2 + 1
						Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_VIEW_PARENT_CODE
						On Selection Bar (lnBar2) Of GridContextExports loForm.ViewParentCode(csrMembers.cName, 'Code')
		
				Endcase
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ViewParentage
				On Selection Bar (lnBar2) Of GridContextExports loForm.ViewParentCode('', 'Parentage')
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt "\-"
		
			Endif
		
			If (Thisform.nMethodView = 2 And Thisform.nSelectedObjects = 1) Or Thisform.oPrefs.lTypeMethod Or Thisform.oPrefs.lTypeEvent
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ExportMethods
				On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'Method Code'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ExportParentMethods
				On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'Full Method Code'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ExportChildMethods
				On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'Children Method Code'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt "\-"
		
			Else
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ExportChildMethods
				On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'Children Method Code'
		
			Endif
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ExportPEMList
			On Bar (lnBar2) Of GridContextExports Activate Popup GridContextExports2
			lnBar3 = 0
		
			If .T.
				Define Popup GridContextExports2 SHORTCUT Relative
				lnBar3 = lnBar3 + 1
				Define Bar (lnBar3) Of GridContextExports2 Prompt ccLOC_CMG_ExportPEMListHTML
				On Selection Bar (lnBar3) Of GridContextExports2 lcChoice = 'HTML List of PEMs'
		
				lnBar3 = lnBar3 + 1
				Define Bar (lnBar3) Of GridContextExports2 Prompt ccLOC_CMG_ExportPEMListText
				On Selection Bar (lnBar3) Of GridContextExports2 lcChoice = 'List of PEMs'
		
			Endif
		
			*	If 0 # Reccount("csrTempFiles")
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of GridContextExports Prompt "\-"
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_Close_All
			On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'Close All'
			*	Endif
		
		Endif
		
		****************************************************************
		If Thisform.lIsTopOfForm And PEME_IsVersion9()
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_MemberDataTools
			On Bar (lnBar) Of GridContextMenu Activate Popup MemberDataTools
		
			Define Popup MemberDataTools SHORTCUT Relative
			lnBar2 = 1
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_MemberData2
			On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'MemberData'
		
			If Thisform.GetPEMStatus(Thisform.oTopOfForm, "_MemberData", 5)				;
					and Thisform.GetPEMStatus(Thisform.oTopOfForm, "_MemberData", 0)	;
					and Not Empty(Thisform.oTopOfForm._MemberData)
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_CleanseMemberData
				On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Cleanse MemberData'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_CleanseMemberStats
				On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Stats for MemberData'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_BrowseMemberData
				On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Browse MemberData'
			Endif
		
		Endif
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of GridContextMenu Prompt "\-"
		
		*!*	* renaming not always possible, or appropriate
		*!*	If Thisform.AutoRenameControls(Thisform.oObject, .T.)
		*!*		lnBar = lnBar + 1
		*!*		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_AutoRename
		*!*		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Auto-Rename'
		*!*	Endif
		
		*!*	If Thisform.lUseCSO And Not Thisform.lIsTopOfForm
		*!*		lnBar = lnBar + 1
		*!*		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_NameToClipBoard
		*!*		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'NameToClipBoard'
		*!*	Endif
		
		*!*	*** JRN 03/10/2009 : See comments in ThisControlDeletable
		*!*	If Thisform.ThisControlDeletable(Thisform.oObject)
		*!*		lnBar = lnBar + 1
		*!*		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_DeleteControl
		*!*		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'DeleteControl'
		*!*	Endif
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of GridContextMenu Prompt ccLoc_CMG_ResetSort
		*!*	On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'ResetSort'
		
		****************************************************************
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt "\-"
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_PREFERENCES
		*!*	On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Preferences'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_FONT
		On Selection Bar (lnBar) Of GridContextMenu loThis.SetFont()
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_VFP_Default
		*!*	On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'VFP Default'
		
		If csrMembers.lNative
			lnBar = lnBar + 1
			Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_Help2
			On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Help'
		Endif
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_Videos
		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Videos'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_About
		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'About'
		****************************************************************
		****************************************************************
		
		Activate Popup GridContextMenu
		Release Popups GridContextMenu
		
		****************************************************************
		****************************************************************
		
		Do Case
		
			Case lcChoice = 'Preferences'
				Thisform.Preferences()
		
			Case lcChoice = 'List of PEMs'
				loForm.ExportListofPEMs()
		
			Case lcChoice = 'HTML List of PEMs'
				loForm.ExportHTMLListofPEMs()
		
			Case lcChoice = 'Method Code'
				Thisform.ExportMethodCode(.F.)
		
			Case lcChoice = 'Children Method Code'
				Thisform.ExportMethodCode(.F., .T.)
		
			Case lcChoice = 'Full Method Code'
				Thisform.ExportMethodCode(.T.)
		
			Case lcChoice = 'Property Editor'
				This.EditPem()
		
			Case lcChoice = 'Zoom'
				If Not Thisform.lEditingOneProperty
					lcPem = Thisform.JustPem(cName)
				Else
					lcPem = Trim(Thisform.cEditPropertyName)
				Endif
				This.Zoom(lcPem, Thisform.nObjNumber, cDescript)
				This.RefreshControls()
		
			Case lcChoice = 'Expression Builder'
				This.Getexpr(lcPem)
				This.RefreshControls()
		
			Case lcChoice = 'ResetToDefault'
				Thisform.ResetMemberToDefault()
				This.RefreshControls()
		
			Case lcChoice = 'Close All'
				Thisform.oUtils.ClearTempFilesList()
		
			Case lcChoice = 'MemberData'
				Thisform.lDontDisableMe = .T.
				Do (_Builder) With Thisform.oTopOfForm, "MemberData", 1, lcPem
				Thisform.lDontDisableMe = .F.
				Thisform.RefreshForm()
		
			Case lcChoice = 'Cleanse MemberData'
				Thisform.MemberDataCleaner()
		
			Case lcChoice = 'Stats for MemberData'
				Thisform.memberdatastats()
		
			Case lcChoice = 'Browse MemberData'
				Xmltocursor (Thisform.oTopOfForm._MemberData, 'Browse_MemberData')
				Index On Name Tag Name
				Browse Normal Noappend Nodelete Nomodify
				Select csrMembers
		
			Case lcChoice = 'Help'
				Help &lcPem
		
			Case lcChoice = 'Remove'
				Thisform.removeMember( Thisform.JustPem( csrMembers.cName ), .F., .T. )
				This.Refresh()
		
			Case lcChoice = 'Change Parent Class'
				Thisform.ChangeParentClass()
		
			Case lcChoice = 'DeleteControl'
				Thisform.lDontDisableMe = .T.
				Thisform.DeleteThisControl()
				Thisform.lDontDisableMe = .F.
		
				*!*		Case lcChoice = 'Auto-Rename'
				*!*			lnMsgBox = Messagebox (ccLOC_ASK_CMG_AutoRename, 4+32, Thisform.Caption)
				*!*			If lnMsgBox = 6
				*!*				Thisform.AutoRenameControls(Thisform.oObject)
				*!*			Endif
				*!*			This.Parent.Refresh()
		
			Case lcChoice = 'NameToClipBoard'
				_Cliptext = Thisform.cCurrentObjectName
		
			Case lcChoice = 'Edit for each control'
				Thisform.oUtils.OpenSearchResults(Thisform.JustPem(cName), .T., Transform (Thisform.nSelectedObjects) + ' Selected Objects') 
				*	This.EditOneProperty()
		
			Case lcChoice = 'Edit all properties'
				Thisform.lEditingOneProperty = .F.
				Thisform.ZapMembersCursor()
				Thisform.ActivateForm(.T.)
		
			Case lcChoice = 'Combo'
				lnValue = Val(Transform (Substr (lcChoice,6))) && lcChoice looks like 'Combo 3'
				Thisform.AssignSelectedControls(lcPem, lnValue)
				*!*			If Not Thisform.lEditingOneProperty
				*!*				Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, lnValue , Thisform.nSelectedObjects <= 1)
				*!*			Else
				*!*				Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPem, lnValue , .T.)
				*!*			Endif
		
			Case lcChoice = 'ResetSort'
		
				If Thisform.nMethodView = 1
					Thisform.cMembersSortOrder = ''
					Thisform.SortGrid( Substr(ccLoc_SortOrder1,2))
				Else
					Thisform.cMembersSortOrderMethodView = ''
					Thisform.SortGrid( Substr(ccLoc_SortOrder2,2))
				Endif
		
			Case lcChoice = 'VFP Default'
				lcPrompt = ccLOC_VFP_Default_Prompt
				lnMsgBox = Messagebox (lcPrompt, 3 + 32, ccLOC_VFP_Default)
				If lnMsgBox = 6
					With Thisform
						.oPersist.Set('OneTimeAbort', .T.)
						.oPersist.Save(.cFoxUserID, .cFoxUserName)
					Endwith
					Thisform.Release()
				Endif
		
			Case lcChoice = 'About'
				Thisform.lDontDisableMe = .T.
				Thisform.oUtils.AboutPEMEditor()
				Thisform.lDontDisableMe = .F.
		
			Case lcChoice = 'Videos'
				Local loHyperlink, lcLink
				lcLink = "http://jordanmachine.com/PEM_Editor_Videos.html"
				loHyperlink = Createobject("Hyperlink")
				loHyperlink.NavigateTo(lcLink)
		
		Endcase
		
		
	ENDPROC

	PROCEDURE headerrightclick
		Lparameters lcMainSortField, lcAltSortField, lcColumnName, lbAlphaReverse
		
		Private loForm
		loForm = ThisForm
		
		Local lcMembersSortOrder, lcPrompt, lnBar, lnBar2, lnMsgBox, lnValue, lcChoice
		
		*** JRN 04/15/2009 :
		With Thisform
			If Thisform.nMethodView = 1
				lcMembersSortOrder = .cMembersSortOrder
			Else
				lcMembersSortOrder = .cMembersSortOrderMethodView
			Endif
		
			Do Case
				Case Not (Pcount() >= 2 And lcMembersSortOrder = "+" + lcMainSortField)
					lcPrompt = ccLOC_Cap_Sort + Iif( Empty (lcColumnName), '', ' (' + lcColumnName + ')')
				Case lbAlphaReverse
					lcPrompt = ccLOC_Cap_Sort_Alpha_Reverse
				Otherwise
					lcPrompt = ccLOC_Cap_Sort_Reverse  + Iif( Empty (lcColumnName), '', ' (' + lcColumnName + ')')
			Endcase
		
		Endwith
		
		Thisform.CreateContextMenu("GridContextMenu")
		lnBar = 0
		
		* find out what row we're over
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt lcPrompt
		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'ColumnSort'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt ccLoc_CMG_ResetSort
		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'ResetSort'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_Exports
		On Bar (lnBar) Of GridContextMenu Activate Popup GridContextExports
		
		If .T. && indents sub-menu
			Define Popup GridContextExports SHORTCUT Relative
			lnBar2 = 1
		
			If (Thisform.nMethodView = 2 And Thisform.nSelectedObjects = 1) Or Thisform.oPrefs.lTypeMethod Or Thisform.oPrefs.lTypeEvent
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ExportMethods
				On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'Method Code'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ExportParentMethods
				On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'Full Method Code'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt "\-"
		
			Endif
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ViewParentage
			On Selection Bar (lnBar2) Of GridContextExports loForm.ViewParentCode('', 'Parentage')
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_ExportPEMList
			On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'List of PEMs'
		
			*	If 0 # Reccount("csrTempFiles")
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt "\-"
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of GridContextExports Prompt ccLOC_CMG_Close_All
				On Selection Bar (lnBar2) Of GridContextExports lcChoice = 'Close All'
			*	Endif
		
		Endif
		
		****************************************************************
		****************************************************************
		If Thisform.lIsTopOfForm And PEME_IsVersion9()
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_MemberDataTools
			On Bar (lnBar) Of GridContextMenu Activate Popup MemberDataTools
		
			Define Popup MemberDataTools SHORTCUT Relative
			lnBar2 = 1
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_MemberData2
			On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'MemberData'
		
			If Thisform.GetPEMStatus(Thisform.oTopOfForm, "_MemberData", 5)				;
					and Thisform.GetPEMStatus(Thisform.oTopOfForm, "_MemberData", 0)	;
					and Not Empty(Thisform.oTopOfForm._MemberData)
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_CleanseMemberData
				On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Cleanse MemberData'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_CleanseMemberStats
				On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Stats for MemberData'
		
				If Lower (cName) = '_memberdata '
					lnBar2 = lnBar2 + 1
					Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_BrowseMemberData
					On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Browse MemberData'
				Endif
			Endif
		
		Endif
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of GridContextMenu Prompt "\-"
		
		*!*	* renaming not always possible, or appropriate
		*!*	If Thisform.AutoRenameControls(Thisform.oObject, .T.)
		*!*		lnBar = lnBar + 1
		*!*		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_AutoRename
		*!*		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Auto-Rename'
		*!*	Endif
		
		*!*	If Thisform.lUseCSO And Not Thisform.lIsTopOfForm
		*!*		lnBar = lnBar + 1
		*!*		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_NameToClipBoard
		*!*		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'NameToClipBoard'
		*!*	Endif
		
		*!*	*** JRN 03/10/2009 : See comments in ThisControlDeletable
		*!*	If Thisform.ThisControlDeletable(Thisform.oObject)
		*!*		lnBar = lnBar + 1
		*!*		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_DeleteControl
		*!*		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'DeleteControl'
		*!*	Endif
		
		****************************************************************
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt "\-"
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_PREFERENCES
		*!*	On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Preferences'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_FONT
		On Selection Bar (lnBar) Of GridContextMenu loThis.SetFont()
		
		If csrMembers.lNative
			lnBar = lnBar + 1
			Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_Help2
			On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Help'
		Endif
		
		****************************************************************
		****************************************************************
		
		Activate Popup GridContextMenu
		Release Popups GridContextMenu
		
		****************************************************************
		****************************************************************
		
		
		Do Case
		
			Case Empty (lcChoice)
		
			Case lcChoice = 'Preferences'
				Thisform.Preferences()
		
			Case lcChoice = 'List of PEMs'
				loForm.ExportListofPEMs()
		
			Case lcChoice = 'Method Code'
				Thisform.ExportMethodCode(.F.)
		
			Case lcChoice = 'Full Method Code'
				Thisform.ExportMethodCode(.T.)
		
			Case lcChoice = 'Zoom'
				This.EditPem()
		
			Case lcChoice = 'Expression Builder'
				This.Getexpr(lcPem)
				This.RefreshControls()
		
			Case lcChoice = 'ResetToDefault'
				Thisform.ResetMemberToDefault()
				This.RefreshControls()
		
			Case lcChoice = 'Close All'
				Thisform.oUtils.ClearTempFilesList()
		
			Case lcChoice = 'MemberData'
				Thisform.lDontDisableMe = .T.
				Do (_Builder) With Thisform.oTopOfForm, "MemberData", 1, lcPem
				Thisform.lDontDisableMe = .F.
				Thisform.RefreshForm()
		
			Case lcChoice = 'Stats for MemberData'
				This.memberdatastats()
		
			Case lcChoice = 'Cleanse MemberData'
				Thisform.MemberDataCleaner()
		
			Case lcChoice = 'Help'
				Help &lcPem
		
			Case lcChoice = 'Remove'
				Thisform.removeMember( Thisform.JustPem( csrMembers.cName ), .F., .T. )
				This.Refresh()
		
			Case lcChoice = 'DeleteControl'
				Thisform.lDontDisableMe = .T.
				Thisform.DeleteThisControl()
				Thisform.lDontDisableMe = .F.
		
		*!*		Case lcChoice = 'Auto-Rename'
		*!*			lnMsgBox = Messagebox (ccLOC_ASK_CMG_AutoRename, 4+32, Thisform.Caption)
		*!*			If lnMsgBox = 6
		*!*				Thisform.AutoRenameControls(Thisform.oObject)
		*!*			Endif
		*!*			This.Parent.Refresh()
		
			Case lcChoice = 'NameToClipBoard'
				_Cliptext = Thisform.cCurrentObjectName
		
		*!*		Case lcChoice = 'Edit for each control'
		*!*			Thisform.lEditingOneProperty = .T.
		*!*			Thisform.cEditPropertyName = lcPem
		*!*			Select * From csrMultMembers 			;
		*!*				where Lower(cName) = Lower (lcPem)	;
		*!*				into Cursor csrMults Readwrite
		*!*			Replace All cName With cObjName
		
		*!*			Thisform.ZapMembersCursor()
		
		*!*			Append From (Dbf("csrMults"))
		*!*			Thisform.SetFilter()
		*!*			Locate
		*!*			This.SetColumnHeadings()
		*!*			This.Refresh()
		
			Case lcChoice = 'Edit all properties'
				Thisform.lEditingOneProperty = .F.
				Thisform.ZapMembersCursor()
				Thisform.ActivateForm(.T.)
		
			Case lcChoice = 'Combo'
				lnValue = Val(Transform (Substr (lcChoice,6))) && lcChoice looks like 'Combo 3'
				Thisform.AssignSelectedControls(lcPem, lnValue )
				*!*			If Not Thisform.lEditingOneProperty
				*!*				Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, lnValue , Thisform.nSelectedObjects <= 1)
				*!*			Else
				*!*				Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPem, lnValue , .T.)
				*!*			Endif
		
			Case lcChoice = 'ColumnSort'
				Thisform.SortGrid(lcMainSortField, lcAltSortField)
		
			Case lcChoice = 'ResetSort'
				With Thisform
					.SetDefaultGridSortOrder()
					.SortGrid()
				EndWith 
		
		Endcase
		
		
	ENDPROC

	PROCEDURE intrinsicpropertyeditors
		*** JRN 04/15/2009 : Intrinsic property editors for toggle and anchor editors
		
		Lparameters lcPem, lcAssignPem, loValue
		Local lbAssigned, lbCancelled, loObject, lbOnlyOne, lxNewValue, loAnchorEditor, lbResult, lnAnchor, lcAppPath, lcFont, lcFontName 
		
		lbAssigned = .F.
		lbCancelled = .F.
		
		If Not Thisform.lEditingOneProperty
			loObject = Thisform.oObject
			lbOnlyOne = Thisform.nSelectedObjects <= 1
		Else
			loObject = ThisForm.GetCurrentObject(ThisForm.nObjNumber)
			lbOnlyOne = .T.
		Endif
		
		Thisform.lDontDisableMe = .T.
		lcAppPath = ThisForm.cApplicationPath + "Property Editors\"
		
		Do Case
		
				* toggle logical values
			Case Thisform.oPrefs.lToggleEditor And loValue.Type == 'L'
				If loValue.SingleValue
					lxNewValue = Not loValue.Value
					lbAssigned = .T.
				Else
					lxNewValue = .F. && if mixed values, turn 'em all off
					lbAssigned = .T.
				Endif
		
				* Anchor editor (VFP Native)
				* 	Invoked form must be modal, return result of the new value.
				* 	Return this value if it is meant to be used; else fall thru
			Case Proper(lcPem) == 'Anchor' And Thisform.oPrefs.nAnchorEditor = 2
				loAnchorEditor = Newobject('AnchorEditor', lcAppPath + 'AnchorEditor\AnchorEditor.vcx', .Null., loObject)
				loAnchorEditor.Show()
				If loValue.Value <> loObject.Anchor
					lxNewValue = loObject.Anchor
					lbAssigned = .T.
				Else
					lbCancelled = .T.
				Endif
		
		
				* Alternative Anchor editor
			Case Proper(lcPem) == 'Anchor' And Thisform.oPrefs.nAnchorEditor = 3
				Do Form (lcAppPath + 'BuildAnchor\BuildAnchorPEME.scx') With loValue.Value To lnAnchor
				If lnAnchor >= 0
					lxNewValue = lnAnchor
					lbAssigned = .T.
				Else
					lbCancelled = .T.
				Endif
		
				* Font info
			Case Proper(lcPem) == 'Fontname'
				lcFontName = Evl (loObject.FontName, 'Arial')
					Do Case
					Case not Thisform.GetPEMStatus (loObject, 'FontSize', 5)
						lcFont = Getfont(lcFontName )
					Case not (Thisform.GetPEMStatus (loObject, 'FontItalic', 5) and Thisform.GetPEMStatus (loObject, 'FontBold', 5))
						lcFont = Getfont(lcFontName , loObject.FontSize)
					Otherwise
						lcFont = Getfont(lcFontName , loObject.FontSize, Iif(loObject.FontBold, 'B', '') + Iif(loObject.FontItalic, 'I', ''))
				Endcase
		
				If Not Empty (lcFont)
					lxNewValue = lcFont
					lbAssigned = .T.
				Else
					lbCancelled = .T.
				Endif
		
			Case Lower(lcPem) == '_memberdata' And Thisform.lIsTopOfForm
				Thisform.lDontDisableMe = .T.
				Do (_Builder) With Thisform.oTopOfForm, "MemberData", 1, lcPem
				Thisform.lDontDisableMe = .F.
				Thisform.RefreshForm()
				lbCancelled = .T.
		
		Endcase
		
		
		Do Case
			Case lbCancelled
				lbResult = .T.
		
			Case lbAssigned And Not Empty (lcFont)
				Alines (laFont, lcFont, .T., ",")
				Thisform.AssignSelectedControls('FontName', laFont(1))
				Thisform.AssignSelectedControls('FontSize', Int (Val(laFont(2))))
				Thisform.AssignSelectedControls('FontBold', 'B' $ laFont(3))
				Thisform.AssignSelectedControls('FontItalic', 'I' $ laFont(3))
				This.RefreshControls()
				lbResult = .T.
		
			Case lbAssigned
				Thisform.AssignSelectedControls(lcAssignPem, lxNewValue)
				This.RefreshControls()
				lbResult = .T.
		
			Otherwise
				lbResult = .F.
		
		Endcase
		
		Thisform.lDontDisableMe = .F.
		
		Return lbResult
		
	ENDPROC

	PROCEDURE iscustomfunctioncall
		Lparameters tcDescript
		
		Return Not Empty(ThisForm.GetDOPEText(tcDescript, '='))
		
	ENDPROC

	PROCEDURE listzoom
		Lparameters lcEditor, lcPem, lcAssignPem, loValue, lnFontSize, tcDescript
		
		Local loObject, lnI
		
		If Not (lcEditor = 'ComboMult' And Thisform.nSelectedObjects # 1 And Not Thisform.lEditingOneProperty)
		
			Local laValues(1), lnI
			If Thisform.nSelectedObjects = 1
				Thisform.GetComboValues (@laValues, lcPem, PropertyList.Editor, Thisform.oObject.BaseClass)
			Else
				If Thisform.lEditingOneProperty
					loObject = ThisForm.GetCurrentObject(ThisForm.nObjNumber)
					Thisform.GetComboValues (@laValues, lcPem, PropertyList.Editor, loObject.BaseClass)
				Else
					For lnI = 1 To Alen ( Thisform.aSelectedObjects)
						loObject = Thisform.aSelectedObjects(lnI)
						If Thisform.GetPEMStatus (loObject, lcPem, 5)
							Thisform.GetComboValues (@laValues, lcPem, PropertyList.Editor, loObject.BaseClass)
							Exit
						Endif
					Endfor
				Endif
			Endif
		
			Local lcPath
		
			lcPath = Justpath (Thisform.ClassLibrary)
			
			Do Form lcPath + '\ListZoomDialog' With lcPem, laValues, loValue.Value, lnFontSize, tcDescript To lxResult
		
			If 'N' = Vartype(lxResult)
				Thisform.AssignSelectedControls(lcAssignPem, lxResult)
				*!*			If Not Thisform.lEditingOneProperty
				*!*				Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, lxResult, Thisform.nSelectedObjects <= 1)
				*!*			Else
				*!*				Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPem, lxResult, .T.)
				*!*			Endif
			Endif
		
		Endif
		
	ENDPROC

	PROCEDURE memberdatastats
		Local lcPrompt, lnNewLen, lnNewMemberData, lnOldLen, lnOldMemberData, lnResponse
		
		#Define MaxSize (cnMAX_MEMBER_DATA_SIZE - 1)
		
		lnLen = Len (Thisform.oTopOfForm._MemberData)
		
		lcPrompt = '_ MemberData Statistics' + ccCR  + ccCR
		lcPrompt = lcPrompt + 'Maximum size = ' + Transform(MaxSize) + ccCR + ccCR
		lcPrompt = lcPrompt + 'Current size = ' + Transform(lnLen ) + ccCR
		lcPrompt = lcPrompt + 'Available    = ' + Transform(MaxSize - lnLen ) + ccCR + ccCR
		lcPrompt = lcPrompt + 'Percent Used = ' + Str( 100 * (lnLen / MaxSize), 3, 0) + '%' + ccCR
		
		Messagebox(lcPrompt, 64, ccLOC_CAP_MDCleaner_Title)
		
	ENDPROC

	PROCEDURE MouseUp
		*** JRN 11/11/2008 : Edit Method Code on shift or ctrl-Click
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.HandleMouseUp (nButton, nShift, nXCoord, nYCoord)
		
	ENDPROC

	PROCEDURE nativepropertyhandler
		Lparameters lcPem, lcAssignPem, lNative, loValue, tcDescript
		Local lcEditor, laClassInfo(1)
		
		If lNative											;
				and Indexseek (lcPem + ' ', .T., "PropertyList")	;
				and Not Empty (PropertyList.Editor)
		
			lcEditor = PropertyList.Editor
			Do Case
				Case lcEditor = 'Toggle'
					This.ToggleEditor(lcPem, loValue)
					This.RefreshControls()
		
				Case lcEditor = 'Color'
					This.ColorPicker(lcPem, lcAssignPem, loValue)
					This.RefreshControls()
		
				Case lcEditor = 'Combo'
					This.ListZoom(lcEditor, lcAssignPem, lcPem, loValue, Thisform.nFontSize, tcDescript)
		
				Case lcEditor = 'GetFile'
					This.Getfile(lcPem, loValue, PropertyList.Parameters)
					This.RefreshControls()
		
				Case lcEditor = 'HeaderClas'
					lcResponse = Messagebox(ccLOC_MB_ChangeHeaderClass,4+32+256,Thisform.Caption)
					If lcResponse = 6
						If Agetclass (laClassInfo)
							Thisform.AssignSelectedControls('HeaderClassLibrary', laClassInfo(1))
							Thisform.AssignSelectedControls('HeaderClass', laClassInfo(2))
							This.RefreshControls()
						Endif
					Endif
		
				Case lcEditor = 'MemberClas'
					lcResponse = Messagebox(ccLOC_MB_ChangeMemberClass,4+32+256,Thisform.Caption)
					If lcResponse = 6
						If Agetclass (laClassInfo)
							Thisform.AssignSelectedControls('MemberClassLibrary', laClassInfo(1))
							Thisform.AssignSelectedControls('MemberClass', laClassInfo(2))
							This.RefreshControls()
						Endif
					Endif
				Otherwise
					Return .F.
		
			Endcase
		
			Return .T.
		
		Else
		
			Return .F.
		
		Endif
		
		
	ENDPROC

	PROCEDURE oldstylepropertyhandler
		Lparameters lcPem, loValue, lcScript
		
		Local loObject As Object
		Local laObjects(1), lbAny, lxResult
		
		If Empty(lcScript) Or Upper(lcPem) == 'CAPTION' Or Upper(lcPem) == 'ANCHOR'
			Return .F.
		Endif
		
		lbAny = 0 # Aselobj(laObjects) Or 0 # Aselobj(laObjects,1)
		If Thisform.nSelectedObjects # 1	;
				or Thisform.oObject # laObjects(1)
			Return .F.
		Endif
		
		Thisform.lDontDisableMe = .T.
		lxResult = Thisform.ExecuteScript(lcScript)
		Thisform.lDontDisableMe = .F.
		
		Return 'O' # Vartype (lxResult)
		
	ENDPROC

	PROCEDURE pluginprg
		Lparameters lcPem, lcAssignPem, loValue
		Local lbResult, lcCustomPRG, loObject, lbOnlyOne, lcCode, loException, loResult
		
		lbResult = .F.
		*	lcCustomPRG =  Thisform.cApplicationPath + "CustomPropertyEditor.PRG"
		lcCustomPRG =  ThisForm.oUtils.GetPlugInPath ("CustomPropertyEditor")
		
		If Not Empty(lcCustomPRG)
			If Not Thisform.lEditingOneProperty
				loObject = Thisform.oObject
				lbOnlyOne = Thisform.nSelectedObjects <= 1
			Else
				loObject = ThisForm.GetCurrentObject(ThisForm.nObjNumber)
				lbOnlyOne = .T.
			Endif
		
			Thisform.lDontDisableMe = .T.
			Try
				loResult = Execscript(Filetostr(lcCustomPRG)		;
					, ThisForm.cApplicationPath + "Property Editors\"	;
					, lcPem											;
					, loValue.Value									;
					, loValue.Type									;
					, loValue.SingleValue)
		
				Do Case
					Case loResult.Cancelled
		
						lbResult = .T.
		
					Case loResult.Assigned
						* apply result?
						Thisform.AssignSelectedControls(lcAssignPem, loResult.Value)
						*!*					If Not Thisform.lEditingOneProperty
						*!*						Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, loResult.Value, Thisform.nSelectedObjects <= 1)
						*!*					Else
						*!*						Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPem, loResult.Value, .T.)
						*!*					Endif
		
						lbResult = .T.
		
					Otherwise
		
						lbResult = .F.
		
				Endcase
		
			Catch To loException
				Thisform.ShowErrorMsg(loException, 'Custom Property Editor', lcCustomPRG)
			Endtry
		
			Thisform.lDontDisableMe = .F.
		
		Endif
		
		Return lbResult
		
	ENDPROC

	PROCEDURE refreshcontrols
		*** JRN 03/09/2009 : fixes non-default, refreshes value control and grid
		Local lcPem
		
		Select csrMembers
		lcPem = cName
		
		Thisform.FixNonDefaultFlags()
		Thisform.oedtDefault.Refresh()
		This.Refresh()
		
		Locate For cName = lcPem
		If Not Found()
			Locate
		EndIf
		
		This.SetFocus()
		
		
	ENDPROC

	PROCEDURE RightClick
		This.HandleRightClick()
		
	ENDPROC

	PROCEDURE setbmp
		Local loControl As Object
		Local lcBMPName, lcFile, lcImgName, lcPath
		
		Do Case
			Case Thisform.lEditingOneProperty
				If Between (nObjNumber, 1, Alen (Thisform.aSelectedObjects))
					loControl = Thisform.aSelectedObjects(nObjNumber)
					If 'O' = Vartype (loControl)
						lcBMPName = Lower(loControl.BaseClass)
					Endif
				Endif
			Case cType = 'P'
				lcBMPName = Iif (nVisibility = 1, 'Propty', Iif(nVisibility = 2, 'PropProt', 'PropHidden'))
			Case cType = 'M'
				lcBMPName = Iif (nVisibility = 1, 'Method', Iif(nVisibility = 2, 'MethodProt', 'MethodHidden'))
			Otherwise
				lcBMPName = 'Event'
		Endcase
		
		If 'C' = Vartype (lcBMPName )
			With This.colTypeIcon
				lcImgName = 'img' + lcBMPName
				If "O" = Type ('.' + lcImgName)
					.CurrentControl = lcImgName
				Else
					.AddObject(lcImgName, 'Image')
		
					lcPath = Thisform.cApplicationPath + "images\"
					lcFile = lcPath + Evl (lcBMPName, '') + ".bmp"
					If File(lcFile)
						.&lcImgName..Picture = lcFile
					Endif
		
					.CurrentControl = lcImgName
				Endif
			Endwith
		Endif
		
		Return .F.
		
	ENDPROC

	PROCEDURE setcolumnheadings
		Local llUseAbbreviations
		
		With This
		
			llUseAbbreviations = Thisform.lUseAbbreviations 
		
			.Columns[ 1].Header1.Caption = IIF(Thisform.lEditingOneProperty, ccLOC_GCH_Control ,ccLOC_GCH_Name)
			.Columns[ 2].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_TypeA,       ccLOC_GCH_Type)
			.Columns[ 3].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_AccessA,     ccLOC_GCH_Access)
			.Columns[ 4].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_AssignA,     ccLOC_GCH_Assign)
			.Columns[ 5].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_VisibilityA, ccLOC_GCH_Visibility)
			.Columns[ 6].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_HierarchyA,  ccLOC_GCH_Hierarchy)
			.Columns[ 7].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_FavoriteA,   ccLOC_GCH_Favorite)
			.Columns[ 8].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_NonDefaultA, ccLOC_GCH_NonDefault)
			.Columns[ 9].Header1.Caption = " "
			.Columns[10].Header1.Caption = ccLOC_GCH_Value
			.Columns[11].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_CodeOriginA, ccLOC_GCH_CodeOrigin)
			.Columns[12].Header1.Caption = IIF(Thisform.lEditingOneProperty, ccLOC_GCH_Control ,ccLOC_GCH_Name)
			.Columns[13].Header1.Caption = IIF(Thisform.lEditingOneProperty, Thisform.cEditPropertyName, ccLOC_GCH_Value)
		
		Endwith
		
		
	ENDPROC

	PROCEDURE setfont
		Local lcFont, laLines(1), lcFontName, lcFontSize
		
		lcFont = Getfont (This.FontName, This.FontSize)
		
		If Empty (lcFont)
			Return
		Endif
		
		Alines (laLines, lcFont, .T., ',')
		With This
			.FontName 	= laLines(1)
			.FontSize 	= Val (laLines(2))
			.RowHeight  = .RowHeight - 1
		EndWith 
		
		With Thisform
			.oPersist.Set('GridFontName', This.FontName)
			.oPersist.Set('GridFontSize', This.FontSize)
		Endwith
		
		
	ENDPROC

	PROCEDURE toggleeditor
		Lparameters lcPEM, loValue
		
		Local lbValue
		
		lbValue = Iif (loValue.SingleValue, Not loValue.Value, .F.)
		
		Thisform.AssignSelectedControls(lcPem, lbValue)
		*!*	If Not Thisform.lEditingOneProperty
		*!*		Thisform.UpdateSelectedControls(Thisform.oObject, lcPEM, lbValue , Thisform.nSelectedObjects <= 1)
		*!*	Else
		*!*		Thisform.UpdateSelectedControls(ThisForm.GetCurrentObject(ThisForm.nObjNumber), lcPEM, lbValue , .T.)
		*!*	Endif
		
	ENDPROC

	PROCEDURE zoom
		Lparameters lcName, tnObjNumber, tcDescript
		
		Local lcClass, lcPem, lcPath, lcAppPath
		lcPath = Thisform.cApplicationPath
		lcAppPath = Forcepath('PEMEditor.app', lcPath)
		
		Release _oZoom
		Public _oZoom
		
		If Thisform.lPEMEditor
			lcClass = 'ZoomDialog'
		Else
			lcClass = 'ZoomDialogSearch'
		Endif
		
		If Not Thisform.lEditingOneProperty
			lcPem = Thisform.JustPem(lcName)
			_oZoom = Newobject(lcClass, 'Source\EditProperty.vcx', lcAppPath	;
				, Thisform.oObject, Thisform.oTopofForm, lcPem, Thisform.nSelectedObjects <= 1			;
				, Thisform.nFontSize, tcDescript)
		Else
			lcPem = Thisform.cEditPropertyName
			_oZoom = Newobject(lcClass, 'Source\EditProperty.vcx', lcAppPath	;
				, Thisform.GetCurrentObject (tnObjNumber), Thisform.oTopofForm, lcPem, .T.				;
				, Thisform.nFontSize, tcDescript)
		Endif
		
		_oZoom.Show()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS chkfiletype AS basecheckbox OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Alignment = 0
	Name = "chkfiletype"
	
	PROCEDURE Refresh
		DoDefault()
		This.Value = ThisForm.CheckFileType(This.Caption)
		
	ENDPROC

	PROCEDURE Valid
		DoDefault()
		ThisForm.AddFileType(This.Caption, This.Value, .T.)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdaddnewpem AS basecommandbutton OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialogenglish.h"
	*<DefinedPropArrayMethod>
		*p: nresult
	*</DefinedPropArrayMethod>

	Height = 27
	Name = "cmdaddnewpem"
	nresult = 0
	Width = 150
	
	PROCEDURE Click
		Thisform.Return(This.nResult)
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdonkeylabel AS basecommandbutton OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: setnondefaults
	*</DefinedPropArrayMethod>

	AutoSize = .F.
	Caption = "Use Suggested HotKeys"
	Height = 25
	Name = "cmdonkeylabel"
	Width = 134
	
	PROCEDURE Click
		This.SetNonDefaults(This.Parent)
	ENDPROC

	PROCEDURE setnondefaults
		Lparameters loObject
		Local loChild As Object
		Local lnI
		
		For lnI = 1 To loObject.ControlCount
			loChild = loObject.Controls (lnI)
			Do Case
				Case Lower (loChild.Class) = 'cntonkeylabel'
					loChild.ToggleDefaultValue(.T.)
				Case Lower (loChild.BaseClass) = 'container'
					This.SetNonDefaults(loChild)
			Endcase
		Endfor
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdpasteselection AS editpropertycommandbutton OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: changeselections
		*p: lvalue
	*</DefinedPropArrayMethod>

	Caption = "Select  "
	Height = 25
	Name = "cmdpasteselection"
	nanchor = 4
	Width = 75
	
	PROCEDURE changeselections
		Lparameters lcSelection
		
		Local lcType, lnRecno
		
		Do Case
			Case lcSelection == 'All'
				lcType = 'PME'
			Case lcSelection == 'Properties'
				lcType = 'P'
			Case lcSelection == 'Methods'
				lcType = 'M'
			Case lcSelection == 'Methods and Events'
				lcType = 'ME'
			Case lcSelection == 'Events'
				lcType = 'E'
			Otherwise
				lcType = ''
		Endcase
		
		Thisform.LockScreen = .T.
		lnRecno = Recno()
		
		Do Case
			Case Not Empty(lcType)
				Replace All lSelect With This.lValue For cType $ lcType
			Case lcSelection = 'PositionAndSize'
				Replace All lSelect With This.lValue For InList(Upper(cName),'TOP ', 'LEFT ', 'HEIGHT ', 'WIDTH')
		Endcase
		
		Goto (lnRecno)
		
		Thisform.LockScreen = .F.
		
		
	ENDPROC

	PROCEDURE Click
		*** JRN 2009-09-16 :
		Local lcChoice, lnBar
		
		lnBar = 0
		lcChoice = 'None'
		Thisform.CreateContextMenu("PasteContextMenu")
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of PasteContextMenu Prompt ccLOC_Paste_All
		On Selection Bar (lnBar) Of PasteContextMenu lcChoice = 'All'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of PasteContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of PasteContextMenu Prompt ccLOC_Paste_Properties
		On Selection Bar (lnBar) Of PasteContextMenu lcChoice = 'Properties'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of PasteContextMenu Prompt ccLOC_Paste_Methods
		On Selection Bar (lnBar) Of PasteContextMenu lcChoice = 'Methods'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of PasteContextMenu Prompt ccLOC_Paste_Events
		On Selection Bar (lnBar) Of PasteContextMenu lcChoice = 'Events'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of PasteContextMenu Prompt ccLOC_Paste_Methods_and_Events
		On Selection Bar (lnBar) Of PasteContextMenu lcChoice = 'Methods and Events'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of PasteContextMenu Prompt ccLOC_Paste_PositionAndSize
		On Selection Bar (lnBar) Of PasteContextMenu lcChoice = 'PositionAndSize'
		
		****************************************************************
		
		Activate Popup PasteContextMenu
		
		Release Popups PasteContextMenu
		
		****************************************************************
		
		This.ChangeSelections(lcChoice)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntfilters AS basecontainer OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblSubString" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSubString" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkProperties" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkMethods" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkEvents" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkNative" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkInherited" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCustom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFavorites" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="choNonDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkMethodLocal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboFavorites" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkMethodInherited" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkMethodNoMethod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkMethodNoEvent" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFilters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel2" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	BorderWidth = 1
	Height = 201
	Name = "cntfilters"
	nanchor = 8
	TabIndex = 9
	Width = 124

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = "With Code:", ;
		Height = 16, ;
		Left = 22, ;
		Name = "Baselabel1", ;
		TabIndex = 11, ;
		Top = 60, ;
		Width = 54, ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Baselabel2' AS baselabel WITH ;
		Caption = "Group", ;
		Height = 16, ;
		Left = 3, ;
		Name = "Baselabel2", ;
		TabIndex = 1, ;
		Top = 13, ;
		Width = 32
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cboFavorites' AS basecombobox WITH ;
		Height = 22, ;
		Left = 35, ;
		Name = "cboFavorites", ;
		RowSourceType = 0, ;
		TabIndex = 2, ;
		Top = 9, ;
		Value = 0, ;
		Width = 82, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkCustom' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Custom", ;
		ccontrolsource = lHierarchyCustom, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkCustom", ;
		TabIndex = 10, ;
		Top = 144
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkEvents' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Events", ;
		ccontrolsource = lTypeEvent, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkEvents", ;
		TabIndex = 7, ;
		Top = 90
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkFavorites' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Favorites", ;
		ccontrolsource = lFavorites, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkFavorites", ;
		TabIndex = 18, ;
		Top = 182
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkInherited' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Inherited", ;
		ccontrolsource = lHierarchyInherited, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkInherited", ;
		TabIndex = 9, ;
		Top = 128
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkMethodInherited' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Inherited Code", ;
		ccontrolsource = lMethodViewInherited, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethodInherited", ;
		TabIndex = 13, ;
		Top = 96
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkMethodLocal' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Local Code", ;
		ccontrolsource = lMethodViewLocal, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethodLocal", ;
		TabIndex = 12, ;
		Top = 78
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkMethodNoEvent' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Empty Events", ;
		ccontrolsource = lMethodViewEventNone, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethodNoEvent", ;
		TabIndex = 15, ;
		Top = 158
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkMethodNoMethod' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Empty Methods", ;
		ccontrolsource = lMethodViewMethodNone, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethodNoMethod", ;
		TabIndex = 14, ;
		Top = 140
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkMethods' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Methods", ;
		ccontrolsource = lTypeMethod, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethods", ;
		TabIndex = 6, ;
		Top = 74
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkNative' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Native", ;
		ccontrolsource = lHierarchyNative, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkNative", ;
		TabIndex = 8, ;
		Top = 112
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkProperties' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Properties", ;
		ccontrolsource = lTypeProperty, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkProperties", ;
		TabIndex = 5, ;
		Top = 58
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'choNonDefault' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Non-Default", ;
		ccontrolsource = lNonDefault, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "choNonDefault", ;
		TabIndex = 17, ;
		Top = 166
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'lblFilters' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Without Code:", ;
		Height = 16, ;
		Left = 24, ;
		Name = "lblFilters", ;
		TabIndex = 16, ;
		Top = 122, ;
		Width = 72, ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblSubString' AS baselabel WITH ;
		Caption = "Find:", ;
		Height = 16, ;
		Left = 7, ;
		Name = "lblSubString", ;
		TabIndex = 3, ;
		Top = 37, ;
		Width = 25
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'txtSubString' AS basetextbox WITH ;
		ControlSource = "Thisform.cSubString", ;
		Format = "!", ;
		Height = 21, ;
		Left = 35, ;
		lupdatecontrolsourceonchange = .T., ;
		Name = "txtSubString", ;
		SelectOnEntry = .T., ;
		TabIndex = 4, ;
		Top = 33, ;
		Width = 82
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		DoDefault ()
		Thisform.ocntFilters = This
	ENDPROC

	PROCEDURE Baselabel1.Init
		This.Caption = ' ' + ccLOC_CAP_MV_With_Code + ' '
		DoDefault()
		
	ENDPROC

	PROCEDURE Baselabel1.Refresh
		This.Visible = ThisForm.nMethodView = 2
	ENDPROC

	PROCEDURE cboFavorites.Init
		With This
			Thisform.CreateGroupCursors()
		
			.AddProperty('aRowSource(1)')
			Select *					;
				from crsr_GroupNames	;
				into Array This.aRowSource
		
			For lnI = 1 to _Tally
				.AddItem (This.aRowSource(lnI, 1))
			endfor
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cboFavorites.Refresh
		Local lnI
		DoDefault()
		
		For lnI = 1 To Floor(Alen(This.aRowSource) / 2)
			If This.aRowSource(lnI, 2) = Thisform.oPrefs.nGroupID
				This.Value = lnI
				Return
			Endif
		Endfor
		This.Value = 1
		
	ENDPROC

	PROCEDURE cboFavorites.Valid
		DoDefault()
		Thisform.oPrefs.nGroupID = This.aRowSource(This.Value, 2)
		If Between(This.Value,2,7)
			ThisForm.oPrefs.lHierarchyNative = .T.
		Endif
		Thisform.SetFilter()
		
	ENDPROC

	PROCEDURE chkCustom.Init
		This.Caption = ccLOC_CAP_CUSTOM
		DoDefault()
		
	ENDPROC

	PROCEDURE chkCustom.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lHierarchyNative		= .T.
					.oPrefs.lHierarchyInherited 	= .T.
				Else
					.oPrefs.lHierarchyNative		= .F.
					.oPrefs.lHierarchyInherited	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE chkCustom.Refresh
		DoDefault()
		
		This.Enabled = Thisform.lIsTopOfForm				;
			and Not Thisform.oMember.InteractiveChanged 	;
			and Not Thisform.oMember.IsNewMember
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE chkEvents.Init
		This.Caption = ccLOC_CAP_EVENTS
		DoDefault()
		
	ENDPROC

	PROCEDURE chkEvents.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lTypeProperty 	= .T.
					.oPrefs.lTypeMethod 	= .T.
				Else
					.oPrefs.lTypeProperty	= .F.
					.oPrefs.lTypeMethod	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE chkEvents.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE chkEvents.Valid
		*** JRN 11/16/2008 : If turning on Events, turn on 'Native' as well
		Thisform.oPrefs.lHierarchyNative = Thisform.oPrefs.lHierarchyNative or This.Value
		DoDefault()
		
	ENDPROC

	PROCEDURE chkFavorites.Init
		This.Caption = ccLOC_CAP_FAVORITES
		DoDefault()
		
	ENDPROC

	PROCEDURE chkInherited.Init
		This.Caption = ccLOC_CAP_INHERITED
		DoDefault()
		
	ENDPROC

	PROCEDURE chkInherited.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lHierarchyNative		= .T.
					.oPrefs.lHierarchyCustom	 	= .T.
				Else
					.oPrefs.lHierarchyNative		= .F.
					.oPrefs.lHierarchyCustom	 	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE chkInherited.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE chkMethodInherited.Init
		With This
			.Caption = ccLOC_CAP_MV_Inherited
		Endwith
		
		
	ENDPROC

	PROCEDURE chkMethodInherited.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		With This
			.ToolTipText = Thisform.InsertFormOrClass(ccLOC_CAP_MV_InheritedTip)
		EndWith
		
		DoDefault()
		
		
	ENDPROC

	PROCEDURE chkMethodInherited.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 2
		
	ENDPROC

	PROCEDURE chkMethodLocal.Init
		With This
			.Caption = ccLOC_CAP_MV_Local
		Endwith
		
		
	ENDPROC

	PROCEDURE chkMethodLocal.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		With This
			.ToolTipText = Thisform.InsertFormOrClass(ccLOC_CAP_MV_LocalTip)
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE chkMethodLocal.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 2
		
	ENDPROC

	PROCEDURE chkMethodNoEvent.Init
		With This
			.Caption = ccLOC_CAP_MV_NoEvent
			.ToolTipText = ccLOC_CAP_MV_NoEventTip
		Endwith
		
		
	ENDPROC

	PROCEDURE chkMethodNoEvent.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 2
	ENDPROC

	PROCEDURE chkMethodNoMethod.Init
		With This
			.Caption = ccLOC_CAP_MV_NoMethod
			.ToolTipText = ccLOC_CAP_MV_NoMethodTip
		Endwith
		
		
	ENDPROC

	PROCEDURE chkMethodNoMethod.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 2
		
	ENDPROC

	PROCEDURE chkMethods.Init
		This.Caption = ccLOC_CAP_METHODS
		DoDefault()
		
	ENDPROC

	PROCEDURE chkMethods.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lTypeProperty 	= .T.
					.oPrefs.lTypeEvent 	= .T.
				Else
					.oPrefs.lTypeProperty	= .F.
					.oPrefs.lTypeEvent 	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE chkMethods.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE chkNative.Init
		This.Caption = ccLOC_CAP_NATIVE
		DoDefault()
		
	ENDPROC

	PROCEDURE chkNative.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lHierarchyInherited	= .T.
					.oPrefs.lHierarchyCustom	 	= .T.
				Else
					.oPrefs.lHierarchyInherited	= .F.
					.oPrefs.lHierarchyCustom	 	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE chkNative.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE chkProperties.Init
		This.Caption = ccLOC_CAP_PROPERTIES
		DoDefault()
		
	ENDPROC

	PROCEDURE chkProperties.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lTypeMethod 	= .T.
					.oPrefs.lTypeEvent 	= .T.
				Else
					.oPrefs.lTypeMethod 	= .F.
					.oPrefs.lTypeEvent 	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE chkProperties.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE choNonDefault.Init
		This.Caption = ccLOC_CAP_NonDefaultPr
		DoDefault()
		
	ENDPROC

	PROCEDURE choNonDefault.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE lblFilters.Init
		This.Caption = ' ' + ccLOC_CAP_MV_None + ' '
		DoDefault()
		
	ENDPROC

	PROCEDURE lblFilters.Refresh
		This.Visible = ThisForm.nMethodView = 2
	ENDPROC

	PROCEDURE lblSubString.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_SUBSTRING
		DoDefault()
		
	ENDPROC

	PROCEDURE txtSubString.Click
		With This
			.SelStart = 0
			.SelLength = 1000
		Endwith
		
	ENDPROC

	PROCEDURE txtSubString.GotFocus
		DoDefault()
		With Thisform 
			If .oPrefs.lGridAbove
				.oSplitterV.Collapse(.F.)
			Else
				.oSplitterH.Collapse(.F.)
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE txtSubString.InteractiveChange
		Local lnSelStart
		lnSelStart = This.SelStart
		
		DoDefault()
		Thisform.SetFilter()
		
		This.SelStart = lnSelStart
		
	ENDPROC

	PROCEDURE txtSubString.KeyPress
		lparameters tnKeyCode,  tnShiftAltCtrl
		
		If tnKeyCode = 13 and tnShiftAltCtrl = 0
			Thisform.oGrid.SetFocus()
			NoDefault
		EndIf 
	ENDPROC

	PROCEDURE txtSubString.Refresh
		If Thisform.nMethodView = 1
			This.ControlSource = 'ThisForm.cSubString'
		Else
			This.ControlSource = 'ThisForm.cSubStringMV'
		Endif
		
	ENDPROC

	PROCEDURE txtSubString.RightClick
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Local loThis, lnBar, lcChoice
		loThis = This
		
		lnBar = 0
		lcChoice = ''
		Thisform.CreateContextMenu("SearchContextMenu")
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_NameContains
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'N$'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_NameStart
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'N='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_DescContains
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'D$'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_DescStart
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'D='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_ValueContains
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'V$'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_ValueStart
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'V='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_StartsUpper
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'U='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_AnyUpper
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'U$'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_StartsLower
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'L='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_AllLower
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'L$'
		
		If Not Empty(This.Value)
			lnBar = lnBar + 1
			Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_Clear
			On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'Clear'
		
		Endif
		
		****************************************************************
		****************************************************************
		
		Activate Popup SearchContextMenu
		
		Release Popups SearchContextMenu
		
		Do Case
		
			Case Empty (lcChoice)
		
			Case lcChoice = 'Clear'
				This.Value = ''
		
			Otherwise
				If Substr (This.Value,2,1) $ '=$'
					This.Value = lcChoice + Substr (This.Value,3)
				Else
					This.Value = lcChoice + This.Value
				Endif
		
		Endcase
		
		Thisform.SetFilter()
		This.SelLength = 0
		This.SelStart = Len(This.Value)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntonkeylabel AS basecontainer OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="TxtHotKey" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblInactive" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: toggledefaultvalue
		*p: cdefaultvalue
		*p: cpersistname
	*</DefinedPropArrayMethod>

	cdefaultvalue = 
	cpersistname = 
	Height = 22
	Name = "cntonkeylabel"
	Width = 150

	ADD OBJECT 'lblInactive' AS baselabel WITH ;
		Caption = "(inactive)", ;
		Left = 97, ;
		Name = "lblInactive", ;
		Top = 3, ;
		Visible = .T., ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'TxtHotKey' AS txtpreferences WITH ;
		Left = 0, ;
		Name = "TxtHotKey", ;
		Top = 0, ;
		Visible = .T., ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		DoDefault()
		
		With This.txtHotKey
			.cPersistname = This.cPersistname 
			.ToolTipText  = This.ToolTipText
			.cDefaultValue = This.cDefaultValue
		EndWith 	
		
		
	ENDPROC

	PROCEDURE toggledefaultvalue
		Lparameters llNonDefault
		Local lcDefaultValue, lcNonDefaultValue
		
		With This.txtHotKey
			lcDefaultValue = .cDefaultValue
			lcNonDefaultValue = Alltrim (Chrtran (lcDefaultValue, '*', ''))
		
			Do Case
				Case llNonDefault
					.Value = lcNonDefaultValue
				Case Pcount() = 0 And '*' $ .Value
					.Value = lcNonDefaultValue
				Otherwise
					.Value = lcDefaultValue
			Endcase
			Thisform.oCallingForm.oPersist.Set (.cPersistName, .Value)
			Thisform.oCallingForm.GetSettings()
		Endwith
		
		This.lblInactive.Refresh()
		
		
		
	ENDPROC

	PROCEDURE lblInactive.Refresh
		This.Visible = '*' $ This.Parent.txtHotKey.Value
		
	ENDPROC

	PROCEDURE TxtHotKey.DblClick
		This.Parent.ToggleDefaultValue()
	ENDPROC

	PROCEDURE TxtHotKey.Valid
		With Thisform.oCallingForm
			.UnSetOnKeyLabels()
		Endwith
		
		DoDefault()
		
		This.Parent.lblInactive.Refresh()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntpemcommands AS basecontainer OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialogenglish.h"
	*<DefinedPropArrayMethod>
		*p: npagenumber
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Name = "cntpemcommands"
	npagenumber = 1
	_memberdata = <VFPData>
		<memberdata name="npagenumber" display="nPageNumber"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Refresh
		Do Case
			Case Thisform.oMember.IsNewMember
				lnPage = 4
			Case Thisform.oMember.InteractiveChanged
				lnPage = 3
			Case 'O' = Vartype(Thisform.oObject)
				lnPage = 2
			Otherwise
				lnPage = 1
		Endcase
		
		If lnPage = This.nPageNumber
			This.ZOrder(0)
		EndIf 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntpemcontrols AS basecontainer OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cntDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.edtDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblnnn255" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblBufferOverruns" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblVisibility" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboVisibility" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAccess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAssign" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboFavorites" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oSplitter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntNothing" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntAdd.cmdApplyAndAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntAdd.cmdRevert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntAdd.cmdApplyAndEdit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntAdd.lblAddMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntNormal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntNormal.cmdAddMethod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntNormal.cmdAddProperty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntNormal.cmdRemove" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntNormal.cmdResetFilters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntEdit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntEdit.cmdApply" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntEdit.lblEditMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntCommandButtons.cntEdit.Basecommandbutton1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: validatepossiblechanges
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Height = 260
	Name = "cntpemcontrols"
	nanchor = 14
	Width = 347
	_memberdata = <VFPData>
		<memberdata name="validatepossiblechanges" display="ValidatePossibleChanges"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		Alignment = 1, ;
		Caption = "Favorites:", ;
		Height = 16, ;
		Left = 78, ;
		Name = "Baselabel1", ;
		nanchor = 4, ;
		TabIndex = 10, ;
		Top = 164, ;
		Width = 50, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cboFavorites' AS basecombobox WITH ;
		ColumnCount = 2, ;
		ColumnWidths = "50,165", ;
		ControlSource = "ThisForm.oMember.nFavorites", ;
		Left = 135, ;
		Name = "cboFavorites", ;
		nanchor = 4, ;
		RowSourceType = 0, ;
		TabIndex = 11, ;
		Top = 160, ;
		Value = 0, ;
		Width = 80, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboVisibility' AS basecombobox WITH ;
		ControlSource = "ThisForm.oMember.nVisibility", ;
		Left = 134, ;
		Name = "cboVisibility", ;
		nanchor = 4, ;
		RowSourceType = 0, ;
		TabIndex = 13, ;
		Top = 185, ;
		Value = 0, ;
		Width = 80, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkAccess' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Access", ;
		ControlSource = "ThisForm.oMember.lAccess", ;
		Left = 12, ;
		lupdatecontrolsourceonchange = .F., ;
		Name = "chkAccess", ;
		nanchor = 4, ;
		TabIndex = 8, ;
		Top = 164, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkAssign' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Assign", ;
		ControlSource = "ThisForm.oMember.lAssign", ;
		Left = 12, ;
		lupdatecontrolsourceonchange = .F., ;
		Name = "chkAssign", ;
		nanchor = 4, ;
		TabIndex = 9, ;
		Top = 188, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntCommandButtons' AS basecontainer WITH ;
		BorderWidth = 0, ;
		Height = 30, ;
		Left = 0, ;
		Name = "cntCommandButtons", ;
		nanchor = 14, ;
		TabIndex = 15, ;
		Top = 213, ;
		Visible = .T., ;
		Width = 349, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntCommandButtons.cntAdd' AS cntpemcommands WITH ;
		BackStyle = 1, ;
		Height = 30, ;
		Left = 0, ;
		Name = "cntAdd", ;
		nanchor = 10, ;
		npagenumber = 4, ;
		Top = 0, ;
		Width = 347, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="container" />

	ADD OBJECT 'cntCommandButtons.cntAdd.cmdApplyAndAdd' AS basecommandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Add", ;
		Height = 25, ;
		Left = 78, ;
		Name = "cmdApplyAndAdd", ;
		nanchor = 4, ;
		TabIndex = 18, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 51, ;
		ZOrderSet = 25
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntAdd.cmdApplyAndEdit' AS basecommandbutton WITH ;
		Caption = "Save, then Edit Method", ;
		Height = 25, ;
		Left = 207, ;
		Name = "cmdApplyAndEdit", ;
		nanchor = 4, ;
		TabIndex = 22, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 132, ;
		ZOrderSet = 27
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntAdd.cmdRevert' AS basecommandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Abandon", ;
		Height = 25, ;
		Left = 138, ;
		Name = "cmdRevert", ;
		nanchor = 4, ;
		TabIndex = 20, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 60, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntAdd.lblAddMode' AS baselabel WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		Caption = "Add Mode", ;
		FontBold = .T., ;
		Height = 16, ;
		Left = 10, ;
		Name = "lblAddMode", ;
		nanchor = 4, ;
		TabIndex = 13, ;
		Top = 9, ;
		Visible = .F., ;
		Width = 57, ;
		ZOrderSet = 28
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntCommandButtons.cntEdit' AS cntpemcommands WITH ;
		BackStyle = 1, ;
		Height = 30, ;
		Left = 0, ;
		Name = "cntEdit", ;
		nanchor = 10, ;
		npagenumber = 3, ;
		Top = 0, ;
		Width = 347, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="container" />

	ADD OBJECT 'cntCommandButtons.cntEdit.Basecommandbutton1' AS basecommandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Abandon", ;
		Height = 25, ;
		Left = 138, ;
		Name = "Basecommandbutton1", ;
		nanchor = 4, ;
		TabIndex = 20, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 60, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntEdit.cmdApply' AS basecommandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Apply", ;
		Default = .F., ;
		Height = 25, ;
		Left = 79, ;
		Name = "cmdApply", ;
		nanchor = 4, ;
		TabIndex = 17, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 51, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntEdit.lblEditMode' AS baselabel WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		Caption = "Edit Mode", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 11, ;
		Name = "lblEditMode", ;
		nanchor = 4, ;
		TabIndex = 13, ;
		Top = 9, ;
		Visible = .F., ;
		Width = 57, ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntCommandButtons.cntNormal' AS cntpemcommands WITH ;
		BackStyle = 1, ;
		Height = 30, ;
		Left = 0, ;
		Name = "cntNormal", ;
		nanchor = 10, ;
		npagenumber = 2, ;
		Top = 0, ;
		Width = 347, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="container" />

	ADD OBJECT 'cntCommandButtons.cntNormal.cmdAddMethod' AS basecommandbutton WITH ;
		AutoSize = .T., ;
		Caption = "Add Method", ;
		Height = 25, ;
		Left = 77, ;
		Name = "cmdAddMethod", ;
		nanchor = 4, ;
		TabIndex = 21, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 74, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntNormal.cmdAddProperty' AS basecommandbutton WITH ;
		AutoSize = .T., ;
		Caption = "Add Prop.", ;
		Height = 25, ;
		Left = 7, ;
		Name = "cmdAddProperty", ;
		nanchor = 4, ;
		TabIndex = 19, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 64, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntNormal.cmdRemove' AS basecommandbutton WITH ;
		AutoSize = .T., ;
		Caption = "Remove", ;
		Height = 25, ;
		Left = 157, ;
		Name = "cmdRemove", ;
		nanchor = 4, ;
		TabIndex = 23, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 55, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntNormal.cmdResetFilters' AS basecommandbutton WITH ;
		AutoSize = .T., ;
		Caption = "Reset Filters", ;
		FontSize = 8, ;
		Height = 25, ;
		Left = 238, ;
		Name = "cmdResetFilters", ;
		nanchor = 12, ;
		TabIndex = 24, ;
		Top = 3, ;
		Visible = .F., ;
		Width = 76, ;
		ZOrderSet = 19
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntCommandButtons.cntNothing' AS cntpemcommands WITH ;
		BackStyle = 1, ;
		Height = 30, ;
		Left = 0, ;
		Name = "cntNothing", ;
		nanchor = 10, ;
		Top = 0, ;
		Width = 347, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="container" />

	ADD OBJECT 'cntDescription' AS basecontainer WITH ;
		Height = 52, ;
		Left = 5, ;
		Name = "cntDescription", ;
		nanchor = 15, ;
		TabIndex = 7, ;
		Top = 104, ;
		Width = 210, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntDescription.edtDescription' AS editpropertyeditbox WITH ;
		Height = 36, ;
		IntegralHeight = .F., ;
		Left = 0, ;
		Name = "edtDescription", ;
		nanchor = 15, ;
		SelectOnEntry = .F., ;
		TabIndex = 14, ;
		Top = 16, ;
		Width = 210, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="editbox" />

	ADD OBJECT 'cntDescription.lblBufferOverruns' AS baselabel WITH ;
		AutoSize = .F., ;
		Caption = "Description", ;
		Height = 48, ;
		Left = 3, ;
		Name = "lblBufferOverruns", ;
		TabIndex = 13, ;
		Top = 1, ;
		Visible = .F., ;
		Width = 200, ;
		WordWrap = .T., ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntDescription.lblDescription' AS baselabel WITH ;
		Caption = "Description", ;
		Left = 3, ;
		Name = "lblDescription", ;
		TabIndex = 13, ;
		Top = 1, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntDescription.lblnnn255' AS baselabel WITH ;
		Caption = "0/254", ;
		Height = 16, ;
		Left = 127, ;
		Name = "lblnnn255", ;
		TabIndex = 13, ;
		Top = 1, ;
		Width = 29, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'edtDefault' AS defaulteditbox WITH ;
		Height = 36, ;
		IntegralHeight = .F., ;
		Left = 5, ;
		luseintellisensex = .T., ;
		Name = "edtDefault", ;
		nanchor = 10, ;
		TabIndex = 6, ;
		Top = 64, ;
		Width = 210, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblDefault' AS baselabel WITH ;
		Caption = "Value", ;
		Left = 7, ;
		Name = "lblDefault", ;
		TabIndex = 5, ;
		Top = 48, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblname' AS baselabel WITH ;
		Caption = "Name:", ;
		Height = 16, ;
		Left = 6, ;
		Name = "lblname", ;
		TabIndex = 1, ;
		Top = 8, ;
		Width = 32, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblType' AS baselabel WITH ;
		Caption = "Type:", ;
		Height = 16, ;
		Left = 6, ;
		Name = "lblType", ;
		TabIndex = 3, ;
		Top = 30, ;
		Width = 29, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblVisibility' AS baselabel WITH ;
		Caption = "Visibility:", ;
		Height = 16, ;
		Left = 89, ;
		Name = "lblVisibility", ;
		nanchor = 4, ;
		TabIndex = 12, ;
		Top = 189, ;
		Width = 44, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Line1' AS baseline WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line1", ;
		nanchor = 14, ;
		Top = 213, ;
		Width = 365, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="line" />

	ADD OBJECT 'opgType' AS baseoptiongroup WITH ;
		ButtonCount = 2, ;
		Height = 25, ;
		Left = 55, ;
		Name = "opgType", ;
		TabIndex = 4, ;
		Top = 25, ;
		Width = 162, ;
		ZOrderSet = 11, ;
		Baseoptionbutton1.AutoSize = .T., ;
		Baseoptionbutton1.Caption = "Property", ;
		Baseoptionbutton1.Height = 16, ;
		Baseoptionbutton1.Left = 5, ;
		Baseoptionbutton1.Name = "Baseoptionbutton1", ;
		Baseoptionbutton1.Style = 0, ;
		Baseoptionbutton1.Top = 5, ;
		Baseoptionbutton1.Width = 59, ;
		Baseoptionbutton2.AutoSize = .T., ;
		Baseoptionbutton2.Caption = "Method", ;
		Baseoptionbutton2.Height = 16, ;
		Baseoptionbutton2.Left = 91, ;
		Baseoptionbutton2.Name = "Baseoptionbutton2", ;
		Baseoptionbutton2.Style = 0, ;
		Baseoptionbutton2.Top = 5, ;
		Baseoptionbutton2.Width = 53
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'oSplitter' AS peme_sfsplitterv WITH ;
		BackColor = 192,192,192, ;
		BackStyle = 1, ;
		cobject1name = edtDefault, ;
		cobject2name = cntDescription, ;
		Height = 6, ;
		Left = 5, ;
		Name = "oSplitter", ;
		nanchor = 10, ;
		nobject1minsize = 20, ;
		nobject2minsize = 36, ;
		TabIndex = 14, ;
		Top = 98, ;
		Width = 210, ;
		ZOrderSet = 13, ;
		gripperhor.Height = 5, ;
		gripperhor.Name = "gripperhor", ;
		gripperhor.Width = 21, ;
		gripperver.Height = 21, ;
		gripperver.Name = "gripperver", ;
		gripperver.Width = 5, ;
		ImgDownArrow.Height = 21, ;
		ImgDownArrow.Name = "ImgDownArrow", ;
		ImgDownArrow.Width = 21, ;
		imgUpArrow.Height = 21, ;
		imgUpArrow.Name = "imgUpArrow", ;
		imgUpArrow.Width = 21, ;
		ImgRightArrow.Height = 17, ;
		ImgRightArrow.Name = "ImgRightArrow", ;
		ImgRightArrow.Width = 17, ;
		ImgLeftArrow.Height = 17, ;
		ImgLeftArrow.Name = "ImgLeftArrow", ;
		ImgLeftArrow.Width = 17
		*< END OBJECT: ClassLib="peme_sfsplitter.vcx" BaseClass="control" />

	ADD OBJECT 'txtName' AS basetextbox WITH ;
		ControlSource = "ThisForm.oMember.cName", ;
		DisabledForeColor = 0,0,0, ;
		Format = "T", ;
		Height = 22, ;
		Left = 61, ;
		Name = "txtName", ;
		nanchor = 10, ;
		TabIndex = 2, ;
		Top = 4, ;
		Width = 155, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE Refresh
		This.Visible = Thisform.lPEMEditor and not (ThisForm.osplitterH.lCollapsed or ThisForm.osplitterV.lCollapsed)
		This.Enabled = ThisForm.lFormIsEnabled
	ENDPROC

	PROCEDURE validatepossiblechanges
		Local lcMsg, lcPemName, lcPrompt, lcWindowName, lnResult
		lcPemName = Thisform.JustPEM (Thisform.oMember.cName)
		
		If Thisform.oMember.cType $ 'ME'
			lcWindowName = Thisform.oObject.Name + '.' + Thisform.cOriginalName
			If Wvisible (lcWindowName)
				lcPrompt = Strtran (ccLOC_CAP_Apply_Open, 'PEM_Name_Place_Holder', lcWindowName)
				lnResult = Messagebox (lcPrompt, 1 + 32 + 256, Thisform.Caption)
				If lnResult # 1
					Return .F.
				Endif
			Endif
		
		Else
			If Thisform.oOriginalMember.lAccess And Not Thisform.oMember.lAccess
				lcPrompt = Strtran (ccLOC_CAP_REMOVE_ACCESS, 'PEM_Name_Place_Holder', lcPemName)
				lnResult = Messagebox (lcPrompt, 4 + 32, Thisform.Caption)
				If lnResult = 7
					Return .F.
				Endif
			Endif
		
			If Thisform.oOriginalMember.lAssign And Not Thisform.oMember.lAssign
				lcPrompt = Strtran (ccLOC_CAP_REMOVE_ASSIGN, 'PEM_Name_Place_Holder', lcPemName)
				lnResult = Messagebox (lcPrompt, 4 + 32, Thisform.Caption)
				If lnResult = 7
					Return .F.
				Endif
			Endif
		
		Endif
		
		If (Thisform.oOriginalMember.lNative Or Thisform.oOriginalMember.lInherited)		;
				And Thisform.oOriginalMember.nVisibility > 1 And Thisform.oMember.nVisibility = 1
			lcMsg = 'Unable to change visibility back to Public'
			lcMsg = lcMsg + CRLF + CRLF + 'To do so, follow these steps:'
			lcMsg = lcMsg + CRLF + '  1) Open the right-click context menu on the combobox'
			lcMsg = lcMsg + CRLF + "  2) Select 'FP default Edit Property/Method...'"
			lcMsg = lcMsg + CRLF + '  3) Close PEM Editor'
			lcMsg = lcMsg + CRLF + "  4) Select 'Edit Property/Method...'"
			lcMsg = lcMsg + CRLF + "        from the " + IIF(Thisform.lClass, 'Class', 'Form') + " sub-menu of the VFP Main Menu"
		
			Messagebox (lcMsg)
		Endif
		
		Return Thisform.CheckForNewProperty(This.edtDefault.Value, ThisForm.oMember.cName, Thisform.oObject, Thisform.oTopOfForm)
		
	ENDPROC

	PROCEDURE Baselabel1.Init
		This.Caption = ccLOC_CAP_FAVORITES2
		DoDefault()
		
	ENDPROC

	PROCEDURE cboFavorites.Init
		With This
			.AddItem(ccLOC_Cap_Fav_None)
			.List (.NewItemId, 2)	= ccLOC_Cap_Fav_None2
		
			.AddItem(ccLOC_Cap_Fav_Local)
			.List (.NewItemId, 2)	= ccLOC_Cap_Fav_Local2
		
			.AddItem(ccLOC_Cap_Fav_Global)
			.List (.NewItemId, 2)	= ccLOC_Cap_Fav_Global2
		
			.AddItem(ccLOC_Cap_Fav_Both)
			.List (.NewItemId, 2)	= ccLOC_Cap_Fav_Both2
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cboFavorites.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE cboFavorites.Refresh
		This.Enabled = Thisform.NotEmptyGrid() 							;
			and (Thisform.lIsTopOfForm Or Thisform.oMember.IsNewMember) ;
			and Thisform.nSelectedObjects =1
		
		This.List(2) = Iif (Thisform.UseMemberData(), '', '\') + ccLOC_Cap_Fav_Local
		
	ENDPROC

	PROCEDURE cboVisibility.Init
		WITH This
		  .AddItem(ccLOC_STR_PUBLIC)
		  .AddItem(ccLOC_CAP_Vis_Protected)
		  .AddItem(ccLOC_CAP_Vis_Hidden)
		ENDWITH 
		
		DoDefault()
	ENDPROC

	PROCEDURE cboVisibility.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE cboVisibility.Refresh
		Local lbOK
		
		lbOK = PEME_IsVersion9()		;
			And Thisform.lClass
		
		This.Enabled = lbOK								;
			And Vartype (Thisform.oObject) = 'O'		;
			And Thisform.nSelectedObjects = 1			;
			And Thisform.lIsTopOfForm
		
		This.Visible = lbOK
		
		
		
	ENDPROC

	PROCEDURE chkAccess.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_ACCESS
		DoDefault()
		
	ENDPROC

	PROCEDURE chkAccess.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE chkAccess.Refresh
		This.Enabled = Thisform.NotEmptyGrid() 							;
			and Vartype(Thisform.oObject) = 'O' 						;
			and Thisform.nSelectedObjects = 1							;
			and Thisform.oMember.cType = 'P'							;
			and (Thisform.lIsTopOfForm Or Thisform.oMember.IsNewMember)
		
	ENDPROC

	PROCEDURE chkAssign.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_ASSIGN
		DoDefault()
		
	ENDPROC

	PROCEDURE chkAssign.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE chkAssign.Refresh
		This.Enabled = Thisform.NotEmptyGrid() 							;
			and vartype(Thisform.oObject) = 'O' 						;
			and Thisform.oMember.cType = 'P'							;
			and (thisform.lIsTopOfForm or Thisform.oMember.IsNewMember)	;
			and Thisform.nSelectedObjects =1
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdApplyAndAdd.Click
		With Thisform
			.ApplyChanges()
			.AddNew()
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdApplyAndAdd.Init
		With This
			.Caption = ccLOC_CAP_Apply_And_Add
			.ToolTipText = ccLOC_TIP_Apply_And_Add
		EndWith 
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdApplyAndAdd.Refresh
		With This
			If Thisform.oMember.IsNewMember
				.Visible = .T.
				.Enabled = Thisform.oMember.InteractiveChanged 							;
					and ccMaxDescriptionLength >= Len (Thisform.GetDescriptionValue())	;
					and Not Empty (Thisform.otxtName.Value)
			Else
				.Visible = .F.
				.Enabled = .F.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdApplyAndEdit.Click
		With Thisform
			lcMethodName = Thisform.oMember.cName
			.ApplyChanges()
			.AddNew()
			.EditMethodCode(lcMethodName, Thisform.oTopOfForm)
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdApplyAndEdit.Init
		With This
			.Caption = ccLOC_CAP_Apply_And_Edit
			.ToolTipText = ccLOC_TIP_Apply_And_Edit
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdApplyAndEdit.Refresh
		With This
			If Thisform.oMember.IsNewMember ;
					And Not Thisform.oObjectTree.lCombotreeOpen
				.Enabled = Thisform.oMember.InteractiveChanged 							;
					and ccMaxDescriptionLength >= Len (Thisform.GetDescriptionValue())	;
					and Not Empty (Thisform.otxtName.Value)					;
					and Thisform.oMember.cType = 'M'
				.Visible = .Enabled
			Else
				.Visible = .F.
				.Enabled = .F.
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdRevert.Click
		With Thisform
			.RevertChanges()
		EndWith 
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdRevert.Init
		DoDefault()
		With This
			.AddProperty('nOriginalWidth', .Width)
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.cmdRevert.Refresh
		Local lnAnchor
		With This
			lnAnchor = .Anchor
			.Anchor = 0
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .T.
					.Enabled = .T.
					If Thisform.oMember.InteractiveChanged
						.Caption = ccLOC_CAP_Cancel1
						.Width   = .nOriginalWidth
					Else
						.Caption = ccLOC_CAP_CancelAdd
						.Width   = .nOriginalWidth + 52
					Endif
				Case Thisform.oMember.InteractiveChanged
					.Visible = .T.
					.Enabled = .T.
					.Caption = ccLOC_CAP_CancelEdit
					.Width   = .nOriginalWidth + 52
				Otherwise
					.Visible = .F.
					.Enabled = .F.
			Endcase
			.Anchor = lnAnchor
		Endwith
		
		
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.lblAddMode.Init
		* Set the caption to a localized string.
		
		*	This.Caption = ccLOC_CAP_DEFAULT_VALUE
		DoDefault()
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntAdd.lblAddMode.Refresh
		With This
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .T.
					.Enabled = .T.
				Otherwise 
					.Visible = .F.
					.Enabled = .F.
			Endcase
		Endwith
		
		
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntEdit.Basecommandbutton1.Click
		With Thisform
			.RevertChanges()
		EndWith 
	ENDPROC

	PROCEDURE cntCommandButtons.cntEdit.Basecommandbutton1.Init
		DoDefault()
		With This
			.AddProperty('nOriginalWidth', .Width)
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntEdit.Basecommandbutton1.Refresh
		Local lnAnchor
		With This
			lnAnchor = .Anchor
			.Anchor = 0
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .T.
					.Enabled = .T.
					If Thisform.oMember.InteractiveChanged
						.Caption = ccLOC_CAP_Cancel1
						.Width   = .nOriginalWidth
					Else
						.Caption = ccLOC_CAP_CancelAdd
						.Width   = .nOriginalWidth + 52
					Endif
				Case Thisform.oMember.InteractiveChanged
					.Visible = .T.
					.Enabled = .T.
					.Caption = ccLOC_CAP_CancelEdit
					.Width   = .nOriginalWidth + 52
				Otherwise
					.Visible = .F.
					.Enabled = .F.
			Endcase
			.Anchor = lnAnchor
		Endwith
		
		
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntEdit.cmdApply.Click
		If Not This.Parent.Parent.Parent.ValidatePossibleChanges()
			Return
		Endif
		
		With Thisform
			.ApplyChanges()
			With .oGrid
				.SetFocus()
				.ncurrentrecno = Recno()
			Endwith
			.SetProperties()
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntEdit.cmdApply.Init
		With this
			.Caption = ccLOC_CAP_APPLY
			.ToolTipText = ccLOC_TIP_Apply_And_Add
		Endwith
		DoDefault()
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntEdit.cmdApply.Refresh
		With This
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .F.
					.Enabled = .F.
				Case Thisform.oMember.InteractiveChanged
					.Visible = .T.
					.Enabled = ccMaxDescriptionLength >= Len (Thisform.GetDescriptionValue())	;
						and Not Empty (Thisform.otxtName.Value)
				Otherwise
					.Visible = .F.
					.Enabled = .F.
			Endcase
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntEdit.lblEditMode.Init
		* Set the caption to a localized string.
		
		* This.Caption = ccLOC_CAP_DEFAULT_VALUE
		DoDefault()
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntEdit.lblEditMode.Refresh
		With This
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .F.
					.Enabled = .F.
				Case Thisform.oMember.InteractiveChanged
					.Visible = .T.
					.Enabled = .T.
				Otherwise 
					.Visible = .F.
					.Enabled = .F.
			Endcase
		Endwith
		
		
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdAddMethod.Click
		If Thisform.oMember.IsNewMember
			Thisform.ApplyChanges()
		Endif
		
		ThisForm.AddNew('M')
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdAddMethod.Init
		This.Caption = ccLOC_CAP_NEW_Method
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdAddMethod.Refresh
		With This
			If Thisform.oMember.IsNewMember or ThisForm.oMember.InteractiveChanged
				.Visible = .F.
				.Enabled = .F.
			Else
				.Visible = .T.
				.Enabled = .T.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdAddProperty.Click
		ThisForm.AddNew('P')
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdAddProperty.Init
		This.Caption = ccLOC_CAP_NEW_Property
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdAddProperty.Refresh
		With This
			If Thisform.oMember.IsNewMember or ThisForm.oMember.InteractiveChanged
				.Visible = .F.
				.Enabled = .F.
			Else
				.Visible = .T.
				.Enabled = .T.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdRemove.Click
		Thisform.removeMember( Thisform.JustPem( ThisForm.oOriginalMember.cName ), .F., .T. )
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdRemove.Init
		This.Caption = ccLOC_CAP_REMOVE
		
		DoDefault()
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdRemove.Refresh
		With This
			If Thisform.oMember.IsNewMember or ThisForm.oMember.InteractiveChanged
				.Visible = .F.
				.Enabled = .F.
			Else
				.Visible = .T.
				.Enabled = Thisform.NotEmptyGrid() 				;
					and Vartype(Thisform.oObject) = 'O' 		;
					and Not Thisform.oOriginalMember.lNative 	;
					and Not Thisform.oOriginalMember.lInherited ;
					and Not Thisform.lCollapsed					;
					and Thisform.nSelectedObjects = 1
		
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdResetFilters.Click
		With ThisForm
			.GetPutFilterDefaults(.T.)
			.cSubString	= ''
			.cSubStringMV = ''
			.SetFilter()
			.Refresh()
		EndWith 
		
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdResetFilters.Init
		This.Caption = ccLOC_CAP_Reset_Filters
		
		DoDefault()
	ENDPROC

	PROCEDURE cntCommandButtons.cntNormal.cmdResetFilters.Refresh
		With This
			Do Case
				Case Thisform.oMember.IsNewMember 				;
						Or Thisform.oMember.InteractiveChanged 	;
						Or Isnull(Thisform.oObject)				;
						or Thisform.oObjectTree.lCombotreeOpen
					.Visible = .F.
					.Enabled = .F.
				Case Thisform.lFilterInEffect
					.Visible = .T.
					.Enabled = .T.
					.ForeColor = Rgb(255,0,0)
					.FontBold = .T.
				Otherwise
					.Visible = .T.
					.Enabled = .F.
					.ForeColor = Rgb(0,0,0)
					.FontBold = .F.
			Endcas
		Endwith
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.Init
		DoDefault()
		Thisform.oedtDescription = this
		This.ToolTipText = ccLOC_Tip_Description
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE cntDescription.edtDescription.KeyPress
		* Don't allow a CR.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = 13 and not Thisform.lAllowDescriptionCRs 
			Declare Integer MessageBeep In Win32API Integer wType
			MessageBeep(MB_ICONSTOP)
			nodefault
		else
			dodefault(tnKeyCode, tnShiftAltCtrl)
		endif tnKeyCode = 13 and not Thisform.lAllowDescriptionCRs 
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.Refresh
		If Thisform.lDocTreeView
			Return
		EndIf 
		
		With This
			If .lFirstTime
				.lFirstTime = .F.
				.FontName	= Nvl(Thisform.oPersist.Get('DescriptionFontName'), ccFontSizeName)
				.FontSize	= Nvl(Thisform.oPersist.Get('DescriptionFontSize'), Thisform.nFontSize)
			Endif
		Endwith
		
		With This
		
			*** JRN 12/01/2008 : conditionally replace CRs with \n
			If Thisform.lAllowDescriptionCRs
				This.Value = Strtran(Thisform.oMember.cDescript, "\n", ccCRLF)
			Else
				This.Value = Thisform.oMember.cDescript
			Endif
		
			*** DougHennig 11/23/2008: also disabled for _MemberData
			***	If Thisform.oMember.lNative Or Thisform.oMember.lInherited
			If (Not PEME_IsVersion9())								;
					or(Not Thisform.NotEmptyGrid()) 			;
					Or Thisform.oMember.lNative 				;
					Or Thisform.oMember.lInherited Or 			;
					upper(Thisform.oMember.cName) = '_MEMBERDATA'
		
				.ReadOnly	= .T.
				.BackColor 	= .DisabledBackColor
		
			Else
		
				.ReadOnly	= .F.
				.BackColor	= Rgb (255,255,255)
		
			Endif
		
		Endwith
		
		This.Visible = Not Thisform.lAvoidBufferOverrun
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.RightClick
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Local loThis, lnBar, loThisForm
		loThisForm = Thisform
		loThis = This
		
		lnBar = 0
		Thisform.CreateContextMenu("EditContextMenu")
		
		*!* * Removed 07/12/2011 
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_undo Of EditContextMenu Prompt ccLOC_MENU_UNDO ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_undo) ;
		*!* 	PictRes _Med_undo
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_cut Of EditContextMenu Prompt ccLOC_MENU_CUT ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_cut) ;
		*!* 	PictRes _Med_cut
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_copy Of EditContextMenu Prompt ccLOC_MENU_COPY ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_copy) ;
		*!* 	PictRes _Med_copy
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_paste Of EditContextMenu Prompt ccLOC_MENU_PASTE ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_paste) ;
		*!* 	PictRes _Med_paste
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_clear Of EditContextMenu Prompt ccLOC_MENU_CLEAR ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_clear) ;
		*!* 	PictRes _Med_clear
		
		*!* lnBar = lnBar + 1
		*!* Define Bar 6 Of EditContextMenu Prompt "\-"
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_slcta Of EditContextMenu Prompt ccLOC_MENU_SELECT_ALL ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_slcta) ;
		*!* 	PictRes _Med_slcta
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CAP_FONT
		On Selection Bar (lnBar) Of EditContextMenu loThis.SetFont()
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMG_PREFERENCES
		*!*	On Selection Bar (lnBar) Of EditContextMenu loThisForm.Preferences()
		
		Activate Popup EditContextMenu
		
		Release Popups EditContextMenu
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.setfont
		Local lcFont, laLines(1), lcFontName, lcFontSize
		
		lcFont = Getfont (This.FontName, This.FontSize)
		
		If Empty (lcFont)
			Return
		Endif
		
		Alines (laLines, lcFont, .T., ',')
		This.FontName 	= laLines(1)
		This.FontSize 	= Val (laLines(2))
		
		With Thisform
			.oPersist.Set('DescriptionFontName', This.FontName)
			.oPersist.Set('DescriptionFontSize', This.FontSize)
		Endwith
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.validation
		*** JRN 12/01/2008 : replace \n with CR
		
		Thisform.oMember.cDescript = Strtran(This.Value, ccCRLF, "\n")
		
		
	ENDPROC

	PROCEDURE cntDescription.lblBufferOverruns.Init
		* Set the caption to a localized string.
		
		With This
			.Caption = ccLOC_Pref_Tip_Buffer_OverRuns_Unavailable
			.FontItalic = .T.
		EndWith 
		
	ENDPROC

	PROCEDURE cntDescription.lblBufferOverruns.Refresh
		This.Visible = Thisform.lAvoidBufferOverrun
	ENDPROC

	PROCEDURE cntDescription.lblDescription.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_DESCRIPTION
		
	ENDPROC

	PROCEDURE cntDescription.lblDescription.Refresh
		This.Visible = Not Thisform.lAvoidBufferOverrun
	ENDPROC

	PROCEDURE cntDescription.lblnnn255.Refresh
		Local lnLength
		With This
		
			If (Not PEME_IsVersion9())								;
					or (Not Thisform.NotEmptyGrid()) 			;
					Or Thisform.oMember.lNative 				;
					Or Thisform.oMember.lInherited 				;
					Or Upper(Thisform.oMember.cName) = '_MEMBERDATA'
				.Caption = ''
			Else
				lnLength = Len (Thisform.GetDescriptionValue())
				.Caption = Transform (lnLength) + [/ccMaxDescriptionLength]
				.Visible = lnLength >= 128
				.FontBold = lnLength >= 200
				.ForeColor = Iif(lnLength <= ccMaxDescriptionLength, Rgb(0,0,0), Rgb(255,0,0))
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE edtDefault.Init
		Thisform.oedtDefault = This
		DoDefault()
		
	ENDPROC

	PROCEDURE edtDefault.InteractiveChange
		with Thisform
			.oMember.DefaultChanged = .T.
			.MemberChanged()
			if .oMember.cType = 'P'
				.oMember.lNonDefault = .T.
			endif .oMember.cType = 'P'
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE edtDefault.LostFocus
		*  Thisform.CheckForNewProperty(This.Value, ThisForm.oMember.cName, Thisform.oObject, Thisform.oTopOfForm)
		
		DoDefault()
		
	ENDPROC

	PROCEDURE edtDefault.Refresh
		With This
			If .lFirstTime
				.lFirstTime = .F.
				.FontName	= Nvl(Thisform.oPersist.Get('DefaultFontName'), ccFontSizeName)
				.FontSize	= Nvl(Thisform.oPersist.Get('DefaultFontSize'), Thisform.nFontSize)
			Endif
		Endwith
		
		Local lcPEM, lcValue, lxValue, lnRed, lnGreen, lnBlue, loValue
		
		With Thisform
			lcPEM = .JustPEM(.oMember.cName)
			With This
				.Value         = ''
				.xValue		   = ''
				.Enabled       = .F.
				.ReadOnly      = .F.
				.ForeColor     = Rgb(0, 0, 0)
				.BackColor     = Rgb(255, 255, 255)
				.SelectOnEntry = .F.
			Endwith
		
			Do Case
		
				Case Isnull(Thisform.oObject)
		
					*** JRN 04/14/2010 : refusing to allow entry to these
				Case Inlist (lcPEM, 'HeaderClass', 'HeaderClassLibrary', 'MemberClass', 'MemberClassLibrary')
					loValue = Thisform.GetValue(lcPEM, lNative, 'For Editing', Thisform.nObjNumber)
					lcValue = loValue.CharValue
					If loValue.Type = 'N' And '-' $ lcValue
						lcValue = Alltrim (Transform (loValue.Value))
					Endif
					With This
						.Value		= lcValue
						.Enabled	= .T.
						.ReadOnly	= .T.
						.ForeColor	= Rgb(0,0,0) && .DisabledForeColor
						.BackColor 	= .DisabledBackColor
					Endwith
		
					* Do nothing if we're resetting to default.
				Case .oMember.cType # 'P' And .oMember.ResetToDefault
		
					* If this was and is a property, handle it. Note the special handling for colors.
				Case .oMember.cType = 'P' And Thisform.oOriginalMember.cType = 'P'
		
					loValue = Thisform.GetValue(lcPEM, lNative, 'For Editing', Thisform.nObjNumber)
					lcValue = loValue.CharValue
					If loValue.Type = 'N' And '-' $ lcValue
						lcValue = Alltrim (Transform (loValue.Value))
					Endif
		
					* Enable the control if if we're not sitting on an object or an array.
		
					If Vartype(lcValue) <> 'O' 				;
							and	Not '[' $ .oMember.cName 	;
							and Not '(' $ .oMember.cName
						This.Value		   = lcValue
						This.Enabled 	   = .T.
						This.SelectOnEntry = .T.
						*** JRN 12/01/2008 : enable unless read-only
						This.ReadOnly	  =	.oMember.lReadOnly
					Endif Vartype(lcValue) <> 'O' ...
		
					* For properties, this is enabled and should select on entry.
		
				Case .oMember.cType = 'P'
					This.Enabled       = .T.
					This.SelectOnEntry = .T.
		
					* For members that were and are methods or events, this is enabled and should
					* select on entry.
		
				Case .oMember.cType $ [ME] And Thisform.oOriginalMember.cType $ [ME]
					Try
						lcValue = .oObject.ReadMethod(lcPEM)
						With This
							.Value		= lcValue
							.Enabled	= .T.
							.ReadOnly	= .T.
							.ForeColor	= Rgb(0,0,0) && .DisabledForeColor
							.BackColor 	= .DisabledBackColor
						Endwith
					Catch
					Endtry
				Case Thisform.oMember.cType $ [ME]
					With This
						.Enabled	= .T.
						.ReadOnly	= .T.
						.ForeColor	= Rgb(0,0,0) && .DisabledForeColor
						.BackColor 	= .DisabledBackColor
					Endwith
			Endcase
			This.SetXValue()
		Endwith
		
	ENDPROC

	PROCEDURE edtDefault.RightClick
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Local lcChoice, lnBar, loThis, loThisForm
		loThisForm = Thisform
		loThis	   = This
		
		lnBar	 = 0
		lcChoice = 'None'
		Thisform.CreateContextMenu ('EditContextMenu')
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Character
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Character'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Logical
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Logical'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Numeric
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Numeric'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Date
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Date'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_DateTime
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Time'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Null
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Null'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt '\-'
		
		****************************************************************
		*!* * Removed 07/12/2011 
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_undo Of EditContextMenu Prompt ccLOC_MENU_UNDO	;
		*!* 	Skip For Skpbar ('_MEDIT', _Med_undo)						;
		*!* 	PictRes _Med_undo
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_cut Of EditContextMenu Prompt ccLOC_MENU_CUT  ;
		*!* 	Skip For Skpbar ('_MEDIT', _Med_cut)					  ;
		*!* 	PictRes _Med_cut
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_copy Of EditContextMenu Prompt ccLOC_MENU_COPY	;
		*!* 	Skip For Skpbar ('_MEDIT', _Med_copy)						;
		*!* 	PictRes _Med_copy
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_paste Of EditContextMenu Prompt ccLOC_MENU_PASTE  ;
		*!* 	Skip For Skpbar ('_MEDIT', _Med_paste)						  ;
		*!* 	PictRes _Med_paste
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_clear Of EditContextMenu Prompt ccLOC_MENU_CLEAR  ;
		*!* 	Skip For Skpbar ('_MEDIT', _Med_clear)						  ;
		*!* 	PictRes _Med_clear
		
		*!* lnBar = lnBar + 1
		*!* Define Bar (lnBar) Of EditContextMenu Prompt '\-'
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_slcta Of EditContextMenu Prompt ccLOC_MENU_SELECT_ALL  ;
		*!* 	Skip For Skpbar ('_MEDIT', _Med_slcta)							   ;
		*!* 	PictRes _Med_slcta
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CAP_FONT
		On Selection Bar (lnBar) Of EditContextMenu loThis.SetFont()
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMG_PREFERENCES
		*!*	On Selection Bar (lnBar) Of EditContextMenu loThisForm.Preferences()
		
		Activate Popup EditContextMenu
		
		Release Popups EditContextMenu
		
		If lcChoice # 'None'
			With This
				Do Case
					Case lcChoice = 'Character'
						.Value = ''
					Case lcChoice = 'Logical'
						.Value = '.F.'
					Case lcChoice = 'Numeric'
						.Value = '0'
					Case lcChoice = 'Date'
						.Value = '{//}'
					Case lcChoice = 'Time'
						.Value = '={// :}'
					Case lcChoice = 'Null'
						.Value = '.NULL.'
				Endcase
				.SelStart  = 0
				.SelLength = Len (.Value)
				With Thisform
					.oMember.DefaultChanged = .T.
					.MemberChanged()
					If .oMember.cType = 'P'
						.oMember.lNonDefault = .T.
					Endif .oMember.cType = 'P'
				Endwith
				.SetFocus()
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE edtDefault.setfont
		Local lcFont, laLines(1), lcFontName, lcFontSize
		
		lcFont = Getfont (This.FontName, This.FontSize)
		
		If Empty (lcFont)
			Return
		Endif
		
		Alines (laLines, lcFont, .T., ',')
		This.FontName 	= laLines(1)
		This.FontSize 	= Val (laLines(2))
		
		With Thisform
			.oPersist.Set('DefaultFontName', This.FontName)
			.oPersist.Set('DefaultFontSize', This.FontSize)
		Endwith
		
	ENDPROC

	PROCEDURE edtDefault.setxvalue
		DoDefault()
		Thisform.oMember.DefaultValue = This.xValue 
	ENDPROC

	PROCEDURE edtDefault.When
		* Don't allow entry for new methods.
		
		return Thisform.oMember.cType <> 'M' or not Thisform.oMember.IsNewMember
		
	ENDPROC

	PROCEDURE lblDefault.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_DEFAULT_VALUE
		DoDefault()
		
	ENDPROC

	PROCEDURE lblDefault.Refresh
		With This
			Do Case
				Case Thisform.oMember.cType # 'P'
					.Caption = ccLOC_CAP_VIEW_METHOD_CODE
				Case Thisform.lClass
					.Caption = ccLOC_CAP_DEFAULT_VALUE
				Otherwise
					.Caption = ccLOC_CAP_DEFAULT_VALUE_Form
			Endcase
		Endwith
		
	ENDPROC

	PROCEDURE lblname.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_NAME
		DoDefault()
		
	ENDPROC

	PROCEDURE lblType.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_MEMBER_TYPE
		DoDefault()
		
	ENDPROC

	PROCEDURE lblVisibility.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_VISIBILITY
		DoDefault()
		
	ENDPROC

	PROCEDURE lblVisibility.Refresh
		This.Visible = PEME_IsVersion9()		;
			And Thisform.lClass
		
	ENDPROC

	PROCEDURE opgType.Baseoptionbutton1.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_PROPERTY
		DoDefault()
		
	ENDPROC

	PROCEDURE opgType.Baseoptionbutton2.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_METHOD
		DoDefault()
		
	ENDPROC

	PROCEDURE opgType.Click
		If This.Value = 2
			Thisform.oMember.lAccess = .F.
			Thisform.oMember.lAssign = .F.
		Endif
		
		
	ENDPROC

	PROCEDURE opgType.InteractiveChange
		Thisform.MemberChanged()
		return 
		
	ENDPROC

	PROCEDURE opgType.Refresh
		This.Value = Iif(Thisform.oMember.cType = [P], 1, 2)
		Thisform.lMethod = ( This.Value = 2 )
		
		This.Enabled = Thisform.NotEmptyGrid() 						;		
			and Not Thisform.oMember.lNative 						;
			And Not Thisform.oMember.lInherited  					;
			and upper(Thisform.oMember.cName) <> '_MEMBERDATA'		;
			and Thisform.nSelectedObjects =1
		
		*!*	* If disabled, only show the button matching the current value
		
		*!*	This.Buttons(1).Visible = This.Enabled Or This.Value = 1
		*!*	This.Buttons(2).Visible = This.Enabled Or This.Value = 2
		
	ENDPROC

	PROCEDURE opgType.Valid
		Thisform.oMember.cType = iif(This.Value = 1, 'P', 'M')
		Thisform.RefreshForm()
		
		If Empty(This.Parent.txtName.Value)
			Return This.Parent.txtName
		EndIf 
	ENDPROC

	PROCEDURE oSplitter.Init
		dodefault()
		This.ToolTipText = ccLOC_TOOLTIP_SPLITTER_VertTextBoxes
		
	ENDPROC

	PROCEDURE txtName.Init
		DoDefault()
		Thisform.otxtName = This
	ENDPROC

	PROCEDURE txtName.InteractiveChange
		Thisform.MemberChanged()
		dodefault()
	ENDPROC

	PROCEDURE txtName.KeyPress
		* Only allow characters, digits if they're not in the first position,
		* underscores, and brackets, parens, or commas if this is a property.
		
		Lparameters tnKeyCode, ;
			tnShiftAltCtrl
		Local lcChar, ;
			llValid
		If Between(tnKeyCode, Asc(' '), 126)
			lcChar  = Chr(tnKeyCode)
			llValid = Isalpha(lcChar) 											;
				Or (Isdigit(lcChar) And Len(Trim(This.Value)) >= 1) 			;
				Or lcChar = '_' 												;
				Or (Inlist(lcChar, '[', ']', '(', ')', ',') And Thisform.oMember.cType = 'P')
			Do Case
				Case Not llValid
					Declare Integer MessageBeep In Win32API Integer wType
					MessageBeep(MB_ICONSTOP)
					Wait Window ccLOC_INVALID_CHAR Nowait
					Nodefault
				Case Thisform.oPrefs.lLowerCaseOnly or Not Thisform.UseMemberData()
					TextBox::KeyPress(Asc(Lower(lcChar)), tnShiftAltCtrl)
					Nodefault
			Endcase
		
		Endif Between(tnKeyCode, Asc(' '), 127)
		
	ENDPROC

	PROCEDURE txtName.Refresh
		This.Enabled = Thisform.NotEmptyGrid() and ;
			NOT Thisform.oMember.lNative AND NOT Thisform.oMember.lInherited and ;
			upper(Thisform.oMember.cName) <> '_MEMBERDATA'
	ENDPROC

	PROCEDURE txtName.RightClick
		Thisform.ShowEditContextMenu()
	ENDPROC

	PROCEDURE txtName.Valid
		Local loObject, ;
			lcName, ;
			llReturn, ;
			lnRecNo, ;
			lcFilter, ;
			llFound,  ;
			llExitOK,	;
			lxValue
		
		* Do nothing if the user's clicking on the Revert button or cancelling.
		*** JRN 01/17/2009 : because of gripper in splitter, following may fail (that's why the Try)
		*   but no RETURN in a try ... so process it outside
		loObject = Sys(1270)
		Try
			llExitOK = (Vartype(loObject) = 'O' And Upper(loObject.Name) = 'CMDREVERT') Or ;
				lastkey() = 27
		Catch
			llExitOK = .F.
		Endtry
		
		If llExitOK
			Return .T.
		Endif
		
		If Vartype(Thisform.oObject) = [O]
			With Thisform
		
				* Ensure we have a valid name.
		
				lcName   = .ValidateName(This.Value)
				llReturn = .T.
				Do Case
		
						* It isn't, so display a warning.
		
					Case Empty(lcName) And Not Empty(This.Value)
						Messagebox(ccLOC_INVALID_NAME, MB_OK + MB_ICONEXCLAMATION, .Caption)
						llReturn = .F.
		
						*** JRN 12/03/2008 : Yes, but not checking here .... Apply only enabled if non-blank
						* The user left the name blank.
						*!*	Case Empty(lcName)
						*!*		Messagebox("Name cannot be blank", ;
						*!*		MB_OK + MB_ICONEXCLAMATION, .Caption)
						*!*		llReturn = .F.
		
						* If the member already exists, display a warning. Note that we're only concerned
						* if the user changes the name of this property or method to one that already exists.
		
					Case Thisform.GetPEMStatus(.oTopOfForm, .JustPEM(lcName), 5) And ;
							not (.JustPEM(lcName, .T.) == .JustPEM(.cOriginalName, .T.))
						Messagebox(Strtran(ccLOC_MEMBER_EXISTS, 'PEM_Name_Place_Holder', lcName), ;
							MB_OK + MB_ICONEXCLAMATION, .Caption)
						llReturn = .F.
				Endcase
		
				* If everything's OK, this is a new property, we don't already have a value for
				* for it, and we're supposed to, assign a default value based on the data type
				* (if we can determine it).
		
				If llReturn And .oMember.IsNewMember And .oMember.cType = 'P' And ;
						.oPrefs.lAssignDefaultValue And Not .oMember.DefaultChanged
					lxValue = Thisform.GetDefaultValue( Thisform.JustPEM(lcName))
					With This.Parent.edtDefault
						.xValue = lxValue
						.Value = .Val2Str(lxValue, lcName, .F.)
					Endwith
		
				Endif llReturn ...
			Endwith
		
		Endif Vartype(Thisform.oObject) = [O]
		Return Iif(llReturn, .T., 0)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS defaulteditbox AS editpropertyeditbox OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: isnumber
		*m: setxvalue		&& Converts .Value into .xValue (proper data type)
		*m: str2val
		*m: val2str
		*p: xvalue		&& Translated from .Value into correct data type
	*</DefinedPropArrayMethod>

	Name = "defaulteditbox"
	xvalue = 		&& Translated from .Value into correct data type
	
	PROCEDURE isnumber
		Lparameters tcString
		Local lcString, lcChar, lbDot, lbDigit, lnI
		
		lcString = Alltrim(tcString)
		For lnI = 1 To Len(lcString)
			lcChar = Substr(lcString,lnI,1)
			Do Case
				Case lcChar = '-'
					If lnI # 1
						Return .F.
					Endif
				Case lcChar = '.'
					If lbDot
						Return .F.
					Endif
					lbDot = .T.
				Case Isdigit(lcChar)
					lbDigit = .T.
				Otherwise
					Return .F.
			Endcase
		Next lnI
		Return lbDigit
		
	ENDPROC

	PROCEDURE KeyPress
		* Don't allow a CR.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = 13
			Declare Integer MessageBeep In Win32API Integer wType
			MessageBeep(MB_ICONSTOP)
			nodefault
		else
			dodefault(tnKeyCode, tnShiftAltCtrl)
		endif tnKeyCode = 13
		
	ENDPROC

	PROCEDURE setxvalue		&& Converts .Value into .xValue (proper data type)
		*** JRN 11/11/2008 : Store default value into This.xValue
		*  converted from character to logical, etc.
		*  Note that values beginning with '=' are later stored with WriteExpression instead
		Local m.vNewVal
		
		m.vNewVal = This.Value
		If "C" = Vartype (m.vNewVal)
			This.xValue = This.Str2Val( m.vNewVal , Thisform.IsNativeColor (Thisform.oMember.cName,Thisform.oMember.lNative))
		Else
			This.xValue = m.vNewVal
		Endif
		
		
	ENDPROC

	PROCEDURE str2val
		Lparameters tcStr, tbIsNativeColor
		
		*** JRN 11/13/2008 : following lifted from NewProperty
		* The only apparent failing is that it doesn't provide for values beginning with '='
		* which must be assigned using "WriteExpression"  (aha!  Agnes brought this up)
		
		* tcStr 			is value in edit box
		* tbIsNativeColor	is .T. for those native colors (BackColor, ForeColor, etc.) which can
		*					be entered as 192, 192, 192 -- but are stored as integers.
		
		Local luDefault, lcStr
		luDefault 	= tcStr
		lcStr		= Alltrim(tcStr)
		
		Do Case
			Case Empty(tcStr)
		
			Case Upper(lcStr) == '.F.' Or Upper(lcStr) == '.T.' Or Upper(lcStr) == '.NULL.' Or This.IsNumber(tcStr)
				luDefault = Evaluate(lcStr)
		
			Case '{' = Left(lcStr,1) And '}' = Right(lcStr,1) and not (IsAlpha(Alltrim(Substr(lcStr,2))) or '=' $ lcStr) 
				Try
					luDefault = Evaluate(lcStr)
				Catch
		
				Endtry
		
			Otherwise
				If tbIsNativeColor
					Try
						luDefault = Rgb (&tcStr)
					Catch
		
					Endtry
				Endif
		
		Endcase
		
		Return luDefault
		
	ENDPROC

	PROCEDURE val2str
		Lparameters txValue, tcPem, tlNative
		
		Local lnRed, lnGreen, lnBlue, lcValue
		
		Do Case
			Case Vartype(txValue) = 'N' And ;
					Thisform.IsNativeColor(tcPem, tlNative)
				lnRed   = Bitand(txValue, 255)
				lnGreen = Bitrshift(Bitand(txValue, 256 * 255), 8)
				lnBlue  = Bitrshift(Bitand(txValue, 256 * 256 * 255), 16)
				lcValue = Transform(lnRed) + ',' + Transform(lnGreen) + ;
					',' + Transform(lnBlue)
			Case Vartype(txValue) <> 'D'
				lcValue = Transform(txValue)
			Case Empty(txValue)
				lcValue = '{}'
			Otherwise
				lcValue = '{^' + Transform(Year(txValue)) + '/' + ;
					transform(Month(txValue)) + '/' + ;
					transform(Day(txValue)) + '}'
		Endcase
		
		Return lcValue
		
	ENDPROC

	PROCEDURE Valid
		This.SetxValue()
	ENDPROC

ENDDEFINE

DEFINE CLASS editpropertycheckbox AS basecheckbox OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Alignment = 0
	Name = "editpropertycheckbox"

ENDDEFINE

DEFINE CLASS editpropertycommandbutton AS basecommandbutton OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "editpropertycommandbutton"

ENDDEFINE

DEFINE CLASS editpropertycontrols AS basecontainer OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdAddMethod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddProperty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblVersion" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblVisibility" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboVisibility" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAccess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAssign" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboFavorites" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdApply" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemove" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.lblSubString" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.txtSubString" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkProperties" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkMethods" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkEvents" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkNative" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkInherited" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkCustom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkFavorites" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.choNonDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkMethodLocal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.cboFavorites" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkMethodInherited" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkMethodNoMethod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.chkMethodNoEvent" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.lblFilters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilters.Baselabel2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baseimage1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFilters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdResetFilters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.edtDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblnnn255" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntDescription.lblBufferOverruns" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblEditMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oSplitter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdApplyAndAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRevert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdApplyAndEdit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblAddMode" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: validatepossiblechanges
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Height = 260
	Name = "editpropertycontrols"
	nanchor = 14
	Width = 347
	_memberdata = <VFPData>
		<memberdata name="validatepossiblechanges" display="ValidatePossibleChanges"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'Baseimage1' AS baseimage WITH ;
		Height = 16, ;
		Left = 242, ;
		MousePointer = 15, ;
		Name = "Baseimage1", ;
		nanchor = 12, ;
		Picture = ..\images\vfpxpoweredby_alternative.gif, ;
		Top = 242, ;
		Width = 85, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		Alignment = 1, ;
		Caption = "Favorites:", ;
		Height = 16, ;
		Left = 78, ;
		Name = "Baselabel1", ;
		nanchor = 4, ;
		TabIndex = 15, ;
		Top = 164, ;
		Width = 50, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cboFavorites' AS basecombobox WITH ;
		ColumnCount = 2, ;
		ColumnWidths = "50,165", ;
		ControlSource = "ThisForm.oMember.nFavorites", ;
		Left = 134, ;
		Name = "cboFavorites", ;
		nanchor = 4, ;
		RowSourceType = 0, ;
		TabIndex = 7, ;
		Top = 160, ;
		Value = 0, ;
		Width = 80, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboVisibility' AS basecombobox WITH ;
		ControlSource = "ThisForm.oMember.nVisibility", ;
		Left = 134, ;
		Name = "cboVisibility", ;
		nanchor = 4, ;
		RowSourceType = 0, ;
		TabIndex = 8, ;
		Top = 185, ;
		Value = 0, ;
		Width = 80, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkAccess' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Access", ;
		ControlSource = "ThisForm.oMember.lAccess", ;
		Left = 12, ;
		lupdatecontrolsourceonchange = .F., ;
		Name = "chkAccess", ;
		nanchor = 4, ;
		TabIndex = 5, ;
		Top = 164, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkAssign' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Assign", ;
		ControlSource = "ThisForm.oMember.lAssign", ;
		Left = 12, ;
		lupdatecontrolsourceonchange = .F., ;
		Name = "chkAssign", ;
		nanchor = 4, ;
		TabIndex = 6, ;
		Top = 188, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdAddMethod' AS basecommandbutton WITH ;
		AutoSize = .T., ;
		Caption = "Add Method", ;
		Height = 25, ;
		Left = 77, ;
		Name = "cmdAddMethod", ;
		nanchor = 4, ;
		TabIndex = 21, ;
		Top = 216, ;
		Visible = .F., ;
		Width = 74, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdAddProperty' AS basecommandbutton WITH ;
		AutoSize = .T., ;
		Caption = "Add Prop.", ;
		Height = 25, ;
		Left = 7, ;
		Name = "cmdAddProperty", ;
		nanchor = 4, ;
		TabIndex = 19, ;
		Top = 216, ;
		Visible = .F., ;
		Width = 64, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdApply' AS basecommandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Apply", ;
		Default = .F., ;
		Height = 25, ;
		Left = 76, ;
		Name = "cmdApply", ;
		nanchor = 4, ;
		TabIndex = 17, ;
		Top = 216, ;
		Visible = .F., ;
		Width = 51, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdApplyAndAdd' AS basecommandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Add", ;
		Height = 25, ;
		Left = 78, ;
		Name = "cmdApplyAndAdd", ;
		nanchor = 4, ;
		TabIndex = 18, ;
		Top = 216, ;
		Visible = .F., ;
		Width = 51, ;
		ZOrderSet = 25
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdApplyAndEdit' AS basecommandbutton WITH ;
		Caption = "Save, then Edit Method", ;
		Height = 25, ;
		Left = 207, ;
		Name = "cmdApplyAndEdit", ;
		nanchor = 4, ;
		TabIndex = 22, ;
		Top = 216, ;
		Visible = .F., ;
		Width = 132, ;
		ZOrderSet = 27
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemove' AS basecommandbutton WITH ;
		AutoSize = .T., ;
		Caption = "Remove", ;
		Height = 25, ;
		Left = 157, ;
		Name = "cmdRemove", ;
		nanchor = 4, ;
		TabIndex = 23, ;
		Top = 216, ;
		Visible = .F., ;
		Width = 55, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdResetFilters' AS basecommandbutton WITH ;
		AutoSize = .T., ;
		Caption = "Reset Filters", ;
		FontSize = 8, ;
		Height = 25, ;
		Left = 238, ;
		Name = "cmdResetFilters", ;
		nanchor = 12, ;
		TabIndex = 24, ;
		Top = 216, ;
		Visible = .F., ;
		Width = 76, ;
		ZOrderSet = 19
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRevert' AS basecommandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Abandon", ;
		Height = 25, ;
		Left = 138, ;
		Name = "cmdRevert", ;
		nanchor = 4, ;
		TabIndex = 20, ;
		Top = 216, ;
		Visible = .F., ;
		Width = 60, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntDescription' AS basecontainer WITH ;
		Height = 52, ;
		Left = 5, ;
		Name = "cntDescription", ;
		nanchor = 15, ;
		TabIndex = 4, ;
		Top = 104, ;
		Width = 210, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntDescription.edtDescription' AS editpropertyeditbox WITH ;
		Height = 36, ;
		IntegralHeight = .F., ;
		Left = 0, ;
		Name = "edtDescription", ;
		nanchor = 15, ;
		SelectOnEntry = .F., ;
		TabIndex = 14, ;
		Top = 16, ;
		Width = 210, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="editbox" />

	ADD OBJECT 'cntDescription.lblBufferOverruns' AS baselabel WITH ;
		AutoSize = .F., ;
		Caption = "Description", ;
		Height = 48, ;
		Left = 44, ;
		Name = "lblBufferOverruns", ;
		TabIndex = 13, ;
		Top = 1, ;
		Visible = .F., ;
		Width = 200, ;
		WordWrap = .T., ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntDescription.lblDescription' AS baselabel WITH ;
		Caption = "Description", ;
		Left = 3, ;
		Name = "lblDescription", ;
		TabIndex = 13, ;
		Top = 1, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntDescription.lblnnn255' AS baselabel WITH ;
		Caption = "0/254", ;
		Height = 16, ;
		Left = 127, ;
		Name = "lblnnn255", ;
		TabIndex = 13, ;
		Top = 1, ;
		Width = 29, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntFilters' AS basecontainer WITH ;
		BorderWidth = 1, ;
		Height = 201, ;
		Left = 223, ;
		Name = "cntFilters", ;
		nanchor = 8, ;
		TabIndex = 9, ;
		Top = 7, ;
		Width = 124, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntFilters.Baselabel1' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = "With Code:", ;
		Height = 16, ;
		Left = 22, ;
		Name = "Baselabel1", ;
		TabIndex = 4, ;
		Top = 60, ;
		Width = 54, ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntFilters.Baselabel2' AS baselabel WITH ;
		Caption = "Group", ;
		Height = 16, ;
		Left = 3, ;
		Name = "Baselabel2", ;
		TabIndex = 2, ;
		Top = 13, ;
		Width = 32
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntFilters.cboFavorites' AS basecombobox WITH ;
		Height = 22, ;
		Left = 35, ;
		Name = "cboFavorites", ;
		RowSourceType = 0, ;
		TabIndex = 7, ;
		Top = 9, ;
		Value = 0, ;
		Width = 82, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cntFilters.chkCustom' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Custom", ;
		ccontrolsource = lHierarchyCustom, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkCustom", ;
		TabIndex = 12, ;
		Top = 144
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkEvents' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Events", ;
		ccontrolsource = lTypeEvent, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkEvents", ;
		TabIndex = 7, ;
		Top = 90
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkFavorites' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Favorites", ;
		ccontrolsource = lFavorites, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkFavorites", ;
		TabIndex = 16, ;
		Top = 182
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkInherited' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Inherited", ;
		ccontrolsource = lHierarchyInherited, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkInherited", ;
		TabIndex = 11, ;
		Top = 128
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkMethodInherited' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Inherited Code", ;
		ccontrolsource = lMethodViewInherited, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethodInherited", ;
		TabIndex = 8, ;
		Top = 96
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkMethodLocal' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Local Code", ;
		ccontrolsource = lMethodViewLocal, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethodLocal", ;
		TabIndex = 6, ;
		Top = 78
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkMethodNoEvent' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Empty Events", ;
		ccontrolsource = lMethodViewEventNone, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethodNoEvent", ;
		TabIndex = 14, ;
		Top = 158
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkMethodNoMethod' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Empty Methods", ;
		ccontrolsource = lMethodViewMethodNone, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethodNoMethod", ;
		TabIndex = 13, ;
		Top = 140
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkMethods' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Methods", ;
		ccontrolsource = lTypeMethod, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkMethods", ;
		TabIndex = 5, ;
		Top = 74
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkNative' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Native", ;
		ccontrolsource = lHierarchyNative, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkNative", ;
		TabIndex = 9, ;
		Top = 112
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.chkProperties' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Properties", ;
		ccontrolsource = lTypeProperty, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "chkProperties", ;
		TabIndex = 3, ;
		Top = 58
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.choNonDefault' AS filtercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Non-Default", ;
		ccontrolsource = lNonDefault, ;
		ControlSource = "", ;
		Left = 14, ;
		Name = "choNonDefault", ;
		TabIndex = 15, ;
		Top = 166
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntFilters.lblFilters' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Without Code:", ;
		Height = 16, ;
		Left = 24, ;
		Name = "lblFilters", ;
		TabIndex = 10, ;
		Top = 122, ;
		Width = 72, ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntFilters.lblSubString' AS baselabel WITH ;
		Caption = "Find:", ;
		Height = 16, ;
		Left = 7, ;
		Name = "lblSubString", ;
		TabIndex = 2, ;
		Top = 37, ;
		Width = 25
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntFilters.txtSubString' AS basetextbox WITH ;
		ControlSource = "Thisform.cSubString", ;
		Format = "!", ;
		Height = 21, ;
		Left = 35, ;
		lupdatecontrolsourceonchange = .T., ;
		Name = "txtSubString", ;
		SelectOnEntry = .T., ;
		TabIndex = 1, ;
		Top = 33, ;
		Width = 82
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'edtDefault' AS defaulteditbox WITH ;
		Height = 36, ;
		IntegralHeight = .F., ;
		Left = 5, ;
		Name = "edtDefault", ;
		nanchor = 10, ;
		TabIndex = 3, ;
		Top = 64, ;
		Width = 210, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblAddMode' AS baselabel WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		Caption = "Add Mode", ;
		FontBold = .T., ;
		Height = 16, ;
		Left = 10, ;
		Name = "lblAddMode", ;
		nanchor = 4, ;
		TabIndex = 13, ;
		Top = 222, ;
		Visible = .F., ;
		Width = 57, ;
		ZOrderSet = 28
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblDefault' AS baselabel WITH ;
		Caption = "Value", ;
		Left = 7, ;
		Name = "lblDefault", ;
		TabIndex = 13, ;
		Top = 48, ;
		ZOrderSet = 23
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblEditMode' AS baselabel WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		Caption = "Edit Mode", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 10, ;
		Name = "lblEditMode", ;
		nanchor = 4, ;
		TabIndex = 13, ;
		Top = 222, ;
		Visible = .F., ;
		Width = 57, ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblFilters' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Filters: ", ;
		Left = 263, ;
		Name = "lblFilters", ;
		nanchor = 8, ;
		TabIndex = 10, ;
		Top = 0, ;
		Width = 40, ;
		ZOrderSet = 18
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblname' AS baselabel WITH ;
		Caption = "Name:", ;
		Height = 16, ;
		Left = 6, ;
		Name = "lblname", ;
		TabIndex = 11, ;
		Top = 8, ;
		Width = 32, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblType' AS baselabel WITH ;
		Caption = "Type:", ;
		Height = 16, ;
		Left = 6, ;
		Name = "lblType", ;
		TabIndex = 12, ;
		Top = 30, ;
		Width = 29, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblVersion' AS baselabel WITH ;
		AutoSize = .F., ;
		Caption = "Version 1.00 - Oct. 28, 2008", ;
		FontSize = 7, ;
		Height = 12, ;
		Left = 9, ;
		Name = "lblVersion", ;
		nanchor = 4, ;
		TabIndex = 25, ;
		ToolTipText = "Link to PEM Editor blog (and latest version)", ;
		Top = 245, ;
		Width = 238, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblVisibility' AS baselabel WITH ;
		Caption = "Visibility:", ;
		Height = 16, ;
		Left = 89, ;
		Name = "lblVisibility", ;
		nanchor = 4, ;
		TabIndex = 16, ;
		Top = 189, ;
		Width = 44, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Line1' AS baseline WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line1", ;
		nanchor = 14, ;
		Top = 213, ;
		Width = 365, ;
		ZOrderSet = 21
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="line" />

	ADD OBJECT 'opgType' AS baseoptiongroup WITH ;
		ButtonCount = 2, ;
		Height = 25, ;
		Left = 55, ;
		Name = "opgType", ;
		TabIndex = 2, ;
		Top = 25, ;
		Width = 162, ;
		ZOrderSet = 13, ;
		Baseoptionbutton1.AutoSize = .T., ;
		Baseoptionbutton1.Caption = "Property", ;
		Baseoptionbutton1.Height = 16, ;
		Baseoptionbutton1.Left = 5, ;
		Baseoptionbutton1.Name = "Baseoptionbutton1", ;
		Baseoptionbutton1.Style = 0, ;
		Baseoptionbutton1.Top = 5, ;
		Baseoptionbutton1.Width = 59, ;
		Baseoptionbutton2.AutoSize = .T., ;
		Baseoptionbutton2.Caption = "Method", ;
		Baseoptionbutton2.Height = 16, ;
		Baseoptionbutton2.Left = 91, ;
		Baseoptionbutton2.Name = "Baseoptionbutton2", ;
		Baseoptionbutton2.Style = 0, ;
		Baseoptionbutton2.Top = 5, ;
		Baseoptionbutton2.Width = 53
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'oSplitter' AS peme_sfsplitterv WITH ;
		BackColor = 192,192,192, ;
		BackStyle = 1, ;
		cobject1name = edtDefault, ;
		cobject2name = cntDescription, ;
		Height = 6, ;
		Left = 5, ;
		Name = "oSplitter", ;
		nanchor = 10, ;
		nobject1minsize = 20, ;
		nobject2minsize = 36, ;
		TabIndex = 14, ;
		Top = 98, ;
		Width = 210, ;
		ZOrderSet = 24, ;
		gripperhor.Height = 5, ;
		gripperhor.Name = "gripperhor", ;
		gripperhor.Width = 21, ;
		gripperver.Height = 21, ;
		gripperver.Name = "gripperver", ;
		gripperver.Width = 5, ;
		ImgDownArrow.Height = 21, ;
		ImgDownArrow.Name = "ImgDownArrow", ;
		ImgDownArrow.Width = 21, ;
		imgUpArrow.Height = 21, ;
		imgUpArrow.Name = "imgUpArrow", ;
		imgUpArrow.Width = 21, ;
		ImgRightArrow.Height = 17, ;
		ImgRightArrow.Name = "ImgRightArrow", ;
		ImgRightArrow.Width = 17, ;
		ImgLeftArrow.Height = 17, ;
		ImgLeftArrow.Name = "ImgLeftArrow", ;
		ImgLeftArrow.Width = 17
		*< END OBJECT: ClassLib="peme_sfsplitter.vcx" BaseClass="control" />

	ADD OBJECT 'txtName' AS basetextbox WITH ;
		ControlSource = "ThisForm.oMember.cName", ;
		DisabledForeColor = 0,0,0, ;
		Format = "T", ;
		Height = 22, ;
		Left = 61, ;
		Name = "txtName", ;
		nanchor = 10, ;
		TabIndex = 1, ;
		Top = 4, ;
		Width = 155, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE validatepossiblechanges
		Local lcMsg, lcPemName, lcPrompt, lcWindowName, lnResult
		lcPemName = Thisform.JustPEM (Thisform.oMember.cName)
		
		If Thisform.oMember.cType $ 'ME'
			lcWindowName = Thisform.oObject.Name + '.' + Thisform.cOriginalName
			If Wvisible (lcWindowName)
				lcPrompt = Strtran (ccLOC_CAP_Apply_Open, 'PEM_Name_Place_Holder', lcWindowName)
				lnResult = Messagebox (lcPrompt, 1 + 32 + 256, Thisform.Caption)
				If lnResult # 1
					Return .F.
				Endif
			Endif
		
		Else
			If Thisform.oOriginalMember.lAccess And Not Thisform.oMember.lAccess
				lcPrompt = Strtran (ccLOC_CAP_REMOVE_ACCESS, 'PEM_Name_Place_Holder', lcPemName)
				lnResult = Messagebox (lcPrompt, 4 + 32, Thisform.Caption)
				If lnResult = 7
					Return .F.
				Endif
			Endif
		
			If Thisform.oOriginalMember.lAssign And Not Thisform.oMember.lAssign
				lcPrompt = Strtran (ccLOC_CAP_REMOVE_ASSIGN, 'PEM_Name_Place_Holder', lcPemName)
				lnResult = Messagebox (lcPrompt, 4 + 32, Thisform.Caption)
				If lnResult = 7
					Return .F.
				Endif
			Endif
		
		Endif
		
		If (Thisform.oOriginalMember.lNative Or Thisform.oOriginalMember.lInherited)		;
				And Thisform.oOriginalMember.nVisibility > 1 And Thisform.oMember.nVisibility = 1
			lcMsg = 'Unable to change visibility back to Public'
			lcMsg = lcMsg + CRLF + CRLF + 'To do so, follow these steps:'
			lcMsg = lcMsg + CRLF + '  1) Open the right-click context menu on the combobox'
			lcMsg = lcMsg + CRLF + "  2) Select 'FP default Edit Property/Method...'"
			lcMsg = lcMsg + CRLF + '  3) Close PEM Editor'
			lcMsg = lcMsg + CRLF + "  4) Select 'Edit Property/Method...'"
			lcMsg = lcMsg + CRLF + "        from the " + IIF(Thisform.lClass, 'Class', 'Form') + " sub-menu of the VFP Main Menu"
		
			Messagebox (lcMsg)
		Endif
		
		Return .T.
		
	ENDPROC

	PROCEDURE Baseimage1.Click
		ThisForm.oUtils.AboutPEMEditor()
		
	ENDPROC

	PROCEDURE Baselabel1.Init
		This.Caption = ccLOC_CAP_FAVORITES2
		DoDefault()
		
	ENDPROC

	PROCEDURE cboFavorites.Init
		With This
			.AddItem(ccLOC_Cap_Fav_None)
			.List (.NewItemId, 2)	= ccLOC_Cap_Fav_None2
		
			.AddItem(ccLOC_Cap_Fav_Local)
			.List (.NewItemId, 2)	= ccLOC_Cap_Fav_Local2
		
			.AddItem(ccLOC_Cap_Fav_Global)
			.List (.NewItemId, 2)	= ccLOC_Cap_Fav_Global2
		
			.AddItem(ccLOC_Cap_Fav_Both)
			.List (.NewItemId, 2)	= ccLOC_Cap_Fav_Both2
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cboFavorites.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE cboFavorites.Refresh
		This.Enabled = Thisform.NotEmptyGrid() 							;
			and (Thisform.lIsTopOfForm Or Thisform.oMember.IsNewMember) ;
			and Thisform.nSelectedObjects =1
		
		This.List(2) = Iif (Thisform.UseMemberData(), '', '\') + ccLOC_Cap_Fav_Local
		
	ENDPROC

	PROCEDURE cboVisibility.Init
		WITH This
		  .AddItem(ccLOC_STR_PUBLIC)
		  .AddItem(ccLOC_CAP_Vis_Protected)
		  .AddItem(ccLOC_CAP_Vis_Hidden)
		ENDWITH 
		
		DoDefault()
	ENDPROC

	PROCEDURE cboVisibility.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE cboVisibility.Refresh
		Local lbOK
		
		lbOK = PEME_IsVersion9()		;
			And Thisform.lClass
		
		This.Enabled = lbOK								;
			And Vartype (Thisform.oObject) = 'O'		;
			And Thisform.nSelectedObjects = 1			;
			And Thisform.lIsTopOfForm
		
		This.Visible = lbOK
		
		
		
	ENDPROC

	PROCEDURE chkAccess.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_ACCESS
		DoDefault()
		
	ENDPROC

	PROCEDURE chkAccess.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE chkAccess.Refresh
		This.Enabled = Thisform.NotEmptyGrid() 							;
			and Vartype(Thisform.oObject) = 'O' 						;
			and Thisform.nSelectedObjects = 1							;
			and Thisform.oMember.cType = 'P'							;
			and (Thisform.lIsTopOfForm Or Thisform.oMember.IsNewMember)
		
	ENDPROC

	PROCEDURE chkAssign.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_ASSIGN
		DoDefault()
		
	ENDPROC

	PROCEDURE chkAssign.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE chkAssign.Refresh
		This.Enabled = Thisform.NotEmptyGrid() 							;
			and vartype(Thisform.oObject) = 'O' 						;
			and Thisform.oMember.cType = 'P'							;
			and (thisform.lIsTopOfForm or Thisform.oMember.IsNewMember)	;
			and Thisform.nSelectedObjects =1
	ENDPROC

	PROCEDURE cmdAddMethod.Click
		If Thisform.oMember.IsNewMember
			Thisform.ApplyChanges()
		Endif
		
		ThisForm.AddNew('M')
		
	ENDPROC

	PROCEDURE cmdAddMethod.Init
		This.Caption = ccLOC_CAP_NEW_Method
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cmdAddMethod.Refresh
		With This
			If Thisform.oMember.IsNewMember or ThisForm.oMember.InteractiveChanged
				.Visible = .F.
				.Enabled = .F.
			Else
				.Visible = .T.
				.Enabled = .T.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cmdAddProperty.Click
		ThisForm.AddNew('P')
		
	ENDPROC

	PROCEDURE cmdAddProperty.Init
		This.Caption = ccLOC_CAP_NEW_Property
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cmdAddProperty.Refresh
		With This
			If Thisform.oMember.IsNewMember or ThisForm.oMember.InteractiveChanged
				.Visible = .F.
				.Enabled = .F.
			Else
				.Visible = .T.
				.Enabled = .T.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cmdApply.Click
		If Not This.Parent.ValidatePossibleChanges()
			Return
		Endif
		
		With Thisform
			.ApplyChanges()
			With .oGrid
				.SetFocus()
				.ncurrentrecno = Recno()
			Endwith
			.SetProperties()
		Endwith
		
	ENDPROC

	PROCEDURE cmdApply.Init
		With this
			.Caption = ccLOC_CAP_APPLY
			.ToolTipText = ccLOC_TIP_Apply_And_Add
		Endwith
		DoDefault()
		
	ENDPROC

	PROCEDURE cmdApply.Refresh
		With This
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .F.
					.Enabled = .F.
				Case Thisform.oMember.InteractiveChanged
					.Visible = .T.
					.Enabled = ccMaxDescriptionLength >= Len (Thisform.GetDescriptionValue())	;
						and Not Empty (Thisform.otxtName.Value)
				Otherwise
					.Visible = .F.
					.Enabled = .F.
			Endcase
		Endwith
		
	ENDPROC

	PROCEDURE cmdApplyAndAdd.Click
		With Thisform
			.ApplyChanges()
			.AddNew()
		Endwith
		
	ENDPROC

	PROCEDURE cmdApplyAndAdd.Init
		With This
			.Caption = ccLOC_CAP_Apply_And_Add
			.ToolTipText = ccLOC_TIP_Apply_And_Add
		EndWith 
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cmdApplyAndAdd.Refresh
		With This
			If Thisform.oMember.IsNewMember
				.Visible = .T.
				.Enabled = Thisform.oMember.InteractiveChanged 							;
					and ccMaxDescriptionLength >= Len (Thisform.GetDescriptionValue())	;
					and Not Empty (Thisform.otxtName.Value)
			Else
				.Visible = .F.
				.Enabled = .F.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cmdApplyAndEdit.Click
		With Thisform
			lcMethodName = Thisform.oMember.cName
			.ApplyChanges()
			.AddNew()
			.EditMethodCode(lcMethodName, Thisform.oTopOfForm)
		Endwith
		
	ENDPROC

	PROCEDURE cmdApplyAndEdit.Init
		With This
			.Caption = ccLOC_CAP_Apply_And_Edit
			.ToolTipText = ccLOC_TIP_Apply_And_Edit
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cmdApplyAndEdit.Refresh
		With This
			If Thisform.oMember.IsNewMember and not Thisform.oObjectTree.lCombotreeOpen
				.Enabled = Thisform.oMember.InteractiveChanged 							;
					and ccMaxDescriptionLength >= Len (Thisform.GetDescriptionValue())	;
					and Not Empty (Thisform.otxtName.Value)					;
					and Thisform.oMember.cType = 'M'
				.Visible = .Enabled
			Else
				.Visible = .F.
				.Enabled = .F.
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE cmdRemove.Click
		Thisform.removeMember( Thisform.JustPem( ThisForm.oOriginalMember.cName ), .F., .T. )
		
	ENDPROC

	PROCEDURE cmdRemove.Init
		This.Caption = ccLOC_CAP_REMOVE
		
		DoDefault()
	ENDPROC

	PROCEDURE cmdRemove.Refresh
		With This
			If Thisform.oMember.IsNewMember or ThisForm.oMember.InteractiveChanged
				.Visible = .F.
				.Enabled = .F.
			Else
				.Visible = .T.
				.Enabled = Thisform.NotEmptyGrid() 				;
					and Vartype(Thisform.oObject) = 'O' 		;
					and Not Thisform.oOriginalMember.lNative 	;
					and Not Thisform.oOriginalMember.lInherited ;
					and Not Thisform.lCollapsed					;
					and Thisform.nSelectedObjects = 1
		
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cmdResetFilters.Click
		With ThisForm
			.GetPutFilterDefaults(.T.)
			.cSubString	= ''
			.cSubStringMV = ''
			.SetFilter()
			.Refresh()
		EndWith 
		
	ENDPROC

	PROCEDURE cmdResetFilters.Init
		This.Caption = ccLOC_CAP_Reset_Filters
		
		DoDefault()
	ENDPROC

	PROCEDURE cmdResetFilters.Refresh
		With This
			Do Case
				Case Thisform.oMember.IsNewMember 				;
						Or Thisform.oMember.InteractiveChanged 	;
						Or Isnull(Thisform.oObject)				;
						or Thisform.oObjectTree.lCombotreeOpen
					.Visible = .F.
					.Enabled = .F.
				Case Thisform.NotEmptyGrid()
					.Visible = .T.
					.Enabled = .T.
					.ForeColor = Rgb(0,0,0)
				Otherwise
					.Visible = .T.
					.Enabled = .T.
					.ForeColor = Rgb(255,0,0)
			Endcas
		Endwith
		
	ENDPROC

	PROCEDURE cmdRevert.Click
		With Thisform
			.RevertChanges()
		EndWith 
	ENDPROC

	PROCEDURE cmdRevert.Init
		DoDefault()
		With This
			.AddProperty('nOriginalWidth', .Width)
		Endwith
		
	ENDPROC

	PROCEDURE cmdRevert.Refresh
		Local lnAnchor
		With This
			lnAnchor = .Anchor
			.Anchor = 0
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .T.
					.Enabled = .T.
					If Thisform.oMember.InteractiveChanged
						.Caption = ccLOC_CAP_Cancel1
						.Width   = .nOriginalWidth
					Else
						.Caption = ccLOC_CAP_CancelAdd
						.Width   = .nOriginalWidth + 52
					Endif
				Case Thisform.oMember.InteractiveChanged
					.Visible = .T.
					.Enabled = .T.
					.Caption = ccLOC_CAP_CancelEdit
					.Width   = .nOriginalWidth + 52
				Otherwise
					.Visible = .F.
					.Enabled = .F.
			Endcase
			.Anchor = lnAnchor
		Endwith
		
		
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.Init
		DoDefault()
		Thisform.oedtDescription = this
		This.ToolTipText = ccLOC_Tip_Description
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.InteractiveChange
		Thisform.MemberChanged()
		DoDefault()
	ENDPROC

	PROCEDURE cntDescription.edtDescription.KeyPress
		* Don't allow a CR.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = 13 and not Thisform.lAllowDescriptionCRs 
			Declare Integer MessageBeep In Win32API Integer wType
			MessageBeep(MB_ICONSTOP)
			nodefault
		else
			dodefault(tnKeyCode, tnShiftAltCtrl)
		endif tnKeyCode = 13 and not Thisform.lAllowDescriptionCRs 
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.Refresh
		With This
		
			If .lFirstTime
				.lFirstTime = .F.
				.FontName	= Nvl(Thisform.oPersist.Get('DescriptionFontName'), ccFontSizeName)
				.FontSize	= Nvl(Thisform.oPersist.Get('DescriptionFontSize'), Thisform.nFontSize)
			Endif
		
		Endwith
		
		With This
		
			*** JRN 12/01/2008 : conditionally replace CRs with \n
			If Thisform.lAllowDescriptionCRs
				This.Value = Strtran(Thisform.oMember.cDescript, "\n", ccCRLF)
			Else
				This.Value = Thisform.oMember.cDescript
			Endif
		
			*** DougHennig 11/23/2008: also disabled for _MemberData
			***	If Thisform.oMember.lNative Or Thisform.oMember.lInherited
			If (Not PEME_IsVersion9())								;
					or(Not Thisform.NotEmptyGrid()) 			;
					Or Thisform.oMember.lNative 				;
					Or Thisform.oMember.lInherited Or 			;
					upper(Thisform.oMember.cName) = '_MEMBERDATA'
		
				.ReadOnly	= .T.
				.BackColor 	= .DisabledBackColor
		
			Else
		
				.ReadOnly	= .F.
				.BackColor	= Rgb (255,255,255)
		
			Endif
		
		Endwith
		
		This.Visible = Not Thisform.lAvoidBufferOverrun
	ENDPROC

	PROCEDURE cntDescription.edtDescription.RightClick
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Local loThis, lnBar, loThisForm
		loThisForm = Thisform
		loThis = This
		
		lnBar = 0
		Thisform.CreateContextMenu("EditContextMenu")
		
		*!* * Removed 07/12/2011 
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_undo Of EditContextMenu Prompt ccLOC_MENU_UNDO ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_undo) ;
		*!* 	PictRes _Med_undo
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_cut Of EditContextMenu Prompt ccLOC_MENU_CUT ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_cut) ;
		*!* 	PictRes _Med_cut
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_copy Of EditContextMenu Prompt ccLOC_MENU_COPY ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_copy) ;
		*!* 	PictRes _Med_copy
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_paste Of EditContextMenu Prompt ccLOC_MENU_PASTE ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_paste) ;
		*!* 	PictRes _Med_paste
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_clear Of EditContextMenu Prompt ccLOC_MENU_CLEAR ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_clear) ;
		*!* 	PictRes _Med_clear
		
		*!* lnBar = lnBar + 1
		*!* Define Bar 6 Of EditContextMenu Prompt "\-"
		
		*!* lnBar = lnBar + 1
		*!* Define Bar _Med_slcta Of EditContextMenu Prompt ccLOC_MENU_SELECT_ALL ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_slcta) ;
		*!* 	PictRes _Med_slcta
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CAP_FONT
		On Selection Bar (lnBar) Of EditContextMenu loThis.SetFont()
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CAP_FONT
		On Selection Bar (lnBar) Of EditContextMenu loThis.SetFont()
		
		Activate Popup EditContextMenu
		
		Release Popups EditContextMenu
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.setfont
		Local lcFont, laLines(1), lcFontName, lcFontSize
		
		lcFont = Getfont (This.FontName, This.FontSize)
		
		If Empty (lcFont)
			Return
		Endif
		
		Alines (laLines, lcFont, .T., ',')
		This.FontName 	= laLines(1)
		This.FontSize 	= Val (laLines(2))
		
		With Thisform
			.oPersist.Set('DescriptionFontName', This.FontName)
			.oPersist.Set('DescriptionFontSize', This.FontSize)
		Endwith
		
		
	ENDPROC

	PROCEDURE cntDescription.edtDescription.validation
		*** JRN 12/01/2008 : replace \n with CR
		
		Thisform.oMember.cDescript = Strtran(This.Value, ccCRLF, "\n")
		
		
	ENDPROC

	PROCEDURE cntDescription.lblBufferOverruns.Init
		* Set the caption to a localized string.
		
		With This
			.Caption = ccLOC_Pref_Tip_Buffer_OverRuns_Unavailable
			.FontItalic = .T.
		EndWith 
		
	ENDPROC

	PROCEDURE cntDescription.lblBufferOverruns.Refresh
		This.Visible = Thisform.lAvoidBufferOverrun
	ENDPROC

	PROCEDURE cntDescription.lblDescription.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_DESCRIPTION
		
	ENDPROC

	PROCEDURE cntDescription.lblDescription.Refresh
		This.Visible = Not Thisform.lAvoidBufferOverrun
	ENDPROC

	PROCEDURE cntDescription.lblnnn255.Refresh
		Local lnLength
		With This
		
			If (Not PEME_IsVersion9())								;
					or (Not Thisform.NotEmptyGrid()) 			;
					Or Thisform.oMember.lNative 				;
					Or Thisform.oMember.lInherited 				;
					Or Upper(Thisform.oMember.cName) = '_MEMBERDATA'
				.Caption = ''
			Else
				lnLength = Len (Thisform.GetDescriptionValue())
				.Caption = Transform (lnLength) + [/ccMaxDescriptionLength]
				.Visible = lnLength >= 128
				.FontBold = lnLength >= 200
				.ForeColor = Iif(lnLength <= ccMaxDescriptionLength, Rgb(0,0,0), Rgb(255,0,0))
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE cntFilters.Baselabel1.Init
		This.Caption = ' ' + ccLOC_CAP_MV_With_Code + ' '
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.Baselabel1.Refresh
		This.Visible = ThisForm.nMethodView = 2
	ENDPROC

	PROCEDURE cntFilters.cboFavorites.Init
		With This
			Thisform.CreateGroupCursors()
		
			.AddProperty('aRowSource(1)')
			Select *					;
				from crsr_GroupNames	;
				into Array This.aRowSource
		
			For lnI = 1 to _Tally
				.AddItem (This.aRowSource(lnI, 1))
			endfor
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.cboFavorites.Refresh
		Local lnI
		DoDefault()
		
		For lnI = 1 To Floor(Alen(This.aRowSource) / 2)
			If This.aRowSource(lnI, 2) = Thisform.oPrefs.nGroupID
				This.Value = lnI
				Return
			Endif
		Endfor
		This.Value = 1
		
	ENDPROC

	PROCEDURE cntFilters.cboFavorites.Valid
		DoDefault()
		Thisform.oPrefs.nGroupID = This.aRowSource(This.Value, 2)
		If Between(This.Value,2,7)
			ThisForm.oPrefs.lHierarchyNative = .T.
		Endif
		Thisform.SetFilter()
		
	ENDPROC

	PROCEDURE cntFilters.chkCustom.Init
		This.Caption = ccLOC_CAP_CUSTOM
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkCustom.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lHierarchyNative		= .T.
					.oPrefs.lHierarchyInherited 	= .T.
				Else
					.oPrefs.lHierarchyNative		= .F.
					.oPrefs.lHierarchyInherited	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE cntFilters.chkCustom.Refresh
		DoDefault()
		
		This.Enabled = Thisform.lIsTopOfForm				;
			and Not Thisform.oMember.InteractiveChanged 	;
			and Not Thisform.oMember.IsNewMember
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE cntFilters.chkEvents.Init
		This.Caption = ccLOC_CAP_EVENTS
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkEvents.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lTypeProperty 	= .T.
					.oPrefs.lTypeMethod 	= .T.
				Else
					.oPrefs.lTypeProperty	= .F.
					.oPrefs.lTypeMethod	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE cntFilters.chkEvents.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE cntFilters.chkEvents.Valid
		*** JRN 11/16/2008 : If turning on Events, turn on 'Native' as well
		Thisform.oPrefs.lHierarchyNative = Thisform.oPrefs.lHierarchyNative or This.Value
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkFavorites.Init
		This.Caption = ccLOC_CAP_FAVORITES
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkInherited.Init
		This.Caption = ccLOC_CAP_INHERITED
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkInherited.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lHierarchyNative		= .T.
					.oPrefs.lHierarchyCustom	 	= .T.
				Else
					.oPrefs.lHierarchyNative		= .F.
					.oPrefs.lHierarchyCustom	 	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE cntFilters.chkInherited.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodInherited.Init
		With This
			.Caption = ccLOC_CAP_MV_Inherited
		Endwith
		
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodInherited.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		With This
			.ToolTipText = Thisform.InsertFormOrClass(ccLOC_CAP_MV_InheritedTip)
		EndWith
		
		DoDefault()
		
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodInherited.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 2
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodLocal.Init
		With This
			.Caption = ccLOC_CAP_MV_Local
		Endwith
		
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodLocal.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		With This
			.ToolTipText = Thisform.InsertFormOrClass(ccLOC_CAP_MV_LocalTip)
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodLocal.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 2
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodNoEvent.Init
		With This
			.Caption = ccLOC_CAP_MV_NoEvent
			.ToolTipText = ccLOC_CAP_MV_NoEventTip
		Endwith
		
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodNoEvent.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 2
	ENDPROC

	PROCEDURE cntFilters.chkMethodNoMethod.Init
		With This
			.Caption = ccLOC_CAP_MV_NoMethod
			.ToolTipText = ccLOC_CAP_MV_NoMethodTip
		Endwith
		
		
	ENDPROC

	PROCEDURE cntFilters.chkMethodNoMethod.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 2
		
	ENDPROC

	PROCEDURE cntFilters.chkMethods.Init
		This.Caption = ccLOC_CAP_METHODS
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkMethods.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lTypeProperty 	= .T.
					.oPrefs.lTypeEvent 	= .T.
				Else
					.oPrefs.lTypeProperty	= .F.
					.oPrefs.lTypeEvent 	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE cntFilters.chkMethods.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE cntFilters.chkNative.Init
		This.Caption = ccLOC_CAP_NATIVE
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkNative.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lHierarchyInherited	= .T.
					.oPrefs.lHierarchyCustom	 	= .T.
				Else
					.oPrefs.lHierarchyInherited	= .F.
					.oPrefs.lHierarchyCustom	 	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE cntFilters.chkNative.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE cntFilters.chkProperties.Init
		This.Caption = ccLOC_CAP_PROPERTIES
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.chkProperties.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If nButton = 1 And nShift = 2
			With Thisform
				If This.Value
					.oPrefs.lTypeMethod 	= .T.
					.oPrefs.lTypeEvent 	= .T.
				Else
					.oPrefs.lTypeMethod 	= .F.
					.oPrefs.lTypeEvent 	= .F.
				Endif
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE cntFilters.chkProperties.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE cntFilters.choNonDefault.Init
		This.Caption = ccLOC_CAP_NonDefaultPr
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.choNonDefault.Refresh
		DoDefault()
		
		This.Visible = ThisForm.nMethodView = 1
		
	ENDPROC

	PROCEDURE cntFilters.Init
		DoDefault ()
		Thisform.ocntFilters = This
	ENDPROC

	PROCEDURE cntFilters.lblFilters.Init
		This.Caption = ' ' + ccLOC_CAP_MV_None + ' '
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.lblFilters.Refresh
		This.Visible = ThisForm.nMethodView = 2
	ENDPROC

	PROCEDURE cntFilters.lblSubString.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_SUBSTRING
		DoDefault()
		
	ENDPROC

	PROCEDURE cntFilters.Refresh
		With This
			*	If Thisform.oMember.IsNewMember 				;
			*		Or Thisform.oMember.InteractiveChanged 	;
			*		Or Thisform.lEditingOneProperty
			If Thisform.oMember.InteractiveChanged 	;
					Or Thisform.lEditingOneProperty
				.Enabled = .F.
				.Visible = .F.
			Else
				.Enabled = .T.
				.Visible = .T.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cntFilters.txtSubString.Click
		With This
			.SelStart = 0
			.SelLength = 1000
		Endwith
		
	ENDPROC

	PROCEDURE cntFilters.txtSubString.GotFocus
		DoDefault()
		With Thisform 
			If .oPrefs.lGridAbove
				.oSplitterV.Collapse(.F.)
			Else
				.oSplitterH.Collapse(.F.)
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE cntFilters.txtSubString.InteractiveChange
		Local lnSelStart
		lnSelStart = This.SelStart
		
		DoDefault()
		Thisform.SetFilter()
		
		This.SelStart = lnSelStart
		
	ENDPROC

	PROCEDURE cntFilters.txtSubString.Refresh
		If Thisform.nMethodView = 1
			This.ControlSource = 'ThisForm.cSubString'
		Else
			This.ControlSource = 'ThisForm.cSubStringMV'
		Endif
		
	ENDPROC

	PROCEDURE cntFilters.txtSubString.RightClick
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Local loThis, lnBar, lcChoice
		loThis = This
		
		lnBar = 0
		lcChoice = ''
		Thisform.CreateContextMenu("SearchContextMenu")
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_NameContains
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'N$'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_NameStart
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'N='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_DescContains
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'D$'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_DescStart
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'D='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_ValueContains
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'V$'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_ValueStart
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'V='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_StartsUpper
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'U='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_AnyUpper
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'U$'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_StartsLower
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'L='
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_AllLower
		On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'L$'
		
		If Not Empty(This.Value)
			lnBar = lnBar + 1
			Define Bar (lnBar) Of SearchContextMenu Prompt "\-"
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of SearchContextMenu Prompt ccLoc_CMSrch_Clear
			On Selection Bar (lnBar) Of SearchContextMenu lcChoice = 'Clear'
		
		Endif
		
		****************************************************************
		****************************************************************
		
		Activate Popup SearchContextMenu
		
		Release Popups SearchContextMenu
		
		Do Case
		
			Case Empty (lcChoice)
		
			Case lcChoice = 'Clear'
				This.Value = ''
		
			Otherwise
				If Substr (This.Value,2,1) $ '=$'
					This.Value = lcChoice + Substr (This.Value,3)
				Else
					This.Value = lcChoice + This.Value
				Endif
		
		Endcase
		
		Thisform.SetFilter()
		This.SelLength = 0
		This.SelStart = Len(This.Value)
		
	ENDPROC

	PROCEDURE edtDefault.Init
		Thisform.oedtDefault = This
		DoDefault()
		
	ENDPROC

	PROCEDURE edtDefault.InteractiveChange
		with Thisform
			.oMember.DefaultChanged = .T.
			.MemberChanged()
			if .oMember.cType = 'P'
				.oMember.lNonDefault = .T.
			endif .oMember.cType = 'P'
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE edtDefault.Refresh
		With This
		
			If .lFirstTime
				.lFirstTime = .F.
				.FontName	= Nvl(Thisform.oPersist.Get('DefaultFontName'), ccFontSizeName)
				.FontSize	= Nvl(Thisform.oPersist.Get('DefaultFontSize'), Thisform.nFontSize)
			Endif
		
		Endwith
		
		
		Local lcPEM, lcValue, lxValue, lnRed, lnGreen, lnBlue, loValue
		
		With Thisform
			lcPEM = .JustPEM(.oMember.cName)
			With This
				.Value         = ''
				.xValue		   = ''
				.Enabled       = .F.
				.ReadOnly      = .F.
				.ForeColor     = Rgb(0, 0, 0)
				.BackColor     = Rgb(255, 255, 255)
				.SelectOnEntry = .F.
			Endwith
		
			Do Case
		
				Case Isnull(Thisform.oObject)
		
					*** JRN 04/14/2010 : refusing to allow entry to these
				Case Inlist (lcPEM, 'HeaderClass', 'HeaderClassLibrary', 'MemberClass', 'MemberClassLibrary')
					loValue = Thisform.GetValue(lcPEM, lNative, 'For Editing', Thisform.nObjNumber)
					lcValue = loValue.CharValue
					If loValue.Type = 'N' And '-' $ lcValue
						lcValue = Alltrim (Transform (loValue.Value))
					Endif
					With This
						.Value		= lcValue
						.Enabled	= .T.
						.ReadOnly	= .T.
						.ForeColor	= Rgb(0,0,0) && .DisabledForeColor
						.BackColor 	= .DisabledBackColor
					Endwith
		
					* Do nothing if we're resetting to default.
				Case .oMember.cType # 'P' And .oMember.ResetToDefault
		
					* If this was and is a property, handle it. Note the special handling for colors.
				Case .oMember.cType = 'P' And Thisform.oOriginalMember.cType = 'P'
		
					loValue = Thisform.GetValue(lcPEM, lNative, 'For Editing', Thisform.nObjNumber)
					lcValue = loValue.CharValue
					If loValue.Type = 'N' And '-' $ lcValue
						lcValue = Alltrim (Transform (loValue.Value))
					Endif
		
					* Enable the control if if we're not sitting on an object or an array.
		
					If Vartype(lcValue) <> 'O' 				;
							and	Not '[' $ .oMember.cName 	;
							and Not '(' $ .oMember.cName
						This.Value		   = lcValue
						This.Enabled 	   = .T.
						This.SelectOnEntry = .T.
						*** JRN 12/01/2008 : enable unless read-only
						This.ReadOnly	  =	.oMember.lReadOnly
					Endif Vartype(lcValue) <> 'O' ...
		
					* For properties, this is enabled and should select on entry.
		
				Case .oMember.cType = 'P'
					This.Enabled       = .T.
					This.SelectOnEntry = .T.
		
					* For members that were and are methods or events, this is enabled and should
					* select on entry.
		
				Case .oMember.cType $ [ME] And Thisform.oOriginalMember.cType $ [ME]
					Try
						lcValue = .oObject.ReadMethod(lcPEM)
						With This
							.Value		= lcValue
							.Enabled	= .T.
							.ReadOnly	= .T.
							.ForeColor	= Rgb(0,0,0) && .DisabledForeColor
							.BackColor 	= .DisabledBackColor
						Endwith
					Catch
					Endtry
				Case Thisform.oMember.cType $ [ME]
					With This
						.Enabled	= .T.
						.ReadOnly	= .T.
						.ForeColor	= Rgb(0,0,0) && .DisabledForeColor
						.BackColor 	= .DisabledBackColor
					Endwith
			Endcase
			This.SetXValue()
		Endwith
		
	ENDPROC

	PROCEDURE edtDefault.RightClick
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Local lcChoice, lnBar, loThis, loThisForm
		loThisForm = Thisform
		loThis	   = This
		
		lnBar	 = 0
		lcChoice = 'None'
		Thisform.CreateContextMenu ('EditContextMenu')
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Character
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Character'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Logical
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Logical'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Numeric
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Numeric'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Date
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Date'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_DateTime
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Time'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMV_Null
		On Selection Bar (lnBar) Of EditContextMenu lcChoice = 'Null'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt '\-'
		
		****************************************************************
		lnBar = lnBar + 1
		Define Bar _Med_undo Of EditContextMenu Prompt ccLOC_MENU_UNDO	;
			Skip For Skpbar ('_MEDIT', _Med_undo)						;
			PictRes _Med_undo
		
		lnBar = lnBar + 1
		Define Bar _Med_cut Of EditContextMenu Prompt ccLOC_MENU_CUT  ;
			Skip For Skpbar ('_MEDIT', _Med_cut)					  ;
			PictRes _Med_cut
		
		lnBar = lnBar + 1
		Define Bar _Med_copy Of EditContextMenu Prompt ccLOC_MENU_COPY	;
			Skip For Skpbar ('_MEDIT', _Med_copy)						;
			PictRes _Med_copy
		
		lnBar = lnBar + 1
		Define Bar _Med_paste Of EditContextMenu Prompt ccLOC_MENU_PASTE  ;
			Skip For Skpbar ('_MEDIT', _Med_paste)						  ;
			PictRes _Med_paste
		
		lnBar = lnBar + 1
		Define Bar _Med_clear Of EditContextMenu Prompt ccLOC_MENU_CLEAR  ;
			Skip For Skpbar ('_MEDIT', _Med_clear)						  ;
			PictRes _Med_clear
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt '\-'
		
		lnBar = lnBar + 1
		Define Bar _Med_slcta Of EditContextMenu Prompt ccLOC_MENU_SELECT_ALL  ;
			Skip For Skpbar ('_MEDIT', _Med_slcta)							   ;
			PictRes _Med_slcta
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CAP_FONT
		On Selection Bar (lnBar) Of EditContextMenu loThis.SetFont()
		
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CMG_PREFERENCES
		*!*	On Selection Bar (lnBar) Of EditContextMenu loThisForm.Preferences()
		
		Activate Popup EditContextMenu
		
		Release Popups EditContextMenu
		
		If lcChoice # 'None'
			With This
				Do Case
					Case lcChoice = 'Character'
						.Value = ''
					Case lcChoice = 'Logical'
						.Value = '.F.'
					Case lcChoice = 'Numeric'
						.Value = '0'
					Case lcChoice = 'Date'
						.Value = '{//}'
					Case lcChoice = 'Time'
						.Value = '={// :}'
					Case lcChoice = 'Null'
						.Value = '.NULL.'
				Endcase
				.SelStart  = 0
				.SelLength = Len (.Value)
				With Thisform
					.oMember.DefaultChanged = .T.
					.MemberChanged()
					If .oMember.cType = 'P'
						.oMember.lNonDefault = .T.
					Endif .oMember.cType = 'P'
				Endwith
				.SetFocus()
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE edtDefault.setfont
		Local lcFont, laLines(1), lcFontName, lcFontSize
		
		lcFont = Getfont (This.FontName, This.FontSize)
		
		If Empty (lcFont)
			Return
		Endif
		
		Alines (laLines, lcFont, .T., ',')
		This.FontName 	= laLines(1)
		This.FontSize 	= Val (laLines(2))
		
		With Thisform
			.oPersist.Set('DefaultFontName', This.FontName)
			.oPersist.Set('DefaultFontSize', This.FontSize)
		Endwith
		
		
	ENDPROC

	PROCEDURE edtDefault.setxvalue
		DoDefault()
		Thisform.oMember.DefaultValue = This.xValue 
	ENDPROC

	PROCEDURE edtDefault.When
		* Don't allow entry for new methods.
		
		return Thisform.oMember.cType <> 'M' or not Thisform.oMember.IsNewMember
		
	ENDPROC

	PROCEDURE lblAddMode.Init
		* Set the caption to a localized string.
		
		*	This.Caption = ccLOC_CAP_DEFAULT_VALUE
		DoDefault()
		
	ENDPROC

	PROCEDURE lblAddMode.Refresh
		With This
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .T.
					.Enabled = .T.
				Otherwise 
					.Visible = .F.
					.Enabled = .F.
			Endcase
		Endwith
		
		
		
	ENDPROC

	PROCEDURE lblDefault.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_DEFAULT_VALUE
		DoDefault()
		
	ENDPROC

	PROCEDURE lblDefault.Refresh
		With This
			Do Case
				Case Thisform.oMember.cType # 'P'
					.Caption = ccLOC_CAP_VIEW_METHOD_CODE
				Case Thisform.lClass
					.Caption = ccLOC_CAP_DEFAULT_VALUE
				Otherwise
					.Caption = ccLOC_CAP_DEFAULT_VALUE_Form
			Endcase
		Endwith
		
	ENDPROC

	PROCEDURE lblEditMode.Init
		* Set the caption to a localized string.
		
		* This.Caption = ccLOC_CAP_DEFAULT_VALUE
		DoDefault()
		
	ENDPROC

	PROCEDURE lblEditMode.Refresh
		With This
			Do Case
				Case Thisform.oMember.IsNewMember
					.Visible = .F.
					.Enabled = .F.
				Case Thisform.oMember.InteractiveChanged
					.Visible = .T.
					.Enabled = .T.
				Otherwise 
					.Visible = .F.
					.Enabled = .F.
			Endcase
		Endwith
		
		
		
	ENDPROC

	PROCEDURE lblFilters.Init
		This.Caption = ' ' + ccLOC_CAP_FILTERS + ' '
		DoDefault()
		
	ENDPROC

	PROCEDURE lblFilters.Refresh
		With This
			*	If Thisform.oMember.IsNewMember 				;
			*		Or Thisform.oMember.InteractiveChanged 	;
			*		Or Thisform.lEditingOneProperty
			If Thisform.oMember.InteractiveChanged 	;
					Or Thisform.lEditingOneProperty
				.Enabled = .F.
				.Visible = .F.
			Else
				.Enabled = .T.
				.Visible = .T.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE lblname.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_NAME
		DoDefault()
		
	ENDPROC

	PROCEDURE lblType.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_MEMBER_TYPE
		DoDefault()
		
	ENDPROC

	PROCEDURE lblVersion.Click
		Local loHyperlink AS "Hyperlink"
		Local lcLink
		
		lcLink = "http://pemeditor.blogspot.com/"
		loHyperlink = CREATEOBJECT("Hyperlink") 
		loHyperlink.navigateto(lcLink)
	ENDPROC

	PROCEDURE lblVersion.Init
		DoDefault()
		
		With This
			.FontSize = ccFontSizeSmall
		Endwith
		
		
	ENDPROC

	PROCEDURE lblVersion.Refresh
		DoDefault()
		
		With This
			.Caption = ThisForm.oPrefs.cVersion
		Endwith
		
		
	ENDPROC

	PROCEDURE lblVisibility.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_VISIBILITY
		DoDefault()
		
	ENDPROC

	PROCEDURE lblVisibility.Refresh
		This.Visible = PEME_IsVersion9()		;
			And Thisform.lClass
		
	ENDPROC

	PROCEDURE opgType.Baseoptionbutton1.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_PROPERTY
		DoDefault()
		
	ENDPROC

	PROCEDURE opgType.Baseoptionbutton2.Init
		* Set the caption to a localized string.
		
		This.Caption = ccLOC_CAP_METHOD
		DoDefault()
		
	ENDPROC

	PROCEDURE opgType.Click
		If This.Value = 2
			Thisform.oMember.lAccess = .F.
			Thisform.oMember.lAssign = .F.
		Endif
		
		
	ENDPROC

	PROCEDURE opgType.InteractiveChange
		Thisform.MemberChanged()
		return 
		
	ENDPROC

	PROCEDURE opgType.Refresh
		This.Value = Iif(Thisform.oMember.cType = [P], 1, 2)
		Thisform.lMethod = ( This.Value = 2 )
		
		This.Enabled = Thisform.NotEmptyGrid() 						;		
			and Not Thisform.oMember.lNative 						;
			And Not Thisform.oMember.lInherited  					;
			and upper(Thisform.oMember.cName) <> '_MEMBERDATA'		;
			and Thisform.nSelectedObjects =1
		
		*!*	* If disabled, only show the button matching the current value
		
		*!*	This.Buttons(1).Visible = This.Enabled Or This.Value = 1
		*!*	This.Buttons(2).Visible = This.Enabled Or This.Value = 2
		
	ENDPROC

	PROCEDURE opgType.Valid
		Thisform.oMember.cType = iif(This.Value = 1, 'P', 'M')
		Thisform.RefreshForm()
		
	ENDPROC

	PROCEDURE oSplitter.Init
		dodefault()
		This.ToolTipText = ccLOC_TOOLTIP_SPLITTER_VertTextBoxes
		
	ENDPROC

	PROCEDURE txtName.Init
		DoDefault()
		Thisform.otxtName = This
	ENDPROC

	PROCEDURE txtName.InteractiveChange
		Thisform.MemberChanged()
		dodefault()
	ENDPROC

	PROCEDURE txtName.KeyPress
		* Only allow characters, digits if they're not in the first position,
		* underscores, and brackets, parens, or commas if this is a property.
		
		Lparameters tnKeyCode, ;
			tnShiftAltCtrl
		Local lcChar, ;
			llValid
		If Between(tnKeyCode, Asc(' '), 126)
			lcChar  = Chr(tnKeyCode)
			llValid = Isalpha(lcChar) 											;
				Or (Isdigit(lcChar) And Len(Trim(This.Value)) >= 1) 			;
				Or lcChar = '_' 												;
				Or (Inlist(lcChar, '[', ']', '(', ')', ',') And Thisform.oMember.cType = 'P')
			Do Case
				Case Not llValid
					Declare Integer MessageBeep In Win32API Integer wType
					MessageBeep(MB_ICONSTOP)
					Wait Window ccLOC_INVALID_CHAR Nowait
					Nodefault
				Case Not Thisform.UseMemberData()
					TextBox::KeyPress(Asc(Lower(lcChar)), tnShiftAltCtrl)
					Nodefault
			Endcase
		
		Endif Between(tnKeyCode, Asc(' '), 127)
		
	ENDPROC

	PROCEDURE txtName.Refresh
		This.Enabled = Thisform.NotEmptyGrid() and ;
			NOT Thisform.oMember.lNative AND NOT Thisform.oMember.lInherited and ;
			upper(Thisform.oMember.cName) <> '_MEMBERDATA'
	ENDPROC

	PROCEDURE txtName.RightClick
		Thisform.ShowEditContextMenu()
	ENDPROC

	PROCEDURE txtName.Valid
		Local loObject, ;
			lcName, ;
			llReturn, ;
			lnRecNo, ;
			lcFilter, ;
			llFound,  ;
			llExitOK,	;
			lxValue
		
		* Do nothing if the user's clicking on the Revert button or cancelling.
		*** JRN 01/17/2009 : because of gripper in splitter, following may fail (that's why the Try)
		*   but no RETURN in a try ... so process it outside
		loObject = Sys(1270)
		Try
			llExitOK = (Vartype(loObject) = 'O' And Upper(loObject.Name) = 'CMDREVERT') Or ;
				lastkey() = 27
		Catch
			llExitOK = .F.
		Endtry
		
		If llExitOK
			Return .T.
		Endif
		
		If Vartype(Thisform.oObject) = [O]
			With Thisform
		
				* Ensure we have a valid name.
		
				lcName   = .ValidateName(This.Value)
				llReturn = .T.
				Do Case
		
						* It isn't, so display a warning.
		
					Case Empty(lcName) And Not Empty(This.Value)
						Messagebox(ccLOC_INVALID_NAME, MB_OK + MB_ICONEXCLAMATION, .Caption)
						llReturn = .F.
		
						*** JRN 12/03/2008 : Yes, but not checking here .... Apply only enabled if non-blank
						* The user left the name blank.
						*!*	Case Empty(lcName)
						*!*		Messagebox("Name cannot be blank", ;
						*!*		MB_OK + MB_ICONEXCLAMATION, .Caption)
						*!*		llReturn = .F.
		
						* If the member already exists, display a warning. Note that we're only concerned
						* if the user changes the name of this property or method to one that already exists.
		
					Case Thisform.GetPEMStatus(.oTopOfForm, .JustPEM(lcName), 5) And ;
							not (.JustPEM(lcName, .T.) == .JustPEM(.cOriginalName, .T.))
						Messagebox(Strtran(ccLOC_MEMBER_EXISTS, 'PEM_Name_Place_Holder', lcName), ;
							MB_OK + MB_ICONEXCLAMATION, .Caption)
						llReturn = .F.
				Endcase
		
				* If everything's OK, this is a new property, we don't already have a value for
				* for it, and we're supposed to, assign a default value based on the data type
				* (if we can determine it).
		
				If llReturn And .oMember.IsNewMember And .oMember.cType = 'P' And ;
						.oPrefs.lAssignDefaultValue And Not .oMember.DefaultChanged
					lxValue = Thisform.GetDefaultValue( Thisform.JustPEM(lcName))
					With This.Parent.edtDefault
						.xValue = lxValue
						.Value = .Val2Str(lxValue, lcName, .F.)
					Endwith
		
				Endif llReturn ...
			Endwith
		
		Endif Vartype(Thisform.oObject) = [O]
		Return Iif(llReturn, .T., 0)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS editpropertyeditbox AS baseeditbox OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: setfont
		*p: lfirsttime
	*</DefinedPropArrayMethod>

	lfirsttime = .T.
	Name = "editpropertyeditbox"

ENDDEFINE

DEFINE CLASS editpropertyform AS baseform OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addclassinfo
		*m: addparentcodetext
		*m: assignselectedcontrols
		*m: creatememberdatanew
		*m: creatememberscursor
		*m: editmethodcode
		*m: executescript
		*m: findattributeformember
		*m: getclassfilename
		*m: getcombovalues
		*m: getcustomcombovalues
		*m: getcustomevaluated
		*m: getdopetext
		*m: getobjectpath
		*m: getparentcode
		*m: getparentcodedetailinfo
		*m: getparentcodesetupinfo
		*m: getparentcodevalue
		*m: insertformorclass
		*m: insureformvisible
		*m: iscustomcolor
		*m: iscustomspinner
		*m: isnativecolor
		*m: isreadonly
		*m: loadnode
		*m: loadtree
		*m: savenodehighlighting
		*m: setoletooltips
		*m: sortgrid
		*m: spellcodeorigin
		*m: spellfavorites
		*m: spellhierarchy
		*m: spelltype
		*m: spellvisibility
		*m: spellyes
		*m: viewparentcode
		*p: capplicationpath
		*p: cdodefaulttext
		*p: cpluginpath
		*p: csnippetpath
		*p: csourcefilename
		*p: cthisformcaption
		*p: lavoidbufferoverrun
		*p: lclass
		*p: ldataenvironment
		*p: ldebugmode
		*p: ldontdisableme
		*p: leditingoneproperty
		*p: lpemeditor
		*p: luseabbreviations
		*p: nhelpid
		*p: nobjnumber
		*p: nselectedobjects
		*p: oserver
		*p: otopofform
		*a: aselectedobjects[1,0]
	*</DefinedPropArrayMethod>

	capplicationpath = 
	cdodefaulttext = .F.
	cpluginpath = 
	csnippetpath = <fb2p_value>&#13;</fb2p_value>
	csourcefilename = 
	cthisformcaption = 
	DoCreate = .T.
	lavoidbufferoverrun = .F.
	lclass = .F.
	ldataenvironment = .F.
	ldebugmode = .F.
	ldontdisableme = .F.
	leditingoneproperty = .F.
	lpemeditor = .F.
	luseabbreviations = .F.
	Name = "editpropertyform"
	nhelpid = 0
	nobjnumber = 0
	nselectedobjects = 0
	oserver = .NULL.
	otopofform = .NULL.
	changefontsize.Name = "changefontsize"
	
	PROCEDURE addclassinfo
		Lparameters loControl, lcText
		
		Local lcClassName
		lcClassName = Iif(Thisform.lClass And loControl = Thisform.oTopOfForm , loControl.ParentClass, loControl.Class)
		
		Do Case
			Case Thisform.oPrefs.nTreeViewClassInfo = 1
				lcText = lcText + ' [' + lcClassName + ']'
			Case Thisform.oPrefs.nTreeViewClassInfo = 2 And Empty (loControl.ClassLibrary)
				lcText = lcText + ' [' + lcClassName + ']'
			Case Thisform.oPrefs.nTreeViewClassInfo = 2
				lcText = lcText + ' [' + Juststem (loControl.ClassLibrary) + ":" + lcClassName + ']'
		Endcase
		
		Return lcText
		
	ENDPROC

	PROCEDURE addparentcodetext
		Lparameters lcStyle, lcPem, lcObjectPathName, lcRelativeName, lcMethodCode
		
		Local lcArrow, lcResult, lcMethodHeader, lcValueHeader, lcNextDoDefaultText
		
		lcArrow 	= '* ' &&+ Replicate("-", 10) +'> '
		If " " $ lcRelativeName And Not lcStyle = 'oParentage'
			lcRelativeName = ['] + lcRelativeName + [']
		Endif
		
		
		Do Case
		Case lcStyle = 'Parentage'
			lcResult = 							;
				ccBottomDividerLine				;
				+ Iif (Empty(lcRelativeName), '', "Class  ")									;
				+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
				+ Iif(Empty(lcRelativeName), '', " of " + lcRelativeName + ccCRLF) 				;
				+ Iif("." $ lcObjectPathName, "Object " + lcObjectPathName	+ ccCRLF, '') 		;
				+ ccCRLF
		
		Case lcStyle = 'oParentage'
			If Empty(lcRelativeName)
				lcResult = ''
			Else
				lcResult = 							;
					FullPath(lcRelativeName)		;
					+ "|" 							;
					+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
					+ Chr(0)
			Endif
		
		Case lcStyle = 'Code'
		
			lcMethodHeader = lcArrow + Iif (Empty(lcRelativeName), '', "Class  ")									;
				+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
				+ Iif(Empty(lcRelativeName), '', " of " + lcRelativeName) + ccCRLF									;
		
			If Empty (lcMethodCode)
				lcResult = 								;
					ccTopDividerLine					;
					+ lcMethodHeader 					;
					+ Iif("." $ lcObjectPathName, lcArrow + 'Object ' + lcObjectPathName + ccCRLF, '')  ;
					+ ccCRLF
			Else
				lcResult = 								;
					ccTopDividerLine					;
					+ lcMethodHeader + ccCRLF			;
					+ "Procedure " + lcObjectPathName + "." + lcPem + ccCRLF;
					+ lcMethodCode + ccCRLF				;
					+ "EndProc" + ccCRLF				;
					+ ccCRLF
			Endif
		
		Case lcStyle = 'All Code'
		
			lcMethodHeader = lcArrow + Iif (Empty(lcRelativeName), '', "Class  ")									;
				+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
				+ Iif(Empty(lcRelativeName), '', " of " + lcRelativeName + ccCRLF)
		
			If Empty (lcMethodCode)
				lcResult = ''
			Else
				lcResult = 								;
					ccTopDividerLine					;
					+ lcMethodHeader + ccCRLF			;
					+ "Procedure " + lcObjectPathName + "." + lcPem + ccCRLF;
					+ lcMethodCode + ccCRLF				;
					+ "EndProc" + ccCRLF				;
					+ ccCRLF
			Endif
		
		Case lcStyle = 'First Code'
		
			lcResult = Evl (lcMethodCode, '')
			If Not Empty (lcResult)
				If Empty(This.cDoDefaultText)
					This.cDoDefaultText = Sys(2015) && some random name
					lcResult = '#Define DoDefault ' + This.cDoDefaultText + ccCRLF ;
						+ lcMethodCode + ccCRLF 						;
						+ '#Undefine DoDefault' + ccCRLF + ccCRLF		;
						+ '******************************' + ccCRLF
				Else
					lcNextDoDefaultText = Sys(2015) && some random name
					lcResult = '#Define DoDefault ' + lcNextDoDefaultText + ccCRLF ;
						+ 'Proc ' + This.cDoDefaultText + ccCRLF		;
						+ lcMethodCode + ccCRLF 						;
						+ '#Undefine DoDefault' + ccCRLF + ccCRLF		;
						+ '******************************' + ccCRLF
					This.cDoDefaultText = lcNextDoDefaultText
				Endif
			Endif
		
		Case lcStyle = 'Inherited Code'
		
			lcResult = Evl (lcMethodCode, '')
		
		Case lcStyle = 'Inherited Value'
		
			lcResult = Evl (lcMethodCode, '')
		
		Case lcStyle = 'Value'
		
			lcValueHeader = lcArrow + Iif (Empty(lcRelativeName), '', "Class  ")									;
				+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
				+ Iif(Empty(lcRelativeName), '', " of " + lcRelativeName) + ccCRLF
		
			If Empty (lcMethodCode)
				lcResult = 								;
					ccTopDividerLine					;
					+ lcValueHeader 					;
					+ ccCRLF
			Else
				lcResult = 								;
					ccTopDividerLine					;
					+ lcValueHeader + ccCRLF			;
					+ Iif('.' $ lcObjectPathName, Substr (lcObjectPathName, At('.', lcObjectPathName)) + '.', '' ) + lcMethodCode + ccCRLF + ccCRLF
			Endif
		
		*	lcResult = Evl (lcMethodCode, '')
		
		Endcase
		
		Return lcResult
		
	ENDPROC

	PROCEDURE assignselectedcontrols
		Lparameters lcPem, luNewValue
		
		If Not Thisform.lEditingOneProperty
			Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, luNewValue, Thisform.nSelectedObjects <= 1)
		Else
			Thisform.UpdateSelectedControls(Thisform.aSelectedObjects (Thisform.nObjNumber), lcPem, luNewValue, .T.)
		Endif
		
	ENDPROC

	PROCEDURE creatememberdatanew
		Lparameters toObject, tcCursorName, tlAvoidBufferOverrun
		
		Local loDOM As ccXML_DOM_CLASS
		Local loResult As Object
		Local laLines(1), laObjectMembers(1), lcFavorites, lcName, lcPEM, llActiveX, llChanged, llReadOnly
		Local lnLen, lnRow
		
		*** JRN 2010-09-23 : Removed .... way too slow, little value
		*** JRN 2009-10-02 : The call to AMembers below can crash VFP with 'Buffer Overrun'
		*!*	Dimension laLines[ 1 ]
		*!*	If Not tlAvoidBufferOverrun
		*!*		Try
		*!*			***********************************************************************
		*!*			*** Changed By.: Marcia G. Akins on 06 January 2007
		*!*			*** Reason.....: Use AMEMBERS() to get the description from column 4
		*!*			***********************************************************************
		*!*			Amembers( laLines, toObject, 3 )
		*!*		Catch
		*!*		Endtry
		*!*	Endif
		
		****************************************************************
		* Create a cursor of MemberData records from the FOXCODE table so we can look
		* for global PEMs. Bug out if we can't open FOXCODE.
		Try
			Use (_Foxcode) Again Shared In 0 Alias Foxcode
		Catch
		Endtry
		If Not Used('FOXCODE')
			This.cErrorMessage = ccLOC_CANT_OPEN_FOXCODE
			Return
		Endif Not Used('FOXCODE')
		Select ABBREV From (_Foxcode) ;
			where Type = 'P' And Not Deleted() ;
			into Cursor _PROPERTIES
		Index On Upper(ABBREV) Tag ABBREV
		Select ABBREV, TIP From (_Foxcode) ;
			where Type = ccGLOBAL_MEMBER_DATA_TYPE And Not Deleted() ;
			into Cursor Global
		Index On Upper(ABBREV) Tag ABBREV
		Use In Foxcode
		lnLen = Len(ABBREV)
		
		loDOM = Createobject(ccXML_DOM_CLASS)
		loDOM.Async = .F.
		
		****************************************************************
		
		This.CreateMembersCursor (.F., tcCursorName)
		loResult = Thisform.oServer.GetPEMList(toObject, Thisform.lClass, .F.)
		Append From Array loResult.MethodList 		;
			Fields cName, cType, lAccess, lAssign, nVisibility, lNative, lInherited, nFavorites, lReadonly, cScript
		Index On Upper(cName) Tag Order
		
		llActiveX = Lower(toObject.BaseClass) = 'olecontrol'
		If llActiveX
			Amembers(laObjectMembers, toObject, 1, 'PHG#')
		Endif
		
		****************************************************************
		Scan
			lcPEM    = Upper (Trim (cName))
		
			If Indexseek (Padr (lcPEM, lnLen), .T., 'GLOBAL');
					and Not Empty (Global.TIP)
				loDOM.LoadXML(Global.TIP)
				If loDOM.parseError.errorCode = 0
					lcFavorites = This.FindAttributeForMember(lcPEM, 'Favorites', loDOM)
					If lcFavorites == ccXML_TRUE
						Replace nFavorites With 2 + nFavorites
					Endif
					If Lower(cName) == cName
						lcName = This.FindAttributeForMember(lcPEM, 'Display', loDOM)
						If Not Empty (lcName)
							Replace cName With lcName
						Endif
					Endif
				Endif
			Endif
		
			If Lower(cName) == cName And (lNative Or llActiveX)
				Replace cName With Proper(cName)
			Endif
		
			If cType = 'P' And "U" # Type("ALen(toObject." + lcPEM + ")")
				Replace cName With Trim(cName) + '[' + Transform (Alen (toObject.&lcPEM,1));
					+ IIf( 0 # Alen (toObject.&lcPEM,2),									;
					"," + Transform (Alen (toObject.&lcPEM,2)) , '') + ']'
			Endif
		
			If llActiveX
				lnRow = Ascan( laObjectMembers, lcPEM, 1, -1, 1, 15 )
				If lnRow > 0
					llChanged = 'C' $ laObjectMembers[lnRow, 3]
					llReadOnly = 'R' $ laObjectMembers[lnRow, 3]
				Else
					llChanged = .F.
					llReadOnly = .F.
				Endif
			Else
				llChanged =  This.GetPEMStatus (toObject, lcPEM, 0)
				llReadOnly = This.GetPEMStatus (toObject, lcPEM, 1)
			Endif
		
			Do Case
				Case cType $ 'P'
					Replace			;
						lNonDefault With  llChanged Or Not (lNative Or lInherited) 	;
						lHasCode	With  .F.										;
						lReadonly   With  llReadOnly
				Case llChanged
					Replace			;
						lNonDefault With  Not Empty (toObject.ReadMethod (lcPEM))	;
						lHasCode	With  llChanged Or Not (lNative Or lInherited)	;
						lReadonly   With  llReadOnly
				Otherwise
					Replace 		;
						lReadonly   With  llReadOnly
			Endcase
		
			*** JRN 2010-09-23 : Removed .... way too slow, little value
			*!*		*   If Type( [laLines], 1 ) = [A]
			*!*		If Alen (laLines) >= 4
			*!*			lnRow = Ascan( laLines, lcPEM, 1, -1, 1, 15 )
			*!*			If lnRow > 0
			*!*				Replace cDescript  With  laLines[ lnRow, 4 ]
			*!*			Endif
			*!*		Endif
		Endscan
		
		
		* Close the cursors.
		
		Use In _PROPERTIES
		Use In Global
		
	ENDPROC

	PROCEDURE creatememberscursor
		Lparameters tlPasteMode, tcCursorName
		
		Local lcCursorName
		lcCursorName = Evl (tcCursorName, 'csrMembers')
		
		If tlPasteMode
			* note that leading fields here must match normal case, but can't have a Memo field
			Create Cursor (lcCursorName) (	;
				cName 		C (128)		, 	;  && ccNameCol
				cType 		C (1)		, 	;  && ccTypeCol
				lAccess 	L			, 	;  && ccAccessCol
				lAssign 	L			, 	;  && ccAssignCol
				nVisibility N(2)		, 	;  && ccVisibilityCol
				lNative 	L			, 	;  && ccNativeCol
				lInherited 	L			, 	;  && ccInheritedCol
				lNonDefault L			, 	;  && ccNonDefaultCol
				lHasCode	L			, 	;  && ccHasCodeCol
				nFavorites 	N (1)		, 	;  && ccFavoritesCol
				lReadOnlyX 	L			, 	;  && ccReadOnlyXCol
				cDescript 	C (254)		, 	;  && ccDescriptCol
				nObjNumber	N (4)		,  	;  && ccObjNumberCol
				cValue		C (100)		,   ;  && ccPastecValueCol
				cScript     C (254)		,   ;  && ccHasScript
				;
				xValue		C (1) Null	,   ;  && ccPasteValueCol
				cTypeCol	C (1)		,	;  && ccPasteTypeCol
				lSelect		L			,	;  && ccPasteSelectCol
				lNew		L			,	;  && ccPastelNewCol
				;
				lReadOnly	L			,	;
				cCurValue	C (100)		,	;
				NRecNo      N (4)		    ;
				)
		
		Else
		
			Create Cursor (lcCursorName) (	;
				cName 		C (128)		, 	;
				cType 		C (1)		, 	;
				lAccess 	L			, 	;
				lAssign 	L			, 	;
				nVisibility N(2)		, 	;
				lNative 	L			, 	;
				lInherited 	L			, 	;
				lNonDefault L			, 	;
				lHasCode	L			, 	;
				nFavorites 	N (1)		, 	;
				lReadOnly 	L			, 	;
				cDescript 	M			, 	;
				nObjNumber	N (4)		,	;
				cValue		C (100)		,   ;
				cScript     M			    ;
				)
		
		Endif
		
	ENDPROC

	PROCEDURE editmethodcode
		Lparameters tcNewMethod, toObject
		
		*** JRN 11/11/2008 : Invoke EditSource to edit Method Code
		
		Local laObject(1), lcFileName, lcClassName, lcPem, oContainerObj, loTopOfForm, lcObjectName
		Local loObject, lcMethod
		
		lcFileName = Thisform.cSourceFileName
		
		If Upper (Justext(lcFileName)) == 'TMP'
			*** JRN 2010-04-27 : per Bernard ... after file is saved, the file name changes
			Aselobj(laObject, 3)
			lcFileName = Lower(laObject[2])
			If Upper (Justext(lcFileName)) == 'TMP'
				Messagebox(ccLOC_CAP_Cant_Edit)
				Return
			Else
				Thisform.cSourceFileName = lcFileName
			Endif
		Endif
		
		If (Not Empty(tcNewMethod)) or Thisform.oMember.cType $ [ME]
		
			If "O" # Vartype(toObject)
				toObject = Thisform.oObject
			Endif
			loObject	= toObject
		
			If "C" # Vartype(tcNewMethod)
				tcNewMethod = Thisform.JustPEM(Thisform.oMember.cName)
			Endif
			lcMethod	= tcNewMethod
		
			This.oUtils.EditLocalMethodCode(lcFileName, Thisform.oTopOfForm, loObject, lcMethod, Thisform.lClass, This.lDataEnvironment)
		
		Endif
		
		
	ENDPROC

	PROCEDURE executescript
		Lparameters lcScript, lcParams, loObject
		
		Local lcFileName, cCmd, lxResult, loException
		
		****************************************************************
		* Following code courtesy of Bernard Bout; with slight modifications
		Set Notify Off && stops the compiling... dialogbox
		Set Safety Off && to overwrite the old file
		*************************************
		lcFileName = "_PEMEditor" + Sys(2015)
		
		
		Strtofile ('#Define Recursive           ' + lcFileName + ccCRLF, lcFileName + ".prg")
		Strtofile(lcScript, lcFileName + ".prg", 1)
		
		cCmd = "Compile ('" + lcFileName + ".prg')"
		&cCmd
		
		cCmd = lcFileName + Iif( Empty (lcParams), '()', Iif('(' $ lcParams, lcParams, '(' + lcParams + ')'))
		
		If This.oPrefs.lDebugMode
			lxResult = &cCmd
		Else
			Try
				lxResult = &cCmd
			Catch To loException
				Thisform.ShowErrorMsg (loException)
				lxResult = Createobject("Empty")
			Endtry
		Endif
		
		Erase (lcFileName + ".*")
		
		Return lxResult
		****************************************************************
		
	ENDPROC

	PROCEDURE findattributeformember
		Lparameters tcMember, tcAttribute, toDOM
		Local loDOM As Object
		Local loNode As Object
		Local lcValue
		
		If Vartype(toDOM) = 'O'
			loDOM = toDOM
		Else
			loDOM = This.oXMLDOM
		Endif Vartype(toDOM) = 'O'
		lcValue = ''
		loNode  = loDOM.selectSingleNode('//' + ccMEMBER_DATA_XML_ELEMENT + ;
			'[@name = "' + Lower(tcMember) + '"]')
		If Vartype(loNode) = 'O'
			lcValue = Nvl(loNode.getAttribute(Lower(tcAttribute)), '')
		Endif Vartype(loNode) = 'O'
		Return lcValue
		
	ENDPROC

	PROCEDURE getclassfilename
		Lparameters tcClassLoc, tcPath
		
		*** JRN 02/24/2009 : per Doug ... handles cases of absolute paths and relative to current directory
		
		Do Case
			Case ":" $ tcClassLoc
				Return tcClassLoc
		
			Case File( Fullpath( m.tcClassLoc, m.tcPath ) )
				Return Fullpath(tcClassLoc, tcPath)
		
			Otherwise
				Return Fullpath( m.tcClassLoc )
		Endcase
		
		
	ENDPROC

	PROCEDURE getcombovalues
		Lparameters laValues, lcPem, lcEditor, lcBaseClass
		External array laValues
		
		lcPem = lcPem + ' '
		If lcEditor == 'Combo'
			Select Value, Descript From PropertyValues	;
				where Name = lcPem 						;
				into Array laValues
		
		Else
		
			Select Value, Descript From PropertyValues	;
				where Name = lcPem 						;
				and BaseClass = Upper (lcBaseClass)		;
				into Array laValues
		
			If _Tally = 0
				Select Value, Descript From PropertyValues	;
					where Name = lcPem 						;
					and Empty (BaseClass)					;
					into Array laValues
			Endif
		Endif
		
		Return
		
	ENDPROC

	PROCEDURE getcustomcombovalues
		Lparameters taValues, tcPem, tcDescript
		External Array taValues
		
		Local lcPem, lnPos, lnCount, lcLine, lcDopeText, lcNum, lnI, lnNum
		lcPem = Upper(tcPem) + ' '
		
		* nEnum
		lcDopeText = This.GetDopeText(tcDescript, 'nEnum')
		If Not Empty (lcDopeText)
			Alines (laValues, Strtran(lcDopeText, '\n', ',', 1, 999, 1), .T., "|", ";")
			lnCount = 0
			For lnI = 1 To Alen (laValues)
				lcLine = laValues(lnI)
				* Find first of '=' or '-'
				lnPos = Min (Evl (At ('-', lcLine), 1000),Evl (At ('=', lcLine), 1000))
				If lnPos # 1000
					lcNum = Left (lcLine, lnPos - 1)
					Try
						lnNum = Evaluate (lcNum)
						lnCount = lnCount + 1
						Dimension taValues (lnCount,2)
						taValues (lnCount, 1) = lnNum
						taValues (lnCount, 2) = lcLine
					Catch
		
					Endtry
				Endif
			Endfor
			Return lnCount # 0
		Endif
		
		* cEnum
		lcDopeText = This.GetDopeText(tcDescript, 'cEnum')
		If Not Empty (lcDopeText)
			Alines (laValues, Strtran(lcDopeText, '\n', ',', 1, 999, 1), .T., "|", ";")
			lnCount = 0
			For lnI = 1 To Alen (laValues)
				lcLine = laValues(lnI)
				If Not Empty (lcLine)
					* Find first of '=' or '-'
					lnPos = Min (Evl (At ('-', lcLine), 1000),Evl (At ('=', lcLine), 1000))
					lcNum = Iif (lnPos = 1000, lcLine, Left (lcLine, lnPos - 1))
					lnCount = lnCount + 1
					Dimension taValues (lnCount,2)
					taValues (lnCount, 1) = lcNum
					taValues (lnCount, 2) = lcLine
				Endif
			Endfor
			Return lnCount # 0
		Endif
		
		* Old Style
		lcDopeText = This.GetDopeText(tcDescript, '')
		If Not Empty (lcDopeText)
			Alines (laValues, Strtran(lcDopeText, '\n', ',', 1, 999, 1), .T., ",", ";")
			lnCount = 0
			For lnI = 1 To Alen (laValues)
				lcLine = laValues(lnI)
				* Find first of '=' or '-'
				lnPos = Min (Evl (At ('-', lcLine), 1000),Evl (At ('=', lcLine), 1000))
				If lnPos # 1000
					lcNum = Left (lcLine, lnPos - 1)
					If ThisForm.oUtils.IsNumber (lcNum)
						lnCount = lnCount + 1
						Dimension taValues (lnCount,2)
						taValues (lnCount, 1) = Val (lcNum)
						taValues (lnCount, 2) = lcLine
					Endif
				Endif
			Endfor
			Return lnCount # 0
		Endif
		
		Return .F.
		
	ENDPROC

	PROCEDURE getcustomevaluated
		Lparameters lcResult, lcDescript
		
		lcResult = This.GetDopeText (lcDescript, '!')
		Return Not Empty (lcResult)
		
	ENDPROC

	PROCEDURE getdopetext
		Lparameters tcDescript, tcKeyValue
		Local lcDOPEText, lcName, lcResult, lnExtenderPos1, lnExtenderPos2, lnPos
		
		If Empty (tcDescript)
			Return ''
		Endif
		
		lnPos = Rat ('***', tcDescript)
		If lnPos # 0
			lcDOPEText = Alltrim (Substr(tcDescript,lnPos + 3))
			If Upper (lcDOPEText) = Upper(tcKeyValue)
				lcResult = Alltrim (Substr (lcDOPEText, 1 + Len (tcKeyValue)))
				If Empty (lcResult)
					Return '?'
				Else
					*** JRN 07/20/09 : DOPE Extender   <[PropertyName]>
					Try && necessary in case the PEM name is bad
						lnExtenderPos1 = At('<[', lcResult)
						lnExtenderPos2 = At(']>', lcResult)
						If lnExtenderPos1 > 0 And lnExtenderPos1 < lnExtenderPos2
							lcName = Substr(lcResult, lnExtenderPos1 + 2, lnExtenderPos2 - lnExtenderPos1 - 2)
							lcResult = Left(lcResult, lnExtenderPos1 - 1) + Getpem(Thisform.oobject, lcName) + Substr(lcResult, lnExtenderPos2 + 2)
						Endif
					Catch
		
					Endtry
					Return lcResult
				Endif
			Endif
		Endif
		
		Return ''
		
		
	ENDPROC

	PROCEDURE getobjectpath
		Lparameters loObject
		
		Local loTopOfForm As Object
		Local lcCaption
		
		loTopOfForm	= Thisform.oTopOfForm
		lcCaption	= ''
		Do While loObject # loTopOfForm
			If Upper(loObject.BaseClass) # "DATAENVIRONMENT"
				lcCaption = '.' + loObject.Name + lcCaption
				If 'O' = Type ('loObject.Parent')
					loObject = loObject.Parent
				Else
					Exit
				Endif
			Else
				lcCaption = loObject.Name + lcCaption
				Exit
			Endif
		Enddo
		
		Return lcCaption
		
	ENDPROC

	PROCEDURE getparentcode
		Lparameters tcName, lcStyle, loObject, llSkipCurrentCode
		
		* lcStyle =
		*     	'Code'
		* 		'Parentage'
		**		'Value'
		*		'All Code'
		**		'First Code'
		**		'Inherited Code'
		**		'Inherited Value'
		
		Local lnSelect, lcResult, loSetupInfo, lcClass, lcClassLib, lcParent, loDetailInfo, loObject
		
		*  tcName = Alltrim(ThisForm.oOriginalMember.cname)
		If "O" # Vartype (loObject)
			loObject = Thisform.oObject
		Endif
		
		lnSelect = Select()
		Select 0
		
		This.cDoDefaultText = ''
		
		*** JRN 12/21/2008 : per Rick's suggestion, start with code for current method
		Do Case
			Case lcStyle = 'Code'
				If llSkipCurrentCode
					lcResult = ''
				Else 
					lcResult = loObject.ReadMethod(tcName)
					If Not Empty(lcResult)
						lcResult = 'Procedure ' + tcName + ccCRLF + lcResult + ccCRLF + 'EndProc' + ccCRLF + ccCRLF
					Endif
				Endif
		
			Case lcStyle = 'All Code'
				lcResult = loObject.ReadMethod(tcName)
				If Not Empty(lcResult)
					lcResult = 'Procedure ' + tcName + ccCRLF + lcResult + ccCRLF + 'EndProc' + ccCRLF + ccCRLF
				Endif
		
			Case lcStyle = 'First Code'
				lcResult = This.addparentcodetext( 'First Code',,, '', loObject.ReadMethod(tcName))
		
			Case lcStyle = 'Parentage'
				lcResult = ''
		
			Case lcStyle = 'oParentage'
				lcResult = ''
		
			Case lcStyle = 'Inherited Code'
				lcResult = ''
		
			Case lcStyle = 'Inherited Value'
				lcResult = ''
		
			Case lcStyle = 'Value'
				If ThisForm.GetPemStatus (loObject, tcName, 0)
					lcResult = '.' + tcName + " = " + Thisform.getValue(tcName, Not ThisForm.GetPemStatus (loObject, tcName, 4),  'Full Value')
					lcResult = lcResult + Iif(Empty(lcResult), '', ccCRLF + ccCRLF)
				Else
					lcResult = ''
				Endif
		Endcase
		
		If Empty (tcName) Or Thisform.GetPEMStatus (loObject, tcName, 6)
			loSetupInfo = This.getparentcodesetupinfo (			;
				Lower(loObject.Class)							;
				, Iif(Thisform.lClass And Thisform.oTopOfForm = loObject, Thisform.cSourceFileName, loObject.ClassLibrary)	;
				, loObject										;
				)
		
			With loSetupInfo
				lcClass		= .Class
				lcClassLib	= .Classlib
				lcParent	= .Parent
			Endwith
		
			loDetailInfo = This.getparentcodedetailinfo (lcStyle, lcClass, lcClassLib, lcParent, tcName, loObject)
			With loDetailInfo
				lcResult	= lcResult + Iif (Inlist (lcStyle, 'Inherited Code', 'Inherited Value') And Not Empty (lcResult), '', .Result)
				lcClass		= .Class
				lcClassLib	= .Classlib
				lcParent	= .Parent
			Endwith
		
			*** JRN 12/26/2008 : Handling of members (pages, optionbuttons, etc)
			Do Case
				Case Thisform.lIsTopOfForm && nothing to do
		
				Case Lower(lcClass) == Lower(loObject.BaseClass) && nothing here either
		
				Case Thisform.GetPEMStatus(loObject.Parent, "MemberClass", 5)
					loDetailInfo = This.getparentcodedetailinfo (lcStyle, loObject.Parent.MemberClass, loObject.Parent.MemberClassLibrary, '', tcName, loObject)
					With loDetailInfo
						lcResult	= lcResult + Iif (Inlist (lcStyle, 'First Code', 'Inherited Code', 'Inherited Value') And Not Empty (lcResult), '', .Result)
						lcClass		= .Class
						lcClassLib	= .Classlib
						lcParent	= .Parent
					Endwith
		
				Case Thisform.GetPEMStatus(loObject.Parent, "HeaderClass", 5)
					loDetailInfo = This.getparentcodedetailinfo (lcStyle, loObject.Parent.HeaderClass, loObject.Parent.HeaderClassLibrary, '', tcName, loObject)
					With loDetailInfo
						lcResult	= lcResult + Iif (Inlist (lcStyle, 'First Code', 'Inherited Code', 'Inherited Value') And Not Empty (lcResult), '', .Result)
						lcClass		= .Class
						lcClassLib	= .Classlib
						lcParent	= .Parent
					Endwith
		
			Endcase
		
			****************************************************************
			If 'L' # Vartype (lcClassLib)
				Do Case
					Case Inlist (lcStyle, 'Code', 'All Code')
						lcResult = lcResult + This.addparentcodetext(lcStyle, ccLOC_VFP_Base_Class + lcClass, ccLOC_VFP_Base_Class + lcClass, '', '')
					Case Inlist (lcStyle, 'Value', 'Inherited Value')
						Local laProps(2)
						Select * From DefaultNativeProperties 				;
							Where cpropname = Upper(tcName) 				;
							And (Empty(cbaseclass) Or cbaseclass = Upper(loObject.BaseClass)) Into Array laProps
						Do Case
							Case _Tally = 0
								lcResult = lcResult + This.addparentcodetext(lcStyle, ccLOC_VFP_Base_Class + lcClass, ccLOC_VFP_Base_Class + lcClass, '', '')
							Case lcStyle = 'Value'
								lcResult = lcResult + This.addparentcodetext(lcStyle, ccLOC_VFP_Base_Class + lcClass, ccLOC_VFP_Base_Class + lcClass, '',		;
									tcName + ' = ' + Alltrim(laProps(_Tally, 3)))
							Case Empty(lcResult)
								lcResult = lcResult + This.addparentcodetext(lcStyle, ccLOC_VFP_Base_Class + lcClass, ccLOC_VFP_Base_Class + lcClass, '',		;
									Alltrim(laProps(_Tally, 3)))
						Endcase
				Endcase
			Endif
		
		Endif
		
		Use
		Select (lnSelect)
		Return lcResult
		
		Use
		
		Select (lnSelect)
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getparentcodedetailinfo
		Lparameters lcStyle, lcClass, lcClassLib, lcParent, tcName, loObject
		
		Local  ;
			loResult As "Empty"
		Local lbFileOpened, lcCurrentParent, lcFullName, lcMethodCode, lcObjectName, lcObjectPathName
		Local lcParent2, lcPEM, lcRelative, lcRelativeName, lcResult, lcSearchName, lcTempObject, lnPos
		Local lnRecno, loException
		
		lcResult 		= ''
		lcObjectName 	= loObject.Name
		lcPEM 			= tcName
		
		Do While Not Empty (lcClassLib)
			Try
				Use In (Select("VCX"))
				Use (lcClassLib) Again Shared Alias VCX
				lbFileOpened = .T.
			Catch To loException
				lbFileOpened = .F.
				lcResult = lcResult	+ ccBottomDividerLine	;
					+ Strtran (ccLOC_ViewParentCode_File_Failed, '<FileName>', "'" + lcClassLib + "'")	;
					+ ccCRLF + loException.Message			;
					+ ccCRLF + ccCRLF
				lcClassLib = '' && all done, can't even open file
			Endtry
		
			If lbFileOpened
				lcSearchName = Lower(lcPEM)
				If Empty(lcParent) && simple case ... this object defined here
					lcObjectPathName = lcClass
					Locate For Lower(OBJNAME) == lcClass And Lower(RESERVED1) = 'class'
					Do Case
		
						Case Inlist (lcStyle, 'Code', 'All Code', 'First Code', 'Inherited Code')
							lcMethodCode = Strextract(ccLF + Methods, ccLF + "procedure " + lcSearchName + ccCRLF, ccCRLF + "endproc",1,1)
		
						Case lcStyle = 'Value'
							lnPos = Atc(ccLF + lcSearchName + ' =', ccLF + properties)
							If lnPos > 0
								lcMethodCode = Substr(properties, lnPos ) && + Len(lcSearchName) + 3)
								lcMethodCode = This.GetParentCodeValue (lcSearchName, lcMethodCode)
							Else
								lcMethodCode = ''
							Endif
		
						Case lcStyle = 'Inherited Value'
							lnPos = Atc(ccLF + lcSearchName + ' =', ccLF + properties)
							If lnPos > 0
								lcMethodCode = Substr(properties, lnPos + Len(lcSearchName) + 3)
								lcMethodCode = This.GetParentCodeValue (lcSearchName, lcMethodCode)
							Else
								lcMethodCode = ''
							Endif
		
					Endcase
		
				Else && this object inherited as object in parent class
		
					* (1)  have to back up through parentage to see where this object is defined in the class
					* (2)  for some objects, the method code may be saved farther back!
					lcObjectPathName = lcParent + "." + lcObjectName
					lnRecno			= 0
					lcTempObject 	= Lower(lcObjectPathName)
					lcCurrentParent = lcParent
					lcMethodCode 	= ''
					Do While Not Empty(lcTempObject) And Empty(lcMethodCode)
						Locate For lcTempObject == Lower( IIf(Empty(Parent), "", Parent + ".") + OBJNAME) ;
							And (Lower(RESERVED1) # 'class' Or Not '.' $ lcTempObject)
						If Found() And (lnRecno = 0 Or Inlist (Lower(BaseClass), 'pageframe', 'grid'))
							lcParent2 = Substr(lcCurrentParent, 2 + Len( lcTempObject))
							If lnRecno = 0
								lnRecno = Recno()
								Do Case
									Case Len( lcTempObject) > Len(lcCurrentParent)
										lcParent 		= ''
										lcSearchName	= lcPEM
									Case Empty(lcParent2)
										lcParent		= VCX.Class
										lcSearchName	= lcObjectName + '.' + lcPEM
									Otherwise
										lcParent 		= VCX.Class + '.' + lcParent2
										lcSearchName	= lcParent2 + '.' + lcObjectName + '.' + lcPEM
								Endcase
							Endif
							*	lcSearchName = Icase( 						;
							Empty(lcParent2), lcPEM, 				;
							"." $ lcTempObject, lcParent2 + "." + lcObjectName + "." + lcPEM,	;
							lcParent2 + "." + lcPEM				;
							)
							Do Case
		
								Case Inlist (lcStyle, 'Code', 'All Code', 'First Code', 'Inherited Code')
									lcMethodCode = Strextract(ccLF + Methods, ccLF + "procedure " + lcSearchName + ccCRLF, ccCRLF + "endproc",1,1)
		
								Case lcStyle = 'Value'
									lnPos = Atc(ccLF + lcSearchName + ' =', ccLF + properties)
									If lnPos > 0
										lcMethodCode = Substr(properties, lnPos ) && + Len(lcSearchName) + 3)
										lcMethodCode = This.GetParentCodeValue (lcSearchName, lcMethodCode)
									Else
										lcMethodCode = ''
									Endif
		
								Case lcStyle = 'Inherited Value'
									lnPos = Atc(ccLF + lcSearchName + ' =', ccLF + properties)
									If lnPos > 0
										lcMethodCode = Substr(properties, lnPos + Len(lcSearchName) + 3)
										lcMethodCode = This.GetParentCodeValue (lcSearchName, lcMethodCode)
									Else
										lcMethodCode = ''
									Endif
		
							Endcase
						Endif
		
						If "." $ lcTempObject
							lcTempObject = Juststem(lcTempObject)
						Else
							lcTempObject = ''
						Endif
		
					Enddo
		
					If lnRecno # 0
						Goto (lnRecno)
					Endif
		
				Endif
		
				If Found()
					lcRelative = Sys(2014, lcClassLib)
					lcRelativeName = IIf(lcRelative # '..\..\..\' And Getwordcount(lcRelative, '\') < Getwordcount(lcClassLib, '\'), lcRelative, lcClassLib)
					lcFullName = lcObjectPathName + '.' + lcPEM + '()' + ' of ' + lcRelativeName
		
					If Not (Inlist (lcStyle, 'Inherited Code', 'Inherited Value') And Not Empty (lcResult))
						lcResult = lcResult + This.addparentcodetext(lcStyle, lcPEM, lcObjectPathName, lcRelativeName, lcMethodCode)
					Endif
		
					lcClass = VCX.Class
					Do Case
						Case Inlist (lcStyle, 'Code', 'All Code') And (ccCRLF + '*' + Lower(lcPEM) + ' ') $ ccCRLF + Reserved3
							lcClassLib = .F. && custom in this class; don't go any further
						Case Inlist (lcStyle, 'Value') And (ccCRLF + Lower(lcPEM) + ' ' ) $ ccCRLF + Strtran(Reserved3, ccCRLF, ' ' + ccCRLF)
							lcClassLib = .F. && custom in this class; don't go any further
						Case Inlist (lcStyle, 'Inherited Value') And (ccCRLF + Lower(lcPEM) + ' ' ) $ ccCRLF + Strtran(Reserved3, ccCRLF, ' ' + ccCRLF)
							lcClassLib = .F. && custom in this class; don't go any further
							If Empty(lcResult)
								lcResult = ".F."
							Endif
						Case Empty(VCX.ClassLoc)
							Exit && baseclass
						Otherwise
							*** DougHennig 12/06/2008: VCX.ClassLoc is relative to the open class library
							lcClassLib = Thisform.GetClassFileName(VCX.ClassLoc, Addbs(Justpath(lcClassLib)))
					Endcase
		
				Else
					lcResult = lcResult	+ ccBottomDividerLine	;
						+ Strtran (Strtran (ccLOC_ViewParentCode_Class_Failed, '<FileName>', "'" + lcClassLib + "'"), '<ClassName>', lcObjectPathName ) 	;
						+ ccCRLF + ccCRLF
					lcClassLib = ''
				Endif
		
			Endif
		
			Use
		
		Enddo
		
		Use In (Select("VCX"))
		loResult = Createobject("Empty")
		AddProperty (loResult, "Result", 	lcResult)
		AddProperty (loResult, "Class", 	lcClass)
		AddProperty (loResult, "ClassLib", 	lcClassLib)
		AddProperty (loResult, "Parent", 	lcParent)
		Return loResult
		
	ENDPROC

	PROCEDURE getparentcodesetupinfo
		Lparameters lcClass, lcClassLib, loObject
		Local loResult, lcParent
		
		loResult = Createobject("Empty")
		
		Use In (Select("VCX"))
		*** JRN 12/12/2008 : special case for classes when at top of form
		* since class and classlib point to the current class, not the parent
		If Thisform.lClass And loObject = Thisform.oTopOfForm
			Use (lcClassLib) Again Shared Alias VCX
			Locate For Lower(OBJNAME) == lcClass and Lower(RESERVED1) = 'class'
		
			If Found()
				lcClass = VCX.Class
				If Not Empty(VCX.ClassLoc)
					lcClassLib = Thisform.GetClassFileName(VCX.ClassLoc, Addbs(Justpath(lcClassLib)))
				Else
					lcClassLib = ''
				Endif
			Else
				lcClass = ''
				lcClassLib = ''
			Endif
		Else
			* if this object was inherited as an object contained in another class,
			* get the full object name in that class
			* special handling for pages, columns, and buttons, since their names are not read-only
			* even when inherited
		
			Do While .T.
		
				Do Case
					Case loObject = Thisform.oTopOfForm
						Exit && obviously at top of class/form
					Case Thisform.Isreadonly(loObject, "Name")
						* if name is read-only, continue -- must be part of parent class
					Case Inlist(Lower(loObject.BaseClass) + '#', 'page#', 'column#', 'optionbutton#', 'header#')
						* any of these baseclasses must be part of parent class ... #'s because of pageframe match
					Otherwise && for all others, we must be done
						Exit
				Endcase
		
				lcParent = loObject.Parent.Name + Iif( Empty(lcParent), '', "." + lcParent)
				loObject = loObject.Parent
				lcClassLib = loObject.ClassLibrary
			Enddo
		
			* but the topmost name must be the name of the class, not the name of the object here
			
			If Thisform.lClass and loObject = ThisForm.oTopOfForm
				lcClassName = loObject.ParentClass
			Else
				lcClassName = loObject.Class
			EndIf
			
			Do Case
				Case Empty(lcParent)
		
				Case Not "." $ lcParent
					lcParent = lcClassName 
		
				Otherwise
					lcParent = lcClassName  + Substr(lcParent, At(".", lcParent))
		
			Endcase
		Endif
		
		Use In (Select("VCX"))
		AddProperty (loResult, "Class", 	lcClass)
		AddProperty (loResult, "ClassLib", 	lcClassLib)
		AddProperty (loResult, "Parent", 	lcParent)
		Return loResult
		
	ENDPROC

	PROCEDURE getparentcodevalue
		Lparameters lcName, lcProperties
		Local lnPos, lnLen, lcResult
		
		lnPos = 1
		
		* We have to handle properties with more than 255 characters in the value
		* differently.
		
		If Substr(lcProperties, lnPos, 1) = ccPROPERTIES_PADDING_CHAR
			lnLen        = Val(Alltrim(Substr(lcProperties, ;
				lnPos + cnPROPERTIES_PADDING_SIZE, ;
				cnPROPERTIES_LEN_SIZE)))
			lcResult = Left (lcProperties, lnPos - 1) + Substr(lcProperties, lnPos + ;
				cnPROPERTIES_PADDING_SIZE + cnPROPERTIES_LEN_SIZE, ;
				lnLen)
		Else
			lcResult = Strextract(lcProperties, '', Chr(13))
		Endif Substr(lcProperties, lnPos, 1) = ccPROPERTIES_PADDING_CHAR
		
		Return Evl (lcResult, [''])
	ENDPROC

	PROCEDURE getvalue
		Lparameters lcName, tbNative, tcResultType, tnObjNumber, tcDescript
		
		Local lcPem, lbFirst, lcValue, lxValue, lcNewValue, lxNewValue, lnRed, lnGreen, lnBlue
		Local loObject, lbTransform, loResult, lcTypes, lcNewType, laValue(1), lcEditor, lnValue
		Local laValues(1), lnI, lnJ, lnK, lcEval
		
		If Isnull(Thisform.oObject)
			Return ''
		Endif
		
		If Not Thisform.lEditingOneProperty
			lcPem = Thisform.JustPem(lcName)
		Else
			lcPem = Trim(Thisform.cEditPropertyName)
		Endif
		
		If Indexseek (lcPem + ' ', .T., "PropertyList")
			lcEditor = PropertyList.Editor
		Else
			lcEditor = 'None'
		Endif
		
		lbTransform = .T.
		
		*** JRN 03/18/2009 : modifications to handle multiple objects
		Do Case
			Case Not Empty(tnObjNumber)
				loObject = Thisform.aSelectedObjects(tnObjNumber)
				lcPem = Thisform.cEditPropertyName
				lcValue = loObject.ReadExpression (lcPem)
				lxValue = This.Get1Value (loObject, lcPem)
				lcTypes = Vartype (lxValue)
		
			Case (Thisform.lUseCSO) And Thisform.nSelectedObjects > 1
				lbFirst = .T.
		
				For lnI = 1 To Alen(Thisform.aSelectedObjects)
					loObject = Thisform.aSelectedObjects(lnI)
					Do Case
						Case Not Thisform.GetPEMStatus (loObject, lcPem, 5)
		
						Case lbFirst
							lcValue = loObject.ReadExpression (lcPem)
							lxValue = This.Get1Value (loObject, lcPem)
							lbFirst = .F.
							lcTypes = Vartype (lxValue)
							If lcTypes = 'O'
								lcValue = '(Object)'
								lxValue = '(Object)'
							Endif
						Otherwise
							lcNewValue = loObject.ReadExpression (lcPem)
							lxNewValue = This.Get1Value (loObject, lcPem)
							lcNewType  = Vartype (lxValue)
							If lcNewType = 'O'
								lcNewValue = '(Object)'
								lxNewValue = '(Object)'
							Endif
							If lbTransform
								If (Not lcValue == lcNewValue)							;
										or Vartype (lxValue) # Vartype (lxNewValue)		;
										or lxValue # lxNewValue
									lcValue = ' '
									lbTransform = .F.
									lcTypes = lcTypes + IIf (lcNewType $ lcTypes, '', lcNewType)
								Endif
							Else
								lcTypes = lcTypes + IIf (lcNewType $ lcTypes, '', lcNewType)
							Endif
					Endcase
				Endfor
				If lbFirst && may occur if OLE is only control having this property
					lcValue = ''
					lxValue = ''
					lcTypes = '?'
					lbTransform  = .F.
				Endif
			Otherwise
				Try
					lcValue = Thisform.oObject.ReadExpression (lcPem)
					lxValue = This.Get1Value (Thisform.oObject, lcPem)
					lcTypes = Vartype (lxValue)
				Catch
					lcValue = ''
					lxValue = ''
					lcTypes = '?'
					lbTransform  = .F.
				Endtry
		
		Endcase
		
		If lbTransform And Empty (lcValue)
			Do Case
					* handle null values
		
				Case Isnull(lxValue)
					lcValue = '.NULL.'
					* Special handling for native colors
		
				Case (tbNative And lcEditor = 'Color')			;
						or (									;
						"N" = Vartype (lxValue)					;
						and Thisform.IsCustomColor (tcDescript)	;
						)
					lnRed   = Bitand(lxValue, 255)
					lnGreen = Bitrshift(Bitand(lxValue, 256 * 255), 8)
					lnBlue  = Bitrshift(Bitand(lxValue, 256 * 256 * 255), 16)
					lcValue = Transform(lnRed) + ',' + Transform(lnGreen) + ',' + Transform(lnBlue)
		
					* Native properties with enumerated values
				Case tbNative 									;
						and lcEditor = 'Combo'					;
						and Not (								;
						lcEditor = 'ComboMult' 					;
						And Thisform.nSelectedObjects # 1 		;
						And Not Thisform.lEditingOneProperty	;
						)
		
					If Thisform.nSelectedObjects = 1
						Thisform.GetComboValues (@laValues, lcPem, lcEditor, Thisform.oObject.BaseClass)
						lnValue = Thisform.Get1Value (Thisform.oObject, lcPem)
					Else
						If Thisform.lEditingOneProperty
							loObject = Thisform.aSelectedObjects(csrMembers.nObjNumber)
							Thisform.GetComboValues (@laValues, lcPem, lcEditor, loObject.BaseClass)
							lnValue = Thisform.Get1Value (loObject, lcPem)
						Else
							For lnJ = 1 To Alen ( Thisform.aSelectedObjects)
								loObject = Thisform.aSelectedObjects(lnJ)
								If Thisform.GetPEMStatus (loObject, lcPem, 5)
									Thisform.GetComboValues (@laValues, lcPem, lcEditor, loObject.BaseClass)
									lnValue = Thisform.Get1Value (loObject, lcPem)
									Exit
								Endif
							Endfor
						Endif
					Endif
		
					If 1 # Alen(laValues)
						lcValue = Transform( lnValue )
						For lnI = 1 To Alen (laValues, 1)
							If laValues(lnI,1) = lnValue
								lcValue = laValues(lnI,2)
								Exit
							Endif
						Endfor
					Endif
		
					* Customize properties with enumerated values
				Case Thisform.GetCustomComboValues (@laValues, lcPem, tcDescript)
		
					If Thisform.nSelectedObjects = 1
						lnValue = Thisform.Get1Value (Thisform.oObject, lcPem)
					Else
						If Thisform.lEditingOneProperty
							loObject = Thisform.aSelectedObjects(csrMembers.nObjNumber)
							lnValue = Thisform.Get1Value (loObject, lcPem)
						Else
							For lnK = 1 To Alen (Thisform.aSelectedObjects)
								loObject = Thisform.aSelectedObjects(lnK)
								If Thisform.GetPEMStatus (loObject, lcPem, 5)
									lnValue = Thisform.Get1Value (loObject, lcPem)
									Exit
								Endif
							Endfor
						Endif
					Endif
		
					lcValue = Transform( lnValue )
					For lnI = 1 To Alen (laValues, 1)
						If Vartype (laValues(lnI,1)) = Vartype (lnValue) And laValues(lnI,1) = lnValue
							lcValue = laValues(lnI,2)
							Exit
						Endif
					Endfor
		
					* Customize properties with enumerated values
				Case Thisform.GetCustomEvaluated (@lcEval, tcDescript)
					Try
						With Thisform.oObject
							lcValue = Transform(Evaluate(lcEval))
						Endwith
					Catch
						lcValue = ''
					Endtry
		
				Case 'C' = Vartype (lxValue) And 0 = Len(lxValue) And tcResultType= 'Display'
					lcValue = '(None)'
		
				Case 'N' = Vartype (lxValue)
					lcValue = Alltrim (Transform( lxValue ))
		
				Case 'D' # Vartype (lxValue)
					lcValue = Transform( lxValue )
		
				Case Empty (lxValue)
					lcValue = '{}'
		
				Otherwise
					lcValue = '{^' + Transform(Year(lxValue)) + "/" + Transform(Month(lxValue)) + "/" + Transform(Day(lxValue)) + "}"
		
			Endcase
		Endif
		
		Do Case
			Case tcResultType= 'Display'
				Return Left (lcValue, 100)
			Case tcResultType= 'Full Value'
				Return lcValue
			Case tcResultType= 'For Editing'
				loResult = Createobject("Empty")
				AddProperty (loResult, "Value", lxValue)
				AddProperty (loResult, "CharValue", lcValue)
				AddProperty (loResult, "Type", lcTypes)
				AddProperty (loResult, "SingleValue", lbTransform)
				Return loResult
		Endcase
		
		
	ENDPROC

	PROCEDURE Init
		If Not PEME_IsVersion9()
			This.BorderStyle = 2
		Endif
		
		DoDefault()
	ENDPROC

	PROCEDURE insertformorclass
		Lparameters lcCaption
		
		If This.lClass
			Return Strtran(lcCaption, '<insert2>', ccLOC_CAP_FC_class)
		Else
			Return Strtran(lcCaption, '<insert2>', ccLOC_CAP_FC_Form)
		Endif
		
	ENDPROC

	PROCEDURE insureformvisible
		Local loObject As Object
		Local lnMaxHeight, lnMaxLeft, lnMaxTop, lnMaxWidth
		
		loObject = Thisform
		*** JRN 2009-09-14 : Following code courtesy of Doug Hennig's blog
		#Define SM_XVIRTUALSCREEN  76     && virtual left
		#Define SM_YVIRTUALSCREEN  77     && virtual top
		#Define SM_CXVIRTUALSCREEN 78   && virtual width
		#Define SM_CYVIRTUALSCREEN 79   && virtual height
		* #Define SM_CXFULLSCREEN    16     && screen width accounting for taskbar
		* #Define SM_CYFULLSCREEN    17     && screen height accounting for taskbar
		
		Do Case
			Case Pemstatus(loObject, 'Dockable', 5) And loObject.Dockable = 1
				Declare Integer GetSystemMetrics In Win32API Integer
				lnMaxLeft   = GetSystemMetrics(SM_XVIRTUALSCREEN)
				lnMaxTop    = GetSystemMetrics(SM_YVIRTUALSCREEN)
				lnMaxWidth  = GetSystemMetrics(SM_CXVIRTUALSCREEN)
				lnMaxHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN)
			Case Pemstatus(loObject, 'Desktop', 5) And (loObject.Desktop Or loObject.ShowWindow = 2)
				Declare Integer GetSystemMetrics In Win32API Integer
				lnMaxLeft   = GetSystemMetrics(SM_XVIRTUALSCREEN)
				lnMaxTop    = GetSystemMetrics(SM_YVIRTUALSCREEN)
				lnMaxWidth  = GetSystemMetrics(SM_CXFULLSCREEN)
				lnMaxHeight = GetSystemMetrics(SM_CYFULLSCREEN)
			Otherwise
				lnMaxLeft   = 0
				lnMaxTop    = 0
				lnMaxWidth  = _Screen.Width
				lnMaxHeight = _Screen.Height - ;
					Iif(Pemstatus(loObject, 'TitleBar', 5) And ;
					loObject.TitleBar = 1, Sysmetric(9), 0)
				&& account for the title bar height if necessary
		Endcase
		
		loObject.Width = Min(Max(loObject.Width, 0, loObject.MinWidth), ;
			lnMaxWidth)
		loObject.Height = Min(Max(loObject.Height, 0, loObject.MinHeight), ;
			lnMaxHeight)
		
		Do Case
		
				* If we're past the left edge, move it to the left edge.
		
			Case loObject.Left < lnMaxLeft
				loObject.Left = lnMaxLeft
		
				* If we're past the right edge of the screen, move it to the right edge.
		
			Case loObject.Left + loObject.Width > lnMaxWidth + lnMaxLeft
				loObject.Left = lnMaxWidth + lnMaxLeft - loObject.Width
		Endcase
		Do Case
		
				* If we're past the top edge, move it to the top edge.
		
			Case loObject.Top < lnMaxTop
				loObject.Top = lnMaxTop
		
				* If we're past the bottom edge of the screen, move it to the bottom edge.
		
			Case loObject.Top + loObject.Height > lnMaxHeight + lnMaxTop
				loObject.Top = lnMaxHeight + lnMaxTop - loObject.Height
		Endcase
		****************************************************************
		****************************************************************
		
	ENDPROC

	PROCEDURE iscustomcolor
		Lparameters tcDescript
		
		Return Not Empty(ThisForm.GetDOPEText(tcDescript, 'Color'))
		
	ENDPROC

	PROCEDURE iscustomspinner
		Lparameters tcDescript
		
		Return Not Empty(ThisForm.GetDOPEText(tcDescript, 'Spinner'))
		
	ENDPROC

	PROCEDURE isnativecolor
		Lparameters tcName, tbNative
		
		Return tbNative and InList (tcName,	;
			  'BackColor', 					;
			  'ForeColor', 					;
			  'BorderColor', 				;
			  'DisabledBackColor', 			;
			  'DisabledForeColor', 			;
			  'DisabledItemBackColor', 		;
			  'DisabledItemForeColor', 		;
			  'FillColor', 					;
			  'GridLineColor', 				;
			  'HighlightBackColor', 		;
			  'HighlightForeColor', 		;
			  'ItemBackColor', 				;
			  'ItemForeColor', 				;
			  'SelectedItemBackColor',		;
			  'SelectedItemForeColor'		;
			  )
			  
		
	ENDPROC

	PROCEDURE isreadonly
		Lparameters loObject, lcPem
		
		Local lbResult
		
		Try
			lbResult = Thisform.GetPEMStatus( loObject, lcPem, 1 )
		Catch
			lbResult = .F.
		Endtry
		
		Return lbResult
		
	ENDPROC

	PROCEDURE Load
		DoDefault()
		
		With This
			.cApplicationPath = Addbs (Justpath (Justpath  (This.ClassLibrary)))
			.cPlugInPath = .cApplicationPath + 'Live Plug-Ins\'
			.cSnippetPath = .cApplicationPath + 'Dynamic Snippets\'
		Endwith
		
	ENDPROC

	PROCEDURE loadnode
		Lparameters toTree, loControl, lcParentKey, lcPath
		
		Local  ;
			loNode As Object	,;
			loTag As "Empty"
		Local lbAnyMethods, lcKey, lcName, lcObjectPath, lcText
		
		Local lcKey, lcName, lcText
		With toTree
			lcKey  = 'Node' + Transform(.Nodes.Count)
			lcName = loControl.Name
			If Thisform.lDataEnvironment And Not Empty(loControl.Alias)
				lcText = loControl.Alias
			Else
				lcText = lcName
			Endif
		
			Do Case
				Case Not Thisform.oPrefs.lTreeShowCaptions
		
				Case Thisform.GetPEMStatus (loControl, 'Caption', 5) And Not Empty (loControl.Caption)
					If 25 > Len (loControl.Caption)
						lcText = lcText + [ - ('] + loControl.Caption + [')]
					Else
						lcText = lcText + [ - ('] + Left (loControl.Caption, 20)  + [ ... ')]
					Endif
				Case Thisform.GetPEMStatus (loControl, 'ControlSource', 5) And Not Empty (loControl.ControlSource)
					lcText = lcText + [ - (] + loControl.ControlSource + [)]
				Case Thisform.GetPEMStatus (loControl, 'RecordSource', 5) And Not Empty (loControl.RecordSource)
					lcText = lcText + [ - (] + loControl.RecordSource + [)]
				Case Thisform.GetPEMStatus (loControl, 'cControlSource', 5) And Not Empty (loControl.cControlSource)
					lcText = lcText + [ - (] + loControl.cControlSource + [)]
			Endcase
		
			lcText = Thisform.AddClassInfo(loControl, lcText)
		
			loNode     	= .Nodes.Add(lcParentKey, 4, lcKey, lcText, Lower(loControl.BaseClass))
		
			lcObjectPath = lcPath + '.' + lcName
			loTag = Createobject("Empty")
			AddProperty (loTag, 'Type', 'Object')
			AddProperty (loTag, 'Path', lcObjectPath)
			AddProperty (loTag, 'Found', .F.)
		
			With loNode
				.Tag = loTag
				If Thisform.GetPEMStatus(loControl, 'Name', 1)
					.BackColor = Rgb(224, 224, 224)
				Endif
		
				If Thisform.oPrefs.lExpandAllNodes
					.Expanded = .T.
				Endif
		
				If Upper (lcObjectPath) == Upper (Thisform.cCurrentObjectName)
					.Selected = .T.
					.Expanded = .T.
					.EnsureVisible()
				Endif
			Endw
		
			lbAnyMethods = This.LoadTree(toTree, loControl, lcObjectPath, lcKey)
		
			* Done this way ... because if no methods, loNode may no longer exist!
			If lbAnyMethods
				loNode.Expanded = .T.
			Endif
		
		Endwith
		
		Return lbAnyMethods
		
	ENDPROC

	PROCEDURE loadtree
		* Load the TreeView with the objects. We'll use the object name as both the
		* text and the key and an image with that same name as the image. We'll store
		* the object path to Tag.
		
		*** JRN 02/14/2009 : Modified so that the key is NOT the name of the object,
		* since there can be duplicate names.  Name of nodes are ROOT, NODE2, NODE3, NODE4
		* and the name of the parent is the third parameter
		
		Lparameters toTree,		;
			toParent, 			;
			tcPath,				;
			tcParentKey
		
		Local loControl As Object
		Local loNode As Object
		Local loParent As Object
		Local loParentNode As Object
		Local loResult As Object
		Local loTag As "Empty"
		Local laControls(1), lbAnyMethods, lcKey, lcMethodCode, lcName, lcParentKey, lcPath, lcStartNode, lcTag, lcText
		Local llTopOfForm, lnCount, lnI
		
		lbAnyMethods = .F.
		
		With toTree
		
			* If we're being called to display the root, get the top-most object and add it
			* to the TreeView. Otherwise, just use the object we were passed.
		
			llTopOfForm = Vartype(toParent) <> 'O'
			If llTopOfForm
		
				If Thisform.lDataEnvironment
					Local laDataEnvironment(1)
					Aselobj(laDataEnvironment,2)
					loParent = laDataEnvironment(1)
				Else
					loParent	= Thisform.oTopOfForm
				Endif
		
				lcName    	= Thisform.AddClassInfo( loParent, loParent.Name)
				lcTag 		= ' ' + Proper(Thisform.InsertFormOrClass('<insert2>'))
				lcPath		= ''
		
				*** JRN 07/28/09 : Restrict to an object and its children
				lcStartNode = Thisform.cTreeStartNode
				If Not Empty(lcStartNode)								;
						and Lower(Thisform.GetObjectPath(Thisform.oObject)) = Lower(lcStartNode)
					loParent = Evaluate("Thisform.oTopofForm" + lcStartNode)
					lcName 	= Thisform.AddClassInfo( loParent, loParent.Name)
					lcTag	= lcStartNode
					lcPath	= lcStartNode
				Else
					Thisform.cTreeStartNode = ''
				Endif
		
				lcKey		= 'Root'
				lcParentKey = lcKey
		
				loParentNode 		= .Nodes.Add(, 1, lcKey, lcName, Lower(loParent.BaseClass))
				loTag = Createobject("Empty")
				AddProperty (loTag, 'Type', 'Object')
				AddProperty (loTag, 'Path', lcPath)
				AddProperty (loTag, 'Found', .F.)
				With loParentNode
					.Tag 	= loTag
					.Expanded = .T.
					.Selected = .T.
				Endwith
		
				If Thisform.lTreeViewShowMethods
					Thisform.oServer.MakeCurrent()
		
					Select * From csrMembers Where .F. Into Cursor csrMembersTemp Readwrite
					With Thisform.oMemberDataEngine
						.lClassDesigner = Thisform.lClass
						.oObject = loParent
						.SetupEngine()
						.CreateMemberMethodList ('csrMembersTemp', .T., .F., This.lNoErrorMsgOnMissingVCX)
					Endwith
					Select * 												;
						, cName 						As SortKey			;
						From csrMembersTemp									;
						where Inlist (cType, 'M', 'E')						;
						into Cursor cMyMembers Readwrite
		
				Endif
			Else
				loParent = toParent
				lcPath   = tcPath
				lcParentKey = tcParentKey
		
				If Thisform.lTreeViewShowMethods
					loResult = Thisform.oServer.GetMethodList(loParent, Thisform.lClass, Thisform.lIsTopOfForm And Thisform.lClass)
					Create Cursor cMyMembers (cName C(128), cType C(1), SortKey C(128))
					Append From Array loResult.MethodList
				Endif
			Endif
		
			****************************************************************
			* Adding methods
			If Thisform.lTreeViewShowMethods
		
				Do Case
					Case Thisform.oPrefs.nTreeSortMethods = 1
						Replace All SortKey With Upper(cName)
					Case Thisform.oPrefs.nTreeSortMethods = 2
						Replace All SortKey With cName
				Endcase
				Index On SortKey Tag Order
		
				Select cMyMembers
				Scan
					lcName = Trim (cName)
					lcMethodCode = loParent.ReadMethod (lcName)
		
					If (Not Empty (lcMethodCode)) 									;
							or (Thisform.oPrefs.lShowAllCustomMethods 				;
							  and llTopOfForm 										;
							  and Not Thisform.GetPemStatus(loParent, lcName, 6))	;
							or (Thisform.oPrefs.lShowAllInheritedCode				;
							  and llTopOfForm 										;
							  and Thisform.GetPemStatus(loParent, lcName, 0))		;
							or (Thisform.oPrefs.lShowChildInheritedCode				;
							  and Thisform.GetPemStatus(loParent, lcName, 0))	
						lbAnyMethods = .T.
						lcKey		= 'Node'+Transform(.Nodes.Count)
						lcText		= lcName
		
						loNode     	= .Nodes.Add(lcParentKey, 4, lcKey, lcText, Lower(Iif(cType = 'M', 'Method', 'Event')))
						With loNode
							loTag = Createobject("Empty")
							AddProperty (loTag, 'Type', 'Method')
							AddProperty (loTag, 'Path', lcPath)
							AddProperty (loTag, 'MethodName', cName)
							AddProperty (loTag, 'Found', .F.)
							.Tag = loTag
							.ForeColor = Iif(Empty (lcMethodCode), Rgb(128,128,128), Rgb(0,0,255))
							.Bold	= .T.
						Endwith
					Endif
				Endscan
		
				Use In cMyMembers
		
			Endif
		
			****************************************************************
		
			* If the object is a container of some type, add each contained object to the
			* TreeView and then call LoadTree recursively to add that object's contained
			* objects.
		
			lnCount = Thisform.CreateSortedObjectArray (loParent, @laControls)
		
			For lnI = 1 To lnCount
				Try
					loControl = loParent.Objects(laControls(lnI,1))
					lbAnyMethods  = This.loadnode(toTree, loControl, lcParentKey, lcPath) Or lbAnyMethods
				Catch
		
				Endtry
			Next lnI
		
			If .Nodes.Count > 1 							;
					and .Nodes(lcParentKey).Children = 0 	;
					And Thisform.lTreeViewShowMethods		;
					and Not Thisform.lTreeViewAllControls
				.Nodes.Remove(lcParentKey)
			Endif
		
			If Vartype(toParent) <> 'O'
				Select csrMembers
		
				* curiously, EnsureVisible again because, with items removed, etc, it might not be visible!
				.Nodes(.Nodes.Count).EnsureVisible()
				If Vartype (.SelectedItem) = 'O'
					.SelectedItem.EnsureVisible()
					Thisform.SaveNodeHighlighting(toTree, 'Selected')
				Else
					loParentNode.EnsureVisible()
					Thisform.SaveNodeHighlighting(toTree, 'Nothing')
				Endif
			Endif
		
		Endwith
		
		Return lbAnyMethods
		
	ENDPROC

	PROCEDURE savenodehighlighting
		Lparameters toTree, tcAction, tcCurrentObjectName
		
		If Thisform.lPEMEditor
			Return
		Endif
		
		Local loBottomNode As Object
		Local loNode As Object
		Local loTag As Object
		Local loTopNode As Object
		Local llFound, llOneMore
		
		With toTree
			Do Case
		
				Case tcAction = 'Selected' && save current node, change its colors, make no node selected
					loNode = .SelectedItem
					Thisform.cTreeViewKey = loNode.Key
					Thisform.nTreeViewForeColor = loNode.ForeColor
					Thisform.nTreeViewBackColor = loNode.BackColor
					loNode.ForeColor = Thisform.nHighlightForeColor
					loNode.BackColor = Thisform.nHighlightBackColor
					.SelectedItem = .Null.
		
				Case tcAction = 'Nothing' && no current node!
					Thisform.cTreeViewKey = .SelectedItem.Key
					.SelectedItem = .Null.
		
				Case tcAction = 'Restore' && restore colors for previously selected node.
					If Not Empty(Thisform.cTreeViewKey)
						loNode = toTree.Nodes(Thisform.cTreeViewKey)
						loNode.ForeColor = Thisform.nTreeViewForeColor
						loNode.BackColor = Thisform.nTreeViewBackColor
					Endif
		
				Case tcAction = 'Reset' && reset previously selected node BACK to the (faked) highlight color
					If Not Empty(Thisform.cTreeViewKey)
						loNode = toTree.Nodes(Thisform.cTreeViewKey)
						loNode.ForeColor = Thisform.nHighlightForeColor
						loNode.BackColor = Thisform.nHighlightBackColor
					Endif
		
				Case tcAction = 'Find' && find and highlight an object
					This.SaveNodeHighlighting (toTree, 'Restore')
					If Empty(tcCurrentObjectName)
						loNode = toTree.Nodes(1)
						.SelectedItem = loNode
						loNode.EnsureVisible()
						This.SaveNodeHighlighting (toTree, 'Selected')
					Else
						llFound = .F.
						llOneMore = .F.
						For Each loNode In toTree.Nodes
							loTag = loNode.Tag
							Do Case
								Case loTag.Type = 'Object' And loTag.Path == tcCurrentObjectName
									loTopNode = loNode
									loBottomNode = loNode
									llFound = .T.
									llOneMore = .T.
								Case llFound And loTag.Path = tcCurrentObjectName
									loBottomNode = loNode
								Case llOneMore
									loBottomNode = loNode
									llOneMore = .F.
							Endcase
						Endfor
		
						If llFound
							loBottomNode.EnsureVisible()
							.SelectedItem = loTopNode
							loTopNode.EnsureVisible()
							This.SaveNodeHighlighting (toTree, 'Selected')
						Endif
					Endif
		
			Endcase
		Endwith
		
	ENDPROC

	PROCEDURE setoletooltips
		Lparameters toObject, tlFlag
		
		Declare Integer SetWindowLong In user32;
			INTEGER HWnd,;
			INTEGER nIndex,;
			INTEGER dwNewLong
		
		Declare Integer GetWindowLong In user32;
			INTEGER HWnd, Integer nIndex
		
		#Define  TVS_NOTOOLTIPS 	128
		#Define  GWL_STYLE 			-16
		
		If tlFlag
			* turn Treeview ItemTips ON
			SetWindowLong (toObject.HWnd, GWL_STYLE, ;
				BITAND(GetWindowLong(toObject.HWnd, GWL_STYLE) ,Bitnot(TVS_NOTOOLTIPS)))
		
		Else
			* turn Treeview ItemTips OFF
			SetWindowLong (toObject.HWnd, GWL_STYLE, ;
				BITOR(GetWindowLong(toObject.HWnd, GWL_STYLE) ,TVS_NOTOOLTIPS))
		
		Endif
		
	ENDPROC

	PROCEDURE sortgrid
	ENDPROC

	PROCEDURE spellcodeorigin
		Lparameters lcType, llSys1269, llLocalCode
		
		Do case
			Case lcType = 'P'
				Return ''
			Case llLocalCode
				Return ccLOC_CAP_CO_Local 
			Case llSys1269
				Return ccLOC_CAP_CO_Inherited
			Otherwise
				Return ''
		endcase		
			
	ENDPROC

	PROCEDURE spellfavorites
		Lparameters tnFavorites
		
		*** JRN 11/20/2008 : Spelling for Parentage (formerly Hierarchy) - based on abbreviations flag
		If Thisform.lUseAbbreviations
			Return IIF(tnFavorites=1, ccLOC_Cap_Fav_NoneA, IIF(tnFavorites=2, ccLOC_Cap_Fav_LocalA, IIF(tnFavorites=3, ccLOC_Cap_Fav_GlobalA, ccLOC_Cap_Fav_BothA))) 
		Else
			Return IIF(tnFavorites=1, ccLOC_Cap_Fav_None, IIF(tnFavorites=2, ccLOC_Cap_Fav_Local, IIF(tnFavorites=3, ccLOC_Cap_Fav_Global, Substr(ccLOC_Cap_Fav_Both,2)))) 
		Endif
		
		
	ENDPROC

	PROCEDURE spellhierarchy
		Lparameters tbNative, tbInherited
		
		*** JRN 11/20/2008 : Spelling for Parentage (formerly Hierarchy) - based on abbreviations flag
		If Thisform.lUseAbbreviations
			Return IIF (tbNative, ccLOC_CAP_Hierarchy_NativeA, IIF(tbInherited, ccLOC_CAP_Hierarchy_InheritedA, ccLOC_CAP_Hierarchy_CustomA))  
		Else
			Return IIF (tbNative, ccLOC_CAP_Hierarchy_Native, IIF(tbInherited, ccLOC_CAP_Hierarchy_Inherited, ccLOC_CAP_Hierarchy_Custom)) 
		Endif
		
	ENDPROC

	PROCEDURE spelltype
		Lparameters tcType
		
		*** JRN 11/20/2008 : Spelling for Type - based on abbreviations flag
		If Thisform.lUseAbbreviations
			Return IIF (tcType = 'P', ccLOC_CAP_Type_PropertyA, IIF(tcType = 'M', ccLOC_CAP_Type_MethodA, IIF(tcType = 'E', ccLOC_CAP_Type_EventA, ''))) 
		Else
			Return IIF (tcType = 'P', ccLOC_CAP_Type_Property, IIF(tcType = 'M', ccLOC_CAP_Type_Method, IIF(tcType = 'E', ccLOC_CAP_Type_Event, '')))  
		Endif
		
		
	ENDPROC

	PROCEDURE spellvisibility
		Lparameters tnVisibility
		
		*** JRN 11/20/2008 : Spelling for Visibility - based on abbreviations flag
		If Thisform.lUseAbbreviations
			Return Iif (tnVisibility = 1, ccLOC_CAP_Vis_PublicA, 	;
				IIF (tnVisibility = 2, ccLOC_CAP_Vis_ProtectedA, 	;
				IIF (tnVisibility = 3, ccLOC_CAP_Vis_HiddenA, 		;
				'')))
		Else
			Return Iif (tnVisibility = 1, ccLOC_CAP_Vis_Public, 	;
				IIF (tnVisibility = 2, ccLOC_CAP_Vis_Protected, 	;
				IIF (tnVisibility = 3, ccLOC_CAP_Vis_Hidden, 		;
				'')))
		Endif
		
	ENDPROC

	PROCEDURE spellyes
		Lparameters lbFlag
		
		If Thisform.lUseAbbreviations
			Return Iif (lbFlag, ccLOC_CAP_YesA, ccLOC_CAP_NoA)
		Else
			Return Iif (lbFlag, ccLOC_CAP_Yes, ccLOC_CAP_No)
		Endif
		
	ENDPROC

	PROCEDURE viewparentcode
		Lparameters tcName, lcStyle, lcWindowName, loObject, llSkipCurrentCode
		
		* lcStyle =
		*     'Code'
		*     'Parentage'
		*	  'Value'
		
		Local lcText, lcFileName
		
		tcName = Alltrim (tcName)
		
		lcText = This.GetParentCode(tcName, lcStyle, loObject, llSkipCurrentCode)
		
		If "O" # Vartype (loObject)
			loObject = Thisform.oObject
		Endif
		
		lcWindowName = '-' + Thisform.oTopofForm.Name + This.GetObjectPath (loObject) ;
			+ Iif (lcStyle # 'Parentage', "." + tcName + '.Inherited', '.-')
			
		This.oUtils.ViewTempFileText (lcWindowName, lcText)	
		
	ENDPROC

ENDDEFINE

DEFINE CLASS editpropertyoptionbutton AS baseoptionbutton OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="optionbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "editpropertyoptionbutton"

ENDDEFINE

DEFINE CLASS editpropertyoptiongroup AS baseoptiongroup OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	MemberClass = "editpropertyoptionbutton"
	MemberClassLibrary = editproperty.vcx
	Name = "editpropertyoptiongroup"

ENDDEFINE

DEFINE CLASS filtercheckbox AS basecheckbox OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ccontrolsource
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Alignment = 0
	ccontrolsource = 
	Name = "filtercheckbox"
	_memberdata = <VFPData>
		<memberdata name="ccontrolsource" display="cControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Refresh
		Local lcControlSource, lxValue
		DoDefault()
		
		lcControlSource = This.cControlSource
		lxValue = ThisForm.oPrefs.&lcControlSource
		If Vartype(lxValue) = 'L'
			This.Value = lxValue
		EndIf 
		
	ENDPROC

	PROCEDURE Valid
		DoDefault()
		
		lcControlSource = This.cControlSource
		ThisForm.oPrefs.&lcControlSource = This.Value
		
		Thisform.SetFilter()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmaddproperty AS frmpemeditorbase OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cntControls" UniqueID="" Timestamp="" />

	#INCLUDE "memberdataeditorenglish.h"
	Caption = "Add Property / Method"
	cfoxuserid = FULLADDFORM
	cfoxusername = FULLADDFORM
	DoCreate = .T.
	Height = 260
	laddpropertyform = .T.
	Name = "frmaddproperty"
	Visible = .T.
	Width = 275
	WindowType = 1
	changefontsize.Name = "changefontsize"

	ADD OBJECT 'cntControls' AS cntpemcontrols WITH ;
		Left = 0, ;
		Name = "cntControls", ;
		Top = 0, ;
		Width = 275, ;
		cntDescription.edtDescription.Name = "edtDescription", ;
		cntDescription.edtDescription.Width = 262, ;
		cntDescription.Height = 52, ;
		cntDescription.lblBufferOverruns.Height = 48, ;
		cntDescription.lblBufferOverruns.Left = 3, ;
		cntDescription.lblBufferOverruns.Name = "lblBufferOverruns", ;
		cntDescription.lblBufferOverruns.Top = 1, ;
		cntDescription.lblBufferOverruns.Width = 256, ;
		cntDescription.lblDescription.Name = "lblDescription", ;
		cntDescription.lblnnn255.Name = "lblnnn255", ;
		cntDescription.Left = 5, ;
		cntDescription.Name = "cntDescription", ;
		cntDescription.Top = 104, ;
		cntDescription.Width = 263, ;
		lblname.Left = 6, ;
		lblname.Name = "lblname", ;
		lblname.Top = 8, ;
		txtName.Height = 22, ;
		txtName.Left = 61, ;
		txtName.Name = "txtName", ;
		txtName.Top = 4, ;
		txtName.Width = 206, ;
		lblVisibility.Name = "lblVisibility", ;
		cboVisibility.Height = 22, ;
		cboVisibility.Left = 134, ;
		cboVisibility.Name = "cboVisibility", ;
		cboVisibility.Top = 185, ;
		cboVisibility.Width = 133, ;
		chkAccess.Alignment = 0, ;
		chkAccess.Name = "chkAccess", ;
		chkAssign.Alignment = 0, ;
		chkAssign.Name = "chkAssign", ;
		Baselabel1.Name = "Baselabel1", ;
		edtDefault.Height = 36, ;
		edtDefault.Left = 5, ;
		edtDefault.Name = "edtDefault", ;
		edtDefault.Top = 64, ;
		edtDefault.Width = 262, ;
		cboFavorites.Height = 22, ;
		cboFavorites.Left = 135, ;
		cboFavorites.Name = "cboFavorites", ;
		cboFavorites.Top = 160, ;
		cboFavorites.Width = 132, ;
		lblDefault.Name = "lblDefault", ;
		opgType.baseoptionbutton1.Left = 5, ;
		opgType.baseoptionbutton1.Name = "baseoptionbutton1", ;
		opgType.baseoptionbutton1.Top = 5, ;
		opgType.baseoptionbutton2.Left = 91, ;
		opgType.baseoptionbutton2.Name = "baseoptionbutton2", ;
		opgType.baseoptionbutton2.Top = 5, ;
		opgType.Name = "opgType", ;
		lblType.Name = "lblType", ;
		oSplitter.gripperhor.Height = 5, ;
		oSplitter.gripperhor.Name = "gripperhor", ;
		oSplitter.gripperhor.Width = 21, ;
		oSplitter.gripperver.Height = 21, ;
		oSplitter.gripperver.Name = "gripperver", ;
		oSplitter.gripperver.Width = 5, ;
		oSplitter.imgDownArrow.Height = 21, ;
		oSplitter.imgDownArrow.Name = "imgDownArrow", ;
		oSplitter.imgDownArrow.Width = 21, ;
		oSplitter.ImgLeftArrow.Height = 17, ;
		oSplitter.ImgLeftArrow.Name = "ImgLeftArrow", ;
		oSplitter.ImgLeftArrow.Width = 17, ;
		oSplitter.ImgRightArrow.Height = 17, ;
		oSplitter.ImgRightArrow.Name = "ImgRightArrow", ;
		oSplitter.ImgRightArrow.Width = 17, ;
		oSplitter.imgUpArrow.Height = 21, ;
		oSplitter.imgUpArrow.Name = "imgUpArrow", ;
		oSplitter.imgUpArrow.Width = 21, ;
		oSplitter.Name = "oSplitter", ;
		oSplitter.Width = 262, ;
		cntCommandButtons.cntAdd.cmdApplyAndAdd.Name = "cmdApplyAndAdd", ;
		cntCommandButtons.cntAdd.cmdApplyAndEdit.Name = "cmdApplyAndEdit", ;
		cntCommandButtons.cntAdd.cmdRevert.Name = "cmdRevert", ;
		cntCommandButtons.cntAdd.lblAddMode.Name = "lblAddMode", ;
		cntCommandButtons.cntAdd.Name = "cntAdd", ;
		cntCommandButtons.cntAdd.ZOrderSet = 3, ;
		cntCommandButtons.cntEdit.Basecommandbutton1.Name = "Basecommandbutton1", ;
		cntCommandButtons.cntEdit.cmdApply.Name = "cmdApply", ;
		cntCommandButtons.cntEdit.lblEditMode.Name = "lblEditMode", ;
		cntCommandButtons.cntEdit.Name = "cntEdit", ;
		cntCommandButtons.cntEdit.ZOrderSet = 2, ;
		cntCommandButtons.cntNormal.cmdAddMethod.Name = "cmdAddMethod", ;
		cntCommandButtons.cntNormal.cmdAddProperty.Name = "cmdAddProperty", ;
		cntCommandButtons.cntNormal.cmdRemove.Name = "cmdRemove", ;
		cntCommandButtons.cntNormal.cmdResetFilters.Name = "cmdResetFilters", ;
		cntCommandButtons.cntNormal.Name = "cntNormal", ;
		cntCommandButtons.cntNormal.ZOrderSet = 1, ;
		cntCommandButtons.cntNothing.Name = "cntNothing", ;
		cntCommandButtons.cntNothing.ZOrderSet = 0, ;
		cntCommandButtons.Left = -72, ;
		cntCommandButtons.Name = "cntCommandButtons", ;
		Line1.Name = "Line1"
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="container" />
	
	PROCEDURE Activate
		* 
	ENDPROC

	PROCEDURE GotFocus
		* 
	ENDPROC

	PROCEDURE Init
		Lparameters toUtils, toServer, toPrefs, tcName
		
		With This
			.oUtils   = toUtils
			.oServer = toServer
			.oPrefs  = toPrefs
		
			.CreateMembersCursor()
			llMethod = 'M' $ Thisform.cNewMemberType
			.ScatterCursor(.T., Iif(llMethod, 'M', 'P'))
		
			.oTxtname.Value = tcName
			.Refresh()
			.oTxtname.SetFocus()
		
		Endwith
		Return
		
		
	ENDPROC

	PROCEDURE LostFocus
		* 
	ENDPROC

	PROCEDURE cntControls.Refresh
		*
	ENDPROC

ENDDEFINE

DEFINE CLASS frmcompareclass AS frmpeme_base OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdPaste" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDeselect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GridMembers" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: dosortgrid
		*m: getcurvalue
		*p: cmemberssortorder
		*p: lanynew
		*p: lincludenew
		*p: lnewallowed
		*p: lpasteit
		*p: ntop
	*</DefinedPropArrayMethod>

	capplicationpath = 
	Caption = "Compare with Parent Class"
	cfoxuserid = compareclass
	cfoxusername = COMPARECLASS
	cmemberssortorder = +CName
	DataSession = 1
	Desktop = .T.
	DoCreate = .T.
	Height = 237
	lanynew = .F.
	lclass = .F.
	lincludenew = .F.
	lnewallowed = .F.
	lpasteit = .F.
	luseabbreviations = .T.
	Name = "frmcompareclass"
	ntop = 0
	Width = 539
	WindowType = 1
	changefontsize.Name = "changefontsize"

	ADD OBJECT 'cmdCancel' AS basecommandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Height = 25, ;
		Left = 424, ;
		Name = "cmdCancel", ;
		nanchor = 8, ;
		TabIndex = 5, ;
		Top = 6, ;
		Width = 70
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdDeselect' AS cmdpasteselection WITH ;
		Caption = "De-Select All", ;
		Height = 25, ;
		Left = 102, ;
		lvalue = .F., ;
		Name = "cmdDeselect", ;
		nanchor = 0, ;
		TabIndex = 3, ;
		Top = 6, ;
		Width = 82
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPaste' AS basecommandbutton WITH ;
		Caption = "Reset Selected Items to Default", ;
		Height = 25, ;
		Left = 228, ;
		Name = "cmdPaste", ;
		nanchor = 8, ;
		TabIndex = 4, ;
		Top = 6, ;
		Width = 184
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelect' AS cmdpasteselection WITH ;
		Caption = "Select All", ;
		Height = 25, ;
		Left = 6, ;
		lvalue = .T., ;
		Name = "cmdSelect", ;
		nanchor = 0, ;
		TabIndex = 2, ;
		Top = 6, ;
		Width = 82
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'GridMembers' AS gridcompareclass WITH ;
		Height = 197, ;
		Left = 6, ;
		Name = "GridMembers", ;
		TabIndex = 1, ;
		Top = 36, ;
		ColName.Header1.Name = "Header1", ;
		ColName.Name = "ColName", ;
		ColName.Text1.Name = "Text1", ;
		ColTypeIcon.Header1.Name = "Header1", ;
		ColTypeIcon.imgHolder.Height = 16, ;
		ColTypeIcon.imgHolder.Name = "imgHolder", ;
		ColTypeIcon.imgHolder.Width = 16, ;
		ColTypeIcon.Name = "ColTypeIcon", ;
		ColValue.Header1.Name = "Header1", ;
		ColValue.Name = "ColValue", ;
		ColValue.Text1.Name = "Text1", ;
		COLSELECT.Basecheckbox1.Alignment = 2, ;
		COLSELECT.Basecheckbox1.Name = "Basecheckbox1", ;
		COLSELECT.Header1.Caption = " ", ;
		COLSELECT.Header1.Name = "Header1", ;
		COLSELECT.Label1.Name = "Label1", ;
		COLSELECT.Name = "COLSELECT", ;
		COLCURVALUE.Header1.Name = "Header1", ;
		COLCURVALUE.Name = "COLCURVALUE", ;
		COLCURVALUE.Text1.Name = "Text1", ;
		ColSame.Header1.Name = "Header1", ;
		ColSame.Name = "ColSame", ;
		ColSame.Text1.Name = "Text1"
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="grid" />
	
	PROCEDURE Destroy
		This.oServer = .Null.
		DoDefault()
		
	ENDPROC

	PROCEDURE dosortgrid
		Lparameters lcMainSortField, lcAltSortField
		
		****************************************************************
		* Created 10/25/2008 by Jim Nelson
		* Invoked by click on header of any column
		* Updates .cMembersSortOrder with new sort criteria
		* First parameter is the "normal" sort order for the column being sorted on
		* Second is the alternate (if any) to cause reverse sorting if grid
		* is already sorted on the main column.
		
		Local lcMembersSortOrder, lcName, lcSortField
		lcName = csrCompareClass.cName
		
		With This
			lcMembersSortOrder = .cMembersSortOrder
		
			If Pcount() > 0
		
				If Pcount() = 2 And lcMembersSortOrder = "+" + lcMainSortField
					lcSortField = lcAltSortField
				Else
					lcSortField = lcMainSortField
				Endif
		
				lcMembersSortOrder = "+" + lcSortField + Strtran( lcMembersSortOrder, "+" + lcSortField, "")
				.cMembersSortOrder = lcMembersSortOrder
			Endif
		
			****************************************************************
			Select csrCompareClass
		
			Delete Tag All
			Set Filter To
		
			Try
				Index On &lcMembersSortOrder Tag cName
			Catch To loException
				This.cMembersSortOrder = ccLoc_SortOrder1
				lcMembersSortOrder = This.cMembersSortOrder
				Index On &lcMembersSortOrder Tag cName
			Endtry
		
			****************************************************************
		
			Locate For cName = lcName
			If Not Found()
				Locate
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE getcurvalue
		Lparameters toObject, toName
		
		Local lcType, lxResult
		lcType = This.GetPEMStatus(toObject, toName, 3)
		
		If Left(lcType, 1) # 'P'
			Return '[User Procedure]'
		Else
			lxResult = toObject.ReadExpression(toName)
			If Not Empty(lxResult )
				Return '=' + lxResult
			Else
				lxResult = Getpem(toObject, toName)
				If 'C' = Vartype (lxResult) And Empty (lxResult)
					Return '(None)'
				Else
					Return Left(Transform(lxResult ), 100)
				Endif
			Endif
		Endif
		
	ENDPROC

	PROCEDURE getvalue
		Lparameters lnRow
		
		lcType = Thisform.oServer.aCopiedProperties (lnRow, ccPasteTypeCol)
		lcValue = Thisform.oServer.aCopiedProperties (lnRow, ccPasteValueCol)
		
		Do Case
			Case lcType $ 'ME' and Empty (lcValue)
				Return ''
			Case lcType $ 'ME'
				Return '[User Procedure]'
			Case lcType = 'X'
				Return '=' + lcValue
			Case 'C' = Vartype (lcValue) And Empty (lcValue)
				Return '(None)'
			Otherwise
				Return Left(Transform(lcValue), 100)
		EndCase
		
	ENDPROC

	PROCEDURE Init
		Lparameters tcFontName, tnFontSize
		
		Local lcDynamicFontBold, lcDynamicFontItalic, lcName
		With This
			.nFontSize = Evl (tnFontSize, 8)
		
			With .GridMembers
				.FontName = Evl (tcFontName, .FontName)
			Endwith
		
			lcDynamicFontBold = 'lSelect'
			.SetAll ('DynamicFontBold', lcDynamicFontBold, 'Column')
		
			*********
			DoDefault()
		
			.DoSortGrid()
			Goto Top
		
			.Refresh()
		
		Endwith
		
		
		
	ENDPROC

	PROCEDURE Load
		DoDefault()
		
		With This
			.oServer = _oPEMEditor.oUtils.oServer
		Endwith
		
		
	ENDPROC

	PROCEDURE loadsettings
		This.cMembersSortOrder = .cPasteOrder
		This.LoadColumnInfo (This.gridMembers)
		DoDefault()
		
		
		
	ENDPROC

	PROCEDURE savesettings
		.cPasteOrder = This.cMembersSortOrder
		This.SaveColumnInfo (This.gridMembers)
		
		DoDefault()
		
	ENDPROC

	PROCEDURE setdefaults
		.cPasteOrder = ''
	ENDPROC

	PROCEDURE sortgrid
		Lparameters lcMainSortField, lcAltSortField
		
		****************************************************************
		* Created 10/25/2008 by Jim Nelson
		* Invoked by click on header of any column
		* Updates .cMembersSortOrder with new sort criteria
		* First parameter is the "normal" sort order for the column being sorted on
		* Second is the alternate (if any) to cause reverse sorting if grid
		* is already sorted on the main column.
		
		With This
			.DoSortGrid(lcMainSortField, lcAltSortField)
			Goto Top
			.GridMembers.SetFocus()
		Endwith
		
	ENDPROC

	PROCEDURE Unload
		Return this.lPasteIt
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.lPasteIt = .F.
		Thisform.Release()
	ENDPROC

	PROCEDURE cmdCancel.Init
		DoDefault()
		With This
			.Caption = ccLOC_Paste_Cancel
		Endwith
		
	ENDPROC

	PROCEDURE cmdDeselect.Init
		DoDefault()
		With This
			.Caption = ccLOC_Paste_DeSelect
			.ToolTipText = ccLOC_Paste_Tip
		Endwith
		
	ENDPROC

	PROCEDURE cmdPaste.Click
		Thisform.lPasteIt = .T.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdPaste.Init
		DoDefault()
		With This
			.Caption = ccLOC_Paste_ResetSelected
		Endwith
		
	ENDPROC

	PROCEDURE cmdSelect.Init
		DoDefault()
		With This
			.Caption = ccLOC_Paste_Select
			.ToolTipText = ccLOC_Paste_Tip
		Endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmcompareproperties AS frmpeme_base OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="gridCompare" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: createcomparecursor
		*m: dosortgrid
		*m: getcurvalue
		*p: cmemberssortorder
		*p: lanynew
		*p: lincludenew
		*p: lnewallowed
		*p: lpasteit
		*p: ntop
	*</DefinedPropArrayMethod>

	capplicationpath = 
	Caption = "Compare Properties and Method Code"
	cfoxuserid = compareproperties
	cfoxusername = COMPAREPROPERTIES
	cmemberssortorder = +CName
	Desktop = .T.
	DoCreate = .T.
	Height = 286
	lanynew = .F.
	lnewallowed = .F.
	luseabbreviations = .T.
	Name = "frmcompareproperties"
	ntop = 0
	Width = 454
	WindowType = 1
	changefontsize.Left = 16
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 68

	ADD OBJECT 'gridCompare' AS gridcompareproperties WITH ;
		Height = 276, ;
		Left = 0, ;
		Name = "gridCompare", ;
		ReadOnly = .T., ;
		Top = 6, ;
		Width = 451, ;
		ZOrderSet = 0, ;
		ColName.ControlSource = "cName", ;
		ColName.DynamicBackColor = "IIF(empty(VarTypeA) or empty(VarTypeB), RGB(192,192,192), RGB(255,255,255))", ;
		ColName.Header1.Name = "Header1", ;
		ColName.Name = "ColName", ;
		ColName.ReadOnly = .T., ;
		ColName.Text1.Name = "Text1", ;
		ColName.Text1.ReadOnly = .T., ;
		ColTypeIcon.ControlSource = "", ;
		ColTypeIcon.Header1.Name = "Header1", ;
		ColTypeIcon.imgHolder.Height = 16, ;
		ColTypeIcon.imgHolder.Name = "imgHolder", ;
		ColTypeIcon.imgHolder.Width = 16, ;
		ColTypeIcon.Name = "ColTypeIcon", ;
		ColTypeIcon.ReadOnly = .T., ;
		ColValue.ControlSource = "DisplayA", ;
		ColValue.DynamicBackColor = "IIF(empty(VarTypeA), RGB(192,192,192), RGB(255,255,255))", ;
		ColValue.DynamicFontBold = "NonDefaultA", ;
		ColValue.Header1.Caption = "Value in Copied Object", ;
		ColValue.Header1.Name = "Header1", ;
		ColValue.Name = "ColValue", ;
		ColValue.ReadOnly = .T., ;
		ColValue.Text1.Name = "Text1", ;
		ColValue.Text1.ReadOnly = .T., ;
		ColCurValue.ControlSource = "DisplayB", ;
		ColCurValue.DynamicBackColor = "IIF(empty(VarTypeB), RGB(192,192,192), RGB(255,255,255))", ;
		ColCurValue.DynamicFontBold = "NonDefaultB", ;
		ColCurValue.Header1.Caption = "Value in This Object", ;
		ColCurValue.Header1.Name = "Header1", ;
		ColCurValue.Name = "ColCurValue", ;
		ColCurValue.ReadOnly = .T., ;
		ColCurValue.Text1.Name = "Text1", ;
		ColCurValue.Text1.ReadOnly = .T.
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="grid" />
	
	PROCEDURE createcomparecursor
		Local laSourceA(1), laSourceB(1)
		Local lnCurRowA, lnCurRowB, lnRowsA, lnRowsB
		
		Create Cursor csrCompareObject (													    ;
			cName 			C (128),													    ;
			VarTypeA		C (1),													    ;
			DisplayA		C (100),												    ;
			NonDefaultA		L,															;
			VarTypeB		C (1),													    ;
			DisplayB		C (100),													;
			NonDefaultB		L															;
			)
		
		Acopy (This.oServer.aCopiedProperties, 'laSourceA')
		Acopy (This.oServer.aCompareProperties, 'laSourceB')
		
		lnRowsA = Alen (laSourceA, 1)
		lnRowsB = Alen (laSourceB, 1)
		
		lnCurRowA = 1
		lnCurRowB = 1
		
		Do While lnCurRowA <= lnRowsA Or lnCurRowB <= lnRowsB
		
			Do Case
		
					* all done with A
				Case lnCurRowA > lnRowsA
					If (Not laSourceB (lnCurRowB, ccNativeCol)) Or (Not laSourceB (lnCurRowB, ccTypeCol) $ 'ME') Or laSourceB (lnCurRowB, ccHasCodeCol)
						Insert Into csrCompareObject (cName, VarTypeB, DisplayB, NonDefaultB)	    ;
							Values														    ;
							(laSourceB (lnCurRowB, ccNameCol), laSourceB (lnCurRowB, ccTypeCol),;
							This.GetValue (laSourceB (lnCurRowB, ccTypeCol), laSourceB (lnCurRowB, ccPasteValueCol), laSourceB (lnCurRowB, ccHasCodeCol)), ;
							laSourceB (lnCurRowB, ccNonDefaultCol))
					Endif
					lnCurRowB = lnCurRowB + 1
		
					* all done with B
				Case lnCurRowB > lnRowsB
					If (Not laSourceA (lnCurRowA, ccNativeCol)) Or (Not laSourceA (lnCurRowA, ccTypeCol) $ 'ME') Or laSourceA (lnCurRowA, ccHasCodeCol)
						Insert Into csrCompareObject (cName, VarTypeA, DisplayA, NonDefaultA)	    ;
							Values														    ;
							(laSourceA (lnCurRowA, ccNameCol), laSourceA (lnCurRowA, ccTypeCol),;
							This.GetValue (laSourceA (lnCurRowA, ccTypeCol), laSourceA (lnCurRowA, ccPasteValueCol), laSourceA (lnCurRowA, ccHasCodeCol)), ;
							laSourceA (lnCurRowA, ccNonDefaultCol))
					Endif
					lnCurRowA = lnCurRowA + 1
		
					* in B, not in A
				Case laSourceA (lnCurRowA, 1) > laSourceB (lnCurRowB, 1)
					If (Not laSourceB (lnCurRowB, ccNativeCol)) Or (Not laSourceB (lnCurRowB, ccTypeCol) $ 'ME') Or laSourceB (lnCurRowB, ccHasCodeCol)
						Insert Into csrCompareObject (cName, VarTypeB, DisplayB, NonDefaultB)	    ;
							Values														    ;
							(laSourceB (lnCurRowB, ccNameCol), laSourceB (lnCurRowB, ccTypeCol),;
							This.GetValue (laSourceB (lnCurRowB, ccTypeCol), laSourceB (lnCurRowB, ccPasteValueCol), laSourceB (lnCurRowB, ccHasCodeCol)), ;
							laSourceB (lnCurRowB, ccNonDefaultCol))
					Endif
					lnCurRowB = lnCurRowB + 1
		
					* in A, not in B
				Case laSourceA (lnCurRowA, 1) < laSourceB (lnCurRowB, 1)
					If (Not laSourceA (lnCurRowA, ccNativeCol)) Or (Not laSourceA (lnCurRowA, ccTypeCol) $ 'ME') Or laSourceA (lnCurRowA, ccHasCodeCol)
						Insert Into csrCompareObject (cName, VarTypeA, DisplayA, NonDefaultA)	    ;
							Values														    ;
							(laSourceA (lnCurRowA, ccNameCol), laSourceA (lnCurRowA, ccTypeCol),;
							This.GetValue (laSourceA (lnCurRowA, ccTypeCol), laSourceA (lnCurRowA, ccPasteValueCol), laSourceA (lnCurRowA, ccHasCodeCol)), ;
							laSourceA (lnCurRowA, ccNonDefaultCol))
					Endif
					lnCurRowA = lnCurRowA + 1
		
					* exact match
				Case laSourceA (lnCurRowA, ccTypeCol) = laSourceB (lnCurRowB, ccTypeCol);
						And Vartype (laSourceA (lnCurRowA, ccPasteValueCol)) = Vartype (laSourceB (lnCurRowB, ccPasteValueCol));
						and laSourceA (lnCurRowA, ccPasteValueCol) == laSourceB (lnCurRowB, ccPasteValueCol)
					lnCurRowA = lnCurRowA + 1
					lnCurRowB = lnCurRowB + 1
		
					* different
				Otherwise
					Insert Into csrCompareObject (cName, VarTypeA, DisplayA, NonDefaultA, VarTypeB, DisplayB, NonDefaultB)	    ;
						Values														    ;
						(laSourceA (lnCurRowA, ccNameCol),							    ;
						;
						laSourceA (lnCurRowA, ccTypeCol),							    ;
						This.GetValue (laSourceA (lnCurRowA, ccTypeCol), laSourceA (lnCurRowA, ccPasteValueCol), laSourceA (lnCurRowA, ccHasCodeCol)), ;
						laSourceA (lnCurRowA, ccNonDefaultCol),							;
						;
						laSourceB (lnCurRowB, ccTypeCol),							    ;
						This.GetValue (laSourceB (lnCurRowB, ccTypeCol), laSourceB (lnCurRowB, ccPasteValueCol), laSourceB (lnCurRowB, ccHasCodeCol)), ;
						laSourceB (lnCurRowB, ccNonDefaultCol))
					lnCurRowA = lnCurRowA + 1
					lnCurRowB = lnCurRowB + 1
		
			Endcase
		
			If lnCurRowA <= lnRowsA And Upper(laSourceA (lnCurRowA, ccNameCol)) == '_MEMBERDATA'
				lnCurRowA = lnCurRowA + 1
			Endif
		
			If lnCurRowB <= lnRowsB And Upper(laSourceB (lnCurRowB, ccNameCol)) == '_MEMBERDATA'
				lnCurRowB = lnCurRowB + 1
			Endif
		
		Enddo
		
		Locate 
	ENDPROC

	PROCEDURE Destroy
		This.oServer = .Null.
		DoDefault()
		
	ENDPROC

	PROCEDURE dosortgrid
		Lparameters lcMainSortField, lcAltSortField
		
	ENDPROC

	PROCEDURE getcurvalue
	ENDPROC

	PROCEDURE getvalue
		Lparameters lcType, lxValue, llHasCode
		
		Do Case
			Case lcType $ 'ME' And Not Empty (lxValue)
				Return '[User Procedure]'
			Case lcType $ 'ME' And llHasCode
				Return '[Inherited]'
			Case lcType $ 'ME'
				Return ''
			Case lcType = 'X'
				Return '=' + lxValue
			Case 'C' = Vartype (lxValue) And Empty (lxValue)
				Return '(None)'
			Otherwise
				Return Left(Transform(lxValue), 100)
		Endcase
		
	ENDPROC

	PROCEDURE Init
		Lparameters tlNewAllowed, tlClass, tcFontName, tnFontSize
		
		With This
			.lNewAllowed = tlNewAllowed
			.lClass		 = tlClass
			.nFontSize	 = Evl (tnFontSize, 9)
		
			If Not Empty (tcFontName)
				With .GridCompare
					.FontName = tcFontName
				Endwith
			Endif
		
			DoDefault()
			Goto Top
		
			.Refresh()
		
		Endwith
		
		
		
	ENDPROC

	PROCEDURE Load
		DoDefault()
		Local lcAlias, lnRow
		
		With This
			.oServer = _oPEMEditor.oUtils.oServer
			.CreateCompareCursor()
		Endwith
		
		
	ENDPROC

	PROCEDURE loadsettings
		This.cMembersSortOrder = .cPasteOrder
		This.LoadColumnInfo(This.gridCompare)
		DoDefault()
		
		
		
	ENDPROC

	PROCEDURE savesettings
		.cPasteOrder = This.cMembersSortOrder
		This.SaveColumnInfo(This.gridCompare)
		
		DoDefault()
		
	ENDPROC

	PROCEDURE setdefaults
		.cPasteOrder = ''
	ENDPROC

	PROCEDURE sortgrid
		Lparameters lcMainSortField, lcAltSortField
		
	ENDPROC

	PROCEDURE Unload
		Return this.lPasteIt
	ENDPROC

ENDDEFINE

DEFINE CLASS frmeditparentclass AS frmpeme_base OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdPaste" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents.Column3.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents.Column3.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents.ColTypeIcon.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridParents.ColTypeIcon.imgHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="BASELABEL1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Basecommandbutton1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*p: cclassname
	*</DefinedPropArrayMethod>

	capplicationpath = 
	Caption = "Edit Parent Class and Containing Classes"
	cclassname = 
	cfoxuserid = editparentclass
	cfoxusername = EDITPARENTCLASS
	DataSession = 2
	Desktop = .T.
	DoCreate = .T.
	Height = 226
	lbindcontrols = .F.
	Name = "frmeditparentclass"
	Width = 488
	_memberdata = <VFPData>
		<memberdata name="cclassname" display="cClassName"/>
		</VFPData>
	CHANGEFONTSIZE.Left = 18
	CHANGEFONTSIZE.Name = "CHANGEFONTSIZE"
	CHANGEFONTSIZE.Top = -36

	ADD OBJECT 'Basecommandbutton1' AS basecommandbutton WITH ;
		Caption = "Return to Original", ;
		Height = 25, ;
		Left = 162, ;
		Name = "Basecommandbutton1", ;
		nanchor = 4, ;
		TabIndex = 4, ;
		Top = 192, ;
		Width = 130
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'BASELABEL1' AS baselabel WITH ;
		Caption = "First:", ;
		FontBold = .T., ;
		FontSize = 10, ;
		Left = 28, ;
		Name = "BASELABEL1", ;
		Top = 9
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Baselabel2' AS baselabel WITH ;
		Caption = "Then:", ;
		FontBold = .T., ;
		FontSize = 10, ;
		Left = 23, ;
		Name = "Baselabel2", ;
		Top = 30
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Baselabel3' AS baselabel WITH ;
		Caption = "Save or close the current form / class", ;
		FontBold = .F., ;
		FontSize = 9, ;
		Left = 70, ;
		Name = "Baselabel3", ;
		Top = 9
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Baselabel4' AS baselabel WITH ;
		Caption = "Select the parent class/containing class from the grid below.", ;
		FontBold = .F., ;
		FontSize = 9, ;
		Left = 70, ;
		Name = "Baselabel4", ;
		Top = 30
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cmdPaste' AS basecommandbutton WITH ;
		Caption = "Modify Selected Class", ;
		Height = 25, ;
		Left = 12, ;
		Name = "cmdPaste", ;
		nanchor = 4, ;
		TabIndex = 4, ;
		Top = 192, ;
		Width = 130
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'gridParents' AS basegrid WITH ;
		ColumnCount = 4, ;
		Height = 128, ;
		Left = 6, ;
		Name = "gridParents", ;
		nanchor = 15, ;
		Panel = 1, ;
		ScrollBars = 2, ;
		Top = 54, ;
		Width = 482, ;
		Column1.ColumnOrder = 2, ;
		Column1.ControlSource = "crsr_ParentClasses.Class", ;
		Column1.Name = "Column1", ;
		Column1.Width = 108, ;
		Column2.ColumnOrder = 3, ;
		Column2.ControlSource = "crsr_ParentClasses.RelativePath", ;
		Column2.Name = "Column2", ;
		Column2.Width = 220, ;
		Column3.ColumnOrder = 4, ;
		Column3.ControlSource = "crsr_ParentClasses.BaseClass", ;
		Column3.Name = "Column3", ;
		Column3.Width = 80, ;
		Column4.ColumnOrder = 1, ;
		Column4.CurrentControl = "imgHolder", ;
		Column4.DynamicFontShadow = "This.SetBMP()", ;
		Column4.Name = "ColTypeIcon", ;
		Column4.ReadOnly = .T., ;
		Column4.Sparse = .F., ;
		Column4.Width = 16
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="grid" />

	ADD OBJECT 'gridParents.ColTypeIcon.Header1' AS header WITH ;
		Caption = " ", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'gridParents.ColTypeIcon.imgHolder' AS image WITH ;
		Height = 16, ;
		Name = "imgHolder", ;
		Picture = ..\images\propty.bmp, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'gridParents.Column1.Header1' AS header WITH ;
		Caption = "Class", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'gridParents.Column1.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'gridParents.Column2.Header1' AS header WITH ;
		Caption = "Class Library", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'gridParents.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ControlSource = "crsr_ParentClasses.RelativePath", ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'gridParents.Column3.Header1' AS header WITH ;
		Caption = "Base Class", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'gridParents.Column3.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Init
		Lparameters loUtils, loParentClasses, lcApplicationPath, lcSourceFileName, lcClassName
		Local lcBaseClass, lcClass, lcClassLib, lnI
		
		With This
		
			DoDefault()
			
			.cApplicationpath = lcApplicationPath
			.cSourceFileName  = lcSourceFileName
			.cClassName		  = Evl(lcClassName, '')
		
			Create Cursor crsr_ParentClasses (Class C(128), RelativePath C(250), VCX C(250), BaseClass C(20))
		
			For lnI = 1 To loParentClasses.Count
				lcClass = loParentClasses(lnI).Class
				lcBaseClass = loParentClasses(lnI).BaseClass
				lcClassLib = loParentClasses(lnI).VCX
				Insert Into crsr_ParentClasses (Class, RelativePath, VCX, BaseClass) Values (lcClass, This.GetRelativePath(This.diskfilename(lcClassLib)), lcClassLib, lcBaseClass)
			Endfor
		
			Goto Top
			.oUtils = loUtils
			.BindControls = .T.
			.Refresh()
		
		Endwith
		
		
		
	ENDPROC

	PROCEDURE loadsettings
		This.LoadColumnInfo (This.gridParents)
		DoDefault()
	ENDPROC

	PROCEDURE savesettings
		This.SaveColumnInfo (This.gridParents)
		DoDefault()
		
	ENDPROC

	PROCEDURE Basecommandbutton1.Click
		ThisForm.oUtils.EditSourceX (Thisform.cSourceFileName, Thisform.cClassName)
		
	ENDPROC

	PROCEDURE cmdPaste.Click
		ThisForm.oUtils.EditSourceX (crsr_ParentClasses.VCX, crsr_ParentClasses.Class)
		
	ENDPROC

	PROCEDURE gridParents.DblClick
		ThisForm.oUtils.EditSourceX (crsr_ParentClasses.VCX, crsr_ParentClasses.Class)
		
	ENDPROC

	PROCEDURE gridParents.KeyPress
		Lparameters nKeyCode, nShiftAltCtrl
		
		If Not Eof()
			Thisform.oUtils.EditSourceX (crsr_ParentClasses.VCX, crsr_ParentClasses.Class)
		Endif
		
	ENDPROC

	PROCEDURE gridParents.setbmp
		Local lcBMPName, lcFile, lcPath
		
		lcBMPName = Lower (Trim (BaseClass))
		
		lcPath = Thisform.cApplicationPath + 'images\'
		lcFile = lcPath + Evl (lcBMPName, '') + '.bmp'
		If Not File (lcFile)
			lcFile = ''
		Endif
		
		This.colTypeIcon.imgHolder.Picture = lcFile
		
		Return .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmfindobjects AS baseformnew OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFont" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baseeditbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboLookFor" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: nonefound
		*p: cdescription
		*p: csearchfor
		*p: lresult
	*</DefinedPropArrayMethod>

	Caption = "Find Object(s)"
	cdescription = 
	cfoxuserid = SEARCHFORM
	csearchfor = 
	Desktop = .T.
	DoCreate = .T.
	Height = 145
	KeyPreview = .T.
	lresult = .F.
	MinHeight = 90
	MinWidth = 260
	Name = "frmfindobjects"
	Width = 460
	WindowType = 1
	changefontsize.Left = 225
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 10

	ADD OBJECT 'Baseeditbox1' AS baseeditbox WITH ;
		ControlSource = "Thisform.cDescription", ;
		Height = 64, ;
		IntegralHeight = .T., ;
		Left = 6, ;
		Name = "Baseeditbox1", ;
		nanchor = 15, ;
		ReadOnly = .T., ;
		SelectOnEntry = .F., ;
		TabIndex = 3, ;
		Top = 54, ;
		Width = 446
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		Caption = "Search expression:", ;
		FontBold = .T., ;
		FontSize = 9, ;
		Height = 17, ;
		Left = 12, ;
		Name = "Baselabel1", ;
		TabIndex = 2, ;
		Top = 6, ;
		Width = 113
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cboLookFor' AS basecombobox WITH ;
		ControlSource = "Thisform.cSearchFor", ;
		DisplayCount = 25, ;
		Format = "", ;
		Height = 24, ;
		Left = 6, ;
		Name = "cboLookFor", ;
		nanchor = 10, ;
		SelectOnEntry = .F., ;
		Style = 0, ;
		TabIndex = 1, ;
		Top = 25, ;
		Width = 446
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS basecommandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 89, ;
		Name = "cmdCancel", ;
		nanchor = 260, ;
		TabIndex = 5, ;
		Top = 118
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdFont' AS basecommandbutton WITH ;
		Caption = "Font...", ;
		Left = 173, ;
		Name = "cmdFont", ;
		nanchor = 36, ;
		TabIndex = 6, ;
		Top = 118
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS basecommandbutton WITH ;
		Caption = "OK", ;
		Default = .T., ;
		Left = 6, ;
		Name = "cmdOK", ;
		nanchor = 132, ;
		TabIndex = 4, ;
		Top = 118
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />
	
	PROCEDURE Init
		Lparameters tnFontSize, tlNoneFound
		
		Local lcFontName, lcStyle
		
		With This
			.MinHeight = .Height
			.MinWidth  = .Width
		
			If Not Empty (tnFontSize)
				.ChangeFontSize.Run(tnFontSize, 8)
			Endif
		
			DoDefault()
		
			* Restore the saved font?
			.RestoreFont(.cboLookFor)
		
			.Refresh()
		
		Endwith
		
	ENDPROC

	PROCEDURE KeyPress
		Lparameters tnKeyCode, tnShiftAltCtrl
		
		Do Case
			Case tnKeyCode=13
				Thisform.cmdOK.SetFocus()
				Thisform.cmdOK.Click()
			Otherwise
				DoDefault(tnKeyCode, tnShiftAltCtrl)
		Endcase
		
		
		
	ENDPROC

	PROCEDURE nonefound
		This.Visible = .T.
		Messagebox ('Not Found', 16, 'Not Found')
		This.cboLookFor.SetFocus()
		
		
	ENDPROC

	PROCEDURE setdefaults
		Local loCombo As Object
		Local lcStyle
		
		loCombo = This.cboLookFor
		lcStyle = IIf(loCombo.FontBold, 'B', '') + IIf(loCombo.FontItalic, 'I', '')
		
		.cFontName = loCombo.FontName
		.nFontSize = loCombo.FontSize
		.cFontStyle = lcStyle
		
	ENDPROC

	PROCEDURE Baseeditbox1.Init
		DoDefault()
		This.value = ccLOC_CAP_FindObjects
	ENDPROC

	PROCEDURE cboLookFor.Init
		Local lnI, loMRUs
		loMRUs = Thisform.GetMRUList ('MRU33')
		
		If loMRUs.Count = 0
			Return
		EndIf 
		
		For lnI = 1 To loMRUs.Count
			This.AddItem (loMRUs.Item (lnI))
		EndFor
		
		This.DisplayValue = loMRUs.Item (1)
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.lResult = .F.
		Thisform.Hide()
		
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = ccLOC_CAP_CANCEL
		DoDefault()
		
	ENDPROC

	PROCEDURE cmdFont.Click
		Thisform.ChangeFont(Thisform.cboLookFor)
		
	ENDPROC

	PROCEDURE cmdFont.Init
		This.Caption = ccLOC_CAP_FONT
		dodefault()
		
	ENDPROC

	PROCEDURE cmdOK.Click
		Local lcSearchFor
		lcSearchFor = Thisform.cboLookFor.DisplayValue
		
		With Thisform
			.cSearchFor = lcSearchFor
			.AddMRUFile (lcSearchFor, '', 'MRU33')
			.lResult = .T.
			.Hide()
		Endwith
		
		
		
	ENDPROC

	PROCEDURE cmdOK.Init
		This.Caption = ccLOC_CAP_Search
		dodefault()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmidlist AS frmpeme_base OF "editproperty.vcx" 		&& Description goes here
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="SplitterH" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid.Column3.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid.Column3.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid.Column4.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdGrid.Column4.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oImageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oTree" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addtopnode
		*m: createsummarycursor
		*m: createtagobject
		*m: expandlevel2
		*m: expandlevel3names
		*m: expandlevel3procs
		*m: expandtopnode
		*m: handledoubleclick
		*m: nodeexpanded
		*m: nodeselected
		*p: cclassname
		*p: csourcefile
		*p: nhandle
	*</DefinedPropArrayMethod>

	Caption = "Cross References"
	cclassname = 
	cfoxuserid = IDList
	csourcefile = 
	Desktop = .T.
	DoCreate = .T.
	Height = 258
	Name = "frmidlist"
	nhandle = 0
	Visible = .T.
	Width = 700
	_memberdata = <VFPData>
		<memberdata name="createsummarycursor" display="CreateSummaryCursor"/>
		<memberdata name="addtopnode" display="AddTopNode"/>
		<memberdata name="expandtopnode" display="ExpandTopNode"/>
		<memberdata name="expandlevel2" display="ExpandLevel2"/>
		<memberdata name="createtagobject" display="CreateTagObject"/>
		<memberdata name="nodeselected" display="NodeSelected"/>
		<memberdata name="handledoubleclick" display="HandleDoubleClick"/>
		<memberdata name="nhandle" display="nHandle"/>
		<memberdata name="expandlevel3procs" display="ExpandLevel3Procs"/>
		<memberdata name="expandlevel3names" display="ExpandLevel3Names"/>
		<memberdata name="csourcefile" display="cSourceFile"/>
		<memberdata name="cclassname" display="cClassName"/>
		<memberdata name="nodeexpanded" display="NodeExpanded"/>
		</VFPData>
	CHANGEFONTSIZE.Name = "CHANGEFONTSIZE"

	ADD OBJECT 'grdGrid' AS basegrid WITH ;
		AllowCellSelection = .T., ;
		ColumnCount = 4, ;
		GridLines = 2, ;
		Height = 257, ;
		Left = 186, ;
		Name = "grdGrid", ;
		nanchor = 15, ;
		Panel = 1, ;
		RecordSource = "crsr_Grid", ;
		Top = 0, ;
		Width = 489, ;
		ZOrderSet = 2, ;
		Column1.ControlSource = "Name", ;
		Column1.Name = "Column1", ;
		Column1.Width = 104, ;
		Column2.ControlSource = "ProcName", ;
		Column2.Name = "Column2", ;
		Column2.Width = 118, ;
		Column3.Alignment = 2, ;
		Column3.ControlSource = "crsr_Grid.LineNo", ;
		Column3.Name = "Column3", ;
		Column3.Width = 46, ;
		Column4.ControlSource = "SourceLine", ;
		Column4.Name = "Column4", ;
		Column4.Width = 188
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="grid" />

	ADD OBJECT 'grdGrid.Column1.Header1' AS header WITH ;
		Caption = " Name", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdGrid.Column1.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdGrid.Column2.Header1' AS header WITH ;
		Caption = " Method / Proc.", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdGrid.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdGrid.Column3.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = " Line", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdGrid.Column3.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdGrid.Column4.Header1' AS header WITH ;
		Caption = " Code", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdGrid.Column4.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'oImageList' AS olecontrol WITH ;
		Height = 100, ;
		Left = 128, ;
		Name = "oImageList", ;
		Top = 48, ;
		Width = 100, ;
		ZOrderSet = 3
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\syswow64\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGCZklNo7NgBAwAAAEABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXAAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAIAAAD+/////v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8jfyQskYXREbFqAMDwKDYoIUM0EggAAADtAwAA7QMAAIB+4eYAAAYAIAAAAAAAAADAwMAA//9EAAHvzasAAAUAXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTF+AEMAXgAsAEsARgB2ADgAWgAhAFAAQwBlAHEARwA3ADMAOAABAACAKwAxACYAOAA2AFsAYwA5ADcANAB0AEYAbgAxAGsATwB1AEIAUQB+AGUAMAArAGkAeQAnAEcAQQBfAF4AUFxtCAYAAAD/////BQAAgChH0wAAAAAAAAAAAG8AfQBvAEAAeQA/ACkAKABxAHMAdwBNACkALgB1AF0AdgBSAFsAXgBEAEoAKAA9AC0AKQB+ACgAWwBJAG4AcwBfAHIAUwBWACEASwA5AEcAaQA1ACsAPwBSADcAcQApAHUAOQAnADAAWgBeAAIAUAByAG8AZAB1AGMAdABGAGkAbABlAHMAAAAAAAAAbgAAbgRtAAAg9MIAiO/CAHcAYQByAGUAXABNAGkAYwByAG8AcwBvAGYAdABcAFcAaQBuAGQAbwB3AHMAXABDAHUAcgByAGUAbgB0AFYAZQByAHMAaQBvAA==" />

	ADD OBJECT 'oTree' AS baseoletreeview WITH ;
		Height = 254, ;
		Left = 0, ;
		Name = "oTree", ;
		nanchor = 5, ;
		Top = 0, ;
		Width = 180, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="olecontrol" OLEObject="c:\windows\syswow64\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7///8EAAAA/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKA1k1No7NgBAwAAAIACAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiwAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAACcBAAAAAAAACAAAAAIAAAD+////BAAAAAUAAAAGAAAABwAAAP7///8JAAAA/v////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAMDwKDYoIUM0EggAAACbEgAAQBoAALE8wWoBAAYAIgAAAD0AAAAJAQAADAAAAAEAAAAB782rXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEAAAAAKNsAAAAAAADg2wAAAAAAAIjcAAAAAAAAkNIAAAAAAAABAACADgAAAEhpZGVTZWxlY3Rpb24ABQAAAEwAAAAADAAAAEluZGVudGF0aW9uABEAAABODQAAAAcAAAAAAAAAAAAkQAoAAABMYWJlbEVkaXQACQAAAEkKAAAAAQAAAAoAAABMaW5lU3R5bGUACQAAAEkKAAAAAQAAAA0AAABNb3VzZVBvaW50ZXIACQAAAEkKAAAAAAAAAA4AAABQYXRoU2VwYXJhdG9yAAoAAABIAAAAAAEAAABcDAAAAE9MRURyYWdNb2RlAAkAAABJCgAAAAAAAAAMAAAAT0xFRHJvcE1vZGUACQAAAEkKAAAAAAAAAAsAAABBcHBlYXJhbmNlAAkAAABJCgAAAAAAAAAMAAAASG90VHJhY2tpbmcABQAAAEwBAAAAAF4PAQAAAAAAnA4BAAAAAADkEAEAAAAAAAAABQDQ+6wIAgBjAAAAAAAFAACASOkZAAEAAABcAB/e7L0BAAUAkekZAANS4wuRj84RneMAqgBLuFEBAAAAkAGQXwEABlRhaG9tYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" />

	ADD OBJECT 'SplitterH' AS peme_sfsplitterh WITH ;
		cobject1name = oTree, ;
		cobject2name = grdGrid, ;
		Height = 259, ;
		Left = 180, ;
		Name = "SplitterH", ;
		nanchor = 5, ;
		Top = 0, ;
		Width = 6, ;
		ZOrderSet = 1, ;
		GRIPPERHOR.Height = 5, ;
		GRIPPERHOR.Name = "GRIPPERHOR", ;
		GRIPPERHOR.Width = 21, ;
		GRIPPERVER.Height = 21, ;
		GRIPPERVER.Name = "GRIPPERVER", ;
		GRIPPERVER.Width = 5, ;
		IMGDOWNARROW.Height = 21, ;
		IMGDOWNARROW.Name = "IMGDOWNARROW", ;
		IMGDOWNARROW.Width = 21, ;
		IMGUPARROW.Height = 21, ;
		IMGUPARROW.Name = "IMGUPARROW", ;
		IMGUPARROW.Width = 21, ;
		IMGRIGHTARROW.Height = 17, ;
		IMGRIGHTARROW.Name = "IMGRIGHTARROW", ;
		IMGRIGHTARROW.Width = 17, ;
		IMGLEFTARROW.Height = 17, ;
		IMGLEFTARROW.Name = "IMGLEFTARROW", ;
		IMGLEFTARROW.Width = 17
		*< END OBJECT: ClassLib="peme_sfsplitter.vcx" BaseClass="control" />
	
	PROCEDURE addtopnode
		Lparameters lnType, lcText
		
		Local loTag As 'Empty'
		Local lcKey, lcStandInKey, loNode
		
		Select crsr_Types
		Locate For Type = lnType
		If Found()
			lcKey  = 'K' + Transform (lnType)
			loNode = This.oTree.Nodes.Add (, 1, lcKey, lcText)
		
			loTag		= Thisform.CreateTagObject (lcKey, 1, lnType)
			loNode.Tag	= loTag
			loNode.Bold	= .T.
		
			This.oTree.Nodes.Add (lcKey, 4, loTag.Standin, 'Standin')
		
			lcType = Transform(lnType)
			If This.oMySettings.Expand&lcType
				loNode.Expanded = .T.
				This.NodeExpanded(loNode)
			Endif
		
			If This.oMySettings.nStartNode = lnType
				This.oTree.SelectedItem = loNode
				This.NodeSelected (loNode)
			Endif
		Endif
		
		
	ENDPROC

	PROCEDURE createsummarycursor
		Select  crsr_RefsSource.*												;
			  , crsr_Procs.ProcName	   As  ProcName								;
			From crsr_RefsSource												;
				Join crsr_Procs On crsr_RefsSource.ProcID = crsr_Procs.Id		;
			Into Cursor crsr_Refs Readwrite
		
		* For the three types Tables, Parameters, and Locals
		* these types override other definitions with dots ..... Cursor.Field, loObject.Property
		Select  Distinct																	;
				ProcName											 As	 ProcName,			;
				Upper (crsr_Refs.Name)								 As	 UpperName,			;
				Type		 										 As	 NewType,			;
				Len (Trim (Name))									 As	 nLength			;
			From crsr_Refs																	;
			Where InList(Type, TYPE_Tables, TYPE_Parameters, TYPE_Locals)					;
			Into Cursor crsr_Tables Readwrite
		
		Select  crsr_Refs.ProcID								  As  ProcID,							;
				crsr_Refs.ProcName								  As  ProcName,							;
				Upper (Name)									  As  UpperName,						;
				Min (Name)										  As  Name,								;
				Cast(Min (Nvl (ConstantType, Nvl (NewType, Type))) as N(3)) 	  As  Type								;
			From crsr_Refs																				;
				Left Join crsr_Tables																	;
					On crsr_Refs.ProcName = crsr_Tables.ProcName										;
					And Left (crsr_Tables.UpperName, nLength) = Upper (Left (crsr_Refs.Name, nLength))	;
					And Substr (crsr_Refs.Name, nLength + 1, 1) $ ' .'									;
				Left Join crsr_Constants																;
					On Upper (Name) = crsr_Constants.Constant											;
			Group By 1, 2, 3																			;
			Into Cursor crsr_Summary
		
		Select  Distinct Type		;
			From crsr_Summary		;
			Into Cursor crsr_Types
		
		Return
		
	ENDPROC

	PROCEDURE createtagobject
		Lparameters lcKey, lnLevel, lnType
		
		Local loTag As 'Empty'
		Local lcStandInKey
		
		lcStandInKey = lcKey + '_StandIn'
		
		loTag = Createobject ('Empty')
		AddProperty (loTag, 'Level', lnLevel)
		AddProperty (loTag, 'Type', lnType)
		AddProperty (loTag, 'Expanded', .F.)
		AddProperty (loTag, 'StandIn', lcStandInKey)
		AddProperty (loTag, 'Name', '')
		AddProperty (loTag, 'ProcName', '')
		
		Return loTag
	ENDPROC

	PROCEDURE Destroy
		This.oMySettings.SplitterLeft = This.SplitterH.Left
		
		DoDefault()
	ENDPROC

	PROCEDURE expandlevel2
		*** ActiveX Control Event ***
		Lparameters Node
		
		Local laNames[1], lcKey, lcName, lcParentKey, lcText, lnI, lnType, loNode, loTag
		loTag		= Node.Tag
		lnType		= loTag.Type
		lcName		= loTag.Name
		lcParentKey	= Node.Key
		
		Select  Distinct ProcName					;
			From crsr_Summary						;
			Where Type = lnType						;
				And UpperName = Upper (lcName)		;
			Into Array laNames
		
		For lnI = 1 To Alen (laNames, 1)
			lcKey  = lcParentKey + '_' + Transform (lnI)
			lcText = Trim (laNames (lnI, 1))
		
			loTag		   = Thisform.CreateTagObject (lcKey, 4, lnType)
			loTag.Name	   = lcName
			loTag.Expanded = .T.
			loTag.ProcName = laNames (lnI, 1)
		
			loNode			 = This.oTree.Nodes.Add (lcParentKey, 4, lcKey, lcText) &&, 'method')
			loNode.Tag		 = loTag
			loNode.ForeColor = Rgb(0, 0, 255)
		
		Endfor
		
		Return
		
	ENDPROC

	PROCEDURE expandlevel3names
		*** ActiveX Control Event ***
		Lparameters Node
		
		Local laNames[1], lcKey, lcName, lcParentKey, lcStandInKey, lcText, lnI, lnType, loNode, loTag
		loTag		= Node.Tag
		lnType		= loTag.Type
		lcName		= GetWordNum(Trim (loTag.Name), 1, '.')
		lcParentKey	= Node.Key
		
		Select  UpperName,													;
				Min (Name)	  As  Name,										;
				Sum(1)		  As  NMatches									;
			From crsr_Summary												;
			Where Type = lnType												;
				and Left (UpperName, 1) # '.'								;
				and Getwordnum (UpperName, 1, '.') == Upper (lcName)		;
			Group By 1														;
			Into Array laNames
		
		For lnI = 1 To Alen (laNames, 1)
			lcKey  = lcParentKey + '_X' + Transform (lnI)
			lcText = Trim (laNames (lnI, 2))
		
			loTag		   = Thisform.CreateTagObject (lcKey, 5, lnType)
			loTag.Expanded = .T.
			loTag.Name	   = laNames (lnI, 2)
		
			loNode	   = This.oTree.Nodes.Add (lcParentKey, 4, lcKey, lcText)
			loNode.Tag = loTag
		
		Endfor
		
		Return
		
	ENDPROC

	PROCEDURE expandlevel3procs
		*** ActiveX Control Event ***
		Lparameters Node
		
		Local laNames[1], lcKey, lcName, lcParentKey, lcText, lnI, lnType, loNode, loTag
		loTag		= Node.Tag
		lnType		= loTag.Type
		lcName		= Getwordnum (Trim (loTag.Name), 1, '.')
		lcParentKey	= Node.Key
		
		Select  Distinct ProcName											;
			From crsr_Summary												;
			Where Type = lnType												;
				And Left (UpperName, 1) # '.'								;
				And Getwordnum (UpperName, 1, '.') == Upper (lcName)		;
			Into Array laNames
		
		For lnI = 1 To Alen (laNames, 1)
			lcKey  = lcParentKey + '_' + Transform (lnI)
			lcText = Trim (laNames (lnI, 1))
		
			loTag		   = Thisform.CreateTagObject (lcKey, 6, lnType)
			loTag.Name	   = lcName
			loTag.Expanded = .T.
			loTag.ProcName = laNames (lnI, 1)
		
			loNode			 = This.oTree.Nodes.Add (lcParentKey, 4, lcKey, lcText) && , 'method')
			loNode.Tag		 = loTag
			loNode.ForeColor = Rgb(0, 0, 255)
		
		Endfor
		
		Return
		
	ENDPROC

	PROCEDURE expandtopnode
		*** ActiveX Control Event ***
		Lparameters Node
		
		Local laNames[1], lcKey, lcParentKey, lcStandInKey, lcText, lnI, lnType, loNode, loTag
		loTag		= Node.Tag
		lnType		= loTag.Type
		lcParentKey	= Node.Key
		
		Select  UpperName,						;
				Min (Name)	  As  Name,			;
				Sum(1)		  As  NMatches		;
			From crsr_Summary					;
			Where Type = lnType					;
			Group By 1							;
			Into Cursor crsr_SubNodes
		
		Select  IIf (UpperName = '.', UpperName, Getwordnum (UpperName, 1, '.')) As UpperName,		;
				Min (Name)											  As  Name,						;
				Sum (1)												  As  Count,					;
				Sum (NMatches)										  As  NMatches					;
			From crsr_SubNodes																		;
			Group By 1																				;
			Into Array laNames
		
		For lnI = 1 To Alen (laNames, 1)
			lcKey  = lcParentKey + '_' + Transform (lnI)
			lcText = Trim (laNames (lnI, 2))
		
			loTag		   = Thisform.CreateTagObject (lcKey, 2, lnType)
			loTag.Expanded = Reccount ('crsr_Procs') = 1 Or laNames (lnI, 4) = 1
			loTag.Name	   = laNames (lnI, 2)
		
			If laNames (lnI, 3) > 1
				lcText		   = Getwordnum (lcText, 1, '.')
				*	lcText		   = lcText + ' (' + Transform (laNames (lnI, 3)) + ')'
				loTag.Level	   = 3
				loTag.Expanded = .F.
			Endif
		
			loNode	   = This.oTree.Nodes.Add (lcParentKey, 4, lcKey, lcText)
			loNode.Tag = loTag
		
			If Not loTag.Expanded
				This.oTree.Nodes.Add (lcKey, 4, loTag.Standin, 'Standin')
			Endif
		
		Endfor
		
		Return
		
	ENDPROC

	PROCEDURE handledoubleclick
		*
		Local lcMethodName, lcObjName, lcProcName, lnHandle, lnSelEnd, lnSelStart, loTopOfForm
		
		lnHandle = This.nHandle
		
		If lnHandle <= 0
		
			This.oUtils.EditSourceX (This.cSourceFile, This.cClassName)
		
			loTopOfForm = This.oUtils.FindTopMostParent()
			If Not Isnull (loTopOfForm)
				lcProcName	 = ProcName
				lcMethodName = Justext (lcProcName)
				lcObjName	 = Left (lcProcName, Rat ('.', lcProcName) - 1)
		
				If 'O' = Type ('loTopOfForm' + lcObjName)
					This.oUtils.EditLocalMethodCode (This.cSourceFile, loTopOfForm, Evaluate ('loTopOfForm' + lcObjName), lcMethodName, Not Empty (This.cClassName))
				Endif
			EndIf
			
			lnHandle = _WonTop()
		
		Endif
		
			Try
				*** JRN 2010-12-28 : convert line number to byte offset
				lnSelStart = _EdGetLPos (lnHandle, crsr_Grid.StartLine + crsr_Grid.Lineno - 2)
				lnSelEnd   = _EdGetLPos (lnHandle, crsr_Grid.StartLine + crsr_Grid.Lineno - 1)
		
				*** JRN 2010-12-28 : Select the entire line
				_EdSelect (lnHandle, lnSelStart, lnSelEnd)
		
				*** JRN 2010-12-28 : ensure that line is visible
				_EdStoPos (lnHandle, lnSelStart, .T.)
		
			Catch
		
			Endtry
		
		
		
	ENDPROC

	PROCEDURE Init
		Lparameters lcProcsXML, lcLinesXML, lcRefsXML, lcConstantsXML, lcApplicationPath;
			, loUtils, lnHandle, lcSourceFileName, lcClassName
		
		Xmltocursor (lcProcsXML, 'crsr_Procs')
		Index On Id Tag Id
		
		Xmltocursor (lcLinesXML, 'crsr_Lines')
		Index On Id Tag Id
		
		Xmltocursor (lcRefsXML, 'crsr_RefsSource')
		Index On Upper (Name) Tag Name
		
		Xmltocursor (lcConstantsXML, 'crsr_Constants_Source')
		Select  Distinct Constant						;
			  , TYPE_Constants	  As  ConstantType		;
			From crsr_Constants_Source					;
			Into Cursor crsr_Constants Readwrite
		Index On Constant Tag Constant
		
		With This
			.oUtils 	 = loUtils
			.nHandle	 = lnHandle
			.cSourceFile = lcSourceFileName
			.cClassName  = lcClassName
			.cApplicationPath = lcApplicationPath
			.CreateSummaryCursor()
		Endwith
		
		DoDefault()
		This.LoadTree()
		
		
	ENDPROC

	PROCEDURE Load
		DoDefault()
		
		Create Cursor crsr_Grid (	;
			  Name  		C(128),	;
			  ProcName		C(128),	;
			  StartLine		N(6),	;
			  Lineno		N(6),	;
			  SourceLine	C(250)	;
			  )
		
		Create Cursor crsr_TypeList ( nType N(3), Description M)
		Insert Into crsr_TypeList Values (TYPE_Assignments, 'Global Assignments')
		Insert Into crsr_TypeList Values (TYPE_Others, 		'Global References')
		Insert Into crsr_TypeList Values (TYPE_Tables, 		'Tables/Cursors')
		Insert Into crsr_TypeList Values (TYPE_Fields, 		'Fields')
		Insert Into crsr_TypeList Values (TYPE_Forms, 		'Forms')
		Insert Into crsr_TypeList Values (Type_Declared, 	'Declared Win API Functions')
		Insert Into crsr_TypeList Values (TYPE_Procedures, 	'Procedures/Functions')
		Insert Into crsr_TypeList Values (TYPE_Methods, 	'Methods')
		Insert Into crsr_TypeList Values (TYPE_PropAssign, 	'Property Assignments')
		Insert Into crsr_TypeList Values (TYPE_Objects, 	'Properties/Objects')
		Insert Into crsr_TypeList Values (TYPE_Parameters, 	'Parameters')
		Insert Into crsr_TypeList Values (TYPE_Locals, 		'Locals')
		Insert Into crsr_TypeList Values (TYPE_Constants, 	'Constants')
		
	ENDPROC

	PROCEDURE loadsettings
		This.LoadColumnInfo(This.grdGrid)
		DoDefault()
	ENDPROC

	PROCEDURE loadtree
		*!*	Local laImages[1], lcImage, lcPath, lnI, lnImages
		
		*!*	lcPath	 = Thisform.cApplicationPath + 'images\'
		*!*	lnImages = Adir (laImages, lcPath + '*.bmp')
		*!*	For lnI = 1 To lnImages
		*!*		lcImage = laImages[lnI, 1]
		*!*		This.oImageList.ListImages.Add (lnI, Lower (Juststem (lcImage)),		;
		*!*			  LoadPicture (lcPath + lcImage))
		*!*	Next lnI
		*!*	This.oTree.Object.ImageList = .oImageList
		
		With This
		
			Select crsr_TypeList
			Scan
				.AddTopNode (nType, Description)
			EndScan
			
			If This.oTree.Nodes.Count > 0
				This.oTree.Nodes(1).EnsureVisible()
			EndIf 
		
		Endwith
		
	ENDPROC

	PROCEDURE nodeexpanded
		*** ActiveX Control Event ***
		Lparameters Node
		
		Local loTag
		
		loTag = Node.Tag
		If loTag.Expanded
			Return
		Endif
		
		Do Case
			Case loTag.Level = 1
				Thisform.ExpandTopNode (Node)
			Case loTag.Level = 2
				Thisform.ExpandLevel2 (Node)
			Case loTag.Level = 3
				Thisform.ExpandLevel3Names (Node)
				If Reccount ('crsr_Procs') > 1
					Thisform.ExpandLevel3Procs (Node)
				EndIf 
		Endcase
		
		Node.Tag.Expanded = .T.
		This.oTree.Nodes.Remove (Node.Tag.Standin)
		
		Return
		
	ENDPROC

	PROCEDURE nodeselected
		Lparameters loNode
		
		Local lcName, lcProcName, loTag
		loTag = loNode.Tag
		
		Do Case
		
			Case loTag.Level = 1 && entire category
				Select  * From crsr_Summary			;
					Where Type = loTag.Type			;
					Into Cursor crsr_Matches
		
			Case loTag.Level = 2 && a single name in a category
				lcName = Upper (loTag.Name)
				Select  * From crsr_Summary			;
					Where Type = loTag.Type			;
						And UpperName = lcName		;
					Into Cursor crsr_Matches
		
			Case loTag.Level = 3 && a single name in a category (matches to stem of name)
				lcName = GetWordNum(Upper (loTag.Name), 1, '.')
				Select  * From crsr_Summary									;
					Where Type = loTag.Type									;
						And Left (UpperName, 1) # '.'						;
						And Getwordnum (UpperName, 1, '.') == lcName		;
					Into Cursor crsr_Matches
		
			Case loTag.Level = 4 && a single Proc in a category
				lcName	   = Upper (loTag.Name)
				lcProcName = Upper (loTag.ProcName)
				Select  * From crsr_Summary						;
					Where Type = loTag.Type						;
						And UpperName = lcName					;
						And Upper (ProcName) = lcProcName		;
					Into Cursor crsr_Matches
		
			Case loTag.Level = 5 && single name in a category (but came from subset of stem of name)
				lcName = Upper (loTag.Name)
				Select  * From crsr_Summary			;
					Where Type = loTag.Type			;
						And UpperName = lcName		;
					Into Cursor crsr_Matches
		
			Case loTag.Level = 6 && single proc in a category for a subset of stem of the name
				lcName = GetWordNum(Upper (loTag.Name), 1, '.')
				lcProcName = Upper (loTag.ProcName)
				Select  * From crsr_Summary									;
					Where Type = loTag.Type									;
						And Left (UpperName, 1) # '.'						;
						And Getwordnum (UpperName, 1, '.') == lcName		;
						And Upper (ProcName) = lcProcName					;
					Into Cursor crsr_Matches
		
		Endcase
		
		
		Select  Distinct														;
				crsr_Procs.Id						 As	 ProcID					;
			  , crsr_Procs.StartLine				 As	 StartLine				;
			  , crsr_Matches.Name					 As	 Name					;
			  , crsr_Procs.ProcName					 As	 ProcName				;
			  , Upper (crsr_Procs.ProcName)			 As	 UProcName				;
			  , crsr_Lines.Lineno					 As	 Lineno					;
			  , Padr (crsr_Lines.SourceLine, 250)	 As	 SourceLine				;
			From crsr_Matches													;
				Join crsr_Procs													;
					On crsr_Matches.ProcID = crsr_Procs.Id						;
				Join crsr_Refs													;
					On crsr_Matches.ProcID = crsr_Refs.ProcID					;
					And crsr_Matches.UpperName = Upper (crsr_Refs.Name)			;
				Join crsr_Lines													;
					On crsr_Refs.LineID = crsr_Lines.Id							;
			Order By UProcName, Lineno											;
			Into Cursor crsr_GridNew Readwrite
		
		This.LockScreen = .T.
		
		Select crsr_Grid
		Delete Tag All
		Set Filter To
		Zap
		Append From (Dbf ('crsr_GridNew'))
		Goto Top
		
		This.LockScreen = .F.
		This.Refresh()
		
	ENDPROC

	PROCEDURE savesettings
		This.SaveColumnInfo(This.grdGrid)
		DoDefault()
		
		
	ENDPROC

	PROCEDURE setdefaults
		Local lcType
		DoDefault()
		
		.SplitterLeft  = This.SplitterH.Left
		.cColumnWidths = ''
		.cColumnOrder  = ''
		.nStartNode    = 0
		Select crsr_TypeList
		Scan
			lcType = Transform(nType)
			.Expand&lcType. = .F.
		Endscan
		
		
		
	ENDPROC

	PROCEDURE Show
		LPARAMETERS nStyle
		
		DoDefault(nStyle)
		This.SplitterH.MoveSplitterToPosition (This.oMySettings.SplitterLeft)
		This.MinWidth = 700
		
	ENDPROC

	PROCEDURE grdGrid.Column1.Text1.DblClick
		Thisform.HandleDoubleClick()
		
	ENDPROC

	PROCEDURE grdGrid.Column2.Text1.DblClick
		Thisform.HandleDoubleClick()
		
	ENDPROC

	PROCEDURE grdGrid.Column3.Text1.DblClick
		Thisform.HandleDoubleClick()
		
	ENDPROC

	PROCEDURE grdGrid.Column4.Text1.DblClick
		Thisform.HandleDoubleClick()
		
	ENDPROC

	PROCEDURE oTree.Expand
		*** ActiveX Control Event ***
		Lparameters Node
		
		Thisform.NodeExpanded(Node)
	ENDPROC

	PROCEDURE oTree.MouseUp
		#Define ccExpandAll 	'Expand All'
		#Define ccCollapseAll 	'Collapse all'
		
		*** ActiveX Control Event ***
		Lparameters Button, Shift, x, Y
		
		Local loMenu As 'ContextMenu' Of 'PEME_Menu.vcx'
		Local lcChoice, lcType, lnI, loNode, loTag
		
		If Abs (This.nMouseButton) # 2  && for right-click only ... negative means on node
			Return
		Endif
		
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Nodefault
		
		****************************************************************
		****************************************************************
		
		loMenu = Newobject ('ContextMenu', 'PEME_Menu.vcx')
		
		With loMenu
			.AddMenuItem ('Expand all top nodes', ccExpandAll)
			.AddMenuItem ('Collapse all top nodes', ccCollapseAll)
		
			If .AddSubMenu ('Nodes to expand at startup')
				Select crsr_TypeList
				Scan
					lcType = Transform (nType)
					.AddMenuItem (Description, 'Expand', nType, , , , Thisform.oMySettings.Expand&lcType.)
				Endscan
				.EndSubmenu()
			Endif
		
			If .AddSubMenu ('Node to select at startup')
				Select crsr_TypeList
				Scan
					.AddMenuItem (Description, 'StartNode', nType, , , , nType = Thisform.oMySettings.nStartNode)
				Endscan
				.EndSubmenu()
			Endif
		Endwith
		
		If Not loMenu.Activate()
			Return
		Endif
		
		****************************************************************
		****************************************************************
		lcChoice = loMenu.Keyword
		
		With This
			Do Case
		
				Case lcChoice = ccExpandAll
		
					For lnI = 1 To .Nodes.Count
						loNode = .Nodes (lnI)
						loTag  = loNode.Tag
						If 'O' = Vartype (loTag) And loTag.Level = 1
							loNode.Expanded = .T.
							Thisform.NodeExpanded (loNode)
						Endif
					Endfor
		
				Case lcChoice = ccCollapseAll
		
					For lnI = 1 To .Nodes.Count
						loNode = .Nodes (lnI)
						loTag  = loNode.Tag
						If 'O' = Vartype (loTag) And loTag.Level = 1
							loNode.Expanded = .F.
						Endif
					Endfor
		
				Case lcChoice = 'Expand'
		
					lcType = Transform (loMenu.Parameters)
					Thisform.oMySettings.Expand&lcType. = Not Thisform.oMySettings.Expand&lcType.
		
				Case lcChoice = 'StartNode'
		
					Thisform.oMySettings.nStartNode = loMenu.Parameters
		
			Endcase
		
		Endwith
		
	ENDPROC

	PROCEDURE oTree.NodeClick
		*** ActiveX Control Event ***
		LPARAMETERS node
		
		Thisform.NodeSelected(Node)
		
	ENDPROC

	PROCEDURE oTree.OLEStartDrag
		*** ActiveX Control Event ***
		LPARAMETERS data, allowedeffects
		
	ENDPROC

	PROCEDURE oTree.Refresh
		*** ActiveX Control Method ***
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmopenclass AS frmopenfile OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cclasslib
		*p: cclassname
		*p: lmodal
	*</DefinedPropArrayMethod>

	cclasslib = 
	cclassname = 
	cfoxuserid = OPENCLASS
	cfoxusername = OpenClass
	DoCreate = .T.
	lmodal = .F.
	Name = "frmopenclass"
	changefontsize.Name = "changefontsize"
	cmdSearch.Name = "cmdSearch"
	cntClass.cbobaseclass.Name = "cbobaseclass"
	cntClass.chkExactMatch1.Alignment = 0
	cntClass.chkExactMatch1.Name = "chkExactMatch1"
	cntClass.cmdMarkAll.Name = "cmdMarkAll"
	cntClass.lblBaseClass.Name = "lblBaseClass"
	cntClass.lblClass.Name = "lblClass"
	cntClass.Name = "cntClass"
	cntClass.txtclasslookfor.Name = "txtclasslookfor"
	cntSearch.cboFolder.Name = "cboFolder"
	cntSearch.cboLookFor.Name = "cboLookFor"
	cntSearch.cboScope.Name = "cboScope"
	cntSearch.chkExactMatch2.Alignment = 0
	cntSearch.chkExactMatch2.Name = "chkExactMatch2"
	cntSearch.chkProjectHomeDir.Alignment = 0
	cntSearch.chkProjectHomeDir.Name = "chkProjectHomeDir"
	cntSearch.chkSubFolders.Alignment = 0
	cntSearch.chkSubFolders.Name = "chkSubFolders"
	cntSearch.cmdCurrent.Name = "cmdCurrent"
	cntSearch.cmdGetFolder.Name = "cmdGetFolder"
	cntSearch.IMGPARENT.Height = 16
	cntSearch.IMGPARENT.Name = "IMGPARENT"
	cntSearch.IMGPARENT.Width = 16
	cntSearch.lblLookFor.Name = "lblLookFor"
	cntSearch.lblLookIn.Name = "lblLookIn"
	cntSearch.lblScope.Name = "lblScope"
	cntSearch.Name = "cntSearch"
	cntTypes.Chkfiletype1.Alignment = 0
	cntTypes.Chkfiletype1.Name = "Chkfiletype1"
	cntTypes.Chkfiletype10.Alignment = 0
	cntTypes.Chkfiletype10.Name = "Chkfiletype10"
	cntTypes.Chkfiletype11.Alignment = 0
	cntTypes.Chkfiletype11.Name = "Chkfiletype11"
	cntTypes.Chkfiletype12.Alignment = 0
	cntTypes.Chkfiletype12.Name = "Chkfiletype12"
	cntTypes.Chkfiletype13.Alignment = 0
	cntTypes.Chkfiletype13.Name = "Chkfiletype13"
	cntTypes.Chkfiletype14.Alignment = 0
	cntTypes.Chkfiletype14.Name = "Chkfiletype14"
	cntTypes.Chkfiletype2.Alignment = 0
	cntTypes.Chkfiletype2.Name = "Chkfiletype2"
	cntTypes.Chkfiletype3.Alignment = 0
	cntTypes.Chkfiletype3.Name = "Chkfiletype3"
	cntTypes.Chkfiletype4.Alignment = 0
	cntTypes.Chkfiletype4.Name = "Chkfiletype4"
	cntTypes.Chkfiletype5.Alignment = 0
	cntTypes.Chkfiletype5.Name = "Chkfiletype5"
	cntTypes.Chkfiletype6.Alignment = 0
	cntTypes.Chkfiletype6.Name = "Chkfiletype6"
	cntTypes.Chkfiletype7.Alignment = 0
	cntTypes.Chkfiletype7.Name = "Chkfiletype7"
	cntTypes.Chkfiletype8.Alignment = 0
	cntTypes.Chkfiletype8.Name = "Chkfiletype8"
	cntTypes.Chkfiletype9.Alignment = 0
	cntTypes.Chkfiletype9.Name = "Chkfiletype9"
	cntTypes.cmdClearAll.Name = "cmdClearAll"
	cntTypes.cmdMarkAll.Name = "cmdMarkAll"
	cntTypes.lblFileTypes.Name = "lblFileTypes"
	cntTypes.Name = "cntTypes"
	grdResults.colBaseClass.Header1.Name = "Header1"
	grdResults.colBaseClass.Name = "colBaseClass"
	grdResults.colBaseClass.Text1.Name = "Text1"
	grdResults.colClass.Header1.Name = "Header1"
	grdResults.colClass.Name = "colClass"
	grdResults.colClass.Text1.Name = "Text1"
	grdResults.colClassLoc.Header1.Name = "Header1"
	grdResults.colClassLoc.Name = "colClassLoc"
	grdResults.colClassLoc.Text1.Name = "Text1"
	grdResults.colFilename.Header1.Name = "Header1"
	grdResults.colFilename.Name = "colFilename"
	grdResults.colFilename.Text1.Name = "Text1"
	grdResults.colFolder.Header1.Name = "Header1"
	grdResults.colFolder.Name = "colFolder"
	grdResults.colFolder.Text1.Name = "Text1"
	grdResults.colParentClass.Header1.Name = "Header1"
	grdResults.colParentClass.Name = "colParentClass"
	grdResults.colParentClass.Text1.Name = "Text1"
	grdResults.ColTimeStamp.Header1.Name = "Header1"
	grdResults.ColTimeStamp.Name = "ColTimeStamp"
	grdResults.ColTimeStamp.Text1.Name = "Text1"
	grdResults.Name = "grdResults"
	imgClassIcon.Name = "imgClassIcon"
	cmdClassIcon.Name = "cmdClassIcon"
	cmdSelect.Name = "cmdSelect"
	chkStayOpen.Alignment = 0
	chkStayOpen.Name = "chkStayOpen"
	cmdRun.Name = "cmdRun"
	
	PROCEDURE editsourcefile
		Lparameters lcFileName, lcClass, lcMethod, lnStartRange, lnEndRange
		
		If This.lModal
			This.cClassLib  = Alltrim (lcFileName)
			This.cClassName = Alltrim (lcClass)
			This.Hide()
			Return .F.
		Else
			DoDefault (lcFileName, lcClass, lcMethod, lnStartRange, lnEndRange)
			If Vartype(lnStartRange) = 'N' and 'PRG' = Upper(JustExt(lcFileName)) 
				Execscript(_Screen.cThorDispatcher, 'THOR_PROC_SELECTTEXT')
			EndIf 
			Return .T.
		Endif
		
	ENDPROC

	PROCEDURE Init
		Lparameters oUtils, oFoxRef, lcType, llModal
		
		This.lModal = llModal
		DoDefault (oUtils, oFoxRef, lcType)
		Thisform.Refresh()
		
		
	ENDPROC

	PROCEDURE cmdClassIcon.MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If Thisform.lModal
			If Agetclass (laClassInfo)
				Thisform.cClassLib	= laClassInfo(1)
				Thisform.cClassName	= laClassInfo(2)
				Thisform.Hide()
			Endif
		Else
			DoDefault (nButton, nShift, nXCoord, nYCoord)
		Endif
		
	ENDPROC

	PROCEDURE cmdClassIcon.Refresh
		Local lcFile, lcPath
		DoDefault()
		
		If Thisform.lModal
			With This
				.Enabled = .T.
				.Visible = .T.
				.ToolTipText = 'Use default VFP dialog to find parent class'
			Endwith
			With This.Parent.imgClassIcon
				.Enabled = .T.
				.Visible = .T.
		
				lcPath	 = Thisform.cApplicationPath + 'images\'
				lcFile	 = lcPath + 'Open' + '.bmp'
				.Picture = lcFile
			Endwith
		Endif
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmopenfile AS frmpeme_base OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntClass.lblClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntClass.chkExactMatch1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntClass.lblBaseClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntClass.cboBaseClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntClass.txtClassLookFor" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntClass.cmdMarkAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.lblLookFor" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.cboLookFor" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.lblScope" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.cboScope" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.cboFolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.lblLookIn" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.cmdGetFolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.chkSubFolders" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.chkProjectHomeDir" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.cmdCurrent" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.chkExactMatch2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntSearch.imgParent" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.lblFileTypes" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.cmdMarkAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.cmdClearAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntTypes.Chkfiletype14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colClass.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colClass.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colFileName.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colFileName.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colFolder.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colFolder.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colParentClass.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colParentClass.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colClassLoc.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colClassLoc.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colBaseClass.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colBaseClass.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colTimeStamp.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdResults.colTimeStamp.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgClassIcon" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClassIcon" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkStayOpen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRun" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialogenglish.h"
	*<DefinedPropArrayMethod>
		*m: addfiletype
		*m: aligncontainers
		*m: checkfiletype
		*m: formaddobject
		*m: loadscope
		*m: refreshresults
		*m: runfile
		*m: savedraginfo
		*m: search
		*m: selectresults
		*m: setallfiletypes
		*m: setsortorder
		*m: updatelookfor
		*m: updatescope
		*p: cbaseclass
		*p: cbobaseclass
		*p: cbofolder
		*p: cbolookfor
		*p: cboscope
		*p: cclass
		*p: cfilename
		*p: cfiletypes
		*p: chkprojecthomedir
		*p: chksubfolders
		*p: chomedir
		*p: csearchtype
		*p: csortorder
		*p: ctype
		*p: lbrowser
		*p: lclassexactmatch
		*p: ldragdrop
		*p: lerror
		*p: lfilenameexactmatch
		*p: lformaddobject
		*p: lignoreerrors
		*p: lkeepopen
		*p: lrequeryscope
		*p: lvcxscxmode
		*p: natpos
		*p: nmousebutton
		*p: nshift
		*p: ofoxref
		*p: oresultsform
		*p: osource
		*p: txtclasslookfor
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	AutoCenter = .T.
	BindControls = .F.
	Caption = "PEM Editor - Open"
	cbaseclass = 
	cbobaseclass = .NULL.
	cbofolder = .NULL.
	cbolookfor = .NULL.
	cboscope = .NULL.
	cclass = 
	cfilename = 
	cfiletypes = |
	chkprojecthomedir = .NULL.
	chksubfolders = .NULL.
	chomedir = 
	csearchtype = 
	csortorder = |COLCLASS|COLFILENAME|
	ctype = 
	DataSession = 2
	Desktop = .T.
	DoCreate = .T.
	Height = 292
	HelpContextID = 1231101
	lbindcontrols = .F.
	lbrowser = .T.
	lclassexactmatch = .F.
	ldragdrop = .F.
	lerror = .F.
	lfilenameexactmatch = .F.
	lformaddobject = .F.
	lignoreerrors = .F.
	lkeepopen = .F.
	lrequeryscope = .T.
	lvcxscxmode = .T.
	MaxButton = .T.
	MinButton = .T.
	Name = "frmopenfile"
	natpos = 0
	nmousebutton = 0
	nshift = 0
	ofoxref = .NULL.
	oresultsform = .NULL.
	osource = .NULL.
	ShowTips = .T.
	txtclasslookfor = .NULL.
	Width = 429
	_memberdata = <VFPData>
		<memberdata name="runfile" display="RunFile"/>
		</VFPData>
	changefontsize.Left = -24
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 114

	ADD OBJECT 'chkStayOpen' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Stay open", ;
		ControlSource = "Thisform.oMySettings.lKeepOpen", ;
		Left = 357, ;
		Name = "chkStayOpen", ;
		nanchor = 8, ;
		ToolTipText = "Will cause this form to remain open after selecting an item.", ;
		Top = 88
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdClassIcon' AS commandbutton WITH ;
		Caption = "", ;
		DragIcon = ..\images\control.cur, ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 10, ;
		Name = "cmdClassIcon", ;
		SpecialEffect = 1, ;
		Style = 1, ;
		TabIndex = 14, ;
		TabStop = .F., ;
		ToolTipText = "", ;
		Top = 8, ;
		Width = 16
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRun' AS basecommandbutton WITH ;
		Caption = "\<Run", ;
		Enabled = .T., ;
		FontBold = .T., ;
		Height = 23, ;
		Left = 360, ;
		Name = "cmdRun", ;
		nanchor = 8, ;
		TabIndex = 5, ;
		Top = 58, ;
		Visible = .T., ;
		Width = 63
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSearch' AS basecommandbutton WITH ;
		Caption = "\<Search", ;
		Default = .T., ;
		Height = 23, ;
		Left = 360, ;
		Name = "cmdSearch", ;
		nanchor = 8, ;
		TabIndex = 5, ;
		Top = 6, ;
		Width = 63
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelect' AS basecommandbutton WITH ;
		Caption = "\<Open", ;
		Enabled = .F., ;
		FontBold = .T., ;
		Height = 23, ;
		Left = 360, ;
		Name = "cmdSelect", ;
		nanchor = 8, ;
		TabIndex = 5, ;
		Top = 32, ;
		Visible = .F., ;
		Width = 63
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntClass' AS basecontainer WITH ;
		BorderWidth = 1, ;
		Height = 57, ;
		Left = 0, ;
		Name = "cntClass", ;
		TabIndex = 1, ;
		Top = 0, ;
		Width = 350
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntClass.cboBaseClass' AS basecombobox WITH ;
		DisplayCount = 25, ;
		Format = "", ;
		Height = 21, ;
		Left = 76, ;
		MaxLength = 254, ;
		Name = "cboBaseClass", ;
		TabIndex = 4, ;
		Top = 32, ;
		Width = 120
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cntClass.chkExactMatch1' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Exact match", ;
		ControlSource = "thisform.lclassexactmatch", ;
		Height = 16, ;
		Left = 265, ;
		Name = "chkExactMatch1", ;
		nanchor = 8, ;
		TabIndex = 5, ;
		Top = 8, ;
		Width = 77
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntClass.cmdMarkAll' AS basecommandbutton WITH ;
		Caption = "\<All", ;
		Height = 23, ;
		Left = 204, ;
		Name = "cmdMarkAll", ;
		TabIndex = 14, ;
		Top = 32, ;
		Width = 54
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntClass.lblBaseClass' AS baselabel WITH ;
		Caption = "Base class:", ;
		Height = 16, ;
		Left = 12, ;
		Name = "lblBaseClass", ;
		TabIndex = 3, ;
		Top = 36, ;
		Width = 59
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntClass.lblClass' AS baselabel WITH ;
		Caption = "Class:", ;
		Height = 16, ;
		Left = 39, ;
		Name = "lblClass", ;
		TabIndex = 1, ;
		Top = 10, ;
		Width = 32
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntClass.txtClassLookFor' AS basetextbox WITH ;
		Format = "", ;
		Height = 21, ;
		Left = 76, ;
		Name = "txtClassLookFor", ;
		Style = 0, ;
		TabIndex = 2, ;
		Top = 6, ;
		Width = 175
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'cntSearch' AS basecontainer WITH ;
		BorderWidth = 1, ;
		Height = 103, ;
		Left = 0, ;
		Name = "cntSearch", ;
		nanchor = 10, ;
		TabIndex = 2, ;
		Top = 55, ;
		Width = 350
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntSearch.cboFolder' AS basecombobox WITH ;
		DisplayCount = 25, ;
		Format = "", ;
		Height = 21, ;
		Left = 76, ;
		MaxLength = 254, ;
		Name = "cboFolder", ;
		nanchor = 10, ;
		Style = 0, ;
		TabIndex = 7, ;
		Top = 56, ;
		Width = 218
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cntSearch.cboLookFor' AS basecombobox WITH ;
		DisplayCount = 25, ;
		Format = "", ;
		Height = 21, ;
		Left = 76, ;
		Name = "cboLookFor", ;
		nanchor = 10, ;
		Style = 0, ;
		TabIndex = 2, ;
		Top = 6, ;
		Width = 175
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cntSearch.cboScope' AS basecombobox WITH ;
		BoundColumn = 2, ;
		BoundTo = .T., ;
		DisabledForeColor = 0,0,0, ;
		DisplayCount = 25, ;
		Format = "", ;
		Height = 21, ;
		Left = 76, ;
		MaxLength = 254, ;
		Name = "cboScope", ;
		nanchor = 10, ;
		Style = 0, ;
		TabIndex = 4, ;
		Top = 31, ;
		Width = 175
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cntSearch.chkExactMatch2' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Exact match", ;
		ControlSource = "thisform.lfilenameexactmatch", ;
		Left = 265, ;
		Name = "chkExactMatch2", ;
		nanchor = 8, ;
		TabIndex = 5, ;
		Top = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntSearch.chkProjectHomeDir' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Limit searc\<h to project home directory and subfolders", ;
		Height = 16, ;
		Left = 76, ;
		Name = "chkProjectHomeDir", ;
		TabIndex = 9, ;
		Top = 82, ;
		Visible = .F., ;
		Width = 275
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntSearch.chkSubFolders' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Searc\<h subfolders", ;
		Height = 16, ;
		Left = 76, ;
		Name = "chkSubFolders", ;
		TabIndex = 10, ;
		Top = 82, ;
		Width = 108
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntSearch.cmdCurrent' AS basecommandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Current Folder", ;
		Height = 23, ;
		Left = 260, ;
		Name = "cmdCurrent", ;
		nanchor = 8, ;
		TabIndex = 11, ;
		ToolTipText = "Use Current Folder", ;
		Top = 79, ;
		Width = 86
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntSearch.cmdGetFolder' AS basecommandbutton WITH ;
		Caption = "...", ;
		Height = 21, ;
		Left = 323, ;
		Name = "cmdGetFolder", ;
		nanchor = 8, ;
		TabIndex = 8, ;
		Top = 56, ;
		Width = 22
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntSearch.imgParent' AS baseimage WITH ;
		BackStyle = 0, ;
		Height = 16, ;
		Left = 300, ;
		Name = "imgParent", ;
		nanchor = 8, ;
		Picture = ..\images\up1lvl.bmp, ;
		Top = 59, ;
		Width = 16, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'cntSearch.lblLookFor' AS baselabel WITH ;
		Caption = "File Name:", ;
		Height = 16, ;
		Left = 12, ;
		Name = "lblLookFor", ;
		TabIndex = 1, ;
		Top = 10, ;
		Width = 51
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntSearch.lblLookIn' AS baselabel WITH ;
		Caption = "\<Look in:", ;
		Height = 16, ;
		Left = 12, ;
		Name = "lblLookIn", ;
		TabIndex = 6, ;
		Top = 60, ;
		Width = 39
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntSearch.lblScope' AS baselabel WITH ;
		Caption = "Sco\<pe:", ;
		Height = 16, ;
		Left = 12, ;
		Name = "lblScope", ;
		TabIndex = 3, ;
		Top = 35, ;
		Width = 36
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntTypes' AS basecontainer WITH ;
		BorderWidth = 1, ;
		Height = 64, ;
		Left = 0, ;
		Name = "cntTypes", ;
		nanchor = 10, ;
		TabIndex = 3, ;
		Top = 156, ;
		Width = 350
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntTypes.Chkfiletype1' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "PRG", ;
		Left = 76, ;
		Name = "Chkfiletype1", ;
		TabIndex = 2, ;
		ToolTipText = "Program", ;
		Top = 8
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype10' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "H", ;
		Left = 176, ;
		Name = "Chkfiletype10", ;
		TabIndex = 8, ;
		ToolTipText = "Header (include)", ;
		Top = 8
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype11' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "TXT", ;
		Left = 176, ;
		Name = "Chkfiletype11", ;
		TabIndex = 10, ;
		Top = 44
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype12' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "QPR", ;
		Left = 226, ;
		Name = "Chkfiletype12", ;
		TabIndex = 12, ;
		ToolTipText = "Generated query program", ;
		Top = 26
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype13' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "VCX", ;
		Left = 26, ;
		Name = "Chkfiletype13", ;
		TabIndex = 3, ;
		ToolTipText = "Class Library", ;
		Top = 26
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype14' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "SCX", ;
		Left = 26, ;
		Name = "Chkfiletype14", ;
		TabIndex = 4, ;
		ToolTipText = "Form", ;
		Top = 44
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype2' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "PJX", ;
		Left = 76, ;
		Name = "Chkfiletype2", ;
		TabIndex = 3, ;
		ToolTipText = "Project", ;
		Top = 26
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype3' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "MNX", ;
		Left = 76, ;
		Name = "Chkfiletype3", ;
		TabIndex = 4, ;
		ToolTipText = "Menu", ;
		Top = 44
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype4' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "DBC", ;
		Left = 126, ;
		Name = "Chkfiletype4", ;
		TabIndex = 6, ;
		ToolTipText = "Database", ;
		Top = 26
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype5' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "LBX", ;
		Left = 126, ;
		Name = "Chkfiletype5", ;
		TabIndex = 7, ;
		ToolTipText = "Label", ;
		Top = 44
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype6' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "FRX", ;
		Left = 126, ;
		Name = "Chkfiletype6", ;
		TabIndex = 5, ;
		ToolTipText = "Report", ;
		Top = 8
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype7' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "SPR", ;
		Left = 226, ;
		Name = "Chkfiletype7", ;
		TabIndex = 13, ;
		ToolTipText = "Generates screen program", ;
		Top = 44
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype8' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "MPR", ;
		Left = 226, ;
		Name = "Chkfiletype8", ;
		TabIndex = 11, ;
		ToolTipText = "Generated menu program", ;
		Top = 8
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.Chkfiletype9' AS chkfiletype WITH ;
		Alignment = 0, ;
		Caption = "INI", ;
		Left = 176, ;
		Name = "Chkfiletype9", ;
		TabIndex = 9, ;
		Top = 26
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntTypes.cmdClearAll' AS basecommandbutton WITH ;
		Caption = "Clear All", ;
		Height = 23, ;
		Left = 276, ;
		Name = "cmdClearAll", ;
		TabIndex = 15, ;
		Top = 35, ;
		Width = 63
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntTypes.cmdMarkAll' AS basecommandbutton WITH ;
		Caption = "Mark all", ;
		Height = 23, ;
		Left = 276, ;
		Name = "cmdMarkAll", ;
		TabIndex = 14, ;
		Top = 9, ;
		Width = 63
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntTypes.lblFileTypes' AS baselabel WITH ;
		Caption = "File Types:", ;
		Height = 16, ;
		Left = 8, ;
		Name = "lblFileTypes", ;
		TabIndex = 1, ;
		Top = 9, ;
		Width = 51, ;
		WordWrap = .T.
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'grdResults' AS basegrid WITH ;
		AllowAutoColumnFit = 2, ;
		ColumnCount = 7, ;
		Height = 59, ;
		Left = 6, ;
		MemberClass = "baseColumn", ;
		MemberClassLibrary = peme_basecontrols.prg, ;
		Name = "grdResults", ;
		nanchor = 15, ;
		RecordSource = "crsr_Results", ;
		TabIndex = 4, ;
		Top = 228, ;
		Width = 417, ;
		Basecolumn1.ControlSource = "Class", ;
		Basecolumn1.LCLASSESONLY = .T., ;
		Basecolumn1.Name = "colClass", ;
		Basecolumn1.Width = 100, ;
		Basecolumn2.ControlSource = "FileName", ;
		Basecolumn2.Name = "colFileName", ;
		Basecolumn2.Width = 150, ;
		Basecolumn3.ControlSource = "ThisForm.GetRelativePath (Folder, Thisform.cHomeDir)", ;
		Basecolumn3.Name = "colFolder", ;
		Basecolumn3.Width = 115, ;
		Basecolumn4.ControlSource = "Parent", ;
		Basecolumn4.LCLASSESONLY = .T., ;
		Basecolumn4.Name = "colParentClass", ;
		Basecolumn4.Width = 100, ;
		Basecolumn5.ControlSource = "ClassLoc", ;
		Basecolumn5.LCLASSESONLY = .T., ;
		Basecolumn5.Name = "colClassLoc", ;
		Basecolumn5.Width = 150, ;
		Basecolumn6.ControlSource = "BaseClass", ;
		Basecolumn6.LCLASSESONLY = .T., ;
		Basecolumn6.Name = "colBaseClass", ;
		Basecolumn6.Width = 100, ;
		Basecolumn7.ControlSource = "TimeStamp", ;
		Basecolumn7.Name = "colTimeStamp", ;
		Basecolumn7.Width = 115
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="grid" />

	ADD OBJECT 'grdResults.colBaseClass.Header1' AS header WITH ;
		Caption = "Base Class", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdResults.colBaseClass.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdResults.colClass.Header1' AS header WITH ;
		Caption = "Class", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdResults.colClass.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdResults.colClassLoc.Header1' AS header WITH ;
		Caption = "Class Location", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdResults.colClassLoc.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdResults.colFileName.Header1' AS header WITH ;
		Caption = "File Name", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdResults.colFileName.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdResults.colFolder.Header1' AS header WITH ;
		Caption = "Folder", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdResults.colFolder.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdResults.colParentClass.Header1' AS header WITH ;
		Caption = "Parent Class", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdResults.colParentClass.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdResults.colTimeStamp.Header1' AS header WITH ;
		Caption = "TimeStamp", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdResults.colTimeStamp.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'imgClassIcon' AS image WITH ;
		BackStyle = 0, ;
		Height = 16, ;
		Left = 10, ;
		Name = "imgClassIcon", ;
		Picture = ..\images\clibrary.ico, ;
		Stretch = 1, ;
		Top = 8, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />
	
	PROCEDURE Activate
		DODEFAULT()
		
		Return
		
		IF THIS.lRequeryScope
			THIS.lRequeryScope = .F.
			THIS.LoadScope()
			THIS.UpdateScope()
		ENDIF
		
	ENDPROC

	PROCEDURE addfiletype
		Lparameters lcFileType, llValue, llFixLookFor
		
		With This
			.cFileTypes = Strtran (.cFileTypes, '|' + lcFileType + '|', '|')
			If llValue
				.cFileTypes = .cFileTypes + lcFileType + '|'
			Endif
		
			If llFixLookFor
				.UpdateLookFor()
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE aligncontainers
		*** JRN 03/24/2010 : show only required containers
		Lparameters lcType
		Local nClassAnchor, nSearchAnchor, nTypesAnchor, nGridAnchor
		
		With This
			nClassAnchor 		= .cntClass.Anchor
			nSearchAnchor 	= .cntSearch.Anchor
			nTypesAnchor 		= .cntTypes.Anchor
			nGridAnchor 		= .grdResults.Anchor
		
			.cntClass.Anchor	= 0
			.cntSearch.Anchor	= 0
			.cntTypes.Anchor	= 0
			.grdResults.Anchor	= 0
		
			Do Case
				Case lcType = 'Class'
					.cntTypes.Visible = .F.
					.grdResults.Top = .cntSearch.Top + .cntSearch.Height + 6
				Case lcType = 'Form'
					.cntClass.Visible = .F.
					.cntSearch.Top = 0
					.cntTypes.Visible = .F.
					.grdResults.Top = .cntSearch.Top + .cntSearch.Height + 6
				Otherwise
					.cntClass.Visible = .F.
					.cntSearch.Top = 0
					.cntTypes.Top = .cntSearch.Top + .cntSearch.Height
					.grdResults.Top = .cntTypes.Top + .cntTypes.Height + 6
			Endcase
		
			.grdResults.Height = .Height - 6 - .grdResults.Top
		
			.cntClass.Anchor	= nClassAnchor
			.cntSearch.Anchor	= nSearchAnchor
			.cntTypes.Anchor	= nTypesAnchor
			.grdResults.Anchor	= nGridAnchor 
			
		Endwith
		
	ENDPROC

	PROCEDURE checkfiletype
		Lparameters lcFileType
		
		Return ('|' + lcFileType + '|') $ this.cFileTypes
	ENDPROC

	PROCEDURE Deactivate
		DODEFAULT()
		
		THIS.lRequeryScope = .T.
		
	ENDPROC

	PROCEDURE Destroy
		DoDefault()
		
		With This
		
			.cboFolder = .Null.
			.cboLookFor = .Null.
			.cboScope = .Null.
			.chkSubFolders = .Null.
			.chkProjectHomeDir = .Null.
		
			.txtClassLookFor = .Null.
			.cboBaseClass = .Null.
			
		Endwith
		
		
	ENDPROC

	PROCEDURE DragDrop
		LPARAMETERS oSource, nXCoord, nYCoord
		LOCAL lnResult,lnLastShift
		
		IF NOT this.lBrowser
			IF ISNULL(this.oItem.oAction)
				RETURN
			ENDIF
			this.oItem.oAction.DragDrop(oSource,nXCoord,nYCoord)
			RETURN
		ENDIF
		*** JRN 2010-04-18 : do nothing!
		IF .T. && TYPE("oSource")#"O" OR this.lReadOnly OR oSource.parent.Name==this.Name OR ;
				NOT LEFT(oSource.parent.Name,12)=="classbrowser" OR ;
				oSource.parent.cFileName==this.cFileName OR ;
				NOT RIGHT(oSource.parent.cFileName,4)==".vcx"
			this.oSource=.NULL.
			RETURN .F.
		ENDIF
		oSource.DragIcon=""
		this.oSource=oSource
		IF this.AddInMethod(PROGRAM())
			this.oSource=.NULL.
			RETURN
		ENDIF
		this.AddClass
		this.oSource=.NULL.
		SET MESSAGE TO
		
		
	ENDPROC

	PROCEDURE DragOver
		LPARAMETERS oSource, nXCoord, nYCoord, nState
		LOCAL lcDragIcon
		
		IF TYPE("nState")#"N" OR nState=2 OR TYPE("oSource.parent")#"O" OR ;
				NOT LEFT(oSource.parent.Name,12)=="classbrowser"
			RETURN .F.
		ENDIF
		DO CASE
			CASE nState=1
				oSource.DragIcon=oSource.parent.cDragIcon
				SET MESSAGE TO
			CASE this.lBrowser AND (this.lReadOnly OR oSource.parent.Name==this.Name OR ;
					oSource.parent.cFileName==this.cFileName OR ;
					NOT RIGHT(oSource.parent.cFileName,4)==".vcx")
				oSource.DragIcon="c:\dev\browser\nodrop.cur"
			CASE NOT oSource.parent.lBrowser
				lcDragIcon="c:\dev\browser\dragmove.cur"
			OTHERWISE
				lcDragIcon=IIF(oSource.parent.nShift=2,"dragcopy.cur","dragmove.cur")
				oSource.DragIcon="c:\dev\browser\"+lcDragIcon
				SET MESSAGE TO IIF(oSource.parent.nShift=2,M_DROP_TO_COPY_LOC,M_DROP_TO_MOVE_LOC)+ ;
						[ (]+oSource.parent.cClass+[) ]+M_FROM_LOC+[ "]+oSource.parent.cFileName+ ;
						[" ]+M_TO_LOC+[ "]+this.cFileName+["]
		ENDCASE
		oSource.Refresh
		
		
	ENDPROC

	PROCEDURE formaddobject
		*** JRN 2010-04-19 : from Class Browser, with only minor modifications, as noted
		* all comments are mine, including code that has been commented out
		LPARAMETERS toObject,tnXCoord,tnYCoord,tlActivateForm,tlDesignMode,tlNoShow,tlNoErrors,tlBuilder,toForm
		LOCAL lcClass,lcObjName,lcMWindow,lnRow,tnRow,llPixelMode,llIgnoreErrors
		LOCAL laMembers,lnMemberCount,oNewObject,lcTargetBaseClass,lcBaseClass,lcBaseClass2
		LOCAL lnFormCount,lnRowOffset,lnColOffset,lcFileName,lcKeyBoard,llBuilder,llAutoAddForm
		LOCAL lnCount,lnCount2,lcFontName,lnFontSize,llAddToScreen,llAddToCommand,llAddToNew
		LOCAL oTemp,lcCode,lnLastSelect,lcParentObjName,lcParentObjProperty, laMouseObj(1), lnMRow, lnMCol
		
		this.lFormAddObject=.T.
		*!*	IF this.lBrowser
		*!*		IF NOT this.lVCXSCXMode OR this.lFileMode OR this.lSCXMode
		*!*			RETURN .F.
		*!*		ENDIF
			lcClass=this.cClass
			lcBaseClass=this.cBaseClass
			lcFileName=this.cFileName
		*!*	ELSE
		*!*		IF ISNULL(this.oItem) OR NOT PEMSTATUS(this.oItem,"cBaseClass",5)
		*!*			RETURN .F.
		*!*		ENDIF
		*!*		lcClass=LOWER(this.oItem.cClass)
		*!*		lcBaseClass=LOWER(this.oItem.cBaseClass)
		*!*		lcFileName=LOWER(this.oItem.cFileName)
		*!*	ENDIF
		IF this.nAtPos=-.1
			this.nAtPos=-.2
		ENDIF
		llAddToScreen=.F.
		llAddToCommand=.F.
		llAddToNew=.F.
		IF VARTYPE(toObject)#"O"
			DO CASE
				CASE VARTYPE(toObject)#"C"
					RETURN .F.
				CASE LOWER(ALLTRIM(toObject))=="_screen"
					llAddToScreen=.T.
				CASE LOWER(ALLTRIM(toObject))=="command"
					llAddToCommand=.T.
				CASE LOWER(ALLTRIM(toObject))=="new"
					llAddToNew=.T.
				OTHERWISE
					RETURN .F.
			ENDCASE
			toObject=_screen
		ELSE
			IF toObject=_screen
				llAddToScreen=.T.
			ELSE
				DO WHILE .T.
					IF PEMSTATUS(toObject,"AddObject",5) OR VARTYPE(toObject.Parent)#"O" OR ;
							VARTYPE(toObject.Parent.BaseClass)#"C"
						EXIT
					ENDIF
					toObject=toObject.Parent
				ENDDO
			ENDIF
		ENDIF
		lcTargetBaseClass=LOWER(toObject.BaseClass)
		llAutoAddForm=(lcTargetBaseClass=="form" AND VARTYPE(tnXCoord)#"N")
		IF lcTargetBaseClass=="form" AND VARTYPE(toForm)#"O"
			toForm=toObject
		ENDIF
		IF lcTargetBaseClass=="pageframe" AND NOT lcTargetBaseClass=="page"
			FOR lnCount = 1 TO toObject.PageCount
				IF lnCount=toObject.ActivePage
					toObject=toObject.Pages[lnCount]
					lcTargetBaseClass=LOWER(toObject.BaseClass)
					EXIT
				ENDIF
			ENDFOR
		ENDIF
		llPixelMode=(VARTYPE(toForm)=="O" AND TYPE("toForm.ScaleMode")=="N" AND ;
				toForm.ScaleMode=3)
		lnScaleMode=3
		IF VARTYPE(tnXCoord)=="N" AND TYPE("toForm.ScaleMode")=="N" AND NOT llPixelMode
			lnScaleMode=toForm.ScaleMode
			IF NOT PEMSTATUS(toForm,"ScaleMode",0)
				lnScaleMode=-1
			ENDIF
			toForm.ScaleMode=3
			llPixelMode=.T.
			llAutoAddForm=.F.
		ENDIF
		IF llPixelMode
			IF TYPE("toForm.FontName")=="C"
				lcFontName=toForm.FontName
				lnFontSize=toForm.FontSize
			ELSE
				oTemp=CREATEOBJECT("Textbox")
				lcFontName=oTemp.FontName
				lnFontSize=oTemp.FontSize
				oTemp=.NULL.
			ENDIF
		ENDIF
		lcMWindow=" "
		lnRow=0
		lnCol=0
		lnRowOffset=0
		lnColOffset=0
		DO CASE
			CASE llAddToScreen OR llAddToCommand OR llAddToNew
				lcMWindow=""
			CASE llAutoAddForm AND tlDesignMode
				lcMWindow=LOWER(toObject.Caption)
			CASE PARAMETERS()<3 AND NOT llAutoAddForm AND NOT tlDesignMode
				lnCount=-1
				DO WHILE .T.
					lnCount=lnCount+1
					lcParentObjName="toObject"+REPLICATE(".parent",lnCount)
					IF TYPE(lcParentObjName)#"O"
						EXIT
					ENDIF
					lcBaseClass2=LOWER(EVALUATE(lcParentObjName+".BaseClass"))
					IF lcBaseClass2=="form"
						lcMWindow=EVALUATE(lcParentObjName+".Name")
						lcParentObjProperty=lcParentObjName+".ScaleMode"
						llPixelMode=(TYPE(lcParentObjProperty)#"N" OR ;
								EVALUATE(lcParentObjProperty)=3)
						EXIT
					ENDIF
					lcParentObjProperty=lcParentObjName+".Top"
					IF TYPE(lcParentObjProperty)#"N"
						LOOP
					ENDIF
					lnRowOffset=lnRowOffset-EVALUATE(lcParentObjProperty)
					lcParentObjProperty=lcParentObjName+".Left"
					lnColOffset=lnColOffset-EVALUATE(lcParentObjProperty)
					lcParentObjProperty=lcParentObjName+".BaseClass"
					IF LOWER(EVALUATE(lcParentObjProperty))=="pageframe"
						lnRowOffset=-OBJTOCLIENT(toObject,1)
						lnColOffset=-OBJTOCLIENT(toObject,2)
					ENDIF
				ENDDO
			CASE llAutoAddForm
				lcMWindow=LOWER(toObject.Name)
		ENDCASE
		IF VARTYPE(tnYCoord)=="N"
			lnRow=tnYCoord
		ELSE
			IF NOT lcMWindow==" " AND llAutoAddForm AND WEXIST(lcMWindow)
				lnRow=MROW(lcMWindow)
				IF lnRow<0
					RETURN .F.
				ENDIF
				IF llPixelMode
					lnRow=lnRow*FONTMETRIC(1,lcFontName,lnFontSize)
				ENDIF
				lnRow=lnRow+lnRowOffset
			ENDIF
		ENDIF
		IF VARTYPE(tnXCoord)=="N"
			lnCol=tnXCoord
		ELSE
			IF NOT lcMWindow==" " AND llAutoAddForm AND WEXIST(lcMWindow)
				lnCol=MCOL(lcMWindow)
				IF lnCol<0
					RETURN .F.
				ENDIF
				IF llPixelMode
					lnCol=lnCol*FONTMETRIC(6,lcFontName,lnFontSize)
				ENDIF
				lnCol=lnCol+lnColOffset
			ENDIF
		ENDIF
		DIMENSION laMembers[1]
		laMembers=""
		lnMemberCount=AMEMBERS(laMembers,toObject,2)
		FOR lnCount2 = 1 TO lnMemberCount
			laMembers[lnCount2]=LOWER(laMembers[lnCount2])+" "
		ENDFOR
		lnCount=0
		DO WHILE .T.
			lnCount=lnCount+1
			lcObjName=lcClass+ALLTRIM(STR(lnCount))
			IF ASCAN(laMembers,LOWER(lcObjName)+" ")=0
				EXIT
			ENDIF
		ENDDO
		DIMENSION laMembers[1]
		laMembersObj=""
		lnMemberCount=AMEMBERS(laMembers,toObject,1)
		FOR lnCount2 = 1 TO (2*lnMemberCount)
			laMembers[lnCount2]=LOWER(laMembers[lnCount2])+" "
		ENDFOR
		DO WHILE .T.
			IF ASCAN(laMembers,LOWER(lcObjName)+" ")=0
				EXIT
			ENDIF
			lnCount=lnCount+1
			lcObjName=lcClass+ALLTRIM(STR(lnCount))
		ENDDO
		llIgnoreErrors=this.lIgnoreErrors
		this.lIgnoreErrors=tlNoErrors
		lcObjName=PROPER(lcObjName)
		lnFormCount=IIF(lcTargetBaseClass=="formset",toObject.FormCount,0)
		IF llAddToCommand OR llAddToNew OR (llAddToScreen AND ;
				(lcBaseClass=="formset" OR lcBaseClass=="form" OR ;
				lcBaseClass=="toolbar" OR lcBaseClass=="custom"))
			lcObjName="o"+PROPER(lcObjName)
			DO WHILE .T.
				IF TYPE(lcObjName)=="U"
					EXIT
				ENDIF
				lnCount=lnCount+1
				lcObjName="o"+PROPER(lcClass+ALLTRIM(STR(lnCount)))
			ENDDO
			IF llAddToCommand
				DO CASE
					CASE lnScaleMode=-1
						toForm.ResetToDefault("ScaleMode")
					CASE lnScaleMode=0
						toForm.ScaleMode=0
				ENDCASE
				lcKeyboard=[{Ctrl+F2}{Ctrl+END}]+lcObjName+ ;
						[=NEWOBJECT("]+lcClass+[","]+lcFileName+["){ENTER}]
				KEYBOARD (lcKeyboard) PLAIN
				this.lIgnoreErrors=llIgnoreErrors
				RETURN
			ENDIF
			oNewObject=NEWOBJECT(lcClass,lcFileName)
			IF VARTYPE(oNewObject)#"O" OR ISNULL(oNewObject)
				DO CASE
					CASE lnScaleMode=-1
						toForm.ResetToDefault("ScaleMode")
					CASE lnScaleMode=0
						toForm.ScaleMode=0
				ENDCASE
				oNewObject=.NULL.
				this.lError=.F.
				this.lIgnoreErrors=llIgnoreErrors
				RETURN .F.
			ENDIF
			IF llAddToNew
				DO CASE
					CASE lnScaleMode=-1
						toForm.ResetToDefault("ScaleMode")
					CASE lnScaleMode=0
						toForm.ScaleMode=0
				ENDCASE
				this.lError=.F.
				this.lIgnoreErrors=llIgnoreErrors
				RETURN oNewObject
			ENDIF
			PUBLIC (lcObjName)
			lcCode=lcObjname+[=oNewObject]
			&lcCode
			IF NOT lcBaseClass=="formset" AND TYPE("oNewObject.ScaleMode")=="N"
				IF oNewObject.ScaleMode=0
					oTemp=IIF(lcBaseClass=="form",oNewObject,_screen)
					lnRow=lnRow/FONTMETRIC(1,oTemp.FontName,oTemp.FontSize)
					lnCol=lnCol/FONTMETRIC(6,oTemp.FontName,oTemp.FontSize)
					oTemp=.NULL.
				ENDIF
				oNewObject.Top=lnRow
				oNewObject.Left=lnCol
			ENDIF
			lnLastSelect=SELECT()
		*!*	IF this.lBrowser
		*!*		this.RefreshRecNo
		*!*		SELECT (this.cAlias)
		*!*		IF NOT llAddToNew AND NOT tlNoShow AND ;
		*!*				ATC(CR_LF+"Visible = .F.",CR_LF+Properties)=0 AND ;
		*!*				PEMSTATUS(oNewObject,"Show",5) AND ;
		*!*				PEMSTATUS(oNewObject,"Show",3)=="Method"
		*!*			oNewObject.Show
		*!*		ENDIF
		*!*	ELSE
				IF PEMSTATUS(oNewObject,"Show",5) AND ;
						PEMSTATUS(oNewObject,"Show",3)=="Method"
					oNewObject.Show
				ENDIF
		*!*	ENDIF
			SELECT (lnLastSelect)
			this.oSource=oNewObject
			this.lError=.F.
			this.lIgnoreErrors=llIgnoreErrors
			IF this.AddInMethod(PROGRAM())
				this.oSource=.NULL.
				this.AutoRefresh
				DO CASE
					CASE lnScaleMode=-1
						toForm.ResetToDefault("ScaleMode")
					CASE lnScaleMode=0
						toForm.ScaleMode=0
				ENDCASE
				RETURN
			ENDIF
			this.oSource=.NULL.
			this.AutoRefresh
			DO CASE
				CASE lnScaleMode=-1
					toForm.ResetToDefault("ScaleMode")
				CASE lnScaleMode=0
					toForm.ScaleMode=0
			ENDCASE
			RETURN
		ELSE
			toObject.NewObject(lcObjName,lcClass,lcFileName)
		ENDIF
		oNewObject=.NULL.
		IF TYPE("toObject."+lcObjName)#"O"
			DO CASE
				CASE lnScaleMode=-1
					toForm.ResetToDefault("ScaleMode")
				CASE lnScaleMode=0
					toForm.ScaleMode=0
			ENDCASE
			this.lError=.F.
			this.lIgnoreErrors=llIgnoreErrors
			RETURN .F.
		ENDIF
		oNewObject=toObject.&lcObjName
		oNewObject.Name=lcObjName
		IF PEMSTATUS(oNewObject, "Top", 5) and not PEMSTATUS(oNewObject, "Top", 1)
			oNewObject.Top=lnRow
		ENDIF
		IF PEMSTATUS(oNewObject, "Left", 5) and not PEMSTATUS(oNewObject, "Left", 1)
			oNewObject.Left=lnCol
		ENDIF
		IF tlDesignMode
			toObject.Refresh
		ELSE
			IF NOT tlNoShow AND TYPE("oNewObject.Visible")=="L"
				*!*	lnLastSelect=SELECT()
				*!*	IF this.lBrowser
				*!*		this.RefreshRecNo
				*!*		SELECT (this.cAlias)
				*!*		IF ATC(CR_LF+"Visible = .F.",CR_LF+Properties)=0 AND ;
				*!*				GETPEM(oNewObject.Class,"Visible")
				*!*			oNewObject.Visible=.T.
				*!*		ENDIF
				*!*	ELSE
				*!*		oNewObject.Visible=.T.
				*!*	ENDIF
				*!*	SELECT (lnLastSelect)
			ENDIF
			IF llAddToScreen
				_screen.Refresh
			ENDIF
		ENDIF
		this.lIgnoreErrors=llIgnoreErrors
		this.lError=.F.
		this.oSource=oNewObject
		*!*	IF this.AddInMethod(PROGRAM())
		*!*		DO CASE
		*!*			CASE lnScaleMode=-1
		*!*				toForm.ResetToDefault("ScaleMode")
		*!*			CASE lnScaleMode=0
		*!*				toForm.ScaleMode=0
		*!*		ENDCASE
		*!*		this.oSource=.F.
		*!*		this.oSource=.NULL.
		*!*		RETURN
		*!*	ENDIF
		this.oSource=.NULL.
		llBuilder=(tlBuilder AND ;
				((TYPE("oNewObject.BuilderX")=="C" AND NOT EMPTY(oNewObject.BuilderX)) OR ;
					(TYPE("oNewObject.Builder")=="C" AND NOT EMPTY(oNewObject.Builder))) AND ;
					NOT EMPTY(_builder) AND FILE(_builder))
		IF NOT tlNoShow AND tlActivateForm
			IF this.lBrowser AND this.Visible
				this.cmdClassIcon.SetFocus
			ENDIF
			oTemp=toObject
			DO WHILE NOT LOWER(oTemp.BaseClass)=="form"
				IF TYPE("oTemp.parent")#"O"
					EXIT
				ENDIF
				oTemp=oTemp.parent
			ENDDO
			IF LOWER(oTemp.BaseClass)=="form"
				oTemp.Show
			ENDIF
			oTemp=.NULL.
		ENDIF
		IF NOT tlDesignMode
			DO CASE
				CASE lnScaleMode=-1
					toForm.ResetToDefault("ScaleMode")
				CASE lnScaleMode=0
					toForm.ScaleMode=0
			ENDCASE
			IF llBuilder
				DOEVENTS
				DO (_builder) WITH (oNewObject)
			ENDIF
			RETURN oNewObject
		ENDIF
		IF lcTargetBaseClass=="formset"
			DO CASE
				CASE lnScaleMode=-1
					toForm.ResetToDefault("ScaleMode")
				CASE lnScaleMode=0
					toForm.ScaleMode=0
			ENDCASE
			IF lnFormCount=1
				DOEVENTS
				CLEAR TYPEAHEAD
				KEYBOARD "{Alt+M}C" PLAIN
			ENDIF
			IF llBuilder
				DOEVENTS
				DO (_builder) WITH (oNewObject)
			ENDIF
			RETURN oNewObject
		ENDIF
		lcMWindow=toObject.Name
		IF NOT WEXIST(lcMWindow)
			IF TYPE("toObject.Caption")#"C"
				DO CASE
					CASE lnScaleMode=-1
						toForm.ResetToDefault("ScaleMode")
					CASE lnScaleMode=0
						toForm.ScaleMode=0
				ENDCASE
				IF llBuilder
					DOEVENTS
					DO (_builder) WITH (oNewObject)
				ENDIF
				RETURN oNewObject
			ENDIF
			lcMWindow=toObject.Caption
			IF NOT WEXIST(lcMWindow)
				DO CASE
					CASE lnScaleMode=-1
						toForm.ResetToDefault("ScaleMode")
					CASE lnScaleMode=0
						toForm.ScaleMode=0
				ENDCASE
				IF llBuilder
					DOEVENTS
					DO (_builder) WITH (oNewObject)
				ENDIF
				RETURN oNewObject
			ENDIF
		ENDIF
		CLEAR TYPEAHEAD
		*** JRN 2010-04-19 : new code to attempt to click on the newly added object
		*!*	lnMRow = Mrow('',3)
		*!*	lnMCol = MCol('',3)
		*!*	Mouse At lnMRow + 4, lnMCol + 2 Pixels
		*!*	IF AMOUSEOBJ(laMouseObj) >= 4 				;
		*!*			AND VARTYPE(laMouseObj[2])=="O" 	;
		*!*			and laMouseObj(2) = oNewObject
		*!*		Mouse Click Shift Control
		*!*	Else
		*!*		?laMouseObj(2).Name, lnMRow, lnMCol
		*!*	ENDIF
		*!*	Mouse At lnMRow, lnMCol Pixels
		
		IF NOT llBuilder AND NOT EMPTY(lcMWindow)
			DOEVENTS
			IF llPixelMode
				MOUSE CLICK ;
						AT lnRow+4,lnCol+2 PIXELS ;
						WINDOW (lcMWindow)
			ELSE
				MOUSE CLICK ;
						AT lnRow+.25,lnCol+.5 ;
						WINDOW (lcMWindow)
			ENDIF
			DOEVENTS
		ENDIF
		DO CASE
			CASE lnScaleMode=-1
				toForm.ResetToDefault("ScaleMode")
			CASE lnScaleMode=0
				toForm.ScaleMode=0
		ENDCASE
		IF llBuilder
			DOEVENTS
			DO (_builder) WITH (oNewObject)
		EndIf
		
		RETURN oNewObject
		
	ENDPROC

	PROCEDURE Init
		Lparameters oUtils, oFoxRef, lcType
		Local i
		Local nCnt
		Local nOffset
		Local cProjectPath
		Local lFound
		Local cFileType
		Local lFirstSearch
		Local cStartDir
		Local oSearch
		
		With This
		
			.cSearchType = lcType
			.AlignContainers(lcType) && must do this before default
		
			.MinHeight = .Height
			.MinWidth = .Width
		
			.cType = lcType
			If Inlist (lcType, 'Class', 'Form')
				.Caption = ccLOC_Cap_Search_Caption + ' ' + lcType
			Else
				.Caption = ccLOC_Cap_Search_Caption + ' File'
			Endif
		
			.oUtils = oUtils
			.oFoxRef = oFoxRef
		
			.cboFolder 			= .cntSearch.cboFolder
			.cboLookFor 		= .cntSearch.cboLookFor
			.cboScope 			= .cntSearch.cboScope
			.chkSubFolders 		= .cntSearch.chkSubFolders
			.chkProjectHomeDir 	= .cntSearch.chkProjectHomeDir
		
			.txtClassLookFor 	= .cntClass.txtClassLookFor
			.cboBaseClass 		= .cntClass.cboBaseClass
		
			.chkSubFolders.Value     = .oFoxRef.SubFolders
			.chkProjectHomeDir.Value = .oFoxRef.ProjectHomeDir
		
			.cboLookFor.DisplayValue 		= .oFoxRef.Pattern
			.txtClassLookFor.Value 			= '' && .oFoxRef.ClassSearch
			.cboBaseClass.DisplayValue 		= .oFoxRef.SearchBaseClass
		
			.lClassExactMatch  		= .oFoxRef.ClassExactMatch
			.lFileNameExactMatch	= .oFoxRef.FileNameExactMatch
			.cHomeDir				= .oFoxRef.HomeDir
		
			DoDefault()
		
			* -- Load Look For MRU
			.UpdateLookFor ()
		
		
			* -- Load Folder MRU
			* .cboFolder.AddItem(SYS(5) + CURDIR())
			nCnt = Alen(.oFoxRef.aFolderMRU, 1)
			For i = 1 To Min(nCnt, 15)
			
				If !Empty(.oFoxRef.aFolderMRU[i])
					.cboFolder.AddItem(.oFoxRef.aFolderMRU[i])
				Endif
			Endfor
		
			.cFileTypes	= .oFoxRef.FileTypes
		
			.LoadScope(.oFoxRef.ProjectFile)
			
			If .oFoxRef.ProjectFile == PROJECT_GLOBAL Or Application.Projects.Count == 0 && OR .cboProject.ListCount == 0
				.cboScope.Value = SCOPE_FOLDER
				If .cboFolder.ListCount == 0
					m.cStartDir = Sys(5) + Curdir()
					.cboFolder.AddItem(Iif(Left(m.cStartDir, 1) == '\', '\', '') + m.cStartDir)
				Endif
			Else
				m.lFound = .F.
				cProjectPath = Addbs(Justpath(.oFoxRef.ProjectFile))
				For m.i = 1 To .cboFolder.ListCount
					If Upper(cProjectPath) == Upper(.cboFolder.List(m.i, 1))
						.cboFolder.ListIndex = m.i
						m.lFound = .T.
						Exit
					Endif
				Endfor
				If !m.lFound
					.cboFolder.AddItem(Iif(Left(m.cProjectPath, 1) == '\', '\', '') + cProjectPath)
				Endif
			Endif
		
			*** JRN 2010-03-26 : Get previous results
			This.RefreshResults ()
		
			.UpdateScope()
		
			.BindControls = .T.
			.SaveDragInfo()
			.Refresh()
		
		Endwith
		
	ENDPROC

	PROCEDURE loadscope
		* Abstract:
		*   Load up list of available scopes, including open Projects.
		*
		* Parameters:
		*	[cGotoProjName]
		#Include "foxpro.h"
		#Include "PEME_foxref.h"
		
		Lparameters cGotoProjName
		
		Local lnRow, loProjects
		Local cFindScope, cProcNameX, cProjName, nGotoIndex
		
		With This.cntSearch.cboScope
			Do Case
				Case Not Empty (cGotoProjName)
					cFindScope = SCOPE_PROJECT
				Case Not Empty(.ListIndex)
					cFindScope	  = This.cboScope.Value
					cGotoProjName = .List (.ListIndex, 3)
				Case _vfp.Projects.Count # 0
					cFindScope	  = SCOPE_PROJECT
					cGotoProjName = _vfp.Projects(1).Name
				Otherwise
					cFindScope	  = ''
					cGotoProjName = ''
			Endcase
		
			m.cGotoProjName = Lower (m.cGotoProjName)
		
			.Clear()
		
			.AddItem (SCOPE_FOLDER_LOC)
			.AddListItem (SCOPE_FOLDER, .NewItemId, 2)
			.AddListItem ('', .NewItemId, 3)
			m.nGotoIndex = .NewIndex
		
			.AddItem ('\-')
			*** JRN 2010-08-21 : Added in MRU Projects from VFP's list
			If 0 # _vfp.Projects.Count
				This.AddMRUFile(_vfp.Projects(1).Name)
			Endif
		
			loProjects = This.GetMRUList ('PJX')
			For lnRow = 1 To Min(loProjects.Count, 15)
				cProjName	 = loProjects.Item (lnRow)
				m.cProcNameX = IIf (Left (m.cProjName, 1) == '\', '\', '') + m.cProjName
				.AddItem (Strtran ('Project ' + Thisform.GetDisplayRelativePath (Lower (cProjName)), '.PJX', '', 1, 1, 1))
				.AddListItem (SCOPE_PROJECT, .NewItemId, 2)
				.AddListItem (m.cProcNameX, .NewItemId, 3)
				If Lower(m.cProjName) == Lower(m.cGotoProjName) And m.cFindScope == SCOPE_PROJECT
					m.nGotoIndex = .NewIndex
				Endif
			Endfor
		
			.ListIndex = m.nGotoIndex
		Endwith
		
	ENDPROC

	PROCEDURE loadsettings
		This.cboScope.Value = .cScopeValue 
		This.LoadColumnInfo (This.grdResults)
		DoDefault()
		
	ENDPROC

	PROCEDURE refreshresults
		*** JRN 2010-03-26 : get our results
		If Used ("crsr_Results")
		
			This.SelectResults("crsr_Temp")
		
			*** JRN 2010-03-26 : Stuff 'em back into our grid's recordsource
			ThisForm.cmdSearch.SetFocus()
			Doevents
			
			Select crsr_Results
			Delete Tag All
			Set Filter To
			Zap
			Append From (Dbf("crsr_Temp"))
			Goto Top
		
		Else
		
			This.SelectResults("crsr_Results")
		
		Endif
		
		This.grdResults.Refresh()
		
		
	ENDPROC

	PROCEDURE runfile
		Local lcExt, lcFileName, llEnabled
		
		If  Used ('crsr_Results') And Between (Recno ('crsr_Results'), 1, Reccount ('crsr_Results'))
			lcFileName = FullName
			lcExt	   = Upper(Justext(lcFileName))
			Do Case
				Case lcExt == 'PRG'
					Do (lcFileName)
				Case  lcExt == 'SCX'
					Do Form (lcFileName)
				Otherwise
			Endcase
		Endif
		
	ENDPROC

	PROCEDURE savedraginfo
		
		Local lcFile, lcPath
		With This
			If .cType = 'Class'														    ;
					and Used ('crsr_Results')										    ;
					and Between (Recno ('crsr_Results'), 1, Reccount ('crsr_Results'))
				.cClass		= Alltrim (crsr_Results.Class)
				.cBaseClass	= Alltrim (crsr_Results.BaseClass)
				.cFileName	= Addbs (Alltrim (crsr_Results.Folder)) + Alltrim (crsr_Results.FileName)
		
				.cmdClassIcon.ToolTipText = Strtran (ccLOC_Cap_Search_Tip_Drag, '<insert>', .cClass)
		
				lcPath = Thisform.cApplicationPath + "images\"
				lcFile = lcPath + Evl (.cBaseClass, '') + ".bmp"
				If File (lcFile)
					.imgClassIcon.Picture = lcFile
				Else
					* ?lcFile
				Endif
			Else
				.cClass		= ''
				.cBaseClass	= ''
				.cFileName	= ''
				.cmdClassIcon.ToolTipText = ''
			Endif
		
			.cmdClassIcon.Refresh()
			.cmdRun.Refresh()
		
		Endwith
		
		
		
	ENDPROC

	PROCEDURE savesettings
		.cScopeValue = This.cboScope.Value
		.oDefaults.cScopeValue = ''
		
		This.SaveColumnInfo(This.grdResults)
		
		DoDefault()
		
	ENDPROC

	PROCEDURE search
		* Abstract:
		*   Perform the reference search based upon the options
		*	specified on the dialog.
		*
		* Parameters:
		*	none
		#include "foxpro.h"
		#include "PEME_foxref.h"
		
		Local cPattern, cScope, lSuccess, lUpdateGrid, nMouse
		
		cPattern = This.cboLookFor.DisplayValue
		cScope   = This.cboScope.Value
		
		If cScope == SCOPE_FOLDER And !Directory(This.cboFolder.DisplayValue)
			This.cboFolder.SetFocus()
			Messagebox(FOLDERNOEXIST_LOC, MB_ICONEXCLAMATION, This.Caption)
			Return .F.
		Endif
		
		nMouse = Thisform.MousePointer
		Thisform.MousePointer = MOUSE_HOURGLASS
		
		lSuccess = .F.
		With This.oFoxRef
			.Pattern        	= Alltrim (cPattern)
			.SubFolders      	= This.chkSubFolders.Value
			.ProjectHomeDir  	= This.chkProjectHomeDir.Value
			.FileTypes      	= Iif(Len(This.cFileTypes) > 1, This.cFileTypes, '')
			.ProjectFile    	= ''
			.FileDirectory  	= ''
			.SearchType			= This.cSearchType
			.FileNameExactMatch = This.lFileNameExactMatch
			.ClassSearch 		= This.txtClassLookFor.Value
			.ClassExactMatch 	= This.lClassExactMatch
			.SearchBaseClass 	= This.cboBaseClass.DisplayValue	
			.HomeDir			= This.cHomeDir
		
			Do Case
		
				Case cScope == SCOPE_PROJECT And This.cboLookFor.ListIndex # 0 And This.cSearchType # 'Class'
					.ProjectFile = This.cboScope.List(This.cboScope.ListIndex, 3)
					This.EditSourceFile (This.cboLookFor.List(This.cboLookFor.ListIndex, 2), '')
					lAllDone = .T.
		
				Case cScope == SCOPE_PROJECT
					.ProjectFile = This.cboScope.List(This.cboScope.ListIndex, 3)
					lSuccess = .Search(cPattern)
					lAllDone = .F.
		
				Case cScope == SCOPE_FOLDER
					.ProjectFile   = PROJECT_GLOBAL
					.FileDirectory = Addbs(This.cboFolder.DisplayValue)
					ThisForm.cHomeDir = .FileDirectory
					lSuccess = .Search(cPattern)
					lAllDone = .F.
		
			Endcase
		
			.SavePrefs()
		Endwith
		
		Thisform.MousePointer = nMouse
		Thisform.SaveDragInfo()
		
		If lAllDone
			Return .T.
		Else
			This.RefreshResults ()
			This.Refresh()
		
			Return .F.
		Endif
		
	ENDPROC

	PROCEDURE selectresults
		Lparameters lcCursorName
		
		Local laSortFields[1], lcExtraFields, lcSortField, lcSortFields, nLines
		
		*** JRN 2010-03-26 : determine the fields to sort on
		lcSortFields = ''
		lcExtraFields = ''
		nLines = Alines (laSortFields, Upper (This.cSortOrder), .T., '|') 
		
		For Each lcSortField In laSortFields
			Do Case
				Case lcSortField == 'COLCLASS'
					lcSortFields = lcSortFields + ", sortclass" 
					lcExtraFields = lcExtraFields + ", Upper (class) as sortclass"
				Case lcSortField == 'COLFILENAME'
					lcSortFields = lcSortFields + ", sortfname"
					lcExtraFields = lcExtraFields + ", Upper (FileName) as sortfname"
				Case lcSortField == 'COLFOLDER'
					lcSortFields = lcSortFields + ", sortfolder"
					lcExtraFields = lcExtraFields + ", Upper (Folder) as sortfolder"
				Case lcSortField == 'COLPARENTCLASS'
					lcSortFields = lcSortFields + ", sortparent"
					lcExtraFields = lcExtraFields + ", Upper (Parent) as sortparent"
				Case lcSortField == 'COLCLASSLOC'
					lcSortFields = lcSortFields + ", sortparloc"
					lcExtraFields = lcExtraFields + ", Upper (ClassLoc) as sortparloc"
				Case lcSortField == 'COLBASECLASS'
					lcSortFields = lcSortFields + ", sortbase"
					lcExtraFields = lcExtraFields + ", Upper (BaseClass) as sortbase"
				Case lcSortField == 'COLTIMESTAMP'
					lcSortFields = lcSortFields + ", timestamp desc"
			Endcase
		Endfor
		
		Use (This.oFoxRef.cResultsTable) In 0 Alias Results
		
		lcSortFields = Substr (lcSortFields, 2)
		Select * 									;
			&lcExtraFields							;
			From Results 							;
			where SearchType = This.cSearchType		;
			Order By &lcSortFields					;
			into Cursor (lcCursorName) Readwrite
		
		Use In Results
		
	ENDPROC

	PROCEDURE setallfiletypes
		Lparameters llFlag
		
		With This.cntTypes 
			For lnI = 1 To .ControlCount
				loControl = .Controls(lnI)
				If 'checkbox' = Lower(loControl.BaseClass)
					Thisform.AddFiletype(loControl.Caption, llFlag, .F.)
				Endif
			EndFor
			This.UpdateLookFor()
			.Refresh()
		Endwith
		
	ENDPROC

	PROCEDURE setdefaults
		.cGridSortOrder = Thisform.cSortOrder
		.lKeepOpen = .T.
		
	ENDPROC

	PROCEDURE setsortorder
		Lparameters lcColumnName
		
		lcColumnName = Upper (lcColumnName)
		With This
			.cSortOrder = Strtran (.cSortOrder, '|' + lcColumnName + '|', '|')
			.cSortOrder = '|' + lcColumnName + .cSortOrder
			*** JRN 2010-03-26 : keep the first three levels only
			lnPos = At('|', .cSortOrder, 4)
			If lnPos > 0
				.cSortOrder = Left (.cSortOrder, lnPos)
			EndIf
			
			ThisForm.oMySettings.cGridSortOrder = .cSortOrder
			.RefreshResults()
		Endwith
		
	ENDPROC

	PROCEDURE updatelookfor
		* -- Load Look For MRU
		Local aFileList[1], cExt, cFile, cFilename, cFileTypes, cHomeDir, cScope, lcFileDisplayName, lcFileName
		Local lcFName, lcPath, lcProjectFile, lcQuote, lnFileCount, lnI, nCnt, oFileRef, oProjectRef
		Local llFound
		
		With This
		
			.cboLookFor.Clear()
			cScope = .cboScope.Value
		
			If cScope == SCOPE_PROJECT
		
				Do Case
					Case This.cSearchType = 'Class'
						cFileTypes = '|VCX|'
					Case This.cSearchType = 'Form'
						cFileTypes = '|SCX|'
					Otherwise
						cFileTypes = This.cFileTypes
						If 1 >= Len (cFileTypes)
							cFileTypes = '|'
						Endif
				Endcase
		
				lnFileCount = 0
				lcProjectFile = Upper(.cboScope.List(This.cboScope.ListIndex, 3))
		
				*!* * Removed 7/6/2012 / JRN
				*!* *** JRN 2010-03-29 : try to open the project file if it is not already open
				*!* For Each oProjectRef In Application.Projects
				*!* 	llFound = .F.
				*!* 	If Upper(oProjectRef.Name) == lcProjectFile
				*!* 		llFound = .T.
				*!* 	Endif
				*!* Endfor
		
				*!* If Not llFound
				*!* 	lOpened = .T.
				*!* 	* open the project
				*!* 	Try
				*!* 		Modify Project (lcProjectFile) Nowait
		
				*!* 	Catch To oErr
				*!* 		Messagebox(oErr.Message, MB_ICONEXCLAMATION, APPNAME_LOC)
				*!* 		lOpened = .F.
				*!* 	Endtry
				*!* Endif
		
				****************************************************************
				For Each oProjectRef In Application.Projects
					If Upper(oProjectRef.Name) == lcProjectFile
						cHomeDir = Addbs(Upper(oProjectRef.HomeDir))
						.cHomeDir = cHomeDir
		
						* now process each file in the project that matches our filetypes
						For Each oFileRef In oProjectRef.Files
							If (!.chkProjectHomeDir.Value Or Addbs(Upper(Justpath(oFileRef.Name))) = cHomeDir)
								cFilename = Upper(oFileRef.Name)
								cFile = Juststem (cFilename)
								cExt  = Justext (cFilename)
								If (1 = Len (cFileTypes) Or ('|' + cExt + '|') $ cFileTypes)
									lnFileCount = lnFileCount + 1
									Dimension aFileList (lnFileCount, 2)
									aFileList (lnFileCount, 1) = Lower (cFilename)
									aFileList (lnFileCount, 2) = Lower (Justfname (cFilename))
								Endif
							Endif
						Endfor
		
						If lnFileCount > 0
		
							Asort (aFileList, 2, -1, 0)
		
							With .cboLookFor
								For lnI = 1 To lnFileCount
									lcFileName = Lower(aFileList(lnI,1))
									lcFileDisplayName = Thisform.GetRelativePath (lcFileName, cHomeDir)
									lcFName = Justfname (lcFileDisplayName)
									lcPath = Justpath (lcFileDisplayName)
		
									If Inlist (This.cSearchType, 'Class', 'Form')
										lcFileDisplayName = Juststem (lcFName)
									Else
										lcFileDisplayName = lcFName
										If Not Empty(lcPath)
											lcQuote = Iif (" " $ lcFName, ['], '')
											lcFileDisplayName = lcQuote + lcFileDisplayName + lcQuote + "  from  " + lcPath
										Endif
									Endif
		
									.AddItem (lcFileDisplayName)
									.AddListItem (lcFileName, .NewItemId, 2)
								Endfor
							Endwith
		
						Endif
		
					Endif
				Endfor
		
			Else
		
				.cboLookFor.Clear()
				*!*	nCnt = Alen(.oFoxRef.aLookForMRU, 1)
				*!*	For lnI = 1 To nCnt
				*!*		If .oFoxRef.aLookForMRU[lnI] # '?'
				*!*			.cboLookFor.AddItem(Alltrim(.oFoxRef.aLookForMRU[lnI]))
				*!*		Endif
				*!*	Endfor
			Endif
		
		Endwith
		
		
	ENDPROC

	PROCEDURE updatescope
		* Abstract:
		*   Called when the Scope combo changes
		*
		* Parameters:
		*	None
		#include "foxpro.h"
		#include "PEME_foxref.h"
		Local cScope
		
		With This.cntSearch
		
			cScope = This.cboScope.Value
		
			.cboFolder.Enabled         = (cScope == SCOPE_FOLDER)
			.cmdGetFolder.Visible      = (cScope == SCOPE_FOLDER)
			.imgParent.Visible         = (cScope == SCOPE_FOLDER)
		
			*!*	.cboFolder.Visible    = (cScope == SCOPE_FOLDER)
			*!*	.cmdGetFolder.Visible = (cScope == SCOPE_FOLDER)
			*!*	.lblLookIn.Visible    = (cScope == SCOPE_FOLDER)
			If cScope == SCOPE_PROJECT
				.cboFolder.DisplayValue = ''
			Endif
		
			.chkSubFolders.Visible     = (cScope == SCOPE_FOLDER)
			.chkProjectHomeDir.Visible = (cScope == SCOPE_PROJECT)
			.cmdCurrent.Visible        = (cScope == SCOPE_FOLDER)
		
			If .cboFolder.Enabled And Empty(.cboFolder.DisplayValue)
				.cboFolder.ListIndex = 1
			Endif
		
		EndWith
		
		This.UpdateLookFor()
		
	ENDPROC

	PROCEDURE cmdClassIcon.DragDrop
		LPARAMETERS oSource, nXCoord, nYCoord
		
		RETURN thisform.DragDrop(oSource,nXCoord,nYCoord)
		
	ENDPROC

	PROCEDURE cmdClassIcon.DragOver
		LPARAMETERS oSource, nXCoord, nYCoord, nState
		
		RETURN thisform.DragOver(oSource,nXCoord,nYCoord,nState)
		
	ENDPROC

	PROCEDURE cmdClassIcon.MouseDown
		*** JRN 2010-04-18 : object copied from Class Browser
		
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL llDesignModeCheck,lcBaseClass,oForm,lcFileName,lcProjectFile
		LOCAL lcMouseWindow,llRunModeCheck,lnSeconds,lnMRow,lnMCol,oForm
		LOCAL oObject,llDesignMode,llError,lnCount,lcStatusBarText,lnXCoord,lnYCoord, oNewObject
		LOCAL laSelObj[1],laMouseObj[1]
		
		lnMRow=MROW()
		lnMCol=MCOL()
		lnSeconds=SECONDS()
		thisform.lDragDrop=.F.
		thisform.nMouseButton=IIF(TYPE("nButton")=="N",nButton,0)
		thisform.nShift=nShift
		thisform.lFormAddObject=.F.
		IF thisform.lBrowser AND NOT thisform.lVCXSCXMode
			RETURN
		ENDIF
		IF nButton=2
			DO WHILE ABS(SECONDS()-lnSeconds)<_dblclick
				IF NOT MDOWN()
					RETURN
				ENDIF
				IF ABS(MROW(thisform.Name,3)-lnMRow)>=this.Height OR ;
						ABS(MCOL(thisform.Name,3)-lnMCol)>=this.Height
					EXIT
				ENDIF
			ENDDO
		ENDIF
		llDesignModeCheck=.T.
		llRunModeCheck=.F.
		*** JRN 2010-04-18 : commented out
		*!*	lcStatusBarText=this.StatusBarText
		*!*	this.StatusBarText=""
		lcBaseClass=thisform.cBaseClass
		*!*	this.DragIcon="c:\dev\browser\control.cur"
		*!*	thisform.cDragIcon=this.DragIcon
		*!*	IF thisform.lBrowser AND (thisform.lSCXMode OR thisform.lFileMode)
		*!*		llDesignModeCheck=.F.
		*!*		this.DragIcon="c:\dev\browser\nodrop.cur"
		*!*	ENDIF
		*!*	llError=thisform.lError
		*!*	thisform.lError=.F.
		thisform.nAtPos=-.1
		
		*** JRN 2010-04-18 : Finally!! This.Drag below!
		IF nButton>=0
			IF NOT MDOWN()
				thisform.lDragDrop=.F.
				RETURN
			ENDIF
			this.Drag
		ENDIF
		****************************************************************
		****************************************************************
		oObject=.NULL.
		lnXCoord=0
		lnYCoord=0
		oForm=.NULL.
		lcMWindow=LOWER(ALLTRIM(MWINDOW()))
		
		If Amouseobj (laMouseObj) >= 4 And Vartype (laMouseObj[2]) == 'O'
			oObject = laMouseObj[2]
			lnXCoord   = laMouseObj[3]
			lnYCoord   = laMouseObj[4]
			laMouseObj = .Null.
			If Amouseobj (laMouseObj, 1) >= 4
				oForm = laMouseObj[2]
			Endif
		
			* Inserted 07/20/2011 / JRN
			If Type ('_oPEMEditor.oUtils.oPEMEditor.oObject') = 'O'
				Local loObject
				loObject = oObject
				Do While .T.
					Do Case
						Case loObject = _oPEMEditor.oUtils.oPEMEditor
							oObject  = _oPEMEditor.oUtils.oPEMEditor.oObject
							lnXCoord = 0
							lnYCoord = 0
							oForm    = _oPEMEditor.oUtils.oPEMEditor.oTopOfForm
							Exit
						Case Type ('loobject.Parent') = 'O'
							loObject = loObject.Parent
						Otherwise
							Exit
					Endcase
				Enddo While .T.
			Endif Type ('_oPEMEditor.oUtils.oPEMEditor.oObject') = 'O'
		
		Endif 
			
		*** JRN 2010-04-18 : following lines not needed
		*!*	this.StatusBarText=lcStatusBarText
		*!*	IF NOT thisform.lBrowser AND (ISNULL(thisform.oItem) OR ISNULL(thisform.oItem.oAction))
		*!*		RETURN
		*!*	ENDIF
		IF TYPE("oObject")#"O" OR ISNULL(oObject)
			oObject=.NULL.
		ENDIF
		IF ISNULL(oObject)
			*!*	lnCount=LEN(M_PROJECT_MANAGER_LOC+" - ")
			*!*	IF LOWER(LEFT(lcMWindow,lnCount))==LOWER(M_PROJECT_MANAGER_LOC+" - ")
			*!*		IF thisform.lBrowser
			*!*			lcFileName=thisform.cFileName
			*!*		ELSE
			*!*			lcFileName=thisform.oItem.cFileName
			*!*		ENDIF
			*!*		IF EMPTY(lcFileName) OR NOT FILE(lcFileName)
			*!*			RETURN
			*!*		ENDIF
			*!*		lcProjectFile=LOWER(FORCEEXT(ALLTRIM(SUBSTR(lcMWindow,lnCount+1)),"pjx"))
			*!*		FOR lnCount = 1 TO _vfp.Projects.Count
			*!*			IF LOWER(JUSTFNAME(_vfp.Projects[lnCount].Name))==lcProjectFile
			*!*				_vfp.Projects[lnCount].Files.Add(lcFileName)
			*!*				EXIT
			*!*			ENDIF
			*!*		ENDFOR
			*!*		RETURN
			*!*	ENDIF
			RETURN
		ELSE
			DO WHILE .T.
				IF PEMSTATUS(oObject,"AddObject",5) OR TYPE("oObject.Parent")#"O" OR ;
						TYPE("oObject.Parent.BaseClass")#"C"
					EXIT
				ENDIF
				oObject=oObject.Parent
			ENDDO
		ENDIF
		IF NOT ISNULL(oForm) AND oForm=thisform
			RETURN
		ENDIF
		*** JRN 2010-04-18 : not needed
		*!*	IF NOT thisform.lBrowser
		*!*		thisform.oItem.oAction.DragDrop2(oObject,lnXCoord,lnYCoord)
		*!*		RETURN
		*!*	ENDIF
		*!*	IF thisform.lDragDrop OR ISNULL(oObject)
		*!*		thisform.lDragDrop=.F.
		*!*		thisform.lFormAddObject=.F.
		*!*		IF NOT lcMWindow=="command"
		*!*			RETURN
		*!*		ENDIF
		*!*	ENDIF
		*!*	IF EMPTY(lcMWindow)
		*!*		IF MROW(thisform.Name)>0 AND MCOL(thisform.Name)>0
		*!*			lcMWindow=thisform.Name
		*!*		ELSE
		*!*			FOR lnCount = _screen.FormCount TO 1 STEP -1
		*!*				oForm=_screen.Forms[lnCount]
		*!*				IF NOT oForm.Name==thisform.Name AND ;
		*!*						oForm.Class==thisform.Class AND ;
		*!*						LOWER(LEFT(oForm.Name,12))=="classbrowser" AND ;
		*!*						TYPE("oForm.cBrowserTable")#"U" AND ;
		*!*						MROW(oForm.Name)>0 AND MCOL(oForm.Name)>0
		*!*					lcMWindow=oForm.Name
		*!*					EXIT
		*!*				ENDIF
		*!*			ENDFOR
		*!*		ENDIF
		*!*	ENDIF
		*!*	this.DragIcon=thisform.cDragIcon
		*!*	IF thisform.lError OR thisform.nAtPos=-.2 OR NOT llDesignModeCheck
		*!*		thisform.cDragIcon=""
		*!*		thisform.lFormAddObject=.F.
		*!*		thisform.nAtPos=0
		*!*		IF llError
		*!*			thisform.lError=llError
		*!*		ENDIF
		*!*		RETURN
		*!*	ENDIF
		*!*	thisform.lError=llError
		*!*	thisform.cDragIcon=""
		*!*	thisform.nAtPos=0
		*!*	IF lcMWindow==LOWER(thisform.Name)
		*!*		thisform.lFormAddObject=.F.
		*!*		RETURN
		*!*	ENDIF
		llDesignMode=.F.
		DO CASE
			CASE lcMWindow=="command"
				oObject="command"
			CASE EMPTY(lcMWindow) AND oObject=_screen
				oObject="_screen"
			CASE TYPE("oObject.lFormAddObject")#"L" OR NOT oObject.lFormAddObject
				llDesignMode=.T.
				DIMENSION laSelObj[1]
				IF ASELOBJ(laSelObj,1)=0 OR (TYPE("oObject.BaseClass")=="C" AND ;
						(LOWER(oObject.BaseClass)=="container" OR ;
						LOWER(oObject.BaseClass)=="column" OR ;
						LOWER(oObject.BaseClass)=="page"))
					llRunModeCheck=.T.
				ELSE
					oObject=laSelObj[1]
					RELEASE laSelObj
					IF LOWER(oObject.BaseClass)=="form"
						IF TYPE("oObject.Caption")#"C" OR NOT lcMWindow==LOWER(ALLTRIM(oObject.Caption))
							llRunModeCheck=.T.
							thisform.lFormAddObject=.F.
						ENDIF
					ELSE
						IF NOT lcMWindow==LOWER(ALLTRIM(oObject.Name))
							llRunModeCheck=.T.
							thisform.lFormAddObject=.F.
						ENDIF
					ENDIF
					IF NOT llRunModeCheck AND (lcBaseClass=="form" OR lcBaseClass=="toolbar")
						oObject=oObject.parent
					ENDIF
				ENDIF
		ENDCASE
		IF llRunModeCheck AND NOT thisform.lFormAddObject
			llDesignMode=.F.
		ENDIF
		thisform.lFormAddObject=.F.
		
		*** JRN 2010-04-18 : modified slightly
		*RETURN thisform.FormAddObject(oObject,lnXCoord,lnYCoord,.T.,llDesignMode, ;
				(nShift=1),(NOT thisform.lDragDropErrors AND nShift#2),(nButton=2),oForm)
		oNewObject = thisform.FormAddObject(oObject,lnXCoord,lnYCoord,.T.,llDesignMode, ;
				(nShift=1),(nShift#2),(nButton=2),oForm)
		
		*** JRN 2010-04-30 : Update PEM Editor
		If Type('_oPEMEditor.oUtils') = 'O' and Vartype(_oPEMEditor.oUtils) = 'O'
			_oPEMEditor.oUtils.SetCurrentSelectedObject (oNewObject)
		EndIf 
		
		Return oNewObject
	ENDPROC

	PROCEDURE cmdClassIcon.Refresh
		Local llEnabled
		llEnabled = Not Empty (Thisform.cClass)
		
		This.Visible = llEnabled
		This.Enabled = llEnabled
		Thisform.imgClassIcon.Visible = llEnabled
		Thisform.imgClassIcon.Enabled = llEnabled
		
	ENDPROC

	PROCEDURE cmdClassIcon.When
		*** JRN 2010-04-18 : removed second phrase
		IF NOT MDOWN() && OR (thisform.lBrowser AND NOT thisform.lVCXSCXMode)
			RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE cmdRun.Click
		ThisForm.RunFile()
		
	ENDPROC

	PROCEDURE cmdRun.Refresh
		Local lcExt, lcFileName, llEnabled
		
		llEnabled = .F.
		If  Used ('crsr_Results') And Between (Recno ('crsr_Results'), 1, Reccount ('crsr_Results'))
			lcFileName = FullName
			lcExt	   = Upper(Justext(lcFileName))
			Do Case
				Case lcExt == 'PRG'
					llEnabled = .T.
				Case  lcExt == 'SCX'
					llEnabled = .T.
			Endcase
		Endif
		
		This.Visible = llEnabled
		This.Enabled = llEnabled
		
		
	ENDPROC

	PROCEDURE cmdSearch.Click
		IF THISFORM.Search()
			THISFORM.Release()
		Else
			This.Parent.cntSearch.cboLookFor.SetFocus()
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdSearch.Init
		This.Caption = ccLOC_Cap_Search_Search
		DoDefault()
	ENDPROC

	PROCEDURE cmdSelect.Click
		If Thisform.EditSourceFile (FullName, Class, '', StartRange, EndRange)
			If Not Thisform.oMySettings.lKeepOpen
				Thisform.Release()
			Endif
		Endif
		
	ENDPROC

	PROCEDURE cmdSelect.Refresh
		Local llEnabled
		If Used ('crsr_Results') And Between (Recno ('crsr_Results'), 1, Reccount ('crsr_Results')) 
			llEnabled = .T.
		Else
			llEnabled = .F.
		Endif
		
		This.Visible = llEnabled
		This.Enabled = llEnabled
		
	ENDPROC

	PROCEDURE cntClass.cboBaseClass.Init
		Local laBaseClasses[1], lcBaseClass, lcBaseClasses, lnCount
		With This
			.AddItem('<All>')
		
			TEXT TO lcBaseClasses 	 NOSHOW TEXTMERGE
			CheckBox
			Collection
			Column
			ComboBox
			CommandButton
			CommandGroup
			Container
			Control
			Cursor
			CursorAdapter
			Custom
			DataEnvironment
			EditBox
			Exception
			Form
			FormSet
			Grid
			Header
			Hyperlink
			Image
			Label
			Line
			ListBox
			OLE Bound
			OLE Container
			OptionButton
			OptionGroup
			Page
			PageFrame
			ProjectHook
			Relation
			ReportListener
			Separator
			Session Object
			Shape
			Spinner
			TextBox
			Timer
			ToolBar
			XMLAdapter
			XMLField
			XMLTable
			ENDTEXT
		
			lnCount = Alines (laBaseClasses, chrtran (lcBaseClasses, Chr(9), ' '), .T.)
			For Each lcBaseClass In laBaseClasses
				If Not Empty (lcBaseClass)
					.AddItem(Alltrim(lcBaseClass))
				Endif
			Endfor
		
		Endwith
		
		DoDefault()
	ENDPROC

	PROCEDURE cntClass.chkExactMatch1.Init
		This.Caption = ccLOC_Cap_Search_ExactMatch1
		DoDefault()
	ENDPROC

	PROCEDURE cntClass.cmdMarkAll.Click
		With This.Parent.cboBaseClass
			.Value = '<All>'
			.Refresh()
		EndWith 
		
		This.Parent.txtCLASSLOOKFOR.SetFocus()
	ENDPROC

	PROCEDURE cntClass.lblBaseClass.Init
		This.Caption = ccLOC_Cap_Search_BaseClass
	ENDPROC

	PROCEDURE cntClass.lblClass.Init
		This.Caption = ccLOC_Cap_Search_Class
	ENDPROC

	PROCEDURE cntClass.txtClassLookFor.Init
		This.ToolTipText = ccLOC_Tip_Search_Class
		DoDefault()
		
	ENDPROC

	PROCEDURE cntSearch.cboLookFor.Init
		This.ToolTipText = ccLOC_Tip_Search_FileName
		DoDefault()
		
	ENDPROC

	PROCEDURE cntSearch.cboScope.GotFocus
		DODEFAULT()
		
		ThisForm.lRequeryScope = .F.
		ThisForm.LoadScope()
		ThisForm.UpdateScope()
		
	ENDPROC

	PROCEDURE cntSearch.cboScope.InteractiveChange
		ThisForm.UpdateScope()
	ENDPROC

	PROCEDURE cntSearch.cboScope.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF ThisForm.lRequeryScope
			ThisForm.lRequeryScope = .F.
			ThisForm.LoadScope()
			ThisForm.UpdateScope()
		ENDIF
		
	ENDPROC

	PROCEDURE cntSearch.chkExactMatch2.Init
		This.Caption = ccLOC_Cap_Search_ExactMatch2
		DoDefault()
	ENDPROC

	PROCEDURE cntSearch.chkProjectHomeDir.Init
		This.Caption = ccLOC_Cap_Search_LimitSearch
	ENDPROC

	PROCEDURE cntSearch.chkProjectHomeDir.InteractiveChange
		ThisForm.UpdateScope()
	ENDPROC

	PROCEDURE cntSearch.chkSubFolders.Init
		This.Caption = ccLOC_Cap_Search_SubFolders
	ENDPROC

	PROCEDURE cntSearch.cmdCurrent.Click
		With This.Parent.cboFolder 
			.DisplayValue = Sys(5) + Curdir()
		EndWith 
		
		
	ENDPROC

	PROCEDURE cntSearch.cmdCurrent.Init
		This.Caption = ccLOC_Cap_Search_CurrentFolder
		DoDefault()
	ENDPROC

	PROCEDURE cntSearch.cmdGetFolder.Click
		Local cFolder
		
		cFolder = Getdir(Thisform.cboFolder.DisplayValue, '', '', 64 + 1)
		If !Empty(cFolder)
			With This.Parent.cboFolder
				.DisplayValue = cFolder
			Endwith
		EndIf
		
		 
	ENDPROC

	PROCEDURE cntSearch.imgParent.Click
		Local lcValue
		With This.Parent.cboFolder
			lcValue = .DisplayValue
			If '\' = Right(lcValue, 1)
				lcValue = Justpath(lcValue)
			Endif
			.DisplayValue = Addbs(Justpath(lcValue))
		Endwith
		
	ENDPROC

	PROCEDURE cntSearch.imgParent.Init
		DoDefault() 
		
		This.ToolTipText = ccLOC_Tip_Parent
		
	ENDPROC

	PROCEDURE cntSearch.lblLookFor.Init
		This.Caption = ccLOC_Cap_Search_FileName
	ENDPROC

	PROCEDURE cntSearch.lblLookIn.Init
		This.Caption = ccLOC_Cap_Search_LookIn
	ENDPROC

	PROCEDURE cntSearch.lblScope.Init
		This.Caption = ccLOC_Cap_Search_Scope
	ENDPROC

	PROCEDURE cntTypes.cmdClearAll.Click
		With Thisform
			.SetAllFileTypes(.F.)
		Endwith
		
	ENDPROC

	PROCEDURE cntTypes.cmdClearAll.Init
		This.Caption = ccLOC_Cap_Search_ClearAll
	ENDPROC

	PROCEDURE cntTypes.cmdMarkAll.Click
		With Thisform
			.SetAllFileTypes(.T.)
		Endwith
		
	ENDPROC

	PROCEDURE cntTypes.cmdMarkAll.Init
		This.Caption = ccLOC_Cap_Search_MarkAll
	ENDPROC

	PROCEDURE cntTypes.lblFileTypes.Init
		This.Caption = ccLOC_Cap_Search_FileTypes
	ENDPROC

	PROCEDURE grdResults.AfterRowColChange
		LPARAMETERS nColIndex
		
		Thisform.SaveDragInfo()
	ENDPROC

	PROCEDURE grdResults.colBaseClass.Header1.Click
		Thisform.SetSortOrder(This.Parent.Name)
		
	ENDPROC

	PROCEDURE grdResults.colClass.Header1.Click
		Thisform.SetSortOrder(This.Parent.Name)
		
	ENDPROC

	PROCEDURE grdResults.colClassLoc.Header1.Click
		Thisform.SetSortOrder(This.Parent.Name)
		
	ENDPROC

	PROCEDURE grdResults.colFileName.Header1.Click
		Thisform.SetSortOrder(This.Parent.Name)
		
	ENDPROC

	PROCEDURE grdResults.colFolder.Header1.Click
		Thisform.SetSortOrder(This.Parent.Name)
		
	ENDPROC

	PROCEDURE grdResults.colParentClass.Header1.Click
		Thisform.SetSortOrder(This.Parent.Name)
		
	ENDPROC

	PROCEDURE grdResults.colTimeStamp.Header1.Click
		Thisform.SetSortOrder(This.Parent.Name)
		
	ENDPROC

	PROCEDURE grdResults.Init
		DoDefault()
		
		With this
			.AddProperty ('nCurrentRecno', 0)
			.AddProperty ('nSeconds', 0)
		EndWith 
	ENDPROC

	PROCEDURE grdResults.KeyPress
		Lparameters nKeyCode, nShiftAltCtrl
		
		If nKeyCode = 13 And nShiftAltCtrl = 0 And Not Eof()
			Thisform.EditSourceFile (FullName, Class, '', StartRange, EndRange)
			Thisform.Release()
		Endif
		
	ENDPROC

	PROCEDURE grdResults.MouseUp
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		#Define DoubleClickLimit 4 * _Dblclick
		
		*** JRN 2010-03-26 : fun and games testing for double click
		Local nRelCol_Out, nRelRow_Out, nView_Out, nWhere_Out, nXCoord_In, nYCoord_In
		
		Do Case
			Case nButton = 1
			
				nXCoord_In = Mcol (Wontop(), 3)
				nYCoord_In = Mrow (Wontop(), 3)
				Store 0 To nWhere_Out, nRelRow_Out, nRelCol_Out, nView_Out
				This.GridHitTest (nXCoord_In, nYCoord_In, @nWhere_Out, @nRelRow_Out, @nRelCol_Out)
			
				If nWhere_Out = 3 And Recno() # 0 And Not Eof()
					If Recno() = This.nCurrentRecno And Seconds() <= DoubleClickLimit + This.nSeconds
						If Thisform.EditSourceFile (FullName, Class, '', StartRange, EndRange)
							If Not Thisform.oMySettings.lKeepOpen
								Thisform.Release()
							Endif
						Endif
					Else
						This.nCurrentRecno = Recno()
						This.nSeconds	   = Seconds()
					Endif
				Endif
			
			Case nButton = 2
		
				Thisform.RunFile()	
				This.nCurrentRecno = 0
				This.nSeconds	   = 0
		
			Otherwise 
			
				This.nCurrentRecno = 0
				This.nSeconds	   = 0
				
		Endcase
		
		
	ENDPROC

	PROCEDURE grdResults.Refresh
		Local loColumn As Object
		Local lnI
		
		With This
			* which ones are visible?
			For lnI = 1 To .ColumnCount
				loColumn = .Columns(lnI)
				With loColumn
					If Thisform.cSearchType # 'Class' And .lClassesOnly
						.Visible = .F.
					Endif
				Endwith
			Endfor
		
			Do Case
				Case Thisform.cSearchType = 'Class'
					.ColFileName.ControlSource = [JustFName (FileName)]
				Case Thisform.cSearchType = 'Form'
					.ColFileName.ControlSource = [JustStem (FileName)]
			Endcase
		
			.ColFolder.ControlSource = [JustPath (ThisForm.GetRelativePath (FullName, '] + Addbs (Thisform.cHomeDir) + ['))]
			.ColClassLoc.ControlSource = [IIF(Empty(ClassLoc), '', ThisForm.GetRelativePath (Trim(ClassLoc), '] + Addbs (Thisform.cHomeDir) + ['))]
		
		Endwith
		
		Thisform.SaveDragInfo()
	ENDPROC

	PROCEDURE imgClassIcon.DragDrop
		LPARAMETERS oSource, nXCoord, nYCoord
		
		RETURN thisform.DragDrop(oSource,nXCoord,nYCoord)
		
	ENDPROC

	PROCEDURE imgClassIcon.DragOver
		LPARAMETERS oSource, nXCoord, nYCoord, nState
		
		RETURN thisform.DragOver(oSource,nXCoord,nYCoord,nState)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmpasteproperties AS frmpeme_base OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="GridMembers" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPaste" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDeselect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="BASECHECKBOX1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: dosortgrid
		*m: getcurvalue
		*p: cmemberssortorder
		*p: lanynew
		*p: lnewallowed
		*p: lpasteit
		*p: ntop
	*</DefinedPropArrayMethod>

	AllowOutput = .T.
	capplicationpath = 
	Caption = "Paste Properties and Method Code"
	cfoxuserid = pasteproperties
	cfoxusername = PASTEPROPERTIES
	cmemberssortorder = +CName
	Desktop = .T.
	DoCreate = .T.
	Height = 235
	lanynew = .F.
	lnewallowed = .F.
	luseabbreviations = .T.
	Name = "frmpasteproperties"
	ntop = 0
	Width = 375
	WindowType = 1
	changefontsize.Name = "changefontsize"

	ADD OBJECT 'BASECHECKBOX1' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Create new properties / methods if they don't already exist?", ;
		ControlSource = "Thisform.oMySettings.lIncludeNew", ;
		Left = 30, ;
		Name = "BASECHECKBOX1", ;
		nanchor = 0, ;
		Top = 34
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		Caption = "Items marked as 'New' cannot be pasted, as they do not exist.", ;
		Height = 16, ;
		Left = 34, ;
		Name = "Baselabel1", ;
		nanchor = 0, ;
		Top = 36, ;
		Width = 301
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cmdCancel' AS basecommandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Height = 25, ;
		Left = 288, ;
		Name = "cmdCancel", ;
		nanchor = 8, ;
		TabIndex = 5, ;
		Top = 6, ;
		Width = 70
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdDeselect' AS cmdpasteselection WITH ;
		Caption = "De-Select All", ;
		Height = 25, ;
		Left = 102, ;
		lvalue = .F., ;
		Name = "cmdDeselect", ;
		nanchor = 0, ;
		TabIndex = 3, ;
		Top = 6, ;
		Width = 82
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPaste' AS basecommandbutton WITH ;
		Caption = "Paste", ;
		Height = 25, ;
		Left = 204, ;
		Name = "cmdPaste", ;
		nanchor = 8, ;
		TabIndex = 4, ;
		Top = 6, ;
		Width = 70
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelect' AS cmdpasteselection WITH ;
		Caption = "Select All", ;
		Height = 25, ;
		Left = 6, ;
		lvalue = .T., ;
		Name = "cmdSelect", ;
		nanchor = 0, ;
		TabIndex = 2, ;
		Top = 6, ;
		Width = 82
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'GridMembers' AS gridpastemembers WITH ;
		Height = 179, ;
		Left = 0, ;
		Name = "GridMembers", ;
		TabIndex = 1, ;
		Top = 54, ;
		Width = 376, ;
		ColName.Header1.Name = "Header1", ;
		ColName.Name = "ColName", ;
		ColName.Text1.Name = "Text1", ;
		ColType.Header1.Name = "Header1", ;
		ColType.Name = "ColType", ;
		ColType.Text1.Name = "Text1", ;
		ColType.Width = 25, ;
		ColAccess.Header1.Name = "Header1", ;
		ColAccess.Name = "ColAccess", ;
		ColAccess.Text1.Name = "Text1", ;
		ColAccess.Width = 25, ;
		ColAssign.Header1.Name = "Header1", ;
		ColAssign.Name = "ColAssign", ;
		ColAssign.Text1.Name = "Text1", ;
		ColAssign.Width = 25, ;
		ColVisibility.Header1.Name = "Header1", ;
		ColVisibility.Name = "ColVisibility", ;
		ColVisibility.Text1.Name = "Text1", ;
		ColVisibility.Width = 25, ;
		ColHierarchy.Header1.Name = "Header1", ;
		ColHierarchy.Name = "ColHierarchy", ;
		ColHierarchy.Text1.Name = "Text1", ;
		ColHierarchy.Width = 25, ;
		ColFavorite.Header1.Name = "Header1", ;
		ColFavorite.Name = "ColFavorite", ;
		ColFavorite.Text1.Name = "Text1", ;
		ColFavorite.Width = 25, ;
		ColNonDefault.Header1.Name = "Header1", ;
		ColNonDefault.Name = "ColNonDefault", ;
		ColNonDefault.Text1.Name = "Text1", ;
		ColNonDefault.Width = 25, ;
		ColTypeIcon.ColumnOrder = 1, ;
		ColTypeIcon.Header1.Name = "Header1", ;
		ColTypeIcon.imgHolder.Height = 16, ;
		ColTypeIcon.imgHolder.Name = "imgHolder", ;
		ColTypeIcon.imgHolder.Width = 16, ;
		ColTypeIcon.Name = "ColTypeIcon", ;
		ColValue.Header1.Caption = "Value in Copied Object", ;
		ColValue.Header1.Name = "Header1", ;
		ColValue.Name = "ColValue", ;
		ColValue.Text1.Name = "Text1", ;
		ColValue.Width = 120, ;
		ColCode.Header1.Name = "Header1", ;
		ColCode.Name = "ColCode", ;
		ColCode.Text1.Name = "Text1", ;
		ColCode.Text1.Visible = .F., ;
		ColCode.Visible = .F., ;
		ColCode.Width = 25, ;
		ColSelect.Basecheckbox1.Alignment = 2, ;
		ColSelect.Basecheckbox1.Name = "Basecheckbox1", ;
		ColSelect.ColumnOrder = 2, ;
		ColSelect.DynamicCurrentControl = 'IIF(csrMembers.lReadOnly or (csrMembers.lNew and not (Thisform.lNewAllowed and Thisform.oMySettings.lIncludeNew)), "Label1", "BaseCheckBox1")', ;
		ColSelect.Header1.Name = "Header1", ;
		ColSelect.LABEL1.Name = "LABEL1", ;
		ColSelect.Name = "ColSelect", ;
		ColNew.ColumnOrder = 3, ;
		ColNew.Header1.Name = "Header1", ;
		ColNew.Name = "ColNew", ;
		ColNew.Text1.Name = "Text1", ;
		ColCurValue.Header1.Caption = "Value in This Object", ;
		ColCurValue.Header1.Name = "Header1", ;
		ColCurValue.Name = "ColCurValue", ;
		ColCurValue.Text1.Name = "Text1"
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="grid" />
	
	PROCEDURE Destroy
		This.oServer = .Null.
		DoDefault()
		
	ENDPROC

	PROCEDURE dosortgrid
		Lparameters lcMainSortField, lcAltSortField
		
		****************************************************************
		* Created 10/25/2008 by Jim Nelson
		* Invoked by click on header of any column
		* Updates .cMembersSortOrder with new sort criteria
		* First parameter is the "normal" sort order for the column being sorted on
		* Second is the alternate (if any) to cause reverse sorting if grid
		* is already sorted on the main column.
		
		Local lcMembersSortOrder, lcName, lcSortField
		lcName = csrMembers.cName
		
		With This
			lcMembersSortOrder = .cMembersSortOrder
		
			If Pcount() > 0
		
				If Pcount() = 2 And lcMembersSortOrder = "+" + lcMainSortField
					lcSortField = lcAltSortField
				Else
					lcSortField = lcMainSortField
				Endif
		
				lcMembersSortOrder = "+" + lcSortField + Strtran( lcMembersSortOrder, "+" + lcSortField, "")
				.cMembersSortOrder = lcMembersSortOrder
			Endif
		
			****************************************************************
			Select csrMembers
		
			Delete Tag All
			Set Filter To
		
			Try
				Index On &lcMembersSortOrder Tag cName
			Catch To loException
				This.cMembersSortOrder = ccLoc_SortOrder1
				lcMembersSortOrder = This.cMembersSortOrder
				Index On &lcMembersSortOrder Tag cName
			Endtry
		
			****************************************************************
		
			Locate For cName = lcName
			If Not Found()
				Locate
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE getcurvalue
		Lparameters toObject, toName
		
		Local lcType, lxResult
		lcType = This.GetPEMStatus(toObject, toName, 3)
		
		If Left(lcType, 1) # 'P'
			If Empty (toObject.ReadMethod(toName))
				Return ''
			Else
				Return '[User Procedure]'
			Endif
		Else
			lxResult = toObject.ReadExpression(toName)
			If Not Empty(lxResult )
				Return '=' + lxResult
			Else
				lxResult = Getpem(toObject, toName)
				If 'C' = Vartype (lxResult) And Empty (lxResult)
					Return '(None)'
				Else
					Return Left(Transform(lxResult ), 100)
				Endif
			Endif
		Endif
		
		
	ENDPROC

	PROCEDURE getvalue
		Lparameters lnRow
		
		lcType = Thisform.oServer.aCopiedProperties (lnRow, ccPasteTypeCol)
		lcValue = Thisform.oServer.aCopiedProperties (lnRow, ccPasteValueCol)
		
		Do Case
			Case lcType = 'M'
				Return '[User Procedure]'
			Case lcType = 'X'
				Return '=' + lcValue
			Case 'C' = Vartype (lcValue) And Empty (lcValue)
				Return '(None)'
			Otherwise
				Return Left(Transform(lcValue), 100)
		EndCase
		
	ENDPROC

	PROCEDURE Init
		Lparameters toObject, tlNewAllowed, tlClass, tcFontName, tnFontSize, tcCaption
		
		Local lbNew, lcBackColorSuffix, lcBgColor, lcCurValue, lcDynamicFontBold, lcDynamicFontItalic
		Local lcDynBackColor, lcDynForeColor, lcFgColor, lcForeColorSuffix, lcGrey, lcMethodText, lcName
		Local lcType, lxResult
		
		With This
			.lNewAllowed = tlNewAllowed
			.lClass = tlClass
			*	.nFontSize = tnFontSize
			If Not Empty(tcCaption)
				.Caption = tcCaption
			Endif
		
			*	With .GridMembers
			*		.FontName = tcFontName
			*	Endwith
		
			.lAnyNew = .F.
		
			Select csrMembers
			Scan
				lcName = Trim(cname)
				If Upper(lcName) == '_MEMBERDATA' And Not tlNewAllowed
					Replace lSelect With .F.
				Endif
		
				lbNew = Not This.GetPEMStatus(toObject, lcName, 5)
				If lbNew
					Replace lNew With Not This.GetPEMStatus(toObject, lcName, 5)
					Replace cCurValue With ''
					.lAnyNew = .T.
				Else
					Replace lNew With .F.
					lcType = This.GetPEMStatus(toObject, lcName, 3)
		
					If Left(lcType, 1) # 'P'
						lcMethodText = toObject.ReadMethod(lcName)
						If Empty (lcMethodText)
							lcCurValue = ''
						Else
							lcCurValue = '[User Procedure]'
						Endif
						*	Replace Identical With cType # 'P' And lcMethodText = aaa
					Else
						lxResult = toObject.ReadExpression(lcName)
						If Not Empty(lxResult )
							lcCurValue = '=' + lxResult
						Else
							lxResult = Getpem(toObject, lcName)
							If 'C' = Vartype (lxResult) And Empty (lxResult)
								lcCurValue =  '(None)'
							Else
								lcCurValue =  Left(Transform(lxResult ), 100)
							Endif
							Replace Identical With cType = 'P' And Trim(cValue) == Trim(lcCurValue)
						Endif
					Endif
		
					Replace cCurValue With lcCurValue
				Endif
		
				Replace lReadOnly With .F.
				Do Case
					Case lNew
		
					Case This.GetPEMStatus(toObject, lcName, 1)
						Replace lReadOnly With .T., lSelect With .F.
		
					Case Not Upper(lcName) == 'NAME'
		
					Case 'O' = Type('toObject.Parent.' + cValue)
						Replace lReadOnly With .T., lSelect With .F.
				Endcase
		
			Endscan
		
			.GridMembers.ColNew.Visible = .lAnyNew
		
			lcDynamicFontBold = 'csrMembers.lSelect and ((Thisform.lNewAllowed and ThisForm.oMySettings.lIncludeNew) or not csrMembers.lNew)'
			.SetAll('DynamicFontBold', lcDynamicFontBold, 'Column')
		
			lcDynamicFontItalic = 'csrMembers.lReadOnly'
			.SetAll('DynamicFontItalic', lcDynamicFontItalic, 'Column')
		
			****************************************************************
		
			lcBgColor = Transform(Thisform.nHighlightBackColor)
			lcFgColor = Transform(Thisform.nHighlightForeColor)
		
			lcForeColorSuffix = Transform (.GridMembers.ForeColor)
			lcBackColorSuffix = Transform (.GridMembers.BackColor)
			lcGrey = 'Rgb(192, 192, 192)'
		
			lcDynForeColor = 'IIF(csrMembers.lSelect and ((Thisform.lNewAllowed and ThisForm.oMySettings.lIncludeNew) or not csrMembers.lNew), ' ;
				+ lcFgColor + ', ' + lcForeColorSuffix + ")"
		
			*!*	lcDynBackColor = 'IIF(csrMembers.lSelect and ((Thisform.lNewAllowed and ThisForm.lIncludeNew) or not csrMembers.lNew), '	;
			+ lcBgColor + ', ' 																										;
			+ 'IIF(csrMembers.lReadOnly or (csrMembers.lNew and not (Thisform.lNewAllowed and Thisform.lIncludeNew)), ' 			;
			+ lcGrey + ', ' 																										;
			+ lcBackColorSuffix + "))"
		
			lcDynBackColor = 'IIF(csrMembers.lReadOnly or (csrMembers.lNew and not (Thisform.lNewAllowed and Thisform.oMySettings.lIncludeNew)), ' 	;
				+ lcGrey + ', ' 																										;
				+ lcBackColorSuffix + ")"
		
			*!*		.SetAll("DynamicForeColor", lcDynForeColor, "Column")
			.SetAll("DynamicBackColor", lcDynBackColor, "Column")
		
			****************************************************************
		
			DoDefault()
		
			.DoSortGrid()
		
			Set Filter To Not Identical
		
			Goto Top
		
			.Refresh()
		
		Endwith
		
		
		
	ENDPROC

	PROCEDURE Load
		Local lcAlias, lcType, lnRow 
		
		DoDefault()
		
		With This
			.oServer = _oPEMEditor.oUtils.oServer
			.CreateMembersCursor (.T.)
		Endwith
		
		Append From Array Thisform.oServer.aCopiedProperties
		
		Scan
			lnRow = Recno()
			Replace						 ;
				nRecno	With  lnRow	 ;
				cValue	With  This.GetValue (lnRow)
		
			lcType = Thisform.oServer.aCopiedProperties (lnRow, ccPasteTypeCol)
			If lcType = 'M' And Not Empty (Thisform.oServer.aCopiedProperties (lnRow, ccPasteValueCol))
				Replace lNonDefault With .T.
			Endif
		
		Endscan
		
		lcAlias = Alias()
		Select  *							 ;
			, .F.	   As  Identical		 ;
			From (lcAlias)					 ;
			Into Cursor (lcAlias) Readwrite	 ;
			Where lNonDefault or not (lNative or lInherited)
		
		
	ENDPROC

	PROCEDURE loadsettings
		This.cMembersSortOrder = .cPasteOrder
		This.LoadColumnInfo (This.gridMembers)
		DoDefault()
		
		
		
	ENDPROC

	PROCEDURE savesettings
		.cPasteOrder = This.cMembersSortOrder
		This.SaveColumnInfo (This.gridMembers)
		
		DoDefault()
		
	ENDPROC

	PROCEDURE setdefaults
		.cPasteOrder = ''
		.lIncludeNew = .F.
	ENDPROC

	PROCEDURE sortgrid
		Lparameters lcMainSortField, lcAltSortField
		
		****************************************************************
		* Created 10/25/2008 by Jim Nelson
		* Invoked by click on header of any column
		* Updates .cMembersSortOrder with new sort criteria
		* First parameter is the "normal" sort order for the column being sorted on
		* Second is the alternate (if any) to cause reverse sorting if grid
		* is already sorted on the main column.
		
		With This
			.DoSortGrid(lcMainSortField, lcAltSortField)
			.GridMembers.SetFocus()
		Endwith
		
	ENDPROC

	PROCEDURE Unload
		Return this.lPasteIt
	ENDPROC

	PROCEDURE BASECHECKBOX1.Refresh
		This.Visible = Thisform.lAnyNew and Thisform.lNewAllowed 
		This.Enabled = Thisform.lAnyNew and Thisform.lNewAllowed 
	ENDPROC

	PROCEDURE BASECHECKBOX1.Valid
		checkbox::Valid
		
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE Baselabel1.Refresh
		This.Visible = Thisform.lAnyNew and not Thisform.lNewAllowed 
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.lPasteIt = .F.
		Thisform.Release()
	ENDPROC

	PROCEDURE cmdCancel.Init
		DoDefault()
		With This
			.Caption = ccLOC_Paste_Cancel
		Endwith
		
	ENDPROC

	PROCEDURE cmdDeselect.Init
		DoDefault()
		With This
			.Caption = ccLOC_Paste_DeSelect
			.ToolTipText = ccLOC_Paste_Tip
		Endwith
		
	ENDPROC

	PROCEDURE cmdPaste.Click
		Local lnRecno
		For lnRecno = 1 To Alen (Thisform.oServer.aCopiedProperties, 1)
			If Thisform.oServer.aCopiedProperties (lnRecno, ccNonDefaultCol)
				Thisform.oServer.aCopiedProperties (lnRecno, ccPasteSelectCol) = .F.
			Endif
		Endfor
		
		Scan
			Do Case
				Case lReadOnly
					Thisform.oServer.aCopiedProperties (nRecno, ccPasteSelectCol) = .F.
		
				Case lNew And Not (Thisform.lNewAllowed And Thisform.oMySettings.lIncludeNew)
					Thisform.oServer.aCopiedProperties (nRecno, ccPasteSelectCol) = .F.
		
				Otherwise
					Thisform.oServer.aCopiedProperties (nRecno, ccPastelNewCol ) = lNew
					Thisform.oServer.aCopiedProperties (nRecno, ccPasteSelectCol) = lSelect
			Endcase
		Endscan
		
		Thisform.lPasteIt = .T.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdPaste.Init
		DoDefault()
		With This
			.Caption = ccLOC_Paste_Paste
		Endwith
		
	ENDPROC

	PROCEDURE cmdSelect.Init
		DoDefault()
		With This
			.Caption = ccLOC_Paste_Select
			.ToolTipText = ccLOC_Paste_Tip
		Endwith
		
	ENDPROC

	PROCEDURE GridMembers.ColNew.Refresh
		This.Visible = Thisform.lAnyNew 
		
	ENDPROC

	PROCEDURE GridMembers.setcolumnheadings
		DoDefault()
		
		This.ColValue.Header1.Caption = 'Value in Copied Object'
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmpeme_base AS baseformnew OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addclassinfo
		*m: addparentcodetext
		*m: assignselectedcontrols
		*m: creatememberdatanew
		*m: creatememberscursor
		*m: editmethodcode
		*m: editsourcefile
		*m: executescript
		*m: findattributeformember
		*m: getclassfilename
		*m: getcombovalues
		*m: getcustomcombovalues
		*m: getcustomevaluated
		*m: getdopetext
		*m: getobjectpath
		*m: getparentcode
		*m: getparentcodedetailinfo
		*m: getparentcodesetupinfo
		*m: getparentcodevalue
		*m: insertformorclass
		*m: insureformvisible
		*m: iscustomcolor
		*m: iscustomspinner
		*m: isnativecolor
		*m: isreadonly
		*m: loadnode
		*m: loadtree
		*m: savenodehighlighting
		*m: setoletooltips
		*m: sortgrid
		*m: spellcodeorigin
		*m: spellfavorites
		*m: spellhierarchy
		*m: spelltype
		*m: spellvisibility
		*m: spellyes
		*m: viewparentcode
		*p: capplicationpath
		*p: cdodefaulttext
		*p: cpluginpath
		*p: csnippetpath
		*p: csourcefilename
		*p: cthisformcaption
		*p: lavoidbufferoverrun
		*p: lclass
		*p: ldataenvironment
		*p: ldebugmode
		*p: ldontdisableme
		*p: leditingoneproperty
		*p: lpemeditor
		*p: luseabbreviations
		*p: nhelpid
		*p: nobjnumber
		*p: nselectedobjects
		*p: oprefs
		*p: oserver
		*p: otopofform
		*p: outils
		*a: aselectedobjects[1,0]
	*</DefinedPropArrayMethod>

	capplicationpath = 
	cdodefaulttext = .F.
	cpluginpath = 
	csnippetpath = <fb2p_value>&#13;</fb2p_value>
	csourcefilename = 
	cthisformcaption = 
	DoCreate = .T.
	lavoidbufferoverrun = .F.
	lclass = .F.
	ldataenvironment = .F.
	ldebugmode = .F.
	ldontdisableme = .F.
	leditingoneproperty = .F.
	lpemeditor = .F.
	luseabbreviations = .F.
	Name = "frmpeme_base"
	nhelpid = 0
	nobjnumber = 0
	nselectedobjects = 0
	oprefs = .NULL.
	oserver = .NULL.
	otopofform = .NULL.
	outils = .NULL.
	_memberdata = <VFPData>
		<memberdata name="setdefaults" display="SetDefaults" favorites="True"/>
		<memberdata name="oprefs" display="oPrefs"/>
		<memberdata name="outils" display="oUtils"/>
		<memberdata name="oserver" display="oServer"/>
		</VFPData>
	changefontsize.Name = "changefontsize"
	
	PROCEDURE addclassinfo
		Lparameters loControl, lcText
		
		Local lcClassName
		lcClassName = Iif(Thisform.lClass And loControl = Thisform.oTopOfForm , loControl.ParentClass, loControl.Class)
		
		Do Case
			Case Thisform.oPrefs.nTreeViewClassInfo = 1
				lcText = lcText + ' [' + lcClassName + ']'
			Case Thisform.oPrefs.nTreeViewClassInfo = 2 And Empty (loControl.ClassLibrary)
				lcText = lcText + ' [' + lcClassName + ']'
			Case Thisform.oPrefs.nTreeViewClassInfo = 2
				lcText = lcText + ' [' + Juststem (loControl.ClassLibrary) + ":" + lcClassName + ']'
		Endcase
		
		Return lcText
		
	ENDPROC

	PROCEDURE addparentcodetext
		Lparameters lcStyle, lcPem, lcObjectPathName, lcRelativeName, lcMethodCode
		
		Local lcArrow, lcResult, lcMethodHeader, lcValueHeader, lcNextDoDefaultText
		
		lcArrow 	= '* ' &&+ Replicate("-", 10) +'> '
		If " " $ lcRelativeName And Not lcStyle = 'oParentage'
			lcRelativeName = ['] + lcRelativeName + [']
		Endif
		
		
		Do Case
		Case lcStyle = 'Parentage'
			lcResult = 							;
				ccBottomDividerLine				;
				+ Iif (Empty(lcRelativeName), '', "Class  ")									;
				+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
				+ Iif(Empty(lcRelativeName), '', " of " + lcRelativeName + ccCRLF) 				;
				+ Iif("." $ lcObjectPathName, "Object " + lcObjectPathName	+ ccCRLF, '') 		;
				+ ccCRLF
		
		Case lcStyle = 'oParentage'
			If Empty(lcRelativeName)
				lcResult = ''
			Else
				lcResult = 							;
					FullPath(lcRelativeName)		;
					+ "|" 							;
					+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
					+ Chr(0)
			Endif
		
		Case lcStyle = 'Code'
		
			lcMethodHeader = lcArrow + Iif (Empty(lcRelativeName), '', "Class  ")									;
				+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
				+ Iif(Empty(lcRelativeName), '', " of " + lcRelativeName) + ccCRLF									;
		
			If Empty (lcMethodCode)
				lcResult = 								;
					ccTopDividerLine					;
					+ lcMethodHeader 					;
					+ Iif("." $ lcObjectPathName, lcArrow + 'Object ' + lcObjectPathName + ccCRLF, '')  ;
					+ ccCRLF
			Else
				lcResult = 								;
					ccTopDividerLine					;
					+ lcMethodHeader + ccCRLF			;
					+ "Procedure " + lcObjectPathName + "." + lcPem + ccCRLF;
					+ lcMethodCode + ccCRLF				;
					+ "EndProc" + ccCRLF				;
					+ ccCRLF
			Endif
		
		Case lcStyle = 'All Code'
		
			lcMethodHeader = lcArrow + Iif (Empty(lcRelativeName), '', "Class  ")									;
				+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
				+ Iif(Empty(lcRelativeName), '', " of " + lcRelativeName + ccCRLF)
		
			If Empty (lcMethodCode)
				lcResult = ''
			Else
				lcResult = 								;
					ccTopDividerLine					;
					+ lcMethodHeader + ccCRLF			;
					+ "Procedure " + lcObjectPathName + "." + lcPem + ccCRLF;
					+ lcMethodCode + ccCRLF				;
					+ "EndProc" + ccCRLF				;
					+ ccCRLF
			Endif
		
		Case lcStyle = 'First Code'
		
			lcResult = Evl (lcMethodCode, '')
			If Not Empty (lcResult)
				If Empty(This.cDoDefaultText)
					This.cDoDefaultText = Sys(2015) && some random name
					lcResult = '#Define DoDefault ' + This.cDoDefaultText + ccCRLF ;
						+ lcMethodCode + ccCRLF 						;
						+ '#Undefine DoDefault' + ccCRLF + ccCRLF		;
						+ '******************************' + ccCRLF
				Else
					lcNextDoDefaultText = Sys(2015) && some random name
					lcResult = '#Define DoDefault ' + lcNextDoDefaultText + ccCRLF ;
						+ 'Proc ' + This.cDoDefaultText + ccCRLF		;
						+ lcMethodCode + ccCRLF 						;
						+ '#Undefine DoDefault' + ccCRLF + ccCRLF		;
						+ '******************************' + ccCRLF
					This.cDoDefaultText = lcNextDoDefaultText
				Endif
			Endif
		
		Case lcStyle = 'Inherited Code'
		
			lcResult = Evl (lcMethodCode, '')
		
		Case lcStyle = 'Inherited Value'
		
			lcResult = Evl (lcMethodCode, '')
		
		Case lcStyle = 'Value'
		
			lcValueHeader = lcArrow + Iif (Empty(lcRelativeName), '', "Class  ")									;
				+ Iif("." $ lcObjectPathName, Left( lcObjectPathName, At(".", lcObjectPathName) - 1), lcObjectPathName) 	;
				+ Iif(Empty(lcRelativeName), '', " of " + lcRelativeName) + ccCRLF
		
			If Empty (lcMethodCode)
				lcResult = 								;
					ccTopDividerLine					;
					+ lcValueHeader 					;
					+ ccCRLF
			Else
				lcResult = 								;
					ccTopDividerLine					;
					+ lcValueHeader + ccCRLF			;
					+ Iif('.' $ lcObjectPathName, Substr (lcObjectPathName, At('.', lcObjectPathName)) + '.', '' ) + lcMethodCode + ccCRLF + ccCRLF
			Endif
		
		*	lcResult = Evl (lcMethodCode, '')
		
		Endcase
		
		Return lcResult
		
	ENDPROC

	PROCEDURE assignselectedcontrols
		Lparameters lcPem, luNewValue
		
		If Not Thisform.lEditingOneProperty
			Thisform.UpdateSelectedControls(Thisform.oObject, lcPem, luNewValue, Thisform.nSelectedObjects <= 1)
		Else
			Thisform.UpdateSelectedControls(Thisform.aSelectedObjects (Thisform.nObjNumber), lcPem, luNewValue, .T.)
		Endif
		
	ENDPROC

	PROCEDURE creatememberdatanew
		Lparameters toObject, tcCursorName, tlAvoidBufferOverrun
		
		Local loDOM As ccXML_DOM_CLASS
		Local loResult As Object
		Local laLines(1), laObjectMembers(1), lcFavorites, lcName, lcPEM, llActiveX, llChanged, llReadOnly
		Local lnLen, lnRow
		
		*** JRN 2010-09-23 : Removed .... way too slow, little value
		*** JRN 2009-10-02 : The call to AMembers below can crash VFP with 'Buffer Overrun'
		*!*	Dimension laLines[ 1 ]
		*!*	If Not tlAvoidBufferOverrun
		*!*		Try
		*!*			***********************************************************************
		*!*			*** Changed By.: Marcia G. Akins on 06 January 2007
		*!*			*** Reason.....: Use AMEMBERS() to get the description from column 4
		*!*			***********************************************************************
		*!*			Amembers( laLines, toObject, 3 )
		*!*		Catch
		*!*		Endtry
		*!*	Endif
		
		****************************************************************
		* Create a cursor of MemberData records from the FOXCODE table so we can look
		* for global PEMs. Bug out if we can't open FOXCODE.
		Try
			Use (_Foxcode) Again Shared In 0 Alias Foxcode
		Catch
		Endtry
		If Not Used('FOXCODE')
			This.cErrorMessage = ccLOC_CANT_OPEN_FOXCODE
			Return
		Endif Not Used('FOXCODE')
		Select ABBREV From (_Foxcode) ;
			where Type = 'P' And Not Deleted() ;
			into Cursor _PROPERTIES
		Index On Upper(ABBREV) Tag ABBREV
		Select ABBREV, TIP From (_Foxcode) ;
			where Type = ccGLOBAL_MEMBER_DATA_TYPE And Not Deleted() ;
			into Cursor Global
		Index On Upper(ABBREV) Tag ABBREV
		Use In Foxcode
		lnLen = Len(ABBREV)
		
		loDOM = Createobject(ccXML_DOM_CLASS)
		loDOM.Async = .F.
		
		****************************************************************
		
		This.CreateMembersCursor (.F., tcCursorName)
		loResult = Thisform.oServer.GetPEMList(toObject, Thisform.lClass, .F.)
		Append From Array loResult.MethodList 		;
			Fields cName, cType, lAccess, lAssign, nVisibility, lNative, lInherited, nFavorites, lReadonly, cScript
		Index On Upper(cName) Tag Order
		
		llActiveX = Lower(toObject.BaseClass) = 'olecontrol'
		If llActiveX
			Amembers(laObjectMembers, toObject, 1, 'PHG#')
		Endif
		
		****************************************************************
		Scan
			lcPEM    = Upper (Trim (cName))
		
			If Indexseek (Padr (lcPEM, lnLen), .T., 'GLOBAL');
					and Not Empty (Global.TIP)
				loDOM.LoadXML(Global.TIP)
				If loDOM.parseError.errorCode = 0
					lcFavorites = This.FindAttributeForMember(lcPEM, 'Favorites', loDOM)
					If lcFavorites == ccXML_TRUE
						Replace nFavorites With 2 + nFavorites
					Endif
					If Lower(cName) == cName
						lcName = This.FindAttributeForMember(lcPEM, 'Display', loDOM)
						If Not Empty (lcName)
							Replace cName With lcName
						Endif
					Endif
				Endif
			Endif
		
			If Lower(cName) == cName And (lNative Or llActiveX)
				Replace cName With Proper(cName)
			Endif
		
			If cType = 'P' And "U" # Type("ALen(toObject." + lcPEM + ")")
				Replace cName With Trim(cName) + '[' + Transform (Alen (toObject.&lcPEM,1));
					+ IIf( 0 # Alen (toObject.&lcPEM,2),									;
					"," + Transform (Alen (toObject.&lcPEM,2)) , '') + ']'
			Endif
		
			If llActiveX
				lnRow = Ascan( laObjectMembers, lcPEM, 1, -1, 1, 15 )
				If lnRow > 0
					llChanged = 'C' $ laObjectMembers[lnRow, 3]
					llReadOnly = 'R' $ laObjectMembers[lnRow, 3]
				Else
					llChanged = .F.
					llReadOnly = .F.
				Endif
			Else
				llChanged = This.GetPEMStatus (toObject, lcPEM, 0)
				llReadOnly = This.GetPEMStatus (toObject, lcPEM, 1)
			Endif
		
			Do Case
				Case cType $ 'P'
					Replace			;
						lNonDefault With  llChanged Or Not (lNative Or lInherited) 	;
						lHasCode	With  .F.										;
						lReadonly   With  llReadOnly
				Case llChanged
					Replace			;
						lNonDefault With  Not Empty (toObject.ReadMethod (lcPEM))	;
						lHasCode	With  llChanged Or Not (lNative Or lInherited)	;
						lReadonly   With  llReadOnly
				Otherwise
					Replace 		;
						lReadonly   With  llReadOnly
			Endcase
		
			*** JRN 2010-09-23 : Removed .... way too slow, little value
			*!*		*   If Type( [laLines], 1 ) = [A]
			*!*		If Alen (laLines) >= 4
			*!*			lnRow = Ascan( laLines, lcPEM, 1, -1, 1, 15 )
			*!*			If lnRow > 0
			*!*				Replace cDescript  With  laLines[ lnRow, 4 ]
			*!*			Endif
			*!*		Endif
		Endscan
		
		
		* Close the cursors.
		
		Use In _PROPERTIES
		Use In Global
		
	ENDPROC

	PROCEDURE creatememberscursor
		Lparameters tlPasteMode, tcCursorName
		
		Local lcCursorName
		lcCursorName = Evl (tcCursorName, 'csrMembers')
		
		If tlPasteMode
			* note that leading fields here must match normal case, but can't have a Memo field
			Create Cursor (lcCursorName) (	;
				cName 		C (128)		, 	;  && ccNameCol
				cType 		C (1)		, 	;  && ccTypeCol
				lAccess 	L			, 	;  && ccAccessCol
				lAssign 	L			, 	;  && ccAssignCol
				nVisibility N(2)		, 	;  && ccVisibilityCol
				lNative 	L			, 	;  && ccNativeCol
				lInherited 	L			, 	;  && ccInheritedCol
				lNonDefault L			, 	;  && ccNonDefaultCol
				lHasCode	L			, 	;  && ccHasCodeCol
				nFavorites 	N (1)		, 	;  && ccFavoritesCol
				lReadOnlyX 	L			, 	;  && ccReadOnlyXCol
				cDescript 	C (254)		, 	;  && ccDescriptCol
				nObjNumber	N (4)		,  	;  && ccObjNumberCol
				cValue		C (100)		,   ;  && ccPastecValueCol
				cScript     C (254)		,   ;  && ccHasScript
				;
				xValue		C (1) Null	,   ;  && ccPasteValueCol
				cTypeCol	C (1)		,	;  && ccPasteTypeCol
				lSelect		L			,	;  && ccPasteSelectCol
				lNew		L			,	;  && ccPastelNewCol
				;
				lReadOnly	L			,	;
				cCurValue	C (100)		,	;
				NRecNo      N (4)		    ;
				)
		
		Else
		
			Create Cursor (lcCursorName) (	;
				cName 		C (128)		, 	;
				cType 		C (1)		, 	;
				lAccess 	L			, 	;
				lAssign 	L			, 	;
				nVisibility N(2)		, 	;
				lNative 	L			, 	;
				lInherited 	L			, 	;
				lNonDefault L			, 	;
				lHasCode	L			, 	;
				nFavorites 	N (1)		, 	;
				lReadOnly 	L			, 	;
				cDescript 	M			, 	;
				nObjNumber	N (4)		,	;
				cValue		C (100)		,   ;
				cScript     M			    ;
				)
		
		Endif
		
	ENDPROC

	PROCEDURE editmethodcode
		Lparameters tcNewMethod, toObject
		
		*** JRN 11/11/2008 : Invoke EditSource to edit Method Code
		
		Local laObject(1), lcFileName, lcClassName, lcPem, oContainerObj, loTopOfForm, lcObjectName
		Local loObject, lcMethod
		
		lcFileName = Thisform.cSourceFileName
		
		If Upper (Justext(lcFileName)) == 'TMP'
			*** JRN 2010-04-27 : per Bernard ... after file is saved, the file name changes
			Aselobj(laObject, 3)
			lcFileName = Lower(laObject[2])
			If Upper (Justext(lcFileName)) == 'TMP'
				Messagebox(ccLOC_CAP_Cant_Edit)
				Return
			Else
				Thisform.cSourceFileName = lcFileName
			Endif
		Endif
		
		If (Not Empty(tcNewMethod)) or Thisform.oMember.cType $ [ME]
		
			If "O" # Vartype(toObject)
				toObject = Thisform.oObject
			Endif
			loObject	= toObject
		
			If "C" # Vartype(tcNewMethod)
				tcNewMethod = Thisform.JustPEM(Thisform.oMember.cName)
			Endif
			lcMethod	= tcNewMethod
		
			This.oUtils.EditLocalMethodCode(lcFileName, Thisform.oTopOfForm, loObject, lcMethod, Thisform.lClass, This.lDataEnvironment)
		
		Endif
		
		
	ENDPROC

	PROCEDURE editsourcefile
		Lparameters lcFileName, lcClass, lcMethod, lnStartRange, lnEndRange
		This.oUtils.EditSourceX(lcFileName, lcClass, lcMethod, lnStartRange, lnEndRange)
	ENDPROC

	PROCEDURE executescript
		Lparameters lcScript, lcParams, loObject
		
		Local lcFileName, cCmd, lxResult, loException
		
		****************************************************************
		* Following code courtesy of Bernard Bout; with slight modifications
		Set Notify Off && stops the compiling... dialogbox
		Set Safety Off && to overwrite the old file
		*************************************
		lcFileName = "_PEMEditor" + Sys(2015)
		
		
		Strtofile ('#Define Recursive           ' + lcFileName + ccCRLF, lcFileName + ".prg")
		Strtofile(lcScript, lcFileName + ".prg", 1)
		
		cCmd = "Compile ('" + lcFileName + ".prg')"
		&cCmd
		
		cCmd = lcFileName + Iif( Empty (lcParams), '()', Iif('(' $ lcParams, lcParams, '(' + lcParams + ')'))
		
		If This.oPrefs.lDebugMode
			lxResult = &cCmd
		Else
			Try
				lxResult = &cCmd
			Catch To loException
				Thisform.ShowErrorMsg (loException)
				lxResult = Createobject("Empty")
			Endtry
		Endif
		
		Erase (lcFileName + ".*")
		
		Return lxResult
		****************************************************************
		
	ENDPROC

	PROCEDURE findattributeformember
		Lparameters tcMember, tcAttribute, toDOM
		Local loDOM As Object
		Local loNode As Object
		Local lcValue
		
		If Vartype(toDOM) = 'O'
			loDOM = toDOM
		Else
			loDOM = This.oXMLDOM
		Endif Vartype(toDOM) = 'O'
		lcValue = ''
		loNode  = loDOM.selectSingleNode('//' + ccMEMBER_DATA_XML_ELEMENT + ;
			'[@name = "' + Lower(tcMember) + '"]')
		If Vartype(loNode) = 'O'
			lcValue = Nvl(loNode.getAttribute(Lower(tcAttribute)), '')
		Endif Vartype(loNode) = 'O'
		Return lcValue
		
	ENDPROC

	PROCEDURE getclassfilename
		Lparameters tcClassLoc, tcPath
		
		*** JRN 02/24/2009 : per Doug ... handles cases of absolute paths and relative to current directory
		
		Do Case
			Case ":" $ tcClassLoc
				Return tcClassLoc
		
			Case File( Fullpath( m.tcClassLoc, m.tcPath ) )
				Return Fullpath(tcClassLoc, tcPath)
		
			Otherwise
				Return Fullpath( m.tcClassLoc )
		Endcase
		
		
	ENDPROC

	PROCEDURE getcombovalues
		Lparameters laValues, lcPem, lcEditor, lcBaseClass
		External array laValues
		
		lcPem = lcPem + ' '
		If lcEditor == 'Combo'
			Select Value, Descript From PropertyValues	;
				where Name = lcPem 						;
				into Array laValues
		
		Else
		
			Select Value, Descript From PropertyValues	;
				where Name = lcPem 						;
				and BaseClass = Upper (lcBaseClass)		;
				into Array laValues
		
			If _Tally = 0
				Select Value, Descript From PropertyValues	;
					where Name = lcPem 						;
					and Empty (BaseClass)					;
					into Array laValues
			Endif
		Endif
		
		Return
		
	ENDPROC

	PROCEDURE getcustomcombovalues
		Lparameters taValues, tcPem, tcDescript
		External Array taValues
		
		Local lcPem, lnPos, lnCount, lcLine, lcDopeText, lcNum, lnI, lnNum
		lcPem = Upper(tcPem) + ' '
		
		* nEnum
		lcDopeText = This.GetDopeText(tcDescript, 'nEnum')
		If Not Empty (lcDopeText)
			Alines (laValues, Strtran(lcDopeText, '\n', ',', 1, 999, 1), .T., "|", ";")
			lnCount = 0
			For lnI = 1 To Alen (laValues)
				lcLine = laValues(lnI)
				* Find first of '=' or '-'
				lnPos = Min (Evl (At ('-', lcLine), 1000),Evl (At ('=', lcLine), 1000))
				If lnPos # 1000
					lcNum = Left (lcLine, lnPos - 1)
					Try
						lnNum = Evaluate (lcNum)
						lnCount = lnCount + 1
						Dimension taValues (lnCount,2)
						taValues (lnCount, 1) = lnNum
						taValues (lnCount, 2) = lcLine
					Catch
		
					Endtry
				Endif
			Endfor
			Return lnCount # 0
		Endif
		
		* cEnum
		lcDopeText = This.GetDopeText(tcDescript, 'cEnum')
		If Not Empty (lcDopeText)
			Alines (laValues, Strtran(lcDopeText, '\n', ',', 1, 999, 1), .T., "|", ";")
			lnCount = 0
			For lnI = 1 To Alen (laValues)
				lcLine = laValues(lnI)
				If Not Empty (lcLine)
					* Find first of '=' or '-'
					lnPos = Min (Evl (At ('-', lcLine), 1000),Evl (At ('=', lcLine), 1000))
					lcNum = Iif (lnPos = 1000, lcLine, Left (lcLine, lnPos - 1))
					lnCount = lnCount + 1
					Dimension taValues (lnCount,2)
					taValues (lnCount, 1) = lcNum
					taValues (lnCount, 2) = lcLine
				Endif
			Endfor
			Return lnCount # 0
		Endif
		
		* Old Style
		lcDopeText = This.GetDopeText(tcDescript, '')
		If Not Empty (lcDopeText)
			Alines (laValues, Strtran(lcDopeText, '\n', ',', 1, 999, 1), .T., ",", ";")
			lnCount = 0
			For lnI = 1 To Alen (laValues)
				lcLine = laValues(lnI)
				* Find first of '=' or '-'
				lnPos = Min (Evl (At ('-', lcLine), 1000),Evl (At ('=', lcLine), 1000))
				If lnPos # 1000
					lcNum = Left (lcLine, lnPos - 1)
					If ThisForm.oUtils.IsNumber (lcNum)
						lnCount = lnCount + 1
						Dimension taValues (lnCount,2)
						taValues (lnCount, 1) = Val (lcNum)
						taValues (lnCount, 2) = lcLine
					Endif
				Endif
			Endfor
			Return lnCount # 0
		Endif
		
		Return .F.
		
	ENDPROC

	PROCEDURE getcustomevaluated
		Lparameters lcResult, lcDescript
		
		lcResult = This.GetDopeText (lcDescript, '!')
		Return Not Empty (lcResult)
		
	ENDPROC

	PROCEDURE getdopetext
		Lparameters tcDescript, tcKeyValue
		Local lcDOPEText, lcName, lcResult, lnExtenderPos1, lnExtenderPos2, lnPos
		
		If Empty (tcDescript)
			Return ''
		Endif
		
		lnPos = Rat ('***', tcDescript)
		If lnPos # 0
			lcDOPEText = Alltrim (Substr(tcDescript,lnPos + 3))
			If Upper (lcDOPEText) = Upper(tcKeyValue)
				lcResult = Alltrim (Substr (lcDOPEText, 1 + Len (tcKeyValue)))
				If Empty (lcResult)
					Return '?'
				Else
					*** JRN 07/20/09 : DOPE Extender   <[PropertyName]>
					Try && necessary in case the PEM name is bad
						lnExtenderPos1 = At('<[', lcResult)
						lnExtenderPos2 = At(']>', lcResult)
						If lnExtenderPos1 > 0 And lnExtenderPos1 < lnExtenderPos2
							lcName = Substr(lcResult, lnExtenderPos1 + 2, lnExtenderPos2 - lnExtenderPos1 - 2)
							lcResult = Left(lcResult, lnExtenderPos1 - 1) + Getpem(Thisform.oobject, lcName) + Substr(lcResult, lnExtenderPos2 + 2)
						Endif
					Catch
		
					Endtry
					Return lcResult
				Endif
			Endif
		Endif
		
		Return ''
		
		
	ENDPROC

	PROCEDURE getobjectpath
		Lparameters loObject
		
		Local loTopOfForm As Object
		Local lcCaption
		
		loTopOfForm	= Thisform.oTopOfForm
		lcCaption	= ''
		Do While loObject # loTopOfForm
			If Upper(loObject.BaseClass) # "DATAENVIRONMENT"
				lcCaption = '.' + loObject.Name + lcCaption
				If 'O' = Type ('loObject.Parent')
					loObject = loObject.Parent
				Else
					Exit
				Endif
			Else
				lcCaption = loObject.Name + lcCaption
				Exit
			Endif
		Enddo
		
		Return lcCaption
		
	ENDPROC

	PROCEDURE getparentcode
		Lparameters tcName, lcStyle, loObject, llSkipCurrentCode
		
		* lcStyle =
		*     	'Code'
		* 		'Parentage'
		**		'Value'
		*		'All Code'
		**		'First Code'
		**		'Inherited Code'
		**		'Inherited Value'
		
		Local lnSelect, lcResult, loSetupInfo, lcClass, lcClassLib, lcParent, loDetailInfo, loObject
		
		*  tcName = Alltrim(ThisForm.oOriginalMember.cname)
		If "O" # Vartype (loObject)
			loObject = Thisform.oObject
		Endif
		
		lnSelect = Select()
		Select 0
		
		This.cDoDefaultText = ''
		
		*** JRN 12/21/2008 : per Rick's suggestion, start with code for current method
		Do Case
			Case lcStyle = 'Code'
				If llSkipCurrentCode
					lcResult = ''
				Else 
					lcResult = loObject.ReadMethod(tcName)
					If Not Empty(lcResult)
						lcResult = 'Procedure ' + tcName + ccCRLF + lcResult + ccCRLF + 'EndProc' + ccCRLF + ccCRLF
					Endif
				Endif
		
			Case lcStyle = 'All Code'
				lcResult = loObject.ReadMethod(tcName)
				If Not Empty(lcResult)
					lcResult = 'Procedure ' + tcName + ccCRLF + lcResult + ccCRLF + 'EndProc' + ccCRLF + ccCRLF
				Endif
		
			Case lcStyle = 'First Code'
				lcResult = This.addparentcodetext( 'First Code',,, '', loObject.ReadMethod(tcName))
		
			Case lcStyle = 'Parentage'
				lcResult = ''
		
			Case lcStyle = 'oParentage'
				lcResult = ''
		
			Case lcStyle = 'Inherited Code'
				lcResult = ''
		
			Case lcStyle = 'Inherited Value'
				lcResult = ''
		
			Case lcStyle = 'Value'
				If ThisForm.GetPemStatus (loObject, tcName, 0)
					lcResult = '.' + tcName + " = " + Thisform.getValue(tcName, Not ThisForm.GetPemStatus (loObject, tcName, 4),  'Full Value')
					lcResult = lcResult + Iif(Empty(lcResult), '', ccCRLF + ccCRLF)
				Else
					lcResult = ''
				Endif
		Endcase
		
		If Empty (tcName) Or Thisform.GetPEMStatus (loObject, tcName, 6)
			loSetupInfo = This.getparentcodesetupinfo (			;
				Lower(loObject.Class)							;
				, Iif(Thisform.lClass And Thisform.oTopOfForm = loObject, Thisform.cSourceFileName, loObject.ClassLibrary)	;
				, loObject										;
				)
		
			With loSetupInfo
				lcClass		= .Class
				lcClassLib	= .Classlib
				lcParent	= .Parent
			Endwith
		
			loDetailInfo = This.getparentcodedetailinfo (lcStyle, lcClass, lcClassLib, lcParent, tcName, loObject)
			With loDetailInfo
				lcResult	= lcResult + Iif (Inlist (lcStyle, 'Inherited Code', 'Inherited Value') And Not Empty (lcResult), '', .Result)
				lcClass		= .Class
				lcClassLib	= .Classlib
				lcParent	= .Parent
			Endwith
		
			*** JRN 12/26/2008 : Handling of members (pages, optionbuttons, etc)
			Do Case
				Case Thisform.lIsTopOfForm && nothing to do
		
				Case Lower(lcClass) == Lower(loObject.BaseClass) && nothing here either
		
				Case Thisform.GetPEMStatus(loObject.Parent, "MemberClass", 5)
					loDetailInfo = This.getparentcodedetailinfo (lcStyle, loObject.Parent.MemberClass, loObject.Parent.MemberClassLibrary, '', tcName, loObject)
					With loDetailInfo
						lcResult	= lcResult + Iif (Inlist (lcStyle, 'First Code', 'Inherited Code', 'Inherited Value') And Not Empty (lcResult), '', .Result)
						lcClass		= .Class
						lcClassLib	= .Classlib
						lcParent	= .Parent
					Endwith
		
				Case Thisform.GetPEMStatus(loObject.Parent, "HeaderClass", 5)
					loDetailInfo = This.getparentcodedetailinfo (lcStyle, loObject.Parent.HeaderClass, loObject.Parent.HeaderClassLibrary, '', tcName, loObject)
					With loDetailInfo
						lcResult	= lcResult + Iif (Inlist (lcStyle, 'First Code', 'Inherited Code', 'Inherited Value') And Not Empty (lcResult), '', .Result)
						lcClass		= .Class
						lcClassLib	= .Classlib
						lcParent	= .Parent
					Endwith
		
			Endcase
		
			****************************************************************
			If 'L' # Vartype (lcClassLib)
				Do Case
					Case Inlist (lcStyle, 'Code', 'All Code')
						lcResult = lcResult + This.addparentcodetext(lcStyle, ccLOC_VFP_Base_Class + lcClass, ccLOC_VFP_Base_Class + lcClass, '', '')
					Case Inlist (lcStyle, 'Value', 'Inherited Value')
						Local laProps(2)
						Select * From DefaultNativeProperties 				;
							Where cpropname = Upper(tcName) 				;
							And (Empty(cbaseclass) Or cbaseclass = Upper(loObject.BaseClass)) Into Array laProps
						Do Case
							Case _Tally = 0
								lcResult = lcResult + This.addparentcodetext(lcStyle, ccLOC_VFP_Base_Class + lcClass, ccLOC_VFP_Base_Class + lcClass, '', '')
							Case lcStyle = 'Value'
								lcResult = lcResult + This.addparentcodetext(lcStyle, ccLOC_VFP_Base_Class + lcClass, ccLOC_VFP_Base_Class + lcClass, '',		;
									tcName + ' = ' + Alltrim(laProps(_Tally, 3)))
							Case Empty(lcResult)
								lcResult = lcResult + This.addparentcodetext(lcStyle, ccLOC_VFP_Base_Class + lcClass, ccLOC_VFP_Base_Class + lcClass, '',		;
									Alltrim(laProps(_Tally, 3)))
						Endcase
				Endcase
			Endif
		
		Endif
		
		Use
		Select (lnSelect)
		Return lcResult
		
		Use
		
		Select (lnSelect)
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getparentcodedetailinfo
		Lparameters lcStyle, lcClass, lcClassLib, lcParent, tcName, loObject
		
		Local  ;
			loResult As "Empty"
		Local lbFileOpened, lcCurrentParent, lcFullName, lcMethodCode, lcObjectName, lcObjectPathName
		Local lcParent2, lcPEM, lcRelative, lcRelativeName, lcResult, lcSearchName, lcTempObject, lnPos
		Local lnRecno, loException
		
		lcResult 		= ''
		lcObjectName 	= loObject.Name
		lcPEM 			= tcName
		
		Do While Not Empty (lcClassLib)
			Try
				Use In (Select("VCX"))
				Use (lcClassLib) Again Shared Alias VCX
				lbFileOpened = .T.
			Catch To loException
				lbFileOpened = .F.
				lcResult = lcResult	+ ccBottomDividerLine	;
					+ Strtran (ccLOC_ViewParentCode_File_Failed, '<FileName>', "'" + lcClassLib + "'")	;
					+ ccCRLF + loException.Message			;
					+ ccCRLF + ccCRLF
				lcClassLib = '' && all done, can't even open file
			Endtry
		
			If lbFileOpened
				lcSearchName = Lower(lcPEM)
				If Empty(lcParent) && simple case ... this object defined here
					lcObjectPathName = lcClass
					Locate For Lower(OBJNAME) == lcClass And Lower(RESERVED1) = 'class'
					Do Case
		
						Case Inlist (lcStyle, 'Code', 'All Code', 'First Code', 'Inherited Code')
							lcMethodCode = Strextract(ccLF + Methods, ccLF + "procedure " + lcSearchName + ccCRLF, ccCRLF + "endproc",1,1)
		
						Case lcStyle = 'Value'
							lnPos = Atc(ccLF + lcSearchName + ' =', ccLF + properties)
							If lnPos > 0
								lcMethodCode = Substr(properties, lnPos ) && + Len(lcSearchName) + 3)
								lcMethodCode = This.GetParentCodeValue (lcSearchName, lcMethodCode)
							Else
								lcMethodCode = ''
							Endif
		
						Case lcStyle = 'Inherited Value'
							lnPos = Atc(ccLF + lcSearchName + ' =', ccLF + properties)
							If lnPos > 0
								lcMethodCode = Substr(properties, lnPos + Len(lcSearchName) + 3)
								lcMethodCode = This.GetParentCodeValue (lcSearchName, lcMethodCode)
							Else
								lcMethodCode = ''
							Endif
		
					Endcase
		
				Else && this object inherited as object in parent class
		
					* (1)  have to back up through parentage to see where this object is defined in the class
					* (2)  for some objects, the method code may be saved farther back!
					lcObjectPathName = lcParent + "." + lcObjectName
					lnRecno			= 0
					lcTempObject 	= Lower(lcObjectPathName)
					lcCurrentParent = lcParent
					lcMethodCode 	= ''
					Do While Not Empty(lcTempObject) And Empty(lcMethodCode)
						Locate For lcTempObject == Lower( IIf(Empty(Parent), "", Parent + ".") + OBJNAME) ;
							And (Lower(RESERVED1) # 'class' Or Not '.' $ lcTempObject)
						If Found() And (lnRecno = 0 Or Inlist (Lower(BaseClass), 'pageframe', 'grid'))
							lcParent2 = Substr(lcCurrentParent, 2 + Len( lcTempObject))
							If lnRecno = 0
								lnRecno = Recno()
								Do Case
									Case Len( lcTempObject) > Len(lcCurrentParent)
										lcParent 		= ''
										lcSearchName	= lcPEM
									Case Empty(lcParent2)
										lcParent		= VCX.Class
										lcSearchName	= lcObjectName + '.' + lcPEM
									Otherwise
										lcParent 		= VCX.Class + '.' + lcParent2
										lcSearchName	= lcParent2 + '.' + lcObjectName + '.' + lcPEM
								Endcase
							Endif
							*	lcSearchName = Icase( 						;
							Empty(lcParent2), lcPEM, 				;
							"." $ lcTempObject, lcParent2 + "." + lcObjectName + "." + lcPEM,	;
							lcParent2 + "." + lcPEM				;
							)
							Do Case
		
								Case Inlist (lcStyle, 'Code', 'All Code', 'First Code', 'Inherited Code')
									lcMethodCode = Strextract(ccLF + Methods, ccLF + "procedure " + lcSearchName + ccCRLF, ccCRLF + "endproc",1,1)
		
								Case lcStyle = 'Value'
									lnPos = Atc(ccLF + lcSearchName + ' =', ccLF + properties)
									If lnPos > 0
										lcMethodCode = Substr(properties, lnPos ) && + Len(lcSearchName) + 3)
										lcMethodCode = This.GetParentCodeValue (lcSearchName, lcMethodCode)
									Else
										lcMethodCode = ''
									Endif
		
								Case lcStyle = 'Inherited Value'
									lnPos = Atc(ccLF + lcSearchName + ' =', ccLF + properties)
									If lnPos > 0
										lcMethodCode = Substr(properties, lnPos + Len(lcSearchName) + 3)
										lcMethodCode = This.GetParentCodeValue (lcSearchName, lcMethodCode)
									Else
										lcMethodCode = ''
									Endif
		
							Endcase
						Endif
		
						If "." $ lcTempObject
							lcTempObject = Juststem(lcTempObject)
						Else
							lcTempObject = ''
						Endif
		
					Enddo
		
					If lnRecno # 0
						Goto (lnRecno)
					Endif
		
				Endif
		
				If Found()
					lcRelative = Sys(2014, lcClassLib)
					lcRelativeName = IIf(lcRelative # '..\..\..\' And Getwordcount(lcRelative, '\') < Getwordcount(lcClassLib, '\'), lcRelative, lcClassLib)
					lcFullName = lcObjectPathName + '.' + lcPEM + '()' + ' of ' + lcRelativeName
		
					If Not (Inlist (lcStyle, 'Inherited Code', 'Inherited Value') And Not Empty (lcResult))
						lcResult = lcResult + This.addparentcodetext(lcStyle, lcPEM, lcObjectPathName, lcRelativeName, lcMethodCode)
					Endif
		
					lcClass = VCX.Class
					Do Case
						Case Inlist (lcStyle, 'Code', 'All Code') And (ccCRLF + '*' + Lower(lcPEM) + ' ') $ ccCRLF + Reserved3
							lcClassLib = .F. && custom in this class; don't go any further
						Case Inlist (lcStyle, 'Value') And (ccCRLF + Lower(lcPEM) + ' ' ) $ ccCRLF + Strtran(Reserved3, ccCRLF, ' ' + ccCRLF)
							lcClassLib = .F. && custom in this class; don't go any further
						Case Inlist (lcStyle, 'Inherited Value') And (ccCRLF + Lower(lcPEM) + ' ' ) $ ccCRLF + Strtran(Reserved3, ccCRLF, ' ' + ccCRLF)
							lcClassLib = .F. && custom in this class; don't go any further
							If Empty(lcResult)
								lcResult = ".F."
							Endif
						Case Empty(VCX.ClassLoc)
							Exit && baseclass
						Otherwise
							*** DougHennig 12/06/2008: VCX.ClassLoc is relative to the open class library
							lcClassLib = Thisform.GetClassFileName(VCX.ClassLoc, Addbs(Justpath(lcClassLib)))
					Endcase
		
				Else
					lcResult = lcResult	+ ccBottomDividerLine	;
						+ Strtran (Strtran (ccLOC_ViewParentCode_Class_Failed, '<FileName>', "'" + lcClassLib + "'"), '<ClassName>', lcObjectPathName ) 	;
						+ ccCRLF + ccCRLF
					lcClassLib = ''
				Endif
		
			Endif
		
			Use
		
		Enddo
		
		Use In (Select("VCX"))
		loResult = Createobject("Empty")
		AddProperty (loResult, "Result", 	lcResult)
		AddProperty (loResult, "Class", 	lcClass)
		AddProperty (loResult, "ClassLib", 	lcClassLib)
		AddProperty (loResult, "Parent", 	lcParent)
		Return loResult
		
	ENDPROC

	PROCEDURE getparentcodesetupinfo
		Lparameters lcClass, lcClassLib, loObject
		Local loResult, lcParent
		
		loResult = Createobject("Empty")
		
		Use In (Select("VCX"))
		*** JRN 12/12/2008 : special case for classes when at top of form
		* since class and classlib point to the current class, not the parent
		If Thisform.lClass And loObject = Thisform.oTopOfForm
			Use (lcClassLib) Again Shared Alias VCX
			Locate For Lower(OBJNAME) == lcClass and Lower(RESERVED1) = 'class'
		
			If Found()
				lcClass = VCX.Class
				If Not Empty(VCX.ClassLoc)
					lcClassLib = Thisform.GetClassFileName(VCX.ClassLoc, Addbs(Justpath(lcClassLib)))
				Else
					lcClassLib = ''
				Endif
			Else
				lcClass = ''
				lcClassLib = ''
			Endif
		Else
			* if this object was inherited as an object contained in another class,
			* get the full object name in that class
			* special handling for pages, columns, and buttons, since their names are not read-only
			* even when inherited
		
			Do While .T.
		
				Do Case
					Case loObject = Thisform.oTopOfForm
						Exit && obviously at top of class/form
					Case Thisform.Isreadonly(loObject, "Name")
						* if name is read-only, continue -- must be part of parent class
					Case Inlist(Lower(loObject.BaseClass) + '#', 'page#', 'column#', 'optionbutton#', 'header#')
						* any of these baseclasses must be part of parent class ... #'s because of pageframe match
					Otherwise && for all others, we must be done
						Exit
				Endcase
		
				lcParent = loObject.Parent.Name + Iif( Empty(lcParent), '', "." + lcParent)
				loObject = loObject.Parent
				lcClassLib = loObject.ClassLibrary
			Enddo
		
			* but the topmost name must be the name of the class, not the name of the object here
			
			If Thisform.lClass and loObject = ThisForm.oTopOfForm
				lcClassName = loObject.ParentClass
			Else
				lcClassName = loObject.Class
			EndIf
			
			Do Case
				Case Empty(lcParent)
		
				Case Not "." $ lcParent
					lcParent = lcClassName 
		
				Otherwise
					lcParent = lcClassName  + Substr(lcParent, At(".", lcParent))
		
			Endcase
		Endif
		
		Use In (Select("VCX"))
		AddProperty (loResult, "Class", 	lcClass)
		AddProperty (loResult, "ClassLib", 	lcClassLib)
		AddProperty (loResult, "Parent", 	lcParent)
		Return loResult
		
	ENDPROC

	PROCEDURE getparentcodevalue
		Lparameters lcName, lcProperties
		Local lnPos, lnLen, lcResult
		
		lnPos = 1
		
		* We have to handle properties with more than 255 characters in the value
		* differently.
		
		If Substr(lcProperties, lnPos, 1) = ccPROPERTIES_PADDING_CHAR
			lnLen        = Val(Alltrim(Substr(lcProperties, ;
				lnPos + cnPROPERTIES_PADDING_SIZE, ;
				cnPROPERTIES_LEN_SIZE)))
			lcResult = Left (lcProperties, lnPos - 1) + Substr(lcProperties, lnPos + ;
				cnPROPERTIES_PADDING_SIZE + cnPROPERTIES_LEN_SIZE, ;
				lnLen)
		Else
			lcResult = Strextract(lcProperties, '', Chr(13))
		Endif Substr(lcProperties, lnPos, 1) = ccPROPERTIES_PADDING_CHAR
		
		Return Evl (lcResult, [''])
	ENDPROC

	PROCEDURE getvalue
		Lparameters lcName, tbNative, tcResultType, tnObjNumber, tcDescript
		
		Local lcPem, lbFirst, lcValue, lxValue, lcNewValue, lxNewValue, lnRed, lnGreen, lnBlue
		Local loObject, lbTransform, loResult, lcTypes, lcNewType, laValue(1), lcEditor, lnValue
		Local laValues(1), lnI, lnJ, lnK, lcEval
		
		If Isnull(Thisform.oObject)
			Return ''
		Endif
		
		If Not Thisform.lEditingOneProperty
			lcPem = Thisform.JustPem(lcName)
		Else
			lcPem = Trim(Thisform.cEditPropertyName)
		Endif
		
		If Indexseek (lcPem + ' ', .T., "PropertyList")
			lcEditor = PropertyList.Editor
		Else
			lcEditor = 'None'
		Endif
		
		lbTransform = .T.
		
		*** JRN 03/18/2009 : modifications to handle multiple objects
		Do Case
			Case Not Empty(tnObjNumber)
				loObject = Thisform.aSelectedObjects(tnObjNumber)
				lcPem = Thisform.cEditPropertyName
				lcValue = loObject.ReadExpression (lcPem)
				lxValue = This.Get1Value (loObject, lcPem)
				lcTypes = Vartype (lxValue)
		
			Case (Thisform.lUseCSO) And Thisform.nSelectedObjects > 1
				lbFirst = .T.
		
				For lnI = 1 To Alen(Thisform.aSelectedObjects)
					loObject = Thisform.aSelectedObjects(lnI)
					Do Case
						Case Not Thisform.GetPEMStatus (loObject, lcPem, 5)
		
						Case lbFirst
							lcValue = loObject.ReadExpression (lcPem)
							lxValue = This.Get1Value (loObject, lcPem)
							lbFirst = .F.
							lcTypes = Vartype (lxValue)
							If lcTypes = 'O'
								lcValue = '(Object)'
								lxValue = '(Object)'
							Endif
						Otherwise
							lcNewValue = loObject.ReadExpression (lcPem)
							lxNewValue = This.Get1Value (loObject, lcPem)
							lcNewType  = Vartype (lxValue)
							If lcNewType = 'O'
								lcNewValue = '(Object)'
								lxNewValue = '(Object)'
							Endif
							If lbTransform
								If (Not lcValue == lcNewValue)							;
										or Vartype (lxValue) # Vartype (lxNewValue)		;
										or lxValue # lxNewValue
									lcValue = ' '
									lbTransform = .F.
									lcTypes = lcTypes + IIf (lcNewType $ lcTypes, '', lcNewType)
								Endif
							Else
								lcTypes = lcTypes + IIf (lcNewType $ lcTypes, '', lcNewType)
							Endif
					Endcase
				Endfor
				If lbFirst && may occur if OLE is only control having this property
					lcValue = ''
					lxValue = ''
					lcTypes = '?'
					lbTransform  = .F.
				Endif
			Otherwise
				Try
					lcValue = Thisform.oObject.ReadExpression (lcPem)
					lxValue = This.Get1Value (Thisform.oObject, lcPem)
					lcTypes = Vartype (lxValue)
				Catch
					lcValue = ''
					lxValue = ''
					lcTypes = '?'
					lbTransform  = .F.
				Endtry
		
		Endcase
		
		If lbTransform And Empty (lcValue)
			Do Case
					* handle null values
		
				Case Isnull(lxValue)
					lcValue = '.NULL.'
					* Special handling for native colors
		
				Case (tbNative And lcEditor = 'Color')			;
						or (									;
						"N" = Vartype (lxValue)					;
						and Thisform.IsCustomColor (tcDescript)	;
						)
					lnRed   = Bitand(lxValue, 255)
					lnGreen = Bitrshift(Bitand(lxValue, 256 * 255), 8)
					lnBlue  = Bitrshift(Bitand(lxValue, 256 * 256 * 255), 16)
					lcValue = Transform(lnRed) + ',' + Transform(lnGreen) + ',' + Transform(lnBlue)
		
					* Native properties with enumerated values
				Case tbNative 									;
						and lcEditor = 'Combo'					;
						and Not (								;
						lcEditor = 'ComboMult' 					;
						And Thisform.nSelectedObjects # 1 		;
						And Not Thisform.lEditingOneProperty	;
						)
		
					If Thisform.nSelectedObjects = 1
						Thisform.GetComboValues (@laValues, lcPem, lcEditor, Thisform.oObject.BaseClass)
						lnValue = Thisform.Get1Value (Thisform.oObject, lcPem)
					Else
						If Thisform.lEditingOneProperty
							loObject = Thisform.aSelectedObjects(csrMembers.nObjNumber)
							Thisform.GetComboValues (@laValues, lcPem, lcEditor, loObject.BaseClass)
							lnValue = Thisform.Get1Value (loObject, lcPem)
						Else
							For lnJ = 1 To Alen ( Thisform.aSelectedObjects)
								loObject = Thisform.aSelectedObjects(lnJ)
								If Thisform.GetPEMStatus (loObject, lcPem, 5)
									Thisform.GetComboValues (@laValues, lcPem, lcEditor, loObject.BaseClass)
									lnValue = Thisform.Get1Value (loObject, lcPem)
									Exit
								Endif
							Endfor
						Endif
					Endif
		
					If 1 # Alen(laValues)
						lcValue = Transform( lnValue )
						For lnI = 1 To Alen (laValues, 1)
							If laValues(lnI,1) = lnValue
								lcValue = laValues(lnI,2)
								Exit
							Endif
						Endfor
					Endif
		
					* Customize properties with enumerated values
				Case Thisform.GetCustomComboValues (@laValues, lcPem, tcDescript)
		
					If Thisform.nSelectedObjects = 1
						lnValue = Thisform.Get1Value (Thisform.oObject, lcPem)
					Else
						If Thisform.lEditingOneProperty
							loObject = Thisform.aSelectedObjects(csrMembers.nObjNumber)
							lnValue = Thisform.Get1Value (loObject, lcPem)
						Else
							For lnK = 1 To Alen (Thisform.aSelectedObjects)
								loObject = Thisform.aSelectedObjects(lnK)
								If Thisform.GetPEMStatus (loObject, lcPem, 5)
									lnValue = Thisform.Get1Value (loObject, lcPem)
									Exit
								Endif
							Endfor
						Endif
					Endif
		
					lcValue = Transform( lnValue )
					For lnI = 1 To Alen (laValues, 1)
						If Vartype (laValues(lnI,1)) = Vartype (lnValue) And laValues(lnI,1) = lnValue
							lcValue = laValues(lnI,2)
							Exit
						Endif
					Endfor
		
					* Customize properties with enumerated values
				Case Thisform.GetCustomEvaluated (@lcEval, tcDescript)
					Try
						With Thisform.oObject
							lcValue = Transform(Evaluate(lcEval))
						Endwith
					Catch
						lcValue = ''
					Endtry
		
				Case 'C' = Vartype (lxValue) And 0 = Len(lxValue) And tcResultType= 'Display'
					lcValue = '(None)'
		
				Case 'N' = Vartype (lxValue)
					lcValue = Alltrim (Transform( lxValue ))
		
				Case 'D' # Vartype (lxValue)
					lcValue = Transform( lxValue )
		
				Case Empty (lxValue)
					lcValue = '{}'
		
				Otherwise
					lcValue = '{^' + Transform(Year(lxValue)) + "/" + Transform(Month(lxValue)) + "/" + Transform(Day(lxValue)) + "}"
		
			Endcase
		Endif
		
		Do Case
			Case tcResultType= 'Display'
				Return Left (lcValue, 100)
			Case tcResultType= 'Full Value'
				Return lcValue
			Case tcResultType= 'For Editing'
				loResult = Createobject("Empty")
				AddProperty (loResult, "Value", lxValue)
				AddProperty (loResult, "CharValue", lcValue)
				AddProperty (loResult, "Type", lcTypes)
				AddProperty (loResult, "SingleValue", lbTransform)
				Return loResult
		Endcase
		
		
	ENDPROC

	PROCEDURE Init
		If Not PEME_IsVersion9()
			This.BorderStyle = 2
		Endif
		
		DoDefault()
	ENDPROC

	PROCEDURE insertformorclass
		Lparameters lcCaption
		
		If This.lClass
			Return Strtran(lcCaption, '<insert2>', ccLOC_CAP_FC_class)
		Else
			Return Strtran(lcCaption, '<insert2>', ccLOC_CAP_FC_Form)
		Endif
		
	ENDPROC

	PROCEDURE insureformvisible
		Local loObject As Object
		Local lnMaxHeight, lnMaxLeft, lnMaxTop, lnMaxWidth
		
		loObject = Thisform
		*** JRN 2009-09-14 : Following code courtesy of Doug Hennig's blog
		#Define SM_XVIRTUALSCREEN  76     && virtual left
		#Define SM_YVIRTUALSCREEN  77     && virtual top
		#Define SM_CXVIRTUALSCREEN 78   && virtual width
		#Define SM_CYVIRTUALSCREEN 79   && virtual height
		* #Define SM_CXFULLSCREEN    16     && screen width accounting for taskbar
		* #Define SM_CYFULLSCREEN    17     && screen height accounting for taskbar
		
		Do Case
			Case This.GetPEMStatus(loObject, 'Dockable', 5) And loObject.Dockable = 1
				Declare Integer GetSystemMetrics In Win32API Integer
				lnMaxLeft   = GetSystemMetrics(SM_XVIRTUALSCREEN)
				lnMaxTop    = GetSystemMetrics(SM_YVIRTUALSCREEN)
				lnMaxWidth  = GetSystemMetrics(SM_CXVIRTUALSCREEN)
				lnMaxHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN)
			Case This.GetPEMStatus(loObject, 'Desktop', 5) And (loObject.Desktop Or loObject.ShowWindow = 2)
				Declare Integer GetSystemMetrics In Win32API Integer
				lnMaxLeft   = GetSystemMetrics(SM_XVIRTUALSCREEN)
				lnMaxTop    = GetSystemMetrics(SM_YVIRTUALSCREEN)
				lnMaxWidth  = GetSystemMetrics(SM_CXFULLSCREEN)
				lnMaxHeight = GetSystemMetrics(SM_CYFULLSCREEN)
			Otherwise
				lnMaxLeft   = 0
				lnMaxTop    = 0
				lnMaxWidth  = _Screen.Width
				lnMaxHeight = _Screen.Height - ;
					Iif(This.GetPEMStatus(loObject, 'TitleBar', 5) And ;
					loObject.TitleBar = 1, Sysmetric(9), 0)
				&& account for the title bar height if necessary
		Endcase
		
		loObject.Width = Min(Max(loObject.Width, 0, loObject.MinWidth), ;
			lnMaxWidth)
		loObject.Height = Min(Max(loObject.Height, 0, loObject.MinHeight), ;
			lnMaxHeight)
		
		Do Case
		
				* If we're past the left edge, move it to the left edge.
		
			Case loObject.Left < lnMaxLeft
				loObject.Left = lnMaxLeft
		
				* If we're past the right edge of the screen, move it to the right edge.
		
			Case loObject.Left + loObject.Width > lnMaxWidth + lnMaxLeft
				loObject.Left = lnMaxWidth + lnMaxLeft - loObject.Width
		Endcase
		Do Case
		
				* If we're past the top edge, move it to the top edge.
		
			Case loObject.Top < lnMaxTop
				loObject.Top = lnMaxTop
		
				* If we're past the bottom edge of the screen, move it to the bottom edge.
		
			Case loObject.Top + loObject.Height > lnMaxHeight + lnMaxTop
				loObject.Top = lnMaxHeight + lnMaxTop - loObject.Height
		Endcase
		****************************************************************
		****************************************************************
		
	ENDPROC

	PROCEDURE iscustomcolor
		Lparameters tcDescript
		
		Return Not Empty(ThisForm.GetDOPEText(tcDescript, 'Color'))
		
	ENDPROC

	PROCEDURE iscustomspinner
		Lparameters tcDescript
		
		Return Not Empty(ThisForm.GetDOPEText(tcDescript, 'Spinner'))
		
	ENDPROC

	PROCEDURE isnativecolor
		Lparameters tcName, tbNative
		
		Return tbNative and InList (tcName,	;
			  'BackColor', 					;
			  'ForeColor', 					;
			  'BorderColor', 				;
			  'DisabledBackColor', 			;
			  'DisabledForeColor', 			;
			  'DisabledItemBackColor', 		;
			  'DisabledItemForeColor', 		;
			  'FillColor', 					;
			  'GridLineColor', 				;
			  'HighlightBackColor', 		;
			  'HighlightForeColor', 		;
			  'ItemBackColor', 				;
			  'ItemForeColor', 				;
			  'SelectedItemBackColor',		;
			  'SelectedItemForeColor'		;
			  )
			  
		
	ENDPROC

	PROCEDURE isreadonly
		Lparameters loObject, lcPem
		
		Local lbResult
		
		Try
			lbResult = Thisform.GetPEMStatus( loObject, lcPem, 1 )
		Catch
			lbResult = .F.
		Endtry
		
		Return lbResult
		
	ENDPROC

	PROCEDURE Load
		DoDefault()
		
		With This
			.cApplicationPath = Addbs (Justpath (Justpath  (This.ClassLibrary)))
			.cPlugInPath = .cApplicationPath + 'Live Plug-Ins\'
			.cSnippetPath = .cApplicationPath + 'Dynamic Snippets\'
		Endwith
		
	ENDPROC

	PROCEDURE loadnode
		Lparameters toTree, loControl, lcParentKey, lcPath
		
		Local  ;
			loNode As Object	,;
			loTag As "Empty"
		Local lbAnyMethods, lcKey, lcName, lcObjectPath, lcText
		
		With toTree
			lcKey  = 'Node' + Transform(.Nodes.Count)
			lcName = loControl.Name
			If Thisform.lDataEnvironment And Not Empty(loControl.Alias)
				lcText = loControl.Alias
			Else
				lcText = lcName
			Endif
		
			Do Case
				Case Not Thisform.oPrefs.lTreeShowCaptions
		
				Case Thisform.GetPEMStatus (loControl, 'Caption', 5) And Not Empty (loControl.Caption)
					If 25 > Len (loControl.Caption)
						lcText = lcText + [ - ('] + loControl.Caption + [')]
					Else
						lcText = lcText + [ - ('] + Left (loControl.Caption, 20)  + [ ... ')]
					Endif
				Case Thisform.GetPEMStatus (loControl, 'ControlSource', 5) And Not Empty (loControl.ControlSource)
					lcText = lcText + [ - (] + loControl.ControlSource + [)]
				Case Thisform.GetPEMStatus (loControl, 'RecordSource', 5) And Not Empty (loControl.RecordSource)
					lcText = lcText + [ - (] + loControl.RecordSource + [)]
				Case Thisform.GetPEMStatus (loControl, 'cControlSource', 5) And Not Empty (loControl.cControlSource)
					lcText = lcText + [ - (] + loControl.cControlSource + [)]
			Endcase
		
			lcText = Thisform.AddClassInfo(loControl, lcText)
		
			loNode     	= .Nodes.Add(lcParentKey, 4, lcKey, lcText, Lower(loControl.BaseClass))
		
			lcObjectPath = lcPath + '.' + lcName
			loTag = Createobject("Empty")
			AddProperty (loTag, 'Type', 'Object')
			AddProperty (loTag, 'Path', lcObjectPath)
			AddProperty (loTag, 'Found', .F.)
		
			With loNode
				.Tag = loTag
				If Thisform.GetPEMStatus(loControl, 'Name', 1)
					.BackColor = Rgb(224, 224, 224)
				Endif
		
				If Thisform.oPrefs.lExpandAllNodes
					.Expanded = .T.
				Endif
		
				If Upper (lcObjectPath) == Upper (Thisform.cCurrentObjectName)
					.Selected = .T.
					.Expanded = .T.
					.EnsureVisible()
				Endif
			Endw
		
			lbAnyMethods = This.LoadTree(toTree, loControl, lcObjectPath, lcKey)
		
			* Done this way ... because if no methods, loNode may no longer exist!
			If lbAnyMethods
				loNode.Expanded = .T.
			Endif
		
		Endwith
		
		Return lbAnyMethods
		
	ENDPROC

	PROCEDURE loadtree
		* Load the TreeView with the objects. We'll use the object name as both the
		* text and the key and an image with that same name as the image. We'll store
		* the object path to Tag.
		
		*** JRN 02/14/2009 : Modified so that the key is NOT the name of the object,
		* since there can be duplicate names.  Name of nodes are ROOT, NODE2, NODE3, NODE4
		* and the name of the parent is the third parameter
		
		Lparameters toTree,		;
			toParent, 			;
			tcPath,				;
			tcParentKey
		
		Local loControl As Object
		Local loNode As Object
		Local loParent As Object
		Local loParentNode As Object
		Local loResult As Object
		Local loTag As "Empty"
		
		Local laControls(1), lbAnyMethods, lcClassInfo, lcKey, lcMethodCode, lcName, lcParentKey, lcPath, lcStartNode, lcTag
		Local lcText, lnControlCount, laControls(1), lnI
		
		lbAnyMethods = .F.
		
		With toTree
		
			* If we're being called to display the root, get the top-most object and add it
			* to the TreeView. Otherwise, just use the object we were passed.
		
			If Vartype(toParent) <> 'O'
		
				If Thisform.lDataEnvironment
					Local laDataEnvironment(1)
					Aselobj(laDataEnvironment,2)
					loParent = laDataEnvironment(1)
				Else
					loParent	= Thisform.oTopOfForm
				Endif
		
				lcName    	= Thisform.AddClassInfo( loParent, loParent.Name)
				lcTag 		= ' ' + Proper(Thisform.InsertFormOrClass('<insert2>'))
				lcPath		= ''
		
				*** JRN 07/28/09 : Restrict to an object and its children
				lcStartNode = Thisform.cTreeStartNode
				If Not Empty(lcStartNode)								;
						and Lower(Thisform.GetObjectPath(Thisform.oObject)) = Lower(lcStartNode)
					loParent = Evaluate("Thisform.oTopofForm" + lcStartNode)
					lcName 	= Thisform.AddClassInfo( loParent, loParent.Name)
					lcTag	= lcStartNode
					lcPath	= lcStartNode
				Else
					Thisform.cTreeStartNode = ''
				Endif
		
				lcKey		= 'Root'
				lcParentKey = lcKey
		
				loParentNode 		= .Nodes.Add(, 1, lcKey, lcName, Lower(loParent.BaseClass))
				loTag = Createobject("Empty")
				AddProperty (loTag, 'Type', 'Object')
				AddProperty (loTag, 'Path', lcPath)
				AddProperty (loTag, 'Found', .F.)
				With loParentNode
					.Tag 	= loTag
					.Expanded = .T.
					.Selected = .T.
				Endwith
		
				If Thisform.lTreeViewShowMethods
					Thisform.oServer.MakeCurrent()
		
					Select * From csrMembers Where .F. Into Cursor csrMembersTemp Readwrite
					With Thisform.oMemberDataEngine
						.lClassDesigner = Thisform.lClass
						.oObject = loParent
						.SetupEngine()
						.CreateMemberMethodList ('csrMembersTemp', .T., .F., This.lNoErrorMsgOnMissingVCX)
					Endwith
					Select * 												;
						, cName 						As SortKey			;
						From csrMembersTemp									;
						where Inlist (cType, 'M', 'E')						;
						into Cursor cMyMembers Readwrite
		
				Endif
			Else
				loParent = toParent
				lcPath   = tcPath
				lcParentKey = tcParentKey
		
				If Thisform.lTreeViewShowMethods
					loResult = Thisform.oServer.GetMethodList(loParent, Thisform.lClass, Thisform.lIsTopOfForm And Thisform.lClass)
					Create Cursor cMyMembers (cName C(128), cType C(1), SortKey C(128))
					Append From Array loResult.MethodList
				Endif
			Endif
		
			****************************************************************
			* Adding methods
			If Thisform.lTreeViewShowMethods
		
				Do Case
					Case Thisform.oPrefs.nTreeSortMethods = 1
						Replace All SortKey With Upper(cName)
					Case Thisform.oPrefs.nTreeSortMethods = 2
						Replace All SortKey With cName
				Endcase
				Index On SortKey Tag Order
		
				Select cMyMembers
				Scan
					lcName = Trim (cName)
					lcMethodCode = loParent.ReadMethod (lcName)
		
					If Not Empty (lcMethodCode)
						lbAnyMethods = .T.
						lcKey		= 'Node'+Transform(.Nodes.Count)
						lcText		= lcName
		
						loNode     	= .Nodes.Add(lcParentKey, 4, lcKey, lcText, Lower(IIf(cType = 'M', 'Method', 'Event')))
						With loNode
							loTag = Createobject("Empty")
							AddProperty (loTag, 'Type', 'Method')
							AddProperty (loTag, 'Path', lcPath)
							AddProperty (loTag, 'MethodName', cName)
							AddProperty (loTag, 'Found', .F.)
							.Tag = loTag
							.ForeColor = Rgb(0,0,255)
							.Bold	= .T.
						Endwith
					Endif
				Endscan
		
				Use In cMyMembers
		
			Endif
		
			****************************************************************
		
			* If the object is a container of some type, add each contained object to the
			* TreeView and then call LoadTree recursively to add that object's contained
			* objects.
		
			lnCount = Thisform.CreateSortedObjectArray (loParent, @laControls)
		
			For lnI = 1 To lnCount
				Try
					loControl = loParent.Objects(laControls(lnI,1))
					lbAnyMethods  = This.loadnode(toTree, loControl, lcParentKey, lcPath) Or lbAnyMethods
				Catch
				
				Endtry
			Next lnI
		
			If .Nodes.Count > 1 							;
					and .Nodes(lcParentKey).Children = 0 	;
					And Thisform.lTreeViewShowMethods		;
					and Not Thisform.lTreeViewAllControls
				.Nodes.Remove(lcParentKey)
			Endif
		
			If Vartype(toParent) <> 'O'
				Select csrMembers
		
				* curiously, EnsureVisible again because, with items removed, etc, it might not be visible!
				.Nodes(.Nodes.Count).EnsureVisible()
				If Vartype (.SelectedItem) = 'O'
					.SelectedItem.EnsureVisible()
					Thisform.SaveNodeHighlighting(toTree, 'Selected')
				Else
					loParentNode.EnsureVisible()
					Thisform.SaveNodeHighlighting(toTree, 'Nothing')
				Endif
			Endif
		
		Endwith
		
		Return lbAnyMethods
		
	ENDPROC

	PROCEDURE savenodehighlighting
		Lparameters toTree, tcAction, tcCurrentObjectName
		
		If Thisform.lPEMEditor
			Return
		Endif
		
		Local loBottomNode As Object
		Local loNode As Object
		Local loTag As Object
		Local loTopNode As Object
		Local llFound, llOneMore
		
		With toTree
			Do Case
		
				Case tcAction = 'Selected' && save current node, change its colors, make no node selected
					loNode = .SelectedItem
					Thisform.cTreeViewKey = loNode.Key
					Thisform.nTreeViewForeColor = loNode.ForeColor
					Thisform.nTreeViewBackColor = loNode.BackColor
					loNode.ForeColor = Thisform.nHighlightForeColor
					loNode.BackColor = Thisform.nHighlightBackColor
					.SelectedItem = .Null.
		
				Case tcAction = 'Nothing' && no current node!
					Thisform.cTreeViewKey = .SelectedItem.Key
					.SelectedItem = .Null.
		
				Case tcAction = 'Restore' && restore colors for previously selected node.
					If Not Empty(Thisform.cTreeViewKey)
						loNode = toTree.Nodes(Thisform.cTreeViewKey)
						loNode.ForeColor = Thisform.nTreeViewForeColor
						loNode.BackColor = Thisform.nTreeViewBackColor
					Endif
		
				Case tcAction = 'Reset' && reset previously selected node BACK to the (faked) highlight color
					If Not Empty(Thisform.cTreeViewKey)
						loNode = toTree.Nodes(Thisform.cTreeViewKey)
						loNode.ForeColor = Thisform.nHighlightForeColor
						loNode.BackColor = Thisform.nHighlightBackColor
					Endif
		
				Case tcAction = 'Find' && find and highlight an object
					This.SaveNodeHighlighting (toTree, 'Restore')
					If Empty(tcCurrentObjectName)
						loNode = toTree.Nodes(1)
						.SelectedItem = loNode
						loNode.EnsureVisible()
						This.SaveNodeHighlighting (toTree, 'Selected')
					Else
						llFound = .F.
						llOneMore = .F.
						For Each loNode In toTree.Nodes
							loTag = loNode.Tag
							Do Case
								Case loTag.Type = 'Object' And loTag.Path == tcCurrentObjectName
									loTopNode = loNode
									loBottomNode = loNode
									llFound = .T.
									llOneMore = .T.
								Case llFound And loTag.Path = tcCurrentObjectName
									loBottomNode = loNode
								Case llOneMore
									loBottomNode = loNode
									llOneMore = .F.
							Endcase
						Endfor
		
						If llFound
							loBottomNode.EnsureVisible()
							.SelectedItem = loTopNode
							loTopNode.EnsureVisible()
							This.SaveNodeHighlighting (toTree, 'Selected')
						Endif
					Endif
		
			Endcase
		Endwith
		
	ENDPROC

	PROCEDURE setoletooltips
		Lparameters toObject, tlFlag
		
		Declare Integer SetWindowLong In user32;
			INTEGER HWnd,;
			INTEGER nIndex,;
			INTEGER dwNewLong
		
		Declare Integer GetWindowLong In user32;
			INTEGER HWnd, Integer nIndex
		
		#Define  TVS_NOTOOLTIPS 	128
		#Define  GWL_STYLE 			-16
		
		If tlFlag
			* turn Treeview ItemTips ON
			SetWindowLong (toObject.HWnd, GWL_STYLE, ;
				BITAND(GetWindowLong(toObject.HWnd, GWL_STYLE) ,Bitnot(TVS_NOTOOLTIPS)))
		
		Else
			* turn Treeview ItemTips OFF
			SetWindowLong (toObject.HWnd, GWL_STYLE, ;
				BITOR(GetWindowLong(toObject.HWnd, GWL_STYLE) ,TVS_NOTOOLTIPS))
		
		Endif
		
	ENDPROC

	PROCEDURE sortgrid
	ENDPROC

	PROCEDURE spellcodeorigin
		Lparameters lcType, llSys1269, llLocalCode
		
		Do case
			Case lcType = 'P'
				Return ''
			Case llLocalCode
				Return ccLOC_CAP_CO_Local 
			Case llSys1269
				Return ccLOC_CAP_CO_Inherited
			Otherwise
				Return ''
		endcase		
			
	ENDPROC

	PROCEDURE spellfavorites
		Lparameters tnFavorites
		
		*** JRN 11/20/2008 : Spelling for Parentage (formerly Hierarchy) - based on abbreviations flag
		If Thisform.lUseAbbreviations
			Return IIF(tnFavorites=1, ccLOC_Cap_Fav_NoneA, IIF(tnFavorites=2, ccLOC_Cap_Fav_LocalA, IIF(tnFavorites=3, ccLOC_Cap_Fav_GlobalA, ccLOC_Cap_Fav_BothA))) 
		Else
			Return IIF(tnFavorites=1, ccLOC_Cap_Fav_None, IIF(tnFavorites=2, ccLOC_Cap_Fav_Local, IIF(tnFavorites=3, ccLOC_Cap_Fav_Global, Substr(ccLOC_Cap_Fav_Both,2)))) 
		Endif
		
		
	ENDPROC

	PROCEDURE spellhierarchy
		Lparameters tbNative, tbInherited
		
		*** JRN 11/20/2008 : Spelling for Parentage (formerly Hierarchy) - based on abbreviations flag
		If Thisform.lUseAbbreviations
			Return IIF (tbNative, ccLOC_CAP_Hierarchy_NativeA, IIF(tbInherited, ccLOC_CAP_Hierarchy_InheritedA, ccLOC_CAP_Hierarchy_CustomA))  
		Else
			Return IIF (tbNative, ccLOC_CAP_Hierarchy_Native, IIF(tbInherited, ccLOC_CAP_Hierarchy_Inherited, ccLOC_CAP_Hierarchy_Custom)) 
		Endif
		
	ENDPROC

	PROCEDURE spelltype
		Lparameters tcType
		
		*** JRN 11/20/2008 : Spelling for Type - based on abbreviations flag
		If Thisform.lUseAbbreviations
			Return IIF (tcType = 'P', ccLOC_CAP_Type_PropertyA, IIF(tcType = 'M', ccLOC_CAP_Type_MethodA, IIF(tcType = 'E', ccLOC_CAP_Type_EventA, ''))) 
		Else
			Return IIF (tcType = 'P', ccLOC_CAP_Type_Property, IIF(tcType = 'M', ccLOC_CAP_Type_Method, IIF(tcType = 'E', ccLOC_CAP_Type_Event, '')))  
		Endif
		
		
	ENDPROC

	PROCEDURE spellvisibility
		Lparameters tnVisibility
		
		*** JRN 11/20/2008 : Spelling for Visibility - based on abbreviations flag
		If Thisform.lUseAbbreviations
			Return Iif (tnVisibility = 1, ccLOC_CAP_Vis_PublicA, 	;
				IIF (tnVisibility = 2, ccLOC_CAP_Vis_ProtectedA, 	;
				IIF (tnVisibility = 3, ccLOC_CAP_Vis_HiddenA, 		;
				'')))
		Else
			Return Iif (tnVisibility = 1, ccLOC_CAP_Vis_Public, 	;
				IIF (tnVisibility = 2, ccLOC_CAP_Vis_Protected, 	;
				IIF (tnVisibility = 3, ccLOC_CAP_Vis_Hidden, 		;
				'')))
		Endif
		
	ENDPROC

	PROCEDURE spellyes
		Lparameters lbFlag
		
		If Thisform.lUseAbbreviations
			Return Iif (lbFlag, ccLOC_CAP_YesA, ccLOC_CAP_NoA)
		Else
			Return Iif (lbFlag, ccLOC_CAP_Yes, ccLOC_CAP_No)
		Endif
		
	ENDPROC

	PROCEDURE viewparentcode
		Lparameters tcName, lcStyle, lcWindowName, loObject, llSkipCurrentCode
		
		* lcStyle =
		*     'Code'
		*     'Parentage'
		*	  'Value'
		
		Local lcText, lcFileName
		
		tcName = Alltrim (tcName)
		
		lcText = This.GetParentCode(tcName, lcStyle, loObject, llSkipCurrentCode)
		
		If "O" # Vartype (loObject)
			loObject = Thisform.oObjectAssert 
		Endif
		
		lcWindowName = '-' + Thisform.oTopofForm.Name + This.GetObjectPath (loObject) ;
			+ Iif (lcStyle # 'Parentage', "." + tcName + '.Inherited', '.-')
			
		This.oUtils.ViewTempFileText (lcWindowName, lcText)	
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmpemeditor AS frmpemeditorbase OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oSplitterV" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntGridControls" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oSplitterH" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Refreshtimer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntNoneFound" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntNoneFound.lblNoneFound" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="QuickTimer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntControls" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntControls.lblVersion" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntControls.Baseimage1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntControls.CntFilters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntControls.lblFilters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntIcons" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntIcons.imgHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntIcons.imgRefresh" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntIcons.imgFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntIcons.imgOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntIcons.imgOpen" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: hidedoctreeview
		*m: setformcaption
		*p: nheighthidden
		*p: nlefthidden
		*p: ntophidden
		*p: nwidthhidden
	*</DefinedPropArrayMethod>

	Caption = "PEM Editor 7"
	DoCreate = .T.
	Height = 260
	Name = "frmpemeditor"
	nheighthidden = -1
	nlefthidden = -1
	ntophidden = -1
	nwidthhidden = -1
	Visible = .T.
	Width = 686
	_memberdata = <VFPData>
		<memberdata name="setformcaption" display="SetFormCaption"/>
		</VFPData>
	changefontsize.Name = "changefontsize"

	ADD OBJECT 'cntControls' AS cntpemcontrols WITH ;
		Left = 338, ;
		Name = "cntControls", ;
		Top = 2, ;
		ZOrderSet = 7, ;
		cntDescription.edtDescription.Name = "edtDescription", ;
		cntDescription.lblBufferOverruns.Name = "lblBufferOverruns", ;
		cntDescription.lblDescription.Name = "lblDescription", ;
		cntDescription.lblnnn255.Name = "lblnnn255", ;
		cntDescription.Name = "cntDescription", ;
		lblname.Name = "lblname", ;
		txtName.Name = "txtName", ;
		lblVisibility.Name = "lblVisibility", ;
		cboVisibility.Name = "cboVisibility", ;
		chkAccess.Alignment = 0, ;
		chkAccess.Name = "chkAccess", ;
		chkAssign.Alignment = 0, ;
		chkAssign.Name = "chkAssign", ;
		Baselabel1.Name = "Baselabel1", ;
		edtDefault.Name = "edtDefault", ;
		cboFavorites.Name = "cboFavorites", ;
		lblDefault.Name = "lblDefault", ;
		opgType.baseoptionbutton1.Left = 5, ;
		opgType.baseoptionbutton1.Name = "baseoptionbutton1", ;
		opgType.baseoptionbutton1.Top = 5, ;
		opgType.baseoptionbutton2.Left = 91, ;
		opgType.baseoptionbutton2.Name = "baseoptionbutton2", ;
		opgType.baseoptionbutton2.Top = 5, ;
		opgType.Name = "opgType", ;
		lblType.Name = "lblType", ;
		oSplitter.gripperhor.Height = 5, ;
		oSplitter.gripperhor.Name = "gripperhor", ;
		oSplitter.gripperhor.Width = 21, ;
		oSplitter.gripperver.Height = 21, ;
		oSplitter.gripperver.Name = "gripperver", ;
		oSplitter.gripperver.Width = 5, ;
		oSplitter.imgDownArrow.Height = 21, ;
		oSplitter.imgDownArrow.Name = "imgDownArrow", ;
		oSplitter.imgDownArrow.Width = 21, ;
		oSplitter.ImgLeftArrow.Height = 17, ;
		oSplitter.ImgLeftArrow.Name = "ImgLeftArrow", ;
		oSplitter.ImgLeftArrow.Width = 17, ;
		oSplitter.ImgRightArrow.Height = 17, ;
		oSplitter.ImgRightArrow.Name = "ImgRightArrow", ;
		oSplitter.ImgRightArrow.Width = 17, ;
		oSplitter.imgUpArrow.Height = 21, ;
		oSplitter.imgUpArrow.Name = "imgUpArrow", ;
		oSplitter.imgUpArrow.Width = 21, ;
		oSplitter.Name = "oSplitter", ;
		cntCommandButtons.cntAdd.cmdApplyAndAdd.Name = "cmdApplyAndAdd", ;
		cntCommandButtons.cntAdd.cmdApplyAndEdit.Name = "cmdApplyAndEdit", ;
		cntCommandButtons.cntAdd.cmdRevert.Name = "cmdRevert", ;
		cntCommandButtons.cntAdd.lblAddMode.Name = "lblAddMode", ;
		cntCommandButtons.cntAdd.Name = "cntAdd", ;
		cntCommandButtons.cntEdit.Basecommandbutton1.Name = "Basecommandbutton1", ;
		cntCommandButtons.cntEdit.cmdApply.Name = "cmdApply", ;
		cntCommandButtons.cntEdit.lblEditMode.Name = "lblEditMode", ;
		cntCommandButtons.cntEdit.Name = "cntEdit", ;
		cntCommandButtons.cntNormal.cmdAddMethod.Name = "cmdAddMethod", ;
		cntCommandButtons.cntNormal.cmdAddProperty.Name = "cmdAddProperty", ;
		cntCommandButtons.cntNormal.cmdRemove.Name = "cmdRemove", ;
		cntCommandButtons.cntNormal.cmdResetFilters.Name = "cmdResetFilters", ;
		cntCommandButtons.cntNormal.Name = "cntNormal", ;
		cntCommandButtons.cntNothing.Name = "cntNothing", ;
		cntCommandButtons.Name = "cntCommandButtons", ;
		Line1.Name = "Line1"
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="container" />

	ADD OBJECT 'cntControls.Baseimage1' AS baseimage WITH ;
		Height = 16, ;
		Left = 242, ;
		MousePointer = 15, ;
		Name = "Baseimage1", ;
		nanchor = 12, ;
		Picture = ..\images\vfpxpoweredby_alternative.gif, ;
		Top = 242, ;
		Width = 85, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'cntControls.CntFilters' AS cntfilters WITH ;
		Left = 223, ;
		Name = "CntFilters", ;
		Top = 7, ;
		Visible = .T., ;
		lblSubString.Name = "lblSubString", ;
		txtSubString.Name = "txtSubString", ;
		chkProperties.Alignment = 0, ;
		chkProperties.Name = "chkProperties", ;
		chkMethods.Alignment = 0, ;
		chkMethods.Name = "chkMethods", ;
		chkEvents.Alignment = 0, ;
		chkEvents.Name = "chkEvents", ;
		chkNative.Alignment = 0, ;
		chkNative.Name = "chkNative", ;
		chkInherited.Alignment = 0, ;
		chkInherited.Name = "chkInherited", ;
		chkCustom.Alignment = 0, ;
		chkCustom.Name = "chkCustom", ;
		chkFavorites.Alignment = 0, ;
		chkFavorites.Name = "chkFavorites", ;
		choNonDefault.Alignment = 0, ;
		choNonDefault.Name = "choNonDefault", ;
		chkMethodLocal.Alignment = 0, ;
		chkMethodLocal.Name = "chkMethodLocal", ;
		cboFavorites.Name = "cboFavorites", ;
		chkMethodInherited.Alignment = 0, ;
		chkMethodInherited.Name = "chkMethodInherited", ;
		chkMethodNoMethod.Alignment = 0, ;
		chkMethodNoMethod.Name = "chkMethodNoMethod", ;
		chkMethodNoEvent.Alignment = 0, ;
		chkMethodNoEvent.Name = "chkMethodNoEvent", ;
		Baselabel2.Name = "Baselabel2", ;
		lblFilters.Name = "lblFilters", ;
		Baselabel1.Name = "Baselabel1"
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="container" />

	ADD OBJECT 'cntControls.lblFilters' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Filters: ", ;
		Left = 263, ;
		Name = "lblFilters", ;
		nanchor = 8, ;
		TabIndex = 10, ;
		Top = 0, ;
		Width = 40, ;
		ZOrderSet = 18
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntControls.lblVersion' AS baselabel WITH ;
		Anchor = 10, ;
		AutoSize = .F., ;
		Caption = "Version 1.00 - Oct. 28, 2008", ;
		FontSize = 7, ;
		Height = 12, ;
		Left = 9, ;
		Name = "lblVersion", ;
		nanchor = 14, ;
		TabIndex = 25, ;
		ToolTipText = "Link to PEM Editor blog (and latest version)", ;
		Top = 245, ;
		Width = 228, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cntGridControls' AS gridcontrols WITH ;
		BackStyle = 1, ;
		Height = 258, ;
		Left = 6, ;
		Name = "cntGridControls", ;
		TabIndex = 1, ;
		Top = 2, ;
		Width = 320, ;
		ZOrderSet = 2, ;
		chkAllControls.Alignment = 0, ;
		chkAllControls.Name = "chkAllControls", ;
		lblControlCount.Name = "lblControlCount", ;
		chkMethodView.Alignment = 0, ;
		chkMethodView.Name = "chkMethodView", ;
		oobjecttree.cboCombo.Name = "cboCombo", ;
		oobjecttree.Name = "oobjecttree", ;
		oobjecttree.OIMAGELIST.Height = 100, ;
		oobjecttree.OIMAGELIST.Left = 120, ;
		oobjecttree.OIMAGELIST.Name = "OIMAGELIST", ;
		oobjecttree.OIMAGELIST.Top = 40, ;
		oobjecttree.OIMAGELIST.Width = 100, ;
		oobjecttree.oTree.Height = 174, ;
		oobjecttree.oTree.Left = 5, ;
		oobjecttree.oTree.Name = "oTree", ;
		oobjecttree.oTree.Top = 29, ;
		oobjecttree.oTree.Width = 308, ;
		oobjecttree.shpTreeView.Name = "shpTreeView", ;
		GRIDMEMBERS.ColAccess.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColAccess.Name = "ColAccess", ;
		GRIDMEMBERS.ColAccess.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColAssign.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColAssign.Name = "ColAssign", ;
		GRIDMEMBERS.ColAssign.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColCode.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColCode.Name = "ColCode", ;
		GRIDMEMBERS.ColCode.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColFavorite.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColFavorite.Name = "ColFavorite", ;
		GRIDMEMBERS.ColFavorite.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColHierarchy.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColHierarchy.Name = "ColHierarchy", ;
		GRIDMEMBERS.ColHierarchy.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColMethodName.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColMethodName.Name = "ColMethodName", ;
		GRIDMEMBERS.ColMethodName.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColMultValue.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColMultValue.Name = "ColMultValue", ;
		GRIDMEMBERS.ColMultValue.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColName.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColName.Name = "ColName", ;
		GRIDMEMBERS.ColName.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColName.Width = 120, ;
		GRIDMEMBERS.ColNonDefault.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColNonDefault.Name = "ColNonDefault", ;
		GRIDMEMBERS.ColNonDefault.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColType.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColType.Name = "ColType", ;
		GRIDMEMBERS.ColType.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColTypeIcon.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColTypeIcon.imgHolder.Height = 16, ;
		GRIDMEMBERS.ColTypeIcon.imgHolder.Name = "imgHolder", ;
		GRIDMEMBERS.ColTypeIcon.imgHolder.Width = 16, ;
		GRIDMEMBERS.ColTypeIcon.Name = "ColTypeIcon", ;
		GRIDMEMBERS.ColValue.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColValue.Name = "ColValue", ;
		GRIDMEMBERS.ColValue.Text1.Name = "Text1", ;
		GRIDMEMBERS.ColVisibility.Header1.Name = "Header1", ;
		GRIDMEMBERS.ColVisibility.Name = "ColVisibility", ;
		GRIDMEMBERS.ColVisibility.Text1.Name = "Text1", ;
		GRIDMEMBERS.Height = 200, ;
		GRIDMEMBERS.Left = 0, ;
		GRIDMEMBERS.Name = "GRIDMEMBERS", ;
		GRIDMEMBERS.Top = 57, ;
		GRIDMEMBERS.Width = 320, ;
		chkCSO.Alignment = 0, ;
		chkCSO.Name = "chkCSO", ;
		lblFavoritesFound.Name = "lblFavoritesFound", ;
		imgParent.Height = 16, ;
		imgParent.Name = "imgParent", ;
		imgParent.Picture = ..\images\up1lvl.bmp, ;
		imgParent.Width = 16, ;
		chkDocumentView.Alignment = 0, ;
		chkDocumentView.Name = "chkDocumentView", ;
		chkFoundForAll.Alignment = 0, ;
		chkFoundForAll.Name = "chkFoundForAll"
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="container" />

	ADD OBJECT 'cntIcons' AS basecontainer WITH ;
		Height = 26, ;
		Left = 202, ;
		Name = "cntIcons", ;
		nanchor = 8, ;
		Top = 2, ;
		Width = 117, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntIcons.imgFind' AS basecommandbutton WITH ;
		Caption = "", ;
		Height = 19, ;
		Left = 48, ;
		Name = "imgFind", ;
		Picture = ..\images\find.bmp, ;
		PicturePosition = 13, ;
		SpecialEffect = 2, ;
		Top = 4, ;
		Width = 21
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntIcons.imgHelp' AS basecommandbutton WITH ;
		Caption = "", ;
		Height = 21, ;
		Left = 96, ;
		Name = "imgHelp", ;
		Picture = ..\images\refhelp.bmp, ;
		PicturePosition = 13, ;
		SpecialEffect = 2, ;
		Top = 4, ;
		Width = 21
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntIcons.imgOpen' AS basecommandbutton WITH ;
		Caption = "", ;
		Height = 19, ;
		Left = 24, ;
		Name = "imgOpen", ;
		Picture = ..\images\open.bmp, ;
		PicturePosition = 13, ;
		SpecialEffect = 2, ;
		Top = 4, ;
		Width = 21
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntIcons.imgOptions' AS basecommandbutton WITH ;
		Caption = "", ;
		Height = 19, ;
		Left = 72, ;
		Name = "imgOptions", ;
		Picture = ..\images\propsht.bmp, ;
		PicturePosition = 13, ;
		SpecialEffect = 2, ;
		Top = 4, ;
		Width = 21
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntIcons.imgRefresh' AS basecommandbutton WITH ;
		Caption = "", ;
		Height = 22, ;
		Left = 0, ;
		Name = "imgRefresh", ;
		Picture = ..\images\refresh.bmp, ;
		PicturePosition = 13, ;
		SpecialEffect = 2, ;
		Top = 2, ;
		Width = 21
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntNoneFound' AS basecontainer WITH ;
		BackColor = 140,200,200, ;
		BackStyle = 1, ;
		Height = 69, ;
		Left = 36, ;
		Name = "cntNoneFound", ;
		nanchor = 768, ;
		TabIndex = 5, ;
		Top = 54, ;
		Visible = .F., ;
		Width = 174, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntNoneFound.lblNoneFound' AS baselabel WITH ;
		AutoSize = .F., ;
		Caption = "There are no PEMs found to match your filters.", ;
		FontSize = 9, ;
		Height = 43, ;
		Left = 14, ;
		Name = "lblNoneFound", ;
		Top = 13, ;
		Width = 145, ;
		WordWrap = .T.
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'oSplitterH' AS peme_sfsplitterh WITH ;
		BackColor = 192,192,192, ;
		BackStyle = 1, ;
		cobject1name = cntGridControls, ;
		cobject2name = cntControls, ;
		Height = 295, ;
		lcollapsible = .T., ;
		Left = 326, ;
		Name = "oSplitterH", ;
		nobject1minsize = 300, ;
		nobject2minsize = 304, ;
		TabIndex = 4, ;
		Top = 2, ;
		Visible = .F., ;
		Width = 6, ;
		ZOrderSet = 3, ;
		gripperhor.Height = 5, ;
		gripperhor.Name = "gripperhor", ;
		gripperhor.Width = 21, ;
		gripperver.Height = 21, ;
		gripperver.Name = "gripperver", ;
		gripperver.Width = 5, ;
		imgDownArrow.Height = 20, ;
		imgDownArrow.Name = "imgDownArrow", ;
		imgDownArrow.Width = 20, ;
		imgUpArrow.Height = 21, ;
		imgUpArrow.Name = "imgUpArrow", ;
		imgUpArrow.Width = 21, ;
		ImgRightArrow.Height = 17, ;
		ImgRightArrow.Name = "ImgRightArrow", ;
		ImgRightArrow.Width = 17, ;
		ImgLeftArrow.Height = 17, ;
		ImgLeftArrow.Name = "ImgLeftArrow", ;
		ImgLeftArrow.Width = 17
		*< END OBJECT: ClassLib="peme_sfsplitter.vcx" BaseClass="control" />

	ADD OBJECT 'oSplitterV' AS peme_sfsplitterv WITH ;
		BackColor = 192,192,192, ;
		BackStyle = 1, ;
		cobject1name = cntGridControls, ;
		cobject2name = cntControls, ;
		Height = 6, ;
		lcollapsible = .T., ;
		Left = 6, ;
		Name = "oSplitterV", ;
		nobject1minsize = 100, ;
		nobject2minsize = 304, ;
		TabIndex = 3, ;
		Top = 282, ;
		Visible = .F., ;
		Width = 300, ;
		ZOrderSet = 0, ;
		GRIPPERHOR.Height = 5, ;
		GRIPPERHOR.Name = "GRIPPERHOR", ;
		GRIPPERHOR.Width = 21, ;
		GRIPPERVER.Height = 21, ;
		GRIPPERVER.Name = "GRIPPERVER", ;
		GRIPPERVER.Width = 5, ;
		IMGDOWNARROW.Height = 20, ;
		IMGDOWNARROW.Name = "IMGDOWNARROW", ;
		IMGDOWNARROW.Width = 20, ;
		IMGUPARROW.Height = 21, ;
		IMGUPARROW.Name = "IMGUPARROW", ;
		IMGUPARROW.Width = 21, ;
		IMGRIGHTARROW.Height = 17, ;
		IMGRIGHTARROW.Name = "IMGRIGHTARROW", ;
		IMGRIGHTARROW.Width = 17, ;
		IMGLEFTARROW.Height = 17, ;
		IMGLEFTARROW.Name = "IMGLEFTARROW", ;
		IMGLEFTARROW.Width = 17
		*< END OBJECT: ClassLib="peme_sfsplitter.vcx" BaseClass="control" />

	ADD OBJECT 'QuickTimer' AS refreshtimer WITH ;
		Interval = 25, ;
		Left = 196, ;
		Name = "QuickTimer", ;
		Top = 185
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="timer" />

	ADD OBJECT 'Refreshtimer' AS refreshtimer WITH ;
		Enabled = .F., ;
		Interval = 250, ;
		Left = 116, ;
		Name = "Refreshtimer", ;
		Top = 184
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="timer" />
	
	PROCEDURE hidedoctreeview
		Lparameters llHide
		
		Local loPEMEditor
		With This
			Do Case
				Case Not (.lDocTreeView And .oPrefs.lHideDocTreeView)
		
				Case llHide And .nWidthHidden < 0 And 'O' = Type ('_oPEMEditor.oUtils.oPEMEditor')
					.nTopHidden	   = .Top
					.nLeftHidden   = .Left
					.nHeightHidden = .Height
					.nWidthHidden  = .Width
		
					loPEMEditor	= _oPEMEditor.oUtils.oPEMEditor
					If 'O' = Vartype(loPEMEditor)
						.Top		= loPEMEditor.Top + 100
						.Left		= loPEMEditor.Left + 100
					Endif
					.Height		= 100
					.Width		= 100
		
				Case (Not llHide) And .nWidthHidden > 0
		
					.Top	= .nTopHidden
					.Left	= .nLeftHidden
					.Height	= .nHeightHidden
					.Width	= .nWidthHidden
		
					.nTopHidden	   = -1
					.nLeftHidden   = -1
					.nHeightHidden = -1
					.nWidthHidden  = -1
		
			Endcase
		Endwith
		
	ENDPROC

	PROCEDURE LostFocus
		thisform.SetFormCaption()
		DoDefault()
		
	ENDPROC

	PROCEDURE setformcaption
		Local lcCaption
		
		lcCaption = IIf(Thisform.lPEMEditor,  ccLOC_CAP_TITLE, ccLOC_CAP_DocTreeViewTITLE)
		
		If This.RefreshTimer.Interval > 10000E3
			lcCaption = m.lcCaption + ' (timer disabled)'
		Endif
		
		This.Caption = m.lcCaption
		
	ENDPROC

	PROCEDURE cntControls.Baseimage1.Click
		ThisForm.oUtils.AboutPEMEditor()
		
	ENDPROC

	PROCEDURE cntControls.CntFilters.Refresh
		With This
			If Thisform.oMember.InteractiveChanged 	;
					Or Thisform.lEditingOneProperty
				.Enabled = .F.
				.Visible = .F.
			Else
				.Enabled = .T.
				.Visible = .T.
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE cntControls.lblFilters.Init
		This.Caption = ' ' + ccLOC_CAP_FILTERS + ' '
		DoDefault()
		
	ENDPROC

	PROCEDURE cntControls.lblFilters.Refresh
		With This
			*	If Thisform.oMember.IsNewMember 				;
			*		Or Thisform.oMember.InteractiveChanged 	;
			*		Or Thisform.lEditingOneProperty
			If Thisform.oMember.InteractiveChanged 	;
					Or Thisform.lEditingOneProperty
				.Enabled = .F.
				.Visible = .F.
			Else
				.Enabled = .T.
				.Visible = .T.
			Endif
		Endwith
		
		This.BackColor = This.Parent.BackColor
		This.ZOrder(0)
		
	ENDPROC

	PROCEDURE cntControls.lblVersion.Click
		Local loHyperlink AS "Hyperlink"
		Local lcLink
		
		lcLink = "http://pemeditor.blogspot.com/"
		loHyperlink = CREATEOBJECT("Hyperlink") 
		loHyperlink.navigateto(lcLink)
	ENDPROC

	PROCEDURE cntControls.lblVersion.Init
		DoDefault()
		
		With This
			.FontSize = ccFontSizeSmall
		Endwith
		
		
	ENDPROC

	PROCEDURE cntControls.lblVersion.Refresh
		DoDefault()
		
		With This
			.Caption = ThisForm.oPrefs.cVersion
		Endwith
		
		
	ENDPROC

	PROCEDURE cntGridControls.GotFocus
		DoDefault()
		
		If ('L' = Type("Thisform.oMember.IsNewMember")) 			;
				and Thisform.oMember.IsNewMember					;
				and Between (Recno ("csrMembers"), 1, Reccount("csrMembers")) 
			This.gridmembers.ncurrentrecno = Recno("csrMembers")
			Thisform.SetProperties()
		Endif
		
	ENDPROC

	PROCEDURE cntGridControls.GRIDMEMBERS.Refresh
		DoDefault()
		
		If Thisform.lDocTreeView
			This.Visible = .F.
		Endif
		
	ENDPROC

	PROCEDURE cntGridControls.oobjecttree.oTree.GotFocus
		This.Parent.lMustSetFocus = .F.
	ENDPROC

	PROCEDURE cntGridControls.oobjecttree.oTree.Init
		DoDefault()
		With This
			.LineStyle = 0  && tvwTreeLines 
			.HideSelection = .T.
		EndWith 
			
	ENDPROC

	PROCEDURE cntGridControls.oobjecttree.oTree.Refresh
		*** ActiveX Control Method ***
		
	ENDPROC

	PROCEDURE cntGridControls.Refresh
		Local lnAnchor
		
		If Thisform.lDocTreeView
			With This
				lnAnchor = .Anchor
				.Anchor = 0
				.Left  	= 3
				.Top 	= 2
				.Width 	= Thisform.Width - 2 * .Left
				.Height = Thisform.Height - 2 * .Top
				.Anchor = lnAnchor
			Endwith
		Endif
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntIcons.imgFind.Click
		Thisform.oUtils.Find()
		
	ENDPROC

	PROCEDURE cntIcons.imgFind.Init
		With This
			.ToolTipText = ccLOC_CAP_Find
		EndWith 
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntIcons.imgFind.Refresh
		This.Enabled = (Used('csrMembers'))			;
			and Vartype(Thisform.oMember) = 'O' 	;
			and Not Isnull(Thisform.oObject)
			
		This.Visible = Thisform.lPEMEditor
		
		
	ENDPROC

	PROCEDURE cntIcons.imgHelp.Click
		Thisform.oUtils.ShowHelp()
	ENDPROC

	PROCEDURE cntIcons.imgHelp.Init
		With This
			.ToolTipText = ccLOC_CAP_Help
		EndWith 	
		DoDefault()
	ENDPROC

	PROCEDURE cntIcons.imgOpen.Click
		Thisform.oUtils.oIDEx.CreateOpenMRUMenu()
		
	ENDPROC

	PROCEDURE cntIcons.imgOpen.Init
		With This
			.ToolTipText = ccLOC_CAP_MRU_List
		EndWith 
		
		DoDefault()
		
	ENDPROC

	PROCEDURE cntIcons.imgOptions.Click
		Thisform.oUtils.EditPreferences()
	ENDPROC

	PROCEDURE cntIcons.imgOptions.Init
		With This
			.ToolTipText = ccLOC_Tip_Preferences
		EndWith 	
		DoDefault()
	ENDPROC

	PROCEDURE cntIcons.imgRefresh.Click
		Thisform.DoRefresh()
		
	ENDPROC

	PROCEDURE cntIcons.imgRefresh.Init
		This.ToolTipText = ccLOC_CAP_RefreshF5 
		DoDefault()
	ENDPROC

	PROCEDURE cntIcons.Refresh
		Local lbEnabled, lPEMEditor
		
		With Thisform
			lbEnabled = .lFormIsEnabled
			lPEMEditor = .lPEMEditor
		Endwith
		
		With This
		
			With .imgRefresh
				.Visible = lbEnabled Or lPEMEditor
				.Enabled = lbEnabled or lPEMEditor
				If not lPEMEditor
					.Left = This.imgHelp.Left
				EndIf 
			Endwith
		
			With .imgOptions
				.Visible = lPEMEditor
				.Enabled = lPEMEditor
			Endwith
		
			With .imgHelp
				.Visible = lPEMEditor
				.Enabled = lPEMEditor
			Endwith
		
			With .imgOpen
				.Visible = lPEMEditor
				.Enabled = lPEMEditor
			Endwith
		
			.lSaveAnchor = .T.
			.Left	 = Thisform.cntGridControls.Width - .Width
			.lSaveAnchor = .F.
		
		Endwith
		
	ENDPROC

	PROCEDURE cntNoneFound.lblNoneFound.Init
		DoDefault()
		This.Caption = ccLOC_NO_FILTER_MATCHES
		With This
			.FontSize = ccFontSizeLarge
		Endwith
		
		
	ENDPROC

	PROCEDURE cntNoneFound.Refresh
		Local lcFilter
		
		Do Case
			Case Thisform.lDocTreeView
				This.Visible = .F.
		
			Case (Not Used('csrMembers'))					;
					or Vartype(Thisform.oMember) # 'O' 		;
					or Isnull(Thisform.oObject) 
				This.Visible = .T.
		
			Case Thisform.NotEmptyGrid()
				This.Visible = .F.
		
			Otherwise
				lcFilter = Filter()
				If Not Empty(lcFilter)
					lcFilter = 'where ' + lcFilter
				Endif
				Select * From csrMembers &lcFilter To Screen Noconsole
		
				This.Visible = _Tally = 0
		Endcase
		
	ENDPROC

	PROCEDURE oSplitterH.collapse
		Lparameters lbCollapse
		
		Thisform.cntGridControls.lSaveAnchor = .T.
		This.lSaveAnchor = .T.
		
		Do Case
		
			Case lbCollapse And This.lCollapsed
		
			Case (Not lbCollapse) And Not This.lCollapsed
		
			Case lbCollapse
				This.lCollapsed = .T.
				Thisform.lCollapsed = .T.
		
				With Thisform
					.cntGridControls.Width = .cntGridControls.Width + .cntControls.Width
					This.Left = .cntGridControls.Left + .cntGridControls.Width
				Endwith
				This.DrawCollapseArrows()
		
			Case Not lbCollapse
				This.lCollapsed = .F.
				Thisform.lCollapsed = .F.
		
				With Thisform
					.cntGridControls.Width = .cntControls.Left - This.Width - .cntGridControls.Left
					This.Left = .cntGridControls.Left + .cntGridControls.Width
				Endwith
				This.DrawCollapseArrows()
		
		Endcase
		
		Thisform.cntGridControls.lSaveAnchor = .F.
		This.lSaveAnchor = .F.
		
		With ThisForm
			.cntIcons.Refresh()
			.cntControls.Refresh()
		EndWith 
		
	ENDPROC

	PROCEDURE oSplitterH.Init
		DoDefault()
		With This
			.ToolTipText 			= ccLOC_TOOLTIP_SPLITTER_Horizontal
			.cToolTipTextRightArrow = ccLOC_TOOLTIP_SPLITTER_RightArrow
			.cToolTipTextLeftArrow 	= ccLOC_TOOLTIP_SPLITTER_LeftArrow
		Endw
		
	ENDPROC

	PROCEDURE oSplitterH.Refresh
		This.Visible = Thisform.lPEMEditor and NOT Thisform.oPrefs.lGridAbove 
		This.Enabled = NOT Thisform.oPrefs.lGridAbove 
	ENDPROC

	PROCEDURE oSplitterH.splittermoved
		With Thisform
			.cntIcons.Refresh()
		Endwith
		
	ENDPROC

	PROCEDURE oSplitterV.collapse
		Lparameters lbCollapse
		
		Thisform.cntGridControls.lSaveAnchor = .T.
		This.lSaveAnchor = .T.
		
		Do Case
		
			Case Thisform.lDocTreeView
		
			Case lbCollapse And This.lCollapsed
		
			Case (Not lbCollapse) And Not This.lCollapsed
		
			Case lbCollapse
				This.lCollapsed = .T.
				Thisform.lCollapsed = .T.
		
				With Thisform
					.cntGridControls.Height = .cntGridControls.Height + .cntControls.Height - 45
					This.Top = .cntGridControls.Top + .cntGridControls.Height
				Endwith
				This.DrawCollapseArrows()
		
			Case Not lbCollapse
				This.lCollapsed = .F.
				Thisform.lCollapsed = .F.
		
				With Thisform
					.cntGridControls.Height = .cntControls.Top - This.Height - .cntGridControls.Top
					This.Top = .cntGridControls.Top + .cntGridControls.Height
				Endwith
				This.DrawCollapseArrows()
		
		Endcase
		
		Thisform.cntGridControls.lSaveAnchor = .F.
		This.lSaveAnchor = .F.
		
		With ThisForm
			.cntIcons.Refresh()
			.cntControls.Refresh()
		EndWith 
		
		
	ENDPROC

	PROCEDURE oSplitterV.Init
		DoDefault()
		With This
			.ToolTipText 			= ccLOC_TOOLTIP_SPLITTER_Vertical
			.cToolTipTextDownArrow 	= ccLOC_TOOLTIP_SPLITTER_DownArrow
			.cToolTipTextUpArrow 	= ccLOC_TOOLTIP_SPLITTER_UpArrow
		Endw
		
	ENDPROC

	PROCEDURE oSplitterV.movesplittertoposition
		Lparameters tnPosition
		
		DoDefault (tnPosition)
		With Thisform.cntControls.osplitter
			.MoveSplitterToPosition(.Top)
		Endw
		
	ENDPROC

	PROCEDURE oSplitterV.Refresh
		This.Visible = Thisform.lPEMEditor and Thisform.oPrefs.lGridAbove 
		This.Enabled = Thisform.oPrefs.lGridAbove 
		
	ENDPROC

	PROCEDURE QuickTimer.Timer
		This.Enabled = .F.
		Do Case
			Case Thisform.cQuickTimerAction = 'MousePointer'
				Thisform.oGrid.MousePointer = 0
			Case Thisform.cQuickTimerAction = 'GridFocus'
				Thisform.cntIcons.SetFocus()
				Thisform.oGrid.SetFocus()
			Case Thisform.cQuickTimerAction = 'Find'
				Thisform.oUtils.Find()
		Endcase
		
	ENDPROC

	PROCEDURE Refreshtimer.resetinterval
		Local loTopOfForm As Object
		Local laObject(1), lbAnyActiveForm, lbFormOrClassDesigner, lbResult, lcClass, lcSourceFileName, lcTitle, lcNewTitle
		Local lcWontop, lnHandle, lnInterval
		
		* delay when focus is on the form / class being modified
		#Define ShortDelay  .25
		#Define MaxTitleLength 90
		
		* delay when focus is elsewhere (excluding special cases for debugging)
		#Define LongDelay   2
		
		lcWontop = Wontop()
		If '-' $ lcWontop
			lcWontop = Upper( Left( lcWontop, 1 + At('-', lcWontop)))
		Endif
		
		*		?Seconds()
		*		Wait (lcWontop ) Window Nowait
		
		lbAnyActiveForm = "O" = Type ("_Screen.ActiveForm")
		
		lbFormOrClassDesigner = Inlist(lcWontop, "FORM DESIGNER - ", "CLASS DESIGNER - ", "FORM DESIGNER --", "CLASS DESIGNER --", "TOOLBOX")		;
			Or (lbAnyActiveForm And (Thisform.lDontDisableMe Or Thisform.GetPEMStatus(_Screen.ActiveForm, "lpemeditorform",5)))		;
			or (lbAnyActiveForm And (Not Isnull(Thisform.oTopOfForm)) 										;
			And Inlist (_Screen.ActiveForm, Thisform.oTopOfForm, Thisform.oTopOfForm.Parent, Thisform))
		
		Do Case
		
			Case Thisform.oPrefs.lDisableIfDebuggerOpen and thisform.IsDebuggerOpen()
				lnInterval = 86400
		
			Case lbFormOrClassDesigner
		
				Do Case
		
					Case Thisform.CloseDebuggerWindows()
						lbResult = .T.
						lnInterval = .05
		
					Case Set("Eventtracking") = "ON" And Wvisible(ccLOC_WINDOW_DEBUG_OUTPUT)
						lnInterval = 5
		
					Case Wvisible(ccLOC_WINDOW_TRACE)
						lnInterval = LongDelay
		
					Case lcWontop = "FORM DESIGNER - " And Thisform.lPEMEditor
						lnInterval = ShortDelay
						If 0 #Aselobj(laObject, 3)
							lcSourceFileName = Lower(laObject[2])
		
							lnHandle = _WFindTitl("Form Designer - " + Lower (Justfname(lcSourceFileName)))
							If lnHandle # 0
								lcTitle = "Form Designer -- "
								lcNewTitle = lcTitle + Thisform.GetRelativePath (lcSourceFileName)
								If Len(lcNewTitle) >= MaxTitleLength
									lcNewTitle = lcTitle + Displaypath (lcSourceFileName, MaxTitleLength - Len (lcTitle))
								Endif
								_WSetTitle (lnHandle, lcNewTitle)
							Endif
						Endif
		
					Case lcWontop = "CLASS DESIGNER - " And Thisform.lPEMEditor
						lnInterval = ShortDelay
						If 0 #Aselobj(laObject, 3)
							lcSourceFileName	= Lower(laObject[2])
							loTopOfForm      	= PEME_FindTopmostParent(laObject[1], .T.)
							lcClass 			= Lower(loTopOfForm.Name)
		
							lnHandle = _WFindTitl("Class Designer - " + Lower (Justfname(lcSourceFileName)) + ' (' + lcClass + ')')
							If lnHandle # 0
								lcTitle = "Class Designer -- " + lcClass + " of "
								lcNewTitle = lcTitle + Thisform.GetRelativePath (lcSourceFileName)
								If Len(lcNewTitle) >= MaxTitleLength
									lcNewTitle = lcTitle + Displaypath (lcSourceFileName, MaxTitleLength - Len (lcTitle))
								Endif
								_WSetTitle (lnHandle, lcNewTitle)
							Endif
						Endif
		
					Otherwise
						lnInterval = ShortDelay
		
				Endcase
		
				* other active form, assumed to be executing ... get out of the way altogether
			Case lbAnyActiveForm And _Screen.ActiveForm # Thisform
				If Wvisible(ccLOC_WINDOW_DEBUGGER) Or Wvisible(ccLOC_WINDOW_TRACE) Or Wvisible(ccLOC_WINDOW_DEBUG_OUTPUT)
					*** JRN 2010-05-03 : just a few seconds even if debugger open
					*	lnInterval = 3600 && effectively, forever
					lnInterval = LongDelay && no debugger?
				Else
					lnInterval = LongDelay && no debugger?  just a few secs!
				Endif
		
				Thisform.oServer.MarkNotCurrent()
		
				* no ActiveForm .. command window, property sheet, modify project, document view, modify method, etc
			Otherwise
				lnInterval = LongDelay
				Thisform.oServer.MarkNotCurrent()
		
				If Thisform.lPEMEditor
					* Get the whandle for the current window
					Thisform.oUtils.oIDEx.SaveHandleHistory()
					* and let the status bar go back to normal
					If Not Empty(Set("Message",1))
						Set Message To
					Endif
				Endif
		
		EndCase
		
		This.Interval = lnInterval * 1000
		
		Return lbResult  && .T. if we closed any debugger windows
		
	ENDPROC

	PROCEDURE Refreshtimer.Timer
		With Thisform
			
			*** JRN 03/27/2009 : added handling of escape, to ignore it when timer running
			Local lcSetEscape
			lcSetEscape = Set("Escape")
			Set Escape Off
		
			*** JRN 04/20/09 : to avoid VFP crashing when selecting multipler objects
			* do nothing when shift key is down --- selected controls show when released
			If (Not This.ResetInterval()) And (Not Thisform.IsShiftOrCtrlDown())
				This.Enabled = .F.
				.ActivateForm()
				*	PEME_ClearWaitCursor()
				This.Enabled = .T.
			Endif
		
			ThisForm.SetFormCaption()
			
			Set Escape &lcSetEscape
		
		Endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmpemeditorbase AS editpropertyform OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: activateform
		*m: addaccessassign		&& Adds an access or assignmethod for the property
		*m: adddopeproperty
		*m: addmrumenuitems
		*m: addnew
		*m: applychanges
		*m: autorename
		*m: autorenamecontrol
		*m: autorenamecontrols
		*m: avoidbufferoverrun
		*m: changewindowdimensions
		*m: checkfornewproperty
		*m: checkmemberdata		&& Checks to see if we need to update member data
		*m: closedebuggerwindows
		*m: closesearchresults
		*m: closetreeview
		*m: createeventbindings
		*m: creategroupcursors
		*m: creatememberdatanode
		*m: createobjecteventbindings
		*m: createsortedobjectarray
		*m: deletethiscontrol
		*m: disableform
		*m: dockable_assign
		*m: doquicktimer
		*m: dorefresh
		*m: editmember		&& Called to save the new values for the property or method
		*m: editpropertymethods
		*m: executemethod
		*m: exportchildmethodcode
		*m: exporthtmllistofpems
		*m: exportlistofpems		&& Exports to the clipboard
		*m: exportmethodcode
		*m: findobjects
		*m: fixnondefaultflags
		*m: fixsplitterpositions
		*m: getcontrolcount
		*m: getdefaultvalue
		*m: getdescriptionvalue
		*m: getmethodvalue
		*m: getmrusettings
		*m: getparentobjects
		*m: getpemlist
		*m: getpemvalue
		*m: getputfilterdefaults
		*m: getsettings
		*m: getwindows
		*m: handleevents
		*m: handleevents_before
		*m: ide_eventhandler
		*m: ide_eventhandler_before
		*m: ide_resizechildren
		*m: initgridhighlighting
		*m: isdebuggeropen
		*m: isshiftorctrldown
		*m: locatepem
		*m: memberchanged
		*m: memberdatacleaner
		*m: memberdatastats
		*m: notemptygrid
		*m: notifynewpemshidden
		*m: opennativetables
		*m: peme_bindevent
		*m: refreshgrid
		*m: removeaccessassign		&& Removes the access and/or assign methods for the property
		*m: removemember		&& Called to delete the property or method
		*m: removememberdata		&& When we remove the member
		*m: renamemethodwindow
		*m: resetmembertodefault
		*m: resortgrid
		*m: restoredebuggerwindows
		*m: restorepositioninfo
		*m: revertchanges
		*m: savedockinginfo
		*m: saveparentclasses
		*m: savepositioninfo
		*m: scattercursor
		*m: selectlastobject
		*m: selectnextobject
		*m: selectnextsibling
		*m: selectpreviousobject
		*m: setcoverage
		*m: setcurrentobjectproperty
		*m: setcurrentselectedobject
		*m: setdefaultgridsortorder
		*m: setdesignerobjects
		*m: setfilter
		*m: setfont
		*m: setformalignment
		*m: setglobalfavorite
		*m: setgridhighlighting
		*m: setmessageto
		*m: setproperties		&& Set the form properties for the item currently selected in the grid
		*m: showeditcontextmenu
		*m: showerrormsg
		*m: startdocumenttreeview
		*m: thiscontroldeletable
		*m: usememberdata
		*m: validatename		&& Validates a PEM name (that is, that the name could be the name of a PEM)
		*m: writememberdata
		*m: zapmemberscursor
		*p: caddtype
		*p: ccurrentobjectname
		*p: ceditpropertyname
		*p: cexporttomethod
		*p: cformermember		&& The name of the formerly selected member when New is clicked
		*p: cfullobjectname
		*p: chelpfile
		*p: cmemberssortorder
		*p: cmemberssortordermethodview
		*p: cmyversion
		*p: cnewmembertype
		*p: coriginalcaption
		*p: coriginalname		&& Used to save the original name of the property or method so that if we edit it, we can find the one whose name we are editing
		*p: cpem		&& Name of the property or method that was selected in the property sheet
		*p: cquicktimeraction
		*p: csearchcolumns
		*p: csearchfor
		*p: csearchstring		&& The string to search for using incremental search
		*p: csession		&& Suffix to global _oPemEditor ; empty for primary session
		*p: csubstring
		*p: csubstringmv
		*p: ctreestartnode
		*p: ctreeviewkey
		*p: laddcr		&& .T. to add a carriage return after each element in the member data XML
		*p: laddmode
		*p: laddpropertyform
		*p: ladjustedforclass		&& .T. if the form has been adjusted based on Form vs. Class Designer
		*p: ladjustedformethod		&& .T. if the form has been adjusted based on Property vs. Method
		*p: lallowdescriptioncrs
		*p: lautomovewindow
		*p: lbeautifyparens
		*p: lcheckformattingform
		*p: lcheckoutscc
		*p: lcheckstartdoctreeview
		*p: lcollapsed
		*p: ldebuggerwasopen
		*p: ldoctreeview
		*p: lduringresizeevent
		*p: lexpandallnodes
		*p: lfilterineffect
		*p: lfirsttime
		*p: lfixsemicolons
		*p: lformisenabled		&& .T.
		*p: lfoundforall
		*p: listopofform
		*p: lmethod		&& .T. if we're adding methods
		*p: lmethodview
		*p: lnoerrormsgonmissingvcx
		*p: lrebuildtree		&& If .T. the object tree must be rebuild before display
		*p: lresetprevnexthistory
		*p: ltreemembersort
		*p: ltreeshowcaptions
		*p: ltreeviewallcontrols
		*p: ltreeviewshowmethods
		*p: lupdategroupnames
		*p: lusecso
		*p: lusememberdata
		*p: ncurrenthandle
		*p: ndebuggerwindows
		*p: ndefinitionfornot
		*p: ndefinitionfornotequal
		*p: ndescsplittertop
		*p: ndesignerobjects
		*p: nfoundobjects
		*p: nhandingindent
		*p: nkeytime		&& The time between keypresses for incremental search
		*p: nmethodview
		*p: nnativeselection
		*p: nnotequalchoice
		*p: noriginalheight
		*p: noriginalvisibility		&& The original visiibility of the selected member
		*p: noriginalwidth
		*p: npreviousselectobjects
		*p: nsplitterleft
		*p: nsplittertop		&& The Top position for oSplitter
		*p: nstartingtop
		*p: nstringdelimiterchoice
		*p: ntopofformheight
		*p: ntopofformwidth
		*p: ntreesort
		*p: ntreesortmethods
		*p: ntreeviewbackcolor
		*p: ntreeviewclassinfo
		*p: ntreeviewforecolor
		*p: obeautify
		*p: ocntfilters
		*p: odoublehash
		*p: oeditorwin
		*p: oedtdefault
		*p: oedtdescription
		*p: oeventhandlerautosize
		*p: oeventhandlercaption
		*p: oeventhandlerheight
		*p: oeventhandlerwidth
		*p: ofoxref
		*p: ogrid		&& Main grid --
		*p: oidex
		*p: omember
		*p: omemberdataengine		&& Object reference to the member data engine
		*p: oobject		&& A reference to the object we're adding members for
		*p: oobjecttree
		*p: ooriginalmember
		*p: opositions		&& A collection of object positions
		*p: oprefs
		*p: osearchresults
		*p: otxtname
		*p: outils
		*p: oxml		&& Object refrence to the XML parser object
		*p: singlesetfieldindent
		*p: xdefaultvalue
		*a: adebuggerwindows[5,2]
		*a: adesignerobjects[1,0]
		*a: afavorites[1,3]
		*a: afoundobjects[1,0]
		*a: agridhighlighting[5,2]
		*a: ahandlehistory[1,0]
		*a: aproclines[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BindControls = .F.
	caddtype = 
	Caption = "PEM Editor 7"
	ccurrentobjectname = 
	ceditpropertyname = 
	cexporttomethod = .F.
	cformermember = 		&& The name of the formerly selected member when New is clicked
	cfoxuserid = NEWEDITPROPDLG
	cfoxusername = NewEditPropertyDialog
	cfullobjectname = .F.
	chelpfile = .F.
	cmemberssortorder = +CName
	cmemberssortordermethodview = +IIF(cType = 'P', '0', IIF(lNonDefault, '1', IIF(lHasCode, '2', IIF(Not lNative, '3', '4')))) + CName
	cmyversion = 
	cnewmembertype = P
	coriginalcaption = .F.
	coriginalname = 		&& Used to save the original name of the property or method so that if we edit it, we can find the one whose name we are editing
	cpem = 		&& Name of the property or method that was selected in the property sheet
	cquicktimeraction = 
	csearchcolumns = .F.
	csearchfor = .F.
	csearchstring = 		&& The string to search for using incremental search
	csession = .F.		&& Suffix to global _oPemEditor ; empty for primary session
	csubstring = 
	csubstringmv = 
	ctreestartnode = .F.
	ctreeviewkey = 
	DoCreate = .T.
	Enabled = .T.
	Height = 260
	KeyPreview = .T.
	laddmode = .F.
	laddpropertyform = .F.
	lallowdescriptioncrs = .F.
	lautomovewindow = .F.
	lbeautifyparens = .F.
	lcheckformattingform = .T.
	lcheckoutscc = .F.
	lcheckstartdoctreeview = .T.
	lcollapsed = .F.
	ldebuggerwasopen = .F.
	ldoctreeview = .F.
	ldontdisableme = .F.
	lduringresizeevent = .F.
	lexpandallnodes = .F.
	lfilterineffect = .F.
	lfirsttime = .T.
	lfixsemicolons = .F.
	lformisenabled = .T.		&& .T.
	lfoundforall = .T.
	listopofform = .F.
	lmethod = .F.		&& .T. if we're adding methods
	lmethodview = .F.
	lnoerrormsgonmissingvcx = .F.
	lrebuildtree = .T.		&& If .T. the object tree must be rebuild before display
	lresetprevnexthistory = .T.
	ltreemembersort = .F.
	ltreeshowcaptions = .T.
	ltreeviewallcontrols = .F.
	ltreeviewshowmethods = .F.
	lupdategroupnames = .T.
	luseabbreviations = .F.
	lusecso = .F.
	lusememberdata = .F.
	MinHeight = -1
	MinWidth = -1
	Name = "frmpemeditorbase"
	ncurrenthandle = 0
	ndebuggerwindows = 0
	ndefinitionfornot = .F.
	ndefinitionfornotequal = .F.
	ndescsplittertop = .F.
	ndesignerobjects = 0
	nfoundobjects = 0
	nhandingindent = 0
	nkeytime = 0		&& The time between keypresses for incremental search
	nmethodview = 1
	nnotequalchoice = 1
	noriginalheight = 0
	noriginalvisibility = 		&& The original visiibility of the selected member
	noriginalwidth = 0
	npreviousselectobjects = 1
	nselectedobjects = 1
	nsplitterleft = 326
	nsplittertop = 0		&& The Top position for oSplitter
	nstartingtop = 0
	nstringdelimiterchoice = 1
	ntopofformheight = .F.
	ntopofformwidth = .F.
	ntreesort = .T.
	ntreesortmethods = 1
	ntreeviewbackcolor = .F.
	ntreeviewclassinfo = 0
	ntreeviewforecolor = 0
	obeautify = .F.
	ocntfilters = .NULL.
	odoublehash = .NULL.
	oeditorwin = .NULL.
	oedtdefault = .NULL.
	oedtdescription = .NULL.
	oeventhandlerautosize = .NULL.
	oeventhandlercaption = .NULL.
	oeventhandlerheight = .NULL.
	oeventhandlerwidth = .NULL.
	ofoxref = .NULL.
	ogrid = .NULL.		&& Main grid --
	oidex = .NULL.
	omember = .NULL.
	omemberdataengine = .NULL.		&& Object reference to the member data engine
	oobject = .NULL.		&& A reference to the object we're adding members for
	oobjecttree = .NULL.
	ooriginalmember = .NULL.
	opositions = .NULL.		&& A collection of object positions
	oprefs = .F.
	osearchresults = .NULL.
	oserver = .F.
	otxtname = .NULL.
	outils = .NULL.
	oxml = .NULL.		&& Object refrence to the XML parser object
	singlesetfieldindent = 0
	Visible = .F.
	Width = 686
	WindowState = 0
	xdefaultvalue = 
	_memberdata = <VFPData>
		<memberdata name="oidex" display="oIDEx"/>
		<memberdata name="setcurrentobjectproperty" display="SetCurrentObjectProperty"/>
		<memberdata name="outils" display="oUtils"/>
		<memberdata name="findobjects" display="FindObjects"/>
		<memberdata name="lfilterineffect" display="lFilterInEffect"/>
		</VFPData>		&& XML Metadata for customizable properties
	changefontsize.Name = "changefontsize"
	
	PROCEDURE Activate
		With This
		
			*!* ******************** Removed 5/21/2013 *****************
			*!* .RefreshTimer.Enabled = .F.
			.CloseDebuggerWindows()
			.ActivateForm()
			.Visible = .T.
		
			*** DH 12/30/2008: handle New Property or Method from menu
			If .lAddMode
				.lAddMode = .F.
				.AddNew(.cAddType)
				.RefreshForm()
			Endif .lAddMode
			*** DH 12/30/2008: end of new code
		
			.cHelpFile = Set("Help", 1)
			*	Set Help to (Thisform.cApplicationPath + "PemEditor.CHM")
		
		Endwith
		
	ENDPROC

	PROCEDURE activateform
		#Define ccLog_Events  Debugout (Program () + ' ' + Transform(Lineno(1)))
		
		Lparameters tlForceIt
		
		Local loDesignerObject As Object
		Local loObject As Object
		Local loTopOfForm As Object
		Local laMouseObj[1], laObject[1], laObject0[1], lbObjectsChanged, lbSameForm, lcCaption
		Local lcCurrentMember, lcMember, lcName, lcSourceFileName, llClass, lnDesignerObjects, lnI, lnMax
		Local lnSeconds, lnSelectedObjects, lcWontop
		
		****************************************************************
		*** JRN 02/15/2009 : Use current object if we don't have to rebuild tree
		* (which indicates that we're using the results of navigation, rather than ASelObj)
		*
		* in addition, we use .oObject as our object, but oDesignerObject for our comparisons here
		* which allows the user to leave PEM Editor and not have it return its display to the
		* object currently selected in the Designer
		
		*!*	Local laMouseObj(1)
		*!*	If 0 # AMouseObj(laMouseObj, 1) and "O" = Vartype(laMouseObj(1))
		*!*		Try
		*!*			Wait (This.getobjectpath(laMouseObj(1)) + ' ' + Transform(laMouseObj(3))  + ' ' + Transform(laMouseObj(4))) window nowait
		*!*		Catch
		*!*
		*!*		EndTry
		*!*	EndIf
		
		lbObjectsChanged = .F.
		If Thisform.lRebuildTree Or 'O' # Vartype (Thisform.oObject)
			*** JRN 12/02/2008 : If no classes or forms are selected, clear grid and blank form
			If Aselobj (laObject, 1) = 0
				Thisform.DisableForm()
				Return .F.
			Endif Aselobj (laObject, 1) = 0
		
			* Get a reference to the selected class or form.
			*** JRN 12/02/2008 : Depending on This.lUseCSO, make sure it's the form or
			* class itself that we're working with, regardless of what's selected.
		
			Aselobj (laObject, 3)
			lcSourceFileName = Lower (laObject[2])
			llClass			 = Justext (lcSourceFileName) == 'vcx'
			loTopOfForm		 = PEME_FindTopmostParent (laObject[1], llClass)
		
			*** JRN 12/02/2008 : Note curious second call to Aselobj, needed for pages (see doc!)
			Do Case
				Case Not This.lUseCSO
					loObject		  = loTopOfForm
					lnDesignerObjects = 1
				Case 0 # Aselobj (laObject0)
					loObject         = laObject0[1]
					If Thisform.lPEMEditor
						lnDesignerObjects = Alen (laObject0)
					Else
						lnDesignerObjects = 1
					Endif
					Do Case
						Case 'O' # Vartype (This.aDesignerObjects(1))
							lbObjectsChanged = .T.
						Case This.nDesignerObjects # lnDesignerObjects
							lbObjectsChanged = .T.
						Otherwise
							For lnI = 1 To lnDesignerObjects
								If This.aDesignerObjects (lnI) # laObject0 (lnI)
									lbObjectsChanged = .T.
								Endif
							Next lnI
					Endcase
				Case Aselobj (laObject0, 1) # 0
					loObject		  = laObject0[1]
					lnDesignerObjects = 1
				Otherwise
					loObject		  = loTopOfForm
					lnDesignerObjects = 1
			Endcase
			loDesignerObject	= loObject
		
		Else
		
			With This
				lcSourceFileName  = .cSourceFileName
				llClass			  = .lClass
				loObject		  = .oObject
				loDesignerObject  = .aDesignerObjects(1)
				loTopOfForm		  = .oTopOfForm
				lnDesignerObjects = .nDesignerObjects
			Endwith
		
		Endif Thisform.lRebuildTree
		
		****************************************************************
		*** JRN 03/27/2009 : Yup, this needs to be repeated!
		If Aselobj (laObject, 1) = 0
			Thisform.DisableForm()
			Return .F.
		Endif Aselobj (laObject, 1) = 0
		
		****************************************************************
		lbObjectsChanged  = lbObjectsChanged					;
			Or This.nDesignerObjects # lnDesignerObjects		;
			Or 'O' # Vartype (This.aDesignerObjects(1))			;
			Or This.aDesignerObjects(1) # loDesignerObject
		
		If tlForceIt Or lbObjectsChanged
		
			* 10/22/14 TGL: Close the debugger if open since it causes performance issues. 
			Local llDebuggerOpen
			If Wexist('WATCH') Or Wexist('TRACE')						;
					Or Wexist('CALL STACK') Or Wexist('LOCALS')			;
					Or Wexist('DEBUG OUTPUT')
				lcWontop = Wontop()
				llDebuggerOpen = .T.
			Else
				llDebuggerOpen = .F.
			Endif
			
			If m.llDebuggerOpen
				Close Debugger
			Endif
			
			With This
		
				If lbObjectsChanged
					* normal case ... selected objects == designer objects
					For lnI = 1 To Alen (.aDesignerObjects)
						.aDesignerObjects (lnI) = .Null.
					Endfor
					.nDesignerObjects = lnDesignerObjects
					Dimension .aDesignerObjects[lnDesignerObjects]
					.aDesignerObjects(1) = loDesignerObject
		
					For lnI = 1 To Alen (.aSelectedObjects)
						.aSelectedObjects (lnI) = .Null.
					Endfor
					.nSelectedObjects = lnDesignerObjects
					Dimension .aSelectedObjects[lnDesignerObjects]
					.aSelectedObjects(1) = loDesignerObject
		
					For lnI = 2 To lnDesignerObjects
						.aDesignerObjects (lnI) = laObject0 (lnI)
						.aSelectedObjects (lnI) = laObject0 (lnI)
					Next lnI
					lnSelectedObjects = lnDesignerObjects
				Else
					* if selecting a different set of objects (results of search)
					loObject		  = .aSelectedObjects(1)
					lnSelectedObjects = Alen (.aSelectedObjects)
					.nSelectedObjects = lnSelectedObjects
				Endif
		
				If Not tlForceIt
					.lDataEnvironment = .F.
					With .cntGridControls
						.Enabled = .T.
					Endwith
				Endif
		
				lcCurrentMember  = IIf (.oPrefs.lStayOnSamePEM And Used ('csrMembers'), csrMembers.cName, '')
				Thisform.ZapMembersCursor()
		
				lbSameForm 		 = .cSourceFileName == lcSourceFileName
		
				.LockScreen			 = .T.
				.lEditingOneProperty = .F.
				.cSourceFileName	 = lcSourceFileName
				.lClass				 = llClass
				.oObject			 = loObject
				.oTopOfForm			 = loTopOfForm
		
				Try
					.nTopOfFormWidth  = loTopOfForm.Width
					.nTopOfFormHeight = loTopOfForm.Height
				Catch
		
				Endtry
		
				.lIsTopOfForm	 = Nvl (loObject = loTopOfForm, .T.)
		
				* Include the class/form and VCX/SCX name in the Caption.
				lcCaption = IIf (Thisform.lPEMEditor,  ccLOC_CAP_TITLE, ccLOC_CAP_DocTreeViewTITLE)		;
					+ ' - ' +																			;
					IIf (.lClass, .oTopOfForm.Name + ' (', '') +										;
					Justfname (.cSourceFileName) + IIf (.lClass, ')', '')
		
				lbSameForm =   lbSameForm And .Caption == lcCaption
				If Not lbSameForm
					.CloseTreeView (.T.)
					.oServer.MarkNotCurrent()
					.Caption = lcCaption
					If .oPrefs.lResetFiltersonChange
						.GetPutFilterDefaults (.T.)
						.cSubString	  = ''
						.cSubStringMV = ''
					Endif
				Endif
		
				Do Case
					Case .lDocTreeView
					
					Case lnSelectedObjects > 1
						* 	Thisform.nMethodView = 1
					Case Thisform.oPrefs.lEventHandlersEnabled
						Thisform.ExecuteMethod  (loObject, '_pemeditor_gotfocus')
				Endcase
		
				.oMemberDataEngine = .Null.
				.oMemberDataEngine = Newobject ([MemberDataEngine], [PEME_MemberDataEngine.PRG])
		
				.lFormIsEnabled = .T.
		
				If .lPEMEditor
		
					If .lClass
						.AddMRUFile (.cSourceFileName, .oTopOfForm.Name)
						.AddMRUFile (.cSourceFileName) && class library
					Else
						.AddMRUFile (.cSourceFileName)
					Endif
		
					*** JRN 2010-03-22 : MRU Project
					If Application.Projects.Count # 0
						.AddMRUFile (Application.ActiveProject.Name)
					Endif
		
					* Populate the grid and select the appropriate property or method.
					.lAvoidBufferOverrun = .AvoidBufferOverrun (loObject, .lIsTopOfForm, .lClass)
		
					With .oMemberDataEngine
						lnSeconds		= Seconds()
						.lClassDesigner	= llClass
						.oObject		= loObject
						.SetupEngine()
						.CreateMemberDataCollection ('csrMembers', Thisform.lIsTopOfForm And llClass, Thisform.lAvoidBufferOverrun, .F., This.lNoErrorMsgOnMissingVCX)
		
						*** JRN 03/17/2009 : determine unique members when multiple controls selected
						lcName = .oObject.Name
						If lnSelectedObjects > 1
		
							Select  *										;
								  , 0001				 As	 nObjCount		;
								  , Padr (lcName, 128)	 As	 cObjName		;
								From csrMembers								;
								Into Cursor csrMultMembers Readwrite
		
							For lnI = 2 To lnSelectedObjects
								.oObject					 = This.aSelectedObjects (lnI)
								Thisform.lAvoidBufferOverrun = Thisform.AvoidBufferOverrun (Thisform.oObject, Thisform.lIsTopOfForm, Thisform.lClass)
								*!*							.SetupEngine()
								*!*							Thisform.ZapMembersCursor()
								*!*							.CreateMemberDataCollection('csrMembers', Thisform.lIsTopOfForm And llClass, Thisform.AvoidBufferOverrun(.oObject, .F., .F.), .F., This.lNoErrorMsgOnMissingVCX)
								This.CreateMemberDataNew (.oObject, 'csrMembersMore')
								lcName = .oObject.Name
								Insert Into csrMultMembers		;
									Select  *					;
										  , lnI					;
										  , lcName				;
										From csrMembersMore && Where cType = 'P'
							Next lnI
		
							Replace All nObjNumber With nObjCount In csrMultMembers
							lnMax = IIf (Thisform.lFoundForAll, lnSelectedObjects, 0)
							Select												;
									Lower (cName)								;
								  , cType										;
								  , Max (cName)			 As	 cName				;
								  , Max (lAccess)		 As	 lAccess			;
								  , Max (lAssign)		 As	 lAssign			;
								  , Max (nVisibility)	 As	 nVisibility		;
								  , Max (lNative)		 As	 lNative			;
								  , Max (lInherited)	 As	 lInherited			;
								  , Max (lNonDefault)	 As	 lNonDefault		;
								  , Max (lHasCode)		 As	 lHasCode			;
								  , Max (nFavorites)	 As	 nFavorites			;
								  , Max (lReadOnly)		 As	 lReadOnly			;
								  , Space(255)			 As	 cDescript			;
								  , Sum(1)				 As	 Count				;
								From csrMultMembers								;
								Group By 1, 2									;
								Into Cursor csrMults Readwrite					;
								Having Count >= lnMax
		
							Thisform.ZapMembersCursor()
							Append From Dbf ('csrMults')
		
							This.lEditingOneProperty = .F.
							*	Wait (Seconds() - lnSeconds) Window Nowait
						Endif
		
						This.CreateEventBindings (.T.)
					Endwith
		
					* Set dynamic highlighting for the grid.
					.SetGridHighlighting()
		
					* Filter the cursor as indicated. If we haven't been told what member to select,
					* go to the first one. Otherwise, ensure the one we're supposed to display is
					* visible given the filter. If not, clear the filter. If we still can't find
					* it, go to the first one.
		
					Select csrMembers
					Set Relation To Padr (cName, 30) Into PropertyList
					.SetFilter (.T.)
					*** JRN 12/02/2008 : only look for .cPem -- not previously displayed value
					* this can cause the filters to be re-set when switching between forms/classes
					lcMember = Evl (.cPem, lcCurrentMember)
					* lcMember = Icase(Not Empty(.cPEM), .cPEM,					;
					vartype(.oMember) = 'O' And Not Empty(.oMember.cName),		;
					.oMember.cName, '')
					If Empty (lcMember)
						Locate
					Else
						Locate For .JustPem (cName, .T.) == .JustPem (lcMember, .T.)
						If Not Found()
							If Empty (.cPem)
								Locate
							Else
								Set Filter To
								Locate For .JustPem (cName, .T.) == .JustPem (lcMember, .T.)
								If Not Found()
									Locate
								Endif Not Found()
							Endif Empty (.cPem)
						Endif Not Found()
					Endif Empty (lcMember)
					.cPem	= '' && so we don't repeat
		
					* Set focus to the grid and populate the form with the attributes of the
					* selected member.
		
					* .grdMembers.SetFocus()
					.ScatterCursor()
					.SetProperties()
		
					* Turn on data binding now that we have something for the control sources.
		
					.BindControls = .T.
		
					With .cntGridControls
						.Enabled					= .T.
						.gridmembers.HighlightStyle	= 1 && turn it off if we ain't got focus, cause its wrong
						.Refresh()
					Endwith
		
					.cntControls.Enabled = .T.
					.cntControls.Refresh()
					.ocntFilters.Visible = .T.
					.oSplitterH.Enabled	 = Not Thisform.oPrefs.lGridAbove
					.osplitterV.Enabled	 = Thisform.oPrefs.lGridAbove
		
					If 'O' = Vartype (This.oUtils.oDocTreeView)
						This.oUtils.oDocTreeView.ActivateForm()
					Endif
		
					This.SetMessageTo (Thisform.oObject)
		
				Else && DocTreeView here
		
					.HideDocTreeView(.F.)
					.cCurrentObjectName = .GetObjectPath (loObject)
					.ScatterCursor()
					.BindControls = .T.
		
					If lbSameForm
						This.SaveNodeHighlighting (.oObjectTree.oTree, 'Find', .cCurrentObjectName)
					Else
						With .oObjectTree
							.lHideCombo		  = .T.
							This.lRebuildTree = .F.
							If Not .lComboTreeOpen
								.OpenControl()
							Endif
							.DrawTreeview (.T., This.lRebuildTree)
						Endwith
						.Refresh()
					EndIf
				Endif
		
				.cntIcons.Refresh()
		
				.LockScreen	= .F.
		
				* 10/22/14 TGL: Re-open the debugger if we closed it. 
				IF llDebuggerOpen
					Debug
					Try
						Show Window (lcWontop)
					Catch
					
					Endtry
				ENDIF
		
			Endwith
		
		Endif
		
		
	ENDPROC

	PROCEDURE addaccessassign		&& Adds an access or assignmethod for the property
		Lparameters tcName,	;
			tcProperty, ;
			tcCode, ;
			tcType, ;
			tnVisibility
		Local lcCodeType, ;
			lcCode, ;
			lcName, ;
			lnRecNo,		;
			lcACCESS_CODE,	;
			lcASSIGN_CODE, ;
			lnVisibility
		
		****************************************************************
		
		If Empty (tcCode)
		
			Do Case
		
					*** JRN 03/02/2009 : following structure used instead of NVL
					* as the #defined variables are multiple lines with ';' for continuation
		
				Case tcType = 'ACCESS' And ('(' $ tcName Or '[' $ tcName)
					lcCode = Thisform.oPrefs.cArrayAccessCode
		
				Case tcType = 'ACCESS'
					lcCode = Thisform.oPrefs.cAccessCode
		
				Case tcType = 'ASSIGN' And ('(' $ tcName Or '[' $ tcName)
					lcCode = Thisform.oPrefs.cArrayAssignCode
		
				Case tcType = 'ASSIGN'
					lcCode = Thisform.oPrefs.cAssignCode
		
			Endcase
		
			lcCode = Strtran(lcCode, 'PEM_Name_Place_Holder', tcProperty) + ccCR
		
		Else
		
			lcCode = tcCode
		
		Endif Empty(tcCode)
		
		* If the name was specified in mixed case, use a mixed case method name.
		
		If Lower(tcProperty) <> tcProperty And Thisform.UseMemberData()
			lcName = tcProperty + '_' + Proper(tcType)
		Else
			lcName = Lower(tcProperty + '_' + tcType)
		Endif Lower(tcProperty) <> tcProperty
		
		* Write the code and add a record to the cursor for the method.
		lcCode = This.oUtils.GetNewMethodHeader(lcName) + lcCode
		
		lnVisibility = Thisform.oPrefs.nAssignVisibility
		Do Case
			Case Not This.lClass
				lnVisibility = 1
			Case lnVisibility = 4
				lnVisibility = tnVisibility
		Endcase
		
		Thisform.oTopOfForm.WriteMethod(lcName, lcCode, .T., lnVisibility)
		
		If Thisform.lIsTopOfForm
			lnRecNo = Recno([csrMembers])
			Insert Into csrMembers(cName, cType, nVisibility, lNonDefault, lHasCode) Values (lcName, [M], lnVisibility, .T., .T.)
			Thisform.NotifyNewPemsHidden()
			Go lnRecNo In csrMembers
		Endif
		
	ENDPROC

	PROCEDURE adddopeproperty
		Lparameters loObject, tcName, tcDopeText, tlAlways
		Local lcDopeText
		
		* if this object if actually top of form (we are editing the class itself)
		* then only add the builder property if tlAlways = .T.
		If Lower(loObject.baseclass) # 'form' and This.oTopOfForm = loObject and not tlAlways
			Return
		endif
		
		lcDopeText = '*** .' + tcDopeText
		loObject.AddProperty (tcName, .F., 1, lcDopeText)
		
		
	ENDPROC

	PROCEDURE addmrumenuitems
		Lparameters lcMRUlist, lcMenuName, lcID, llClassLib
		
		Local laMRUList[1], lcFileName, lcPrompt, lcText, lnBar2, lnRow
		
		Acopy (Thisform.&lcMRUlist, laMRUList)
		lnBar2 = 0
		
		For lnRow = 1 To Alen (laMRUList,1)
			lcFileName = laMRUList(lnRow,1)
			If Not Empty (lcFileName)
				lcPrompt = Thisform.GetDisplayRelativePath (lcFileName)
		
				If 'VCX' = Upper(Justext(lcFileName))
					lcClass = laMRUList (lnRow,2)
					If Not llClassLib
						lcPrompt = Evl (lcClass, '?') + "  of  " + lcPrompt
					Endif
				Else
					lcClass = ''
				Endif
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of (lcMenuName) Prompt lcPrompt
				lcText = lcID + ' |' + lcFileName + '|' + Evl(lcClass, ' ')
				On Selection Bar (lnBar2) Of (lcMenuName) lcChoice = [&lcText]
		
			Endif
		Endfor
		
		Return lnBar2
		
	ENDPROC

	PROCEDURE addnew
		Lparam tcType, tcName
		
		Local llMethod
		
		This.CloseTreeView()
		
		If This.oPrefs.lGridAbove
			This.oSplitterV.Collapse(.F.)
		Else
			This.oSplitterH.Collapse(.F.)
		Endif
		
		If Not Empty(tcType)
			Thisform.cnewmembertype = tcType
		Endif
		llMethod = 'M' $ Thisform.cnewmembertype
		
		With This
			.ScatterCursor(.T., Iif(llMethod, 'M', 'P'))
			.Refresh()
			With .otxtname
				If Empty(tcName)
					.SetFocus()
				Else
					.Value = tcName
					This.MemberChanged()
					This.cntControls.cntCommandButtons.cntAdd.cmdApplyAndAdd.SetFocus()
				Endif
			Endwith
		Endwith
		Return
		
		
	ENDPROC

	PROCEDURE applychanges
		*** JRN 11/11/2008 : Create all locals at top
		Local  ;
			loObject As Object
		Local lbResetToDefault, lcDefault, lcDescription, lcExpression, lcName, lcOldName, lcOldType, lcPem
		Local llNew, lnRecNo, lnVisibility, luVal, lxValue
		
		llNew = Thisform.oMember.IsNewMember
		lcOldName = Thisform.JustPEM(Thisform.oOriginalMember.cName)
		lcOldType = Thisform.JustPEM(Thisform.oOriginalMember.cType)
		
		If Not llNew
			*** JRN - 11/03/2008 -- Save the changes to the member from the object thisform.oMember
		
			*** JimNelson 10/31/2008: due to filters, there may not be any current record
			If Recno() > Reccount()
				Return
			Endif
		
			If Thisform.nSelectedObjects = 1
		
				****************************************************************
				* Change type to Property or Method
				* Previously was opgType.InteractiveChange
				* Delayed until now so it only occurs when change are actually applied
		
				If Thisform.oMember.cType # Thisform.oOriginalMember.cType
		
					***********************************************************************
					*** Changed By.: Marcia G. Akins on 13 May 2007
					*** Reason.....: If we are here, it means that we mistakenly added a property
					*** ...........: when we meant to add a method or vice versa
					***********************************************************************
					*** Get the values to use for the member.
					*** and save the current position in the grid
		
					lnRecNo = Recno( [csrMembers] )
					With Thisform
						lcName        = Thisform.JustPEM(Thisform.oMember.cName, .T.)
						lnVisibility  = .oMember.nVisibility
						lcDefault     = .oedtDefault.xValue
						lcDescription = Alltrim(.oMember.cDescript)
		
						*** Now remove the thing we are changing
						*** but do not delete the record from the grid
						.removeMember(  lcName, .T. )
						Go lnRecNo In csrMembers
						If Thisform.oMember.cType = 'M'
							.oObject.WriteMethod( lcName, [], .T., lnVisibility, lcDescription)
							Replace cType With [M] In csrMembers
							.lMethod = .T.
						Else
							.oObject.AddProperty(lcName, lcDefault, lnVisibility, lcDescription )
							Replace cType With [P] In csrMembers
							.lMethod = .F.
						Endif
					Endwith
		
				Endif
		
				****************************************************************
				*  Change to default value?
				*  Previously was in oedtDefault.Valid
		
				If Thisform.oMember.cType = 'P' And Thisform.oMember.DefaultChanged
					lcName = Alltrim(Thisform.JustPEM(Thisform.oOriginalMember.cName, .T.))
					luVal = Iif( InList (Upper(lcName), ccCharacterProperties), Thisform.oedtDefault.Value, Thisform.oedtDefault.xValue)
		
					With Thisform
						*** JimNelson 10/31/2008: for some native properties, not all values entered are valid
						Try && for some native properties, not all values entered are valid
		
							Do Case
								Case Vartype(luVal) = 'C' And luVal = ['] And Not ['] $ Substr(luVal,2)
									Thisform.oObject.WriteExpression (lcName, [='] + Substr(luVal,2) + ['])
								Case Vartype(luVal) = 'C' And luVal = '='
									Thisform.oObject.WriteExpression (lcName, luVal)
								Otherwise
									If Not Empty(Thisform.oObject.ReadExpression (lcName))
										Thisform.oObject.WriteExpression (lcName, '') && clear out all expression, if any.
									Endif
									*** JRN 12/23/2008 : assignment rather than AddProperty, since that fails on OLEs
									With Thisform.oObject
										lcExpression = "." + lcName + " = luVal"
										&lcExpression && note that macro expansion works here
									Endwith
									*  Thisform.oObject.AddProperty( Alltrim( lcName ), luVal) && , lnVisibility, lcDescrip)
							Endcase
		
						Catch To loException
							Thisform.ShowErrorMsg(loException, 'Set Property!! Failure')
						Endtry
						*** JimNelson 10/31/2008: end of new code
					Endwith
		
				Endif
		
			Else
		
				With Thisform
					If Not Thisform.lEditingOneProperty
						lxValue = Iif( InList (Upper(lcOldName), ccCharacterProperties), .oedtDefault.Value, .oedtDefault.xValue)
						.UpdateSelectedControls (.oObject, lcOldName, lxValue, .F.)
					Else
						lcPem = Trim(Thisform.cEditPropertyName)
						lxValue = Iif( InList (Upper(lcPem), ccCharacterProperties), .oedtDefault.Value, .oedtDefault.xValue)
						loObject = Thisform.aSelectedObjects(Thisform.nObjNumber)
						.UpdateSelectedControls (loObject, lcPem, lxValue, .T.)
					Endif
				Endwith
		
			Endif
		
			****************************************************************
		
			Gather Name Thisform.oMember Memo
		
		Else
		
			If Thisform.oMember.cType = 'P'
		
				If Thisform.oPrefs.lAssignDefaultValue And Not Thisform.oMember.DefaultChanged
					* assign default value if appropriate
					lxValue = Thisform.GetDefaultValue( Thisform.JustPEM(Thisform.oMember.cName))
					With Thisform.oedtDefault
						.xValue = lxValue
					Endwith
				Else
					lxValue = Thisform.oedtDefault.xValue
				Endif
		
				*** JRN 2009-10-27 : new properties always non-default; removed If / Endif
				*	If 'L' # Vartype(lxValue) Or lxValue
				Thisform.oMember.lNonDefault = .T.
				*	Endif
			Endif
		
			Insert Into csrMembers From Name Thisform.oMember
			Thisform.NotifyNewPemsHidden()
			Thisform.cnewmembertype = csrMembers.cType
		
		Endif
		
		*** JimNelson 11/08/2008: after saving the changes, refresh the grid
		*** Thisform.editMember() for top level stuff
		With Thisform
		
			*** JRN 2009-10-27 : New properties always non-default; removed following line
			*	lbResetToDefault = llNew And Thisform.oMember.cType = 'P' And Not Thisform.oMember.lNonDefault
		
			If llNew Or Thisform.lIsTopOfForm
				.EditPropertyMethods(lcOldName, lcOldType) && _Access and _Assign ... and also renaming
				.EditMember() && this does actual updating of _Memberdata
			EndIf
		
			If llNew	
				.oUtils.AddToCKL(.JustPEM(Alltrim(.oMember.cName)))
			EndIf 
		
			* Reset the member to default if we're supposed to.
		
			*** JRN 2009-10-27 : Following lines no longer needed
			*	If lbResetToDefault
			*		Thisform.ResetMembertodefault()
			*	Endif tlResetToDefault
		
			If llNew And Not Thisform.lIsTopOfForm
				Thisform.ActivateForm(.T.)
			Else
				.SetProperties()
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE autorename
		Lparameters loControl
		Thisform.AutoRenameControls (loControl, .T., .F.)
	ENDPROC

	PROCEDURE autorenamecontrol
		Lparameters loControl, lcNewPrefix
		Local lcBaseClass, lcNewName, lcCaption, lnThirdSpace, lcChars, lcControlSource, lcRecordSource
		Local lcCustomPRG, lnCounter, lcName, loException, lbHide1
		
		*** JRN 03/05/2009 : Default behavior
		lcBaseClass = Lower(loControl.BaseClass)
		
		Do Case
		
			Case Not Empty (lcNewPrefix)
				lcNewName = lcNewPrefix
		
			Case lcBaseClass= 'checkbox'
				lcNewName = 'chk'
		
			Case lcBaseClass= 'collection'
				lcNewName = 'col'
		
			Case lcBaseClass= 'combobox'
				lcNewName = 'cbo'
		
			Case lcBaseClass= 'commandbutton'
				lcNewName = 'cmd'
		
			Case lcBaseClass= 'commandgroup'
				lcNewName = 'cmg'
		
			Case lcBaseClass= 'container'
				lcNewName = 'cnt'
		
			Case lcBaseClass= 'control'
				lcNewName = 'ctl'
		
			Case lcBaseClass= 'editbox'
				lcNewName = 'edt'
		
			Case lcBaseClass= 'form'
				lcNewName = 'frm'
		
			Case lcBaseClass= 'grid'
				lcNewName = 'grd'
		
			Case lcBaseClass= 'column'
				lcNewName = 'grc#'
		
			Case lcBaseClass= 'header'
				lcNewName = 'grh'
		
			Case lcBaseClass= 'hyperlink'
				lcNewName = 'hpl'
		
			Case lcBaseClass= 'image'
				lcNewName = 'img'
		
			Case lcBaseClass= 'label'
				lcNewName = 'lbl'
		
			Case lcBaseClass= 'line'
				lcNewName = 'lin'
		
			Case lcBaseClass= 'listbox'
				lcNewName = 'lst'
		
			Case lcBaseClass= 'oleboundcontrol'
				lcNewName = 'olb'
		
			Case lcBaseClass= 'ole'
				lcNewName = 'ole'
		
			Case lcBaseClass= 'optionbutton'
				lcNewName = 'opt#'
		
			Case lcBaseClass= 'optiongroup'
				lcNewName = 'opg'
		
			Case lcBaseClass= 'pageframe'
				lcNewName = 'pgf'
		
			Case lcBaseClass= 'page'
				lcNewName = 'pag#'
		
			Case lcBaseClass= 'separator'
				lcNewName = 'sep'
		
			Case lcBaseClass= 'shape'
				lcNewName = 'shp'
		
			Case lcBaseClass= 'spinner'
				lcNewName = 'spn'
		
			Case lcBaseClass= 'textbox'
				lcNewName = 'txt'
		
			Case lcBaseClass= 'timer'
				lcNewName = 'tmr'
		
			Case lcBaseClass= 'toolbar'
				lcNewName = 'tbr'
		
		Endcase
		
		Do Case
		
			Case Empty (lcNewName)
		
			Case Thisform.GetPEMStatus (loControl, 'ControlSource', 5) And Not Empty (loControl.ControlSource)
				lcControlSource = loControl.ControlSource
				If "." $ lcControlSource
					lcControlSource = Substr (lcControlSource, 1 + RAt(".", lcControlSource ))
				Endif
				lcNewName = lcNewName + lcControlSource
		
			Case Thisform.GetPEMStatus (loControl, 'RecordSource', 5) And Not Empty (loControl.RecordSource)
				lcRecordSource = loControl.RecordSource
				lcNewName = lcNewName + lcRecordSource
		
			Case Thisform.GetPEMStatus (loControl, 'Caption', 5) And Thisform.GetPEMStatus (loControl, 'Caption', 0)
				lcCaption = loControl.Caption
				lnThirdSpace = At(" ", lcCaption, 3)
				If lnThirdSpace # 0
					lcCaption = Left (lcCaption, lnThirdSpace)
				Endif
				lcChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
				lcNewName = lcNewName + Chrtran(lcCaption , Chrtran(lcCaption , lcChars, ""), "")
		
		Endcase
		
		*** JRN 03/05/2009 : Custom PRG to handle this?
		*	lcCustomPRG =  Thisform.cApplicationPath + "AutoRenameControl.PRG"
		lcCustomPRG =  This.oUtils.GetPlugInPath ("AutoRenameControl")
		If not Empty (lcCustomPRG)
			Try
				lcNewName = Execscript(Filetostr(lcCustomPRG), loControl, lcNewName)
			Catch To loException
				Thisform.ShowErrorMsg(loException, 'Automatic Control Rename Failure', lcCustomPRG)
			Endtry
		
		Else
		
		Endif
		
		*** JRN 03/05/2009 : add on the number suffix, if needed, to avoid conflicts
		lnCounter = 1
		If '#' $ lcNewName
			lcNewName = Strtran(lcNewName, '#', '')
			lbHide1 = .F.
		Else
			lbHide1 = .T.
		Endif
		
		Do While Not Empty (lcNewName) And (Not Thisform.GetPEMStatus (loControl, "Name", 1))
			lcName = lcNewName + Iif (lbHide1 And lnCounter = 1, '', Transform (lnCounter))
			If Thisform.GetPEMStatus (loControl.Parent, lcName, 5)
				lnCounter = lnCounter + 1
			Else
				lcNewName = lcName
				Exit
			Endif
		Enddo
		
		Return lcNewName
		
	ENDPROC

	PROCEDURE autorenamecontrols
		Lparameters loControl, lbNoChildren, lbCheckingOnly
		
		* automatically renames the current control (and its sub-controls) if it has the default VFP name
		Local loChildControl AS Object
		Local lbChangeChildren, lbChangeMyName, lbNameChangeable, lcClass, lcNamePrefix, lcNewName, lnIndex 
		
		lcClass = Lower(loControl.Class)
		lcNamePrefix = ''
		If Empty (loControl.ClassLibrary)
			Local laClasses(1), laStdNames(1), laPrefixes(1)
			Alines(laClasses, "TextBox,EditBox,CommandButton,OptionButton,CheckBox,ComboBox,ListBox", .T.,',')
			Alines(laStdNames, "text,edit,command,option,check,combo,list", .T.,',')
			Alines(laPrefixes, "txt,edt,cmd,opt,chk,cbo,lst", .T.,',')
		
			lnIndex = Ascan (laClasses, loControl.Class, 1, -1, 1, 1)
			If lnIndex # 0
				lcClass = laStdNames(lnIndex)
				lcNamePrefix = laPrefixes(lnIndex)
			Endif
		Endif
		
		lbNameChangeable = Not Thisform.GetPEMStatus (loControl, "Name", 1)
		
		If lbNoChildren
			lbChangeMyName = lbNameChangeable 
			lbChangeChildren = .F.
		Else
			lbChangeMyName = lbNameChangeable								;
				and Lower (loControl.Name) = lcClass 						;
				and 0 # Val (Substr (loControl.Name, 1 + Len (lcClass)))	
		
			lbChangeChildren =  Thisform.GetPEMStatus(loControl, 'Objects', 5)			;
				or (Thisform.lClass And Thisform.oTopOfForm = loControl)
		Endif
		
		Do Case
			Case Not (lbNameChangeable Or lbChangeChildren)
				Return .F.
			Case lbCheckingOnly
				Do Case
					Case lbNameChangeable And lbChangeChildren
						Return 'Both'
					Case lbNameChangeable
						Return 'Name'
					Case lbChangeChildren
						Return 'Children'
					Otherwise
						Return ''
				Endcase
		
				*	Return Icase(												;
					lbNameChangeable And lbChangeChildren, 	'Both',			;
					lbNameChangeable, 						'Name',			;
					lbChangeChildren, 						'Children',		;
					'')
		Endcase
		
		If lbChangeMyName
			lcNewName = This.AutoRenameControl (loControl, lcNamePrefix)
		
			Try && not sure if this Try/EndTry is necessary
				loControl.Name = lcNewName
			Catch
		
			Endtry
		Endif
		
		If lbChangeChildren
			If Thisform.GetPEMStatus(loControl, 'Objects', 5)
				For Each loChildControl In loControl.Objects
					This.AutoRenameControls(loChildControl )
				Next loControl
			Endif Thisform.GetPEMStatus(loControl, 'Objects', 5)
		Endif
		
		
	ENDPROC

	PROCEDURE avoidbufferoverrun
		Lparameters toObject, tlTopOfForm, tlClass
		
		If Not Used('BufferOverrunList')
			Return .F.
		Endif
		
		Do Case
			Case tlTopOfForm And tlClass
				Select * From BufferOverrunList 							;
					where Lower(classname) = Lower(toObject.Class)			;
					and Lower(Justfname(classloc)) = Lower(Justfname(Thisform.cSourcefilename))	;
					noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
				Select * From BufferOverrunList 							;
					where Lower(classname) = Lower(toObject.ParentClass)			;
					and Lower(Justfname(classloc)) = Lower(Justfname(toObject.ClassLibrary))	;
					noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
			Case tlTopOfForm And Not tlClass
		
				Select * From BufferOverrunList 							;
					where Lower(Justfname(classloc)) = Lower(Justfname(Thisform.cSourcefilename))	;
					noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
				Select * From BufferOverrunList 							;
					where Lower(classname) = Lower(toObject.Class)			;
					and Lower(Justfname(classloc)) = Lower(Justfname(toObject.ClassLibrary))	;
					noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
			Otherwise
		
				Select * From BufferOverrunList 							;
					where Lower(classname) = Lower(toObject.Class)			;
					and Lower(Justfname(classloc)) = Lower(Justfname(toObject.ClassLibrary))	;
					noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
		Endcase
		
		Return .F.
		
		
	ENDPROC

	PROCEDURE changewindowdimensions
	ENDPROC

	PROCEDURE checkfornewproperty
		Lparameters lxValue, lcPem, loObject, loTopOfForm
		
		Local lcObjectName, lcPropertyName, lnLastDot, lnMsgBoxAns, loThis, lxNewValue
		Do Case
			Case 'C' # Vartype (lxValue)
				Return .T.
		
			Case Upper (lxValue) = 'THISFORM.' and 2 = GetWordCount(lxValue, '.')
				lcPropertyName = Getwordnum (lxValue, 2, '.')
				Do Case
					Case Lower(loTopOfForm.BaseClass) # 'form'
						Return .T.
					Case Empty(lcPropertyName)
						Return .T.
					Case Len (Alltrim (lcPropertyName)) # Len (lcPropertyName)
						Return .T.
					Case Pemstatus (loTopOfForm, lcPropertyName, 5)
						Return .T.
					Otherwise
						Do Form AskAddPemNew With lcPropertyName To llResult
						Return llResult
				Endcase
		
			Case Upper (lxValue) = 'THIS.'
			
				lnLastDot	   = RAt ('.', lxValue)
				lcPropertyName = Substr (lxValue, lnLastDot + 1)
				lcObjectName   = 'lo' + Left (lxValue, lnLastDot - 1)
				loThis		   = loObject
				If 'O' # Type (lcObjectName) Or loTopOfForm # Evaluate (lcObjectName)
					Return .T.
				Endif
		
				Do Case
					Case Len (Alltrim (lcPropertyName)) # Len (lcPropertyName)
						Return .T.
					Case Empty(lcPropertyName)
						Return .T.
					Case Pemstatus (loTopOfForm, lcPropertyName, 5)
						Return .T.
					Otherwise
						Do Form AskAddPemNew With lcPropertyName To llResult
						Return llResult
				Endcase
		
			Otherwise
				Return .T.
		
		Endcase
		
		
		
	ENDPROC

	PROCEDURE checkmemberdata		&& Checks to see if we need to update member data
		Lparameters tcName, tlFixFavorites
		
		Local  ;
			loNode As Object	,;
			loRoot As Object
		Local llFavorites, llMixedCase, lnRecno, lcXML
		
		If Not This.UseMemberData()
			Return
		Endif
		
		llMixedCase = Not Lower(tcName) == tcName
		If tlFixFavorites
			llFavorites = Inlist (csrMembers.nFavorites, 2, 4)
		Else
			llFavorites = .F.
		EndIf 
		
		With This
			* Re-load .oXML with _Memberdata; unless it doesn't exist, hasn't changed or is empty
			If Thisform.GetPEMStatus(.oTopOfForm, '_MemberData', 5)				;
					and Thisform.GetPEMStatus(.oTopOfForm, '_MemberData', 0)	;
					and Not Empty (.oTopOfForm._MemberData)
				.oXML.LoadXML(.oTopOfForm._MemberData)
				* Get the node for the member.
				loNode = .oXML.selectSingleNode('//memberdata[@name = "' + Lower(tcName) + '"]')
			Else
				.oXML.LoadXML('')
				loNode = .Null.
			Endif Not llChanged
		Endwith
		
		* close With / EndWith so that the 'Return' below is not within them
		
		Do Case
				* not already in MemberData, and no reason to put it there
			Case Vartype(loNode) # 'O' And Not (llMixedCase Or llFavorites)
				Return
				* not already in MemberData
			Case Vartype(loNode) # 'O'
				loNode = This.createMemberDataNode(tcName)
				* create MemberData if it doesn't already exist.
				With This
					If Not Thisform.GetPEMStatus(.oTopOfForm, '_MemberData', 5)
						.oTopOfForm.AddProperty('_MemberData', '')
						lnRecno = Recno('csrMembers')
						Insert Into csrMembers (cName, cType, lNonDefault, nVisibility) ;
							values ('_MemberData', 'P', .T., 1)
						* .CheckMemberData('_MemberData')
						Go lnRecno In csrMembers
					Endif
				Endwith
			Otherwise
		
		Endcase
		
		With This
			* update or remove the name display
			Do Case
				Case llMixedCase
					loNode.setAttribute('display', tcName)
				Case Isnull (loNode.getAttribute('display'))
		
				Otherwise
					loNode.removeAttribute('display')
			Endcase
		
			* update or remove the favorites
			Do Case
				Case llFavorites
					loNode.setAttribute('favorites', ccXML_TRUE)
				Case Isnull (loNode.getAttribute('favorites'))
		
				Otherwise
					loNode.removeAttribute('favorites')
			Endcase
		
			* remove node altogether if only one attribute (name)
			If 1 = loNode.Attributes.Length
				loRoot = .oXML.selectSingleNode('/' + ccXML_ROOT_NODE)
				loRoot.RemoveChild(loNode)
				If Not loRoot.HasChildNodes
					.oXML.LoadXML('')
				Endif Not loRoot.HasChildNodes
			Endif
		
			.WriteMemberData(.oXML)
		
		Endwith
		
		Return
		
	ENDPROC

	PROCEDURE closedebuggerwindows
		*** JRN 03/12/2009 : close debugger windows, if any; save restore info
		*  Thisform.nDebuggerWindows:
		*  	    	0 = not checked yet
		*   	   -1 = checked, none found
		*      		1 = checked, some found
		
		Local lnI, lbResult
		
		With This
			If Empty(.nDebuggerWindows) And .oPrefs.lCloseDebuggerWindows
				.nDebuggerWindows = -1
				For lnI = 1 To Alen (.aDebuggerWindows,1)
					If This.lPEMEditor and Wexist (.aDebuggerWindows(lnI,1))
						Try && just in case; what if window is currently active?
							Release Window (.aDebuggerWindows(lnI,1))
						Catch
		
						Endtry
						.aDebuggerWindows(lnI,2) = .T.
						.nDebuggerWindows = 1
						lbResult  = .T.
					Endif
				Next lnI
				.lDebuggerWasOpen = This.IsDebuggerOpen()
			Endif
		Endwith
		
		Return lbResult
		
	ENDPROC

	PROCEDURE closesearchresults
		If 'O' = Vartype (This.oUtils.oSearchResults)
			This.oUtils.oSearchResults.Release
			This.oUtils.oSearchResults = .null.
		EndIf 
	ENDPROC

	PROCEDURE closetreeview
		Lparameters lbTreeviewCurrent
		
		With This.cntGridControls
			.oObjectTree.CloseControl()
			.lTreeviewCurrent = .lTreeviewCurrent And lbTreeviewCurrent
		Endwith
		
	ENDPROC

	PROCEDURE createeventbindings
		Lparameters lbStartOver
		Local loObject AS Object
		Local laEvents(1), lnI
		
		Do Case
			Case Not PEME_IsVersion9()
				Return
			Case Not This.oPrefs.lEventHandlersEnabled
				Unbindevents(This)
				Return
			Case lbStartOver
				Unbindevents(This)
		Endcase
		
		For lnI = 1 To Alen (This.aSelectedObjects)
			loObject = This.aSelectedObjects(lnI)
			If 0 = Aevents (laEvents, loObject) 
				Try
					This.CreateObjectEventBindings (loObject, .T.)
				Catch
				
				EndTry
			EndIf
			If Aevents (laEvents, This) > 50
				Exit
			EndIf 
		Endfor
		
		loObject = This.oObject
		If 0 = Aevents (laEvents, loObject)
			This.CreateObjectEventBindings (loObject, .T.)
		Endif
		
		loObject = This.oTopOfForm
		If 0 = Aevents (laEvents, loObject)
			This.CreateObjectEventBindings (loObject)
		Endif
		
		
		
	ENDPROC

	PROCEDURE creategroupcursors
		****************************************************************
		*****  Group Names
		Local lcGroupNames, lnSelect
		
		lnSelect = Select()
		Try
		
			lcGroupNames = This.cpluginpath + 'GroupNames'
			If Used ('xGroup')
				Use In xGroup
			Endif
		
			Use (lcGroupNames) Alias xGroup Again Shared In 0
			Select  Name, Id		 ;
				From xGroup			 ;
				Order By DisplayOrd	 ;
				Into Cursor crsr_GroupNames
			Use In xGroup
		
		Catch
		
			Select  Name, Id		 ;
				From GroupNames		 ;
				Order By DisplayOrd	 ;
				Into Cursor crsr_GroupNames
		
		Endtry
		
		****************************************************************
		******  Pem Names
		
		Try
			lcGroupNames = This.cpluginpath + 'PemNameGroups'
			If Used ('xGroup')
				Use In xGroup
			Endif
		
			Use (lcGroupNames) Alias xGroup Again Shared In 0
		
			Select  PemNamegroups.*									;
				From PemNamegroups									;
					Left Join xGroup								;
						On PemNamegroups.GroupID = xGroup.GroupID	;
						And PemNamegroups.PemName = xGroup.PemName	;
				Where Isnull (xGroup.PemName)						;
			Union All												;
			Select  GroupID, PemName								;
				From xGroup											;
				Where Not Removed									;
				Into Cursor crsr_PemNameGroups
		
			Use In xGroup
		
		Catch
		
			Select  *				;
				From PemNamegroups	;
				Into Cursor crsr_PemNameGroups Readwrite
		
		Endtry
		
		Index On Upper (PemName) Tag PemName
		
		Select  (lnSelect)
	ENDPROC

	PROCEDURE creatememberdatanode
		lparameters tcName
		local loNode, ;
			lcType, ;
			lcName, ;
			loRoot, ;
			loException
		try
		
		* Create a MemberData node for this member.
		
			loNode = This.oXML.createElement(ccMEMBER_DATA_XML_ELEMENT)
			lcName = lower(tcName)
			loNode.setAttribute('name', lcName)
			
			lcType = iif(csrMembers.cType == [P], [property], [method])
			*** JRN 06/01/09 : add attribute 'Type' only if user so demands, and then only for properties
			If lcType = 'property' and Thisform.oPrefs.lMemberDataKeepType 
				loNode.setAttribute('type', lcType) 
			EndIf 
		
		* Get the root node of the MemberData XML. If it doesn't exist, create it.
		
			loRoot = This.oXML.selectSingleNode('/' + ccXML_ROOT_NODE)
			if vartype(loRoot) <> 'O'
				loRoot = This.oXML.createElement(ccXML_ROOT_NODE)
				This.oXML.appendChild(loRoot)
			endif vartype(loRoot) <> 'O'
		
		* Add the new node to the root.
		
			loRoot.appendChild(loNode)
		catch to loException
			Thisform.ShowErrorMsg(loException)
		endtry
		return loNode
		
	ENDPROC

	PROCEDURE createobjecteventbindings
		Lparameters loObject, llAllEvents
		
		Local laHandlers(1), lcEvent, lcHandler, lcName, lnFlags, lnLength
		
		If Thisform.oPrefs.lEventHandlersEnabled
			If llAllEvents
				lnLength = Len(ccHandlerPrefix)
				Select cname From csrMembers							;
					where Lower(Left(cname,lnLength)) = ccHandlerPrefix	;
					and cType = 'M'										;
					and lHasCode										;
					into Array laHandlers
		
				If _Tally > 0
					For Each lcName In laHandlers
						lcEvent = Lower (Trim(Substr(lcName, lnLength + 1)))
		
						If Right (lcEvent,7) = '_before'
							lcHandler = 'HandleEvents_Before'
							lcEvent = Left (lcEvent, Len(lcEvent) - 7)
							lnFlags = 0
						Else
							lcHandler = 'HandleEvents'
							lnFlags = 1
						Endif
		
						Do Case
							Case lcEvent = 'resize'
								This.peme_bindevent (loObject, 'width', 	lcHandler, lnFlags)
								This.peme_bindevent (loObject, 'height', 	lcHandler, lnFlags)
							Case lcEvent = 'moved'
								This.peme_bindevent (loObject, 'top', 		lcHandler, lnFlags)
								This.peme_bindevent (loObject, 'left', 		lcHandler, lnFlags)
							Otherwise
								This.peme_bindevent (loObject, lcEvent, lcHandler, lnFlags)
						Endcase
					Endfor Each lcName In laHandlers
				Endif _Tally > 0
		
				If Thisform.oPrefs.lHandleEvent_Caption ;
						and Inlist (Lower (loObject.BaseClass), 'checkbox', 'label', 'optionbutton') ;
						and Not loObject = Thisform.oTopofForm
					Bindevent (loObject, 'caption', This, 'ide_eventhandler_before', 0)
					Bindevent (loObject, 'caption', This, 'ide_eventhandler', 1)
					Bindevent (loObject, 'autosize', This, 'ide_eventhandler_before', 0)
					Bindevent (loObject, 'autosize', This, 'ide_eventhandler', 1)
				Endif
			Endif
		
			If Thisform.oPrefs.lHandleEvent_Resize ;
					and ('|' + Lower (loObject.BaseClass) + '|') $ '|form|pageframe|container|commandgroup|optiongroup|'
				Try
					Bindevent (loObject, 'height', This, 'ide_eventhandler', 1)
					Bindevent (loObject, 'width', This, 'ide_eventhandler', 1)
		
					If loObject # Thisform.oTopofForm
						Bindevent (loObject, 'height', This, 'ide_eventhandler_before', 0)
						Bindevent (loObject, 'width', This, 'ide_eventhandler_before', 0)
					Endif
				Catch
		
				Endtry
			Endif
		
		Endif Thisform.oPrefs.lEventHandlersEnabled
		
		
	ENDPROC

	PROCEDURE createsortedobjectarray
		Lparameters loParent, laControls
		
		Local loControl AS Object
		Local laControls, lnControlCount, lnCount, lnI, lnValue
		
		lnControlCount = Thisform.GetControlCount(loParent)
		If lnControlCount # 0 And "O" = Type("loParent.Objects(1)")
		
			Dimension laControls (lnControlCount, 2)
			lnCount = 0
			For lnI = 1 To lnControlCount
				loControl = loParent.Objects(lnI)
				Do Case
					Case Thisform.oPrefs.nTreeSort = 1
						lnValue = 0
					Case Thisform.oPrefs.lTreeMemberSort And Thisform.GetPEMStatus (loControl, 'PageOrder', 5)
						lnValue = loControl.PageOrder
					Case Thisform.oPrefs.lTreeMemberSort And Thisform.GetPEMStatus (loControl, 'ColumnOrder', 5)
						lnValue = loControl.ColumnOrder
					Case Thisform.oPrefs.nTreeSort = 2
						lnValue = loControl.Name
					Case Thisform.oPrefs.nTreeSort = 6
						lnValue = Upper(loControl.Name)
					Case Thisform.oPrefs.nTreeSort = 3 						;
							and Thisform.GetPEMStatus (loControl, 'tabindex', 5)
						lnValue = loControl.TabIndex
					Case Thisform.oPrefs.nTreeSort = 4 						;
							and Thisform.GetPEMStatus (loControl, 'top', 5) 		;
							And Thisform.GetPEMStatus (loControl, 'left', 5)
						lnValue = 1E4 * loControl.Top + loControl.Left
					Case Thisform.oPrefs.nTreeSort = 5 						;
							and Thisform.GetPEMStatus (loControl, 'top', 5) 		;
							And Thisform.GetPEMStatus (loControl, 'left', 5)
						lnValue = 1E4 * loControl.Left + loControl.Top
					Otherwise
						lnValue = 1E9
				Endcase
		
				lnCount = lnCount + 1
				laControls(lnCount,1) = lnCount
				laControls(lnCount,2) = lnValue
			Endfor
		
			If lnCount > 0
				Asort (laControls,2,-1)
			EndIf
		
		Else
		
			lnControlCount = 0
		
		Endif
		
		Return lnControlCount 
	ENDPROC

	PROCEDURE deletethiscontrol
		Local lcPrompt, lnMsgBox, loParent, lcName, loException
		lcPrompt = Strtran (ccLOC_ASK_CMG_DeleteControl, '<insert1>', Thisform.cCurrentObjectName)
		lnMsgBox = Messagebox (lcPrompt , 4+32, Thisform.Caption)
		If lnMsgBox = 6
			Try
				loParent 	= Thisform.oObject.Parent
				lcName 		= Thisform.oObject.Name
				With Thisform
					.oObject = .Null.
					For lnI = 1 To Alen (.aSelectedObjects)
						.aSelectedObjects (lnI) = .Null.
					Endfor
					.nSelectedObjects = 0
				Endwith
				Thisform.ZapMembersCursor()
				Thisform.oTopOfForm.Parent.Show() && transfers focus ... for later refresh by timer
				loParent.RemoveObject(lcName )
			Catch To loException
				Thisform.ShowErrorMsg(loException, 'Delete Control Failure')
			Endtry
		Endif
		
	ENDPROC

	PROCEDURE Destroy
		This.HideDocTreeView(.F.)
		
		Try
			This.RestoreDebuggerWindows()
			DoDefault()
		Catch
		
		Endtry
		
		Local laMembers[1], lcMember 
		Amembers (laMembers, This, 0)
		For Each lcMember In laMembers
			lcMember = Upper (lcMember)
			If Pemstatus(This, lcMember, 4) And 'O' = Vartype (Getpem (This, lcMember))
				This.&lcMember. = .Null.
			Endif
		Endfor
		
	ENDPROC

	PROCEDURE disableform
		Local laObject[1], lcCaption, lnI
		
		*** JRN 12/02/2008 : If no classes or forms are selected, clear grid and blank form
		
		With This
			If This.lFormIsEnabled
				If Used("csrMembers")
					Thisform.ZapMembersCursor()
					.ScatterCursor()
					.Refresh()
				Endif
		
				If Used("csrTreeViewMembersList")
					Use In csrTreeViewMembersList
				Endif
		
				.RestoreDebuggerWindows()
		
				This.CloseTreeView()
				This.lFormIsEnabled = .F.
				.cntIcons.Refresh()
			Endif
		
			.cntGridControls.Enabled = .F.
			.cntControls.Enabled = .F.
			.ocntFilters.Visible = .F.
			.oSplitterH.Enabled = .F.
			.osplitterV.Enabled = .F.
		
			.oObject = .Null.
			.nSelectedObjects = 0
			.oTopOfForm = .Null.
			.HideDocTreeView(.T.)
		
			For lnI = 1 To Alen (.aSelectedObjects)
				.aSelectedObjects (lnI) = .Null.
			Endfor
		
			For lnI = 1 To Alen (.aDesignerObjects)
				.aDesignerObjects (lnI) = .Null.
			Endfor
		
		Endwith
		
	ENDPROC

	PROCEDURE dockable_assign
		Lparameters tDockable
		Local lnOldValue
		
		lnOldValue = This.Dockable
		This.Dockable = tDockable
		
		* if dockable is turned off, form may disappear!
		If lnOldValue = 1 And tDockable = 2
			With This
		
				.Top = Max (0, Min (.Top, _Screen.Height - .Height)) 
		
				.Left = Max (0, Min (.Left, _Screen.Width - .Width))
		
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE doquicktimer
		Lparameters lcQuickTimerAction
		
		With This
			.cQuickTimerAction = lcQuickTimerAction
			.QuickTimer.Enabled = .T.
		Endwith
		
	ENDPROC

	PROCEDURE dorefresh
		Local lcName
		
		*** JRN 12/17/2008 : Try to stay on the same member
		With This
		
			.lRebuildTree = .T.
			If .oObjectTree.lCombotreeOpen
				.oObjectTree.DrawTreeView(.T.)
			Else
				.RefreshGrid()
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE editmember		&& Called to save the new values for the property or method
		Local lcCleanName, ;
			llAccess, ;
			llAssign, ;
			lcAccess, ;
			lcAssign, ;
			llOK
		
		With This
		
			* Get the properties of the member.
			lcCleanName = .JustPEM(Alltrim(.oMember.cName))
			llAccess    = .oMember.lAccess
			llAssign    = .oMember.lAssign
			lcAccess    = lcCleanName + [_Access]
			lcAssign    = lcCleanName + [_Assign]
		
			* If we have member data for the object, load it.
			llOK = .T.
			If Thisform.GetPEMStatus(.oTopOfForm, [_MemberData], 5) And ;
					not Empty(.oTopOfForm._MemberData) And ;
					not .oXML.LoadXML(.oTopOfForm._MemberData)
				Messagebox(ccLOC_INVALID_XML, MB_OK + MB_ICONEXCLAMATION, .Caption)
				llOK = .F.
			Endif Thisform.GetPEMStatus(.oTopOfForm, [_MemberData], 5) ...
			If llOK
				* Update the member data for the member.
				.CheckMemberData(lcCleanName, .T.) && second parameter means to check Favorites as well
		
				* Update the member data for access and assign methods.
				If llAccess
					.CheckMemberData(lcAccess)
				Endif llAccess
				If llAssign
					.CheckMemberData(lcAssign)
				Endif llAssign
			Endif llOK
			
			.SetGlobalFavorite(lcCleanName)
		Endwith
		Return
		
		
		
	ENDPROC

	PROCEDURE editpropertymethods
		Lparameters tcOldName, tcOldType
		
		Local loException As Exception
		Local lcAccess, lcAccessCode, lcAssign, lcAssignCode, lcCleanName, lcCode, lcCustomPRG, lcDefault
		Local lcDescription, lcName, lcNotes, lcOrigName, lcScriptFile, llAccess, llAssign, llFavorites
		Local llHaveAccess, llHaveAssign, llOK, lnRecNo, lnVisibility, loISXOptions
		
		With This
		
			* Change the case of first letter of the name if we're supposed to.
		
			lcName = Alltrim (.oMember.cName)
			If clLOWER_CASE_FIRST_LETTER
				lcName		   = Lower (Left (lcName, 1)) + Substr (lcName, 2)
				.oMember.cName = lcName
				Replace cName With lcName In csrMembers
			Endif clLOWER_CASE_FIRST_LETTER
		
			* Get the properties of the member.
		
			lnVisibility = .oMember.nVisibility
			llAccess	 = .oMember.lAccess
			llAssign	 = .oMember.lAssign
			*** TODO: get this from a property of oMember
			lcDefault	  = .oedtDefault.xValue
			lcDescription = Alltrim (.oMember.cDescript)
			lcCleanName	  = .JustPEM (lcName)
			lcOrigName	  = tcOldName
			lcAccessCode  = []
			lcAssignCode  = []
		
			* Handle a method. Start by reading the existing code. Next, if we changed the
			* name of the method or changed its visibility to Public, delete the original.
			* (The reason we have to do it if the visibility changed is that WriteMethod
			* can't handle that.) Finally, use WriteMethod to create or update the method.
		
			If .lMethod
		
				*	lcCode = Iif(.oMember.IsNewMember, '', .oTopOfForm.ReadMethod(lcOrigName))
				If .oMember.IsNewMember Or tcOldType = 'P'
					lcCode = This.oUtils.GetNewMethodHeader (lcName, lcDescription, lnVisibility)
				Else
					lcCode = .oTopOfForm.ReadMethod (lcOrigName)
				Endif
		
				If Not Lower(lcName) == Lower(lcOrigName) Or ;
						(csrMembers.nVisibility = 1 And .nOriginalVisibility <> 1)
		
					.removeMember (lcOrigName, .T.)
					Try
						If Not Empty (lcDescription)
							.oTopOfForm.WriteMethod (lcName, '', .T., lnVisibility, lcDescription)
						Else
							.oTopOfForm.WriteMethod (lcName, '', .T., lnVisibility)
						Endif
		
						.oTopOfForm.WriteMethod (lcName, lcCode, .F., lnVisibility, lcDescription)
		
					Catch To loException
						If Not Empty (lcCode)
							_Cliptext = lcCode
							Thisform.ShowErrorMsg (loException, 'Failure changing method - Method text copied to clipboard', , 'Method text copied to clipboard')
						Else
							Thisform.ShowErrorMsg (loException, 'Failure changing method')
						Endif
					Endtry
		
				Else
		
					Try
						.oTopOfForm.WriteMethod (lcName, lcCode, .F., lnVisibility, lcDescription)
					Catch To loException
						If Not Empty (lcCode)
							_Cliptext = lcCode
							Thisform.ShowErrorMsg (loException, 'Failure changing method - Method text copied to clipboard', , 'Method text copied to clipboard')
						Else
							Thisform.ShowErrorMsg (loException, 'Failure changing method')
						Endif
					Endtry
		
		
				Endif Not Lower (lcName) == Lower (lcOrigName) ...
		
				* Handle a property. First, if we changed the name of the property or changed
				* its visibility to Public, delete the original. (As above, the reason we have
				* to do it if the visibility changed is that AddProperty can't handle that.)
				* Before we do that, get the existing code for any Access and Assign methods		;
				* note that the old name is replaced in this code with the new one.
				* Finally, add the property and use WriteExpression if the value contains a
				* "=".
		
			Else
				If (Not .oMember.IsNewMember)												;
						And (Not csrMembers.lInherited)										;
						And (Not csrMembers.lNative)										;
						And (																;
						  (Not Lower (lcName) == Lower (lcOrigName)) Or						;
						  (csrMembers.nVisibility = 1 And .nOriginalVisibility # 1)			;
						  )
					If llAccess
						lcAccessCode = .oTopOfForm.ReadMethod (lcOrigName + '_Access')
						lcAccessCode = Strtran (lcAccessCode, lcOrigName, lcCleanName, -1, -1, 1)
					Endif llAccess
					If llAssign
						lcAssignCode = .oTopOfForm.ReadMethod (lcOrigName + '_Assign')
						lcAssignCode = Strtran (lcAssignCode, lcOrigName, lcCleanName, -1, -1, 1)
					Endif llAssign
					.removeMember (lcOrigName, .T.)
				Endif Not .oMember.IsNewMember ...
				Try
					If PEME_IsVersion9()
						.oTopOfForm.AddProperty (lcName, lcDefault, lnVisibility, lcDescription)
					Else
						.oTopOfForm.AddProperty (lcName, lcDefault)
					Endif
					If Vartype (lcDefault) = 'C' And lcDefault = '='
						.oTopOfForm.WriteExpression (lcName, lcDefault)
					Endif Vartype (lcDefault) = 'C' ...
				Catch To loException
					Thisform.ShowErrorMsg (loException, 'Set Property Failure')
				Endtry
		
				* If we need an Access method and it doesn't exist, create it. Remove it if
				* it exists and it's not supposed to.
		
				lcAccess	 = lcCleanName + [_Access]
				llHaveAccess = Thisform.GetPEMStatus (.oTopOfForm, lcAccess, 5)
				Do Case
					Case llAccess And Not llHaveAccess
						.AddAccessAssign (lcName, lcCleanName, lcAccessCode, 'ACCESS', lnVisibility)
					Case Not llAccess And llHaveAccess
						Select csrMembers
						Set Filter To
						.RemoveAccessAssign (lcAccess)
						.SetFilter()
				Endcase
		
				* If we need an Assign method and it doesn't exist, create it. Remove it if
				* it exists and it's not supposed to.
		
				lcAssign	 = lcCleanName + [_Assign]
				llHaveAssign = Thisform.GetPEMStatus (.oTopOfForm, lcAssign, 5)
				Do Case
					Case llAssign And Not llHaveAssign
						.AddAccessAssign (lcName, lcCleanName, lcAssignCode, 'ASSIGN', lnVisibility)
					Case Not llAssign And llHaveAssign
						* Remove the filter in csrMembers because we may need to access other records.
						Select csrMembers
						Set Filter To
						.RemoveAccessAssign (lcAssign)
						.SetFilter()
				Endcase
			Endif .lMethod
		
			If .oMember.IsNewMember or Not lcCleanName == .JustPEM(lcOrigName)
				loISXOptions  = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_GetISXOptions')
				loISXOptions.oKeyWordList.UpdateWord(lcCleanName, .T., .T.)
			EndIf 
		
		Endwith
		
	ENDPROC

	PROCEDURE executemethod
		Lparameters loObject, lcMethod, lcParams, loCodeObject
		
		Private go_PEMEditor, go_PEMEditor_CurrentObject, go_PEMEditor_CurrentForm 
		Local lcMethodCode, lxResult, lcProcs
		
		If "O" # Vartype (loCodeObject)
			loCodeObject = loObject
		EndIf
		
		If This.GetPEMStatus (loCodeObject, lcMethod, 5)
			lcMethodCode = Thisform.GetParentCode(lcMethod, "First Code", loCodeObject)
		
			If Not Empty (lcMethodCode)
				go_PEMEditor = This
				go_PEMEditor_CurrentForm = Thisform.oTopOfForm 
				go_PEMEditor_CurrentObject = loObject
						
				lcMethodCode = 	''																 ;
					+ '#Define This                go_PEMEditor_CurrentObject ' 		+ ccCRLF ;
					+ '#Define ThisForm            go_PEMEditor_CurrentForm ' 			+ ccCRLF ;
					+ '#Define ExecMethod          go_PEMEditor.ExecuteMethod ' 		+ ccCRLF ;
					+ '#Define AutoRename          go_PEMEditor.AutoRenameControls '	+ ccCRLF ;
					+ '#Define EditMethod          go_PEMEditor.EditMethodCode '		+ ccCRLF ;
					+ '******************************'									+ ccCRLF ;
					+ lcMethodCode 														+ ccCRLF 
					
				lxResult = This.ExecuteScript(lcMethodCode, lcParams, loObject)
			Endif
		Endif
		
		Return lxResult
	ENDPROC

	PROCEDURE exportchildmethodcode
		Lparameters loParent, lcFileName, lcNamePrefix
		
		Local loControl As Object
		Local loResult As Object
		Local lcName, lcText, lnCount, lnI, laControls(1)
		
		loResult = Thisform.oServer.GetMethodList(loParent, Thisform.lClass, Thisform.lIsTopOfForm And Thisform.lClass)
		Create Cursor cMyMembers (cName C(128), cType C(1), SortKey C(128))
		Append From Array loResult.MethodList
		
		Select cMyMembers
		Scan
			lcName = Trim (cName)
			lcText = loParent.ReadMethod (lcName)
		
			If Not Empty(lcText)
				lcText = ccCRLF+ ccCRLF + ccTopDividerLine + ccTopDividerLine ;
					+ 'Procedure ' + lcNamePrefix + Trim (cName)+ ccCRLF + lcText + ccCRLF	;
					+ "EndProc" + ccCRLF
		
				Strtofile(lcText, lcFileName, 1)
		
			Endif
		Endscan
		
		****************************************************************
		lnCount = Thisform.CreateSortedObjectArray (loParent, @laControls)
		
		For lnI = 1 To lnCount
			loControl = loParent.Objects(laControls(lnI,1))
			This.ExportChildMethodCode (loControl, lcFileName, lcNamePrefix + loControl.Name + ".")
		Next lnI
		
	ENDPROC

	PROCEDURE exporthtmllistofpems
		*** JRN 12/01/2008 : export list of pems
		
		Local lcDescrip, lcDescript, lcFileName, lcText, lcValue, lcWindowName, lnRecno, lnRight
		
		lcWindowName = Thisform.oTopofForm.Name + Thisform.cCurrentObjectName + ".PEMlist"
		lcFileName = Sys(2023) + "\" + lcWindowName + '.HTML'
		Erase (lcFileName)
		
		Thisform.LockScreen = .T.
		lnRecno = Recno()
		
		****************************************************************
		*** Main Header
		****************************************************************
		
		StrToFile (This.oUtils.oIDEx.gethtmlmainheader(), lcFileName, 1)
		
		****************************************************************
		*** Properties
		****************************************************************
		
		TEXT TO lcText NOSHOW TEXTMERGE
		<div>
		 <strong>Properties</strong>
		</div>
		
		<table style="width: 100%">
			<tr class="GridHeader">
				<td style="vertical-align:middle;">Property Name</td>
				<td style="vertical-align:middle;">Default Value</td>
				<td style="vertical-align:middle;">Description</td>
			</tr>
			
		EndText
		
		StrToFile (lcText, lcFileName, 1)
		
		*** scan thru properties
		Scan for cType = 'P' and Lower (cname) # '_memberdata '
			lcValue = Thisform.GetValue(cName, lNative, 'Display', Thisform.nObjNumber, cDescript)
			TEXT TO lcText NOSHOW TEXTMERGE
			<tr>
				<td> <<Trim(cName)>> </td>
				<td> <<lcValue>> </td>
				<td> <<Trim(cDescript)>> </td>
			</tr>
			EndText
			StrToFile (lcText, lcFileName, 1)
		
		EndScan 
		
		TEXT TO lcText NOSHOW TEXTMERGE
		</table>
		
		 <p />
		
		EndText
		
		StrToFile (lcText, lcFileName, 1)
		
		****************************************************************
		*** Methods and Events
		****************************************************************
		
		
		TEXT TO lcText NOSHOW TEXTMERGE
		<div>
		
		 <strong>Methods</strong>
		</div>
		
		
		<table style="width: 100%">
			<tr class="GridHeader">
				<td style="vertical-align:middle;"Method Name</td>
				<td colspan="2">Description</td>
			</tr>
		
		EndText
		
		StrToFile (lcText, lcFileName, 1)
		
		
		*** scan thru methods
		Scan for cType $ 'ME' 
			TEXT TO lcText NOSHOW TEXTMERGE
			<tr>
				<td><<Trim(cName)>></td>
				<td><<Trim(cDescript)>></td>
			</tr>
			EndText
			StrToFile (lcText, lcFileName, 1)
		
		EndScan 
		
		
		TEXT TO lcText NOSHOW TEXTMERGE
		</table>
		
		
		</body>
		
		</html>
		EndText
		
		****************************************************************
		
		StrToFile (lcText, lcFileName, 1)
		This.oUtils.ViewHTMLTempFile(lcFileName)
		
		****************************************************************
		****************************************************************
		
		Try
			Locate For Recno() = lnRecno && checked
		Catch
			Locate && checked
		Endtry
		
		Thisform.LockScreen = .F.
		
	ENDPROC

	PROCEDURE exportlistofpems		&& Exports to the clipboard
		*** JRN 12/01/2008 : export list of pems
		
		Local lcDescrip, lcDescript, lcFileName, lcText, lcValue, lcWindowName, lnRecno, lnRight
		
		Thisform.LockScreen = .T.
		lnRecno = Recno()
		
		lcText = ''
		Scan
			Do Case
				Case cType $ 'P'
					lcText = lcText + ccLOC_CAP_Type_Property + ': ' + Trim (cName) + ccCRLF
		
					lcValue = Thisform.GetValue(cName, lNative, 'Full Value', ,cDescript)
					lcText = lcText + ccLOC_STR_DEFAULT_VALUE + ': ' + lcValue + ccCRLF
		
				Case cType $ 'M'
					lcText = lcText + ccLOC_CAP_Type_Method + ': ' + Trim (cName) + ccCRLF
		
				Case cType $ 'E'
					lcText = lcText + ccLOC_CAP_Type_Event + ': ' + Trim (cName) + ccCRLF
		
			Endcase
		
			* add in description, doing a line-wrap for longer ones
			If Not Empty(cDescript)
				lcDescript = ccLOC_STR_DESCRIPTION + ": " + Alltrim (cDescript)
				Do While Len(lcDescript) > ccLOC_STR_DESCRIPTION_Max_Length
					lnRight = Rat (' ', Left (lcDescript, ccLOC_STR_DESCRIPTION_Max_Length + 1)) 
					If lnRight # 0
						lcText = lcText + Left (lcDescript, lnRight - 1) + ccCRLF 
						lcDescript = Space(4) + Substr (lcDescript, lnRight + 1)
					Else
						lnRight = ccLOC_STR_DESCRIPTION_Max_Length
						lcText = lcText + Left (lcDescript, lnRight) + ccCRLF
						lcDescript = Space(4) + Substr (lcDescript, lnRight + 1)
					Endif
				Enddo
		
				lcText = lcText + lcDescript + ccCRLF
			Endif
		
			lcText = lcText + ccCRLF
		Endscan
		
		Try
			Locate For Recno() = lnRecno && checked
		Catch
			Locate && checked
		Endtry
		
		Thisform.LockScreen = .F.
		
		****************************************************************
		lcWindowName = Thisform.oTopofForm.Name + Thisform.cCurrentObjectName + ".PEMlist"
		This.oUtils.ViewTempFileText (lcWindowName, lcText)
		
	ENDPROC

	PROCEDURE exportmethodcode
		Lparameters tbParentage, tbRecursive
		
		*** JRN 12/01/2008 : export list of pems
		
		Local lnRecno, lcText, lcValue, lcDescrip, tcName, lcWindowName, lcFileName
		
		Thisform.LockScreen = .T.
		lnRecno = Recno()
		lnSelect = Select()
		
		lcText = ''
		lcWindowName = Thisform.oTopofForm.Name + Thisform.cCurrentObjectName + ".Procedures.PRG"
		lcFileName = Sys(2023) + "\" + lcWindowName
		
		Strtofile('* Procedures for ' + Thisform.oTopofForm.Name + Thisform.cCurrentObjectName, lcFileName, 0)
		
		If tbRecursive
		
			This.ExportChildMethodCode (Thisform.oObject, lcFileName, '')
		
		Else
		
			Scan For cType $ 'ME'
		
				lcText = ''
				If tbParentage
					If lHasCode
						lcText = This.GetParentCode(Trim (cName), 'All Code')
						If Not Empty(lcText)
							lcText = ccCRLF+ ccCRLF 										;
								+ ccTopDividerLine + ccTopDividerLine						;
								+ '*' + Space(5) + Trim (cName)+ ccCRLF						;
								+ lcText
						Endif
					Endif
				Else
					If lNonDefault
						lcText = Thisform.oObject.ReadMethod (Trim (cName))
						If Not Empty(lcText)
							lcText = ccCRLF+ ccCRLF + ccTopDividerLine + ccTopDividerLine ;
								+ 'Procedure ' + Trim (cName)+ ccCRLF + lcText + ccCRLF	;
								+ "EndProc" + ccCRLF
						Endif
					Endif
				Endif
		
				If Not Empty(lcText)
					Strtofile(lcText, lcFileName, 1)
				Endif
			Endscan
		
		Endif
		
		Select (lnSelect)
		
		Try
			Locate For Recno() = lnRecno && checked
		Catch
			Locate && checked
		Endtry
		
		Thisform.LockScreen = .F.
		
		****************************************************************
		
		This.oUtils.ViewTempFile(lcFileName)
		
	ENDPROC

	PROCEDURE findobjects
		Lparameters tcSearchFor
		
		Local loCollection AS 'Collection'
		Local loNextItem AS 'Empty'
		Local loObject AS Object
		Local lnI
		
		With This
			.nFoundObjects = 0
			.DoFind (This.oTopOfForm, tcSearchFor, '')
		
			loCollection = Createobject('Collection')
			For lnI = 1 To .nFoundObjects
				loObject = .aFoundObjects(lnI)
		
				loNextItem = Createobject('Empty')
				AddProperty(loNextItem, 'Object', loObject)
				AddProperty(loNextItem, 'Name', This.GetObjectPath(loObject))
				loCollection.Add(loNextItem)
		
				.aFoundObjects (lnI) = .Null.
			Endfor
		Endwith
		
		Return loCollection
		
	ENDPROC

	PROCEDURE fixnondefaultflags
		Local laMembers(1)
		Local lcName, lnI, llAssign, llAccess, lnVisibility, llReadOnly, llChanged, llNonDefault, lcTypeAbbrev
		Local llLocalCode, llHasCode
		
		If Isnull(This.oObject) Or 0 = Amembers (laMembers, This.oObject, 1, 'PHG#')	;
				or (1 # Thisform.nSelectedObjects And Not Thisform.lEditingOneProperty)
			Return
		Endif
		
		lcName = This.JustPEM(csrMembers.cName)
		lnI = Ascan(laMembers, lcName, -1, -1, 1, 15)
		
		If lnI # 0
		
			llAssign = 0 # Ascan(laMembers, lcName + [_Assign], -1, -1, 1, 15)
			llAccess = 0 # Ascan(laMembers, lcName + [_Access], -1, -1, 1, 15)
		
			lnVisibility = Iif( [G] $laMembers[lnI, 3], 1, Iif([P] $laMembers[lnI, 3], 2, 3))
			llReadOnly = 'R' $ laMembers[lnI, 3]
			Do Case
				Case lnVisibility = 1 && Public
				Case Not ('N' $ laMembers[lnI, 3] Or 'I' $ laMembers[lnI, 3]) && Custom
				Case Thisform.lIsTopOfForm And This.lClass && class -- thisform
				Otherwise
					llReadOnly = .T.
			Endcase
		
			*** JRN - 11/20/2008 -- capture which PEMs are non-default
			llChanged = 'C' $ laMembers[lnI, 3]
			Do Case
				Case csrMembers.cType = 'P'
					llNonDefault = llChanged
					llLocalCode = .F.
					llHasCode	= .F.
				Case llChanged
					llNonDefault = Not Empty (This.oObject.ReadMethod (lcName))
					llLocalCode = llNonDefault
					llHasCode	= llNonDefault Or 'N' $ laMembers[lnI, 3] Or 'I' $ laMembers[lnI, 3] && .T.
				Otherwise
					llNonDefault = .F.
					llLocalCode = .F.
					llHasCode	= .F.
			Endcase
		
			Replace									;
				lAssign		With 	llAssign		;
				lAccess		With	llAccess		;
				nVisibility With	lnVisibility 	;
				lReadOnly 	With 	llReadOnly 		;
				lNonDefault	With	llNonDefault	;
				lHasCode	With	llHasCode		;
				in csrMembers
		
		Endif
		
	ENDPROC

	PROCEDURE fixsplitterpositions
		With Thisform
		
			Try
				If .oPrefs.lGridAbove
					With .oSplitterV
						If Not .lCollapsed
							.MoveSplitterToPosition(.Top)
						Endif
					Endwith
				Else
					With .oSplitterH
						If Not .lCollapsed
							.MoveSplitterToPosition(.Top)
						Endif
					Endwith
				Endif
		
				With .cntControls.oSplitter
					.MoveSplitterToPosition(.Top)
				Endwith
		
			Catch
		
			Endtry
		
		Endwith
		
	ENDPROC

	PROCEDURE getcontrolcount
		Lparameters loObject
		Local lnCount
		
		With loObject
			Do Case
				Case Not Thisform.GetPEMStatus(loObject, 'Objects', 5)
					lnCount = 0
				Case Thisform.GetPEMStatus(loObject, 'ControlCount', 5)
					lnCount = .ControlCount
				Case Inlist(Lower(.BaseClass),[pageframe])
					lnCount = .PageCount
				Case Inlist(Lower(.BaseClass),[grid])
					lnCount = .ColumnCount
				Case Inlist(Lower(.BaseClass),[optiongroup],[commandgroup])
					lnCount = .ButtonCount
				Case Inlist(Lower(.BaseClass),[formset])
					lnCount = .FormCount
				Case Inlist(Lower(.BaseClass),[dataenvironment])
					lnCount = 0
					Do While 'O' = Type(".Objects(lnCount + 1)")
						lnCount = lnCount + 1
					Enddo
				Otherwise
					lnCount = 0
			Endcase
		Endwith
		
		Return lnCount
		
	ENDPROC

	PROCEDURE getdefaultvalue
		Lparameters lcName
		Local lcFirst, lcDefault, loException, lcCustomPRG
		
		lcFirst  = Left(lcName, 1)
		Do Case
			Case Not Islower(lcFirst)
				*** TODO: set property of oMember instead of setting edtDefault.Value and calling SetXValue
			Case lcFirst = 'c'
				lcDefault = []
			Case lcFirst = 'l'
				lcDefault = .F.
			Case Inlist(lcFirst, 'n', 'i', 'b', 'y')
				lcDefault = 0
			Case lcFirst = 'd'
				lcDefault = {}
			Case lcFirst = 't'
				lcDefault = {/:}
			Case lcFirst = 'o' Or lcFirst = 'u'
				lcDefault = .Null.
		Endcase
		
		*	lcCustomPRG =  Thisform.cApplicationPath + "GetDefaultValue.PRG"
		lcCustomPRG =  This.oUtils.GetPlugInPath ("GetDefaultValue")
		If Not Empty(lcCustomPRG)
			Try
				lcDefault = Execscript(Filetostr(lcCustomPRG), lcName)
			Catch To loException
				Thisform.ShowErrorMsg(loException, 'Default Value Failure', lcCustomPRG)
			Endtry
		Endif
		
		Return lcDefault
		
	ENDPROC

	PROCEDURE getdescriptionvalue
		Local lcDescript
		
		lcDescript = This.oedtDescription.Value 
		If Thisform.lAllowDescriptionCRs
			Return Strtran(lcDescript, ccCRLF, "\n")
		Else
			Return lcDescript
		Endif
		
	ENDPROC

	PROCEDURE getmethodvalue
		Lparameters tlNonDefault, tlHasCode
		
		Do Case
			Case tlNonDefault
				Return '[User Procedure]'
			Case tlHasCode
				Return '[Inherited]'
			Otherwise
				Return ''
		Endcase
		
	ENDPROC

	PROCEDURE getmrusettings
		Lparameters llPutFlag
		
		Local laList[1], lcName, lcText, lnRow
		
		*!*	*** JRN 2010-03-22 : classes
		*!*	With This
		
		*!*		For lnRow = 1 To Alen (.aMRUClasses, 1)
		
		*!*			lcName = 'MRU' + Transform (lnRow)
		
		*!*			If llPutFlag
		
		*!*				lcText = .aMRUClasses (lnRow, 1) + "|" + .aMRUClasses (lnRow, 2) + "|" + .aMRUClasses (lnRow, 3)
		*!*				.PutSetting (lcName, lcText)
		
		*!*			Else
		*!*				lcText = .GetSetting (lcName, ' | | ')
		*!*				If 3 # Alines (laList, lcText, .T., '|')
		*!*					Alines (laList, ' | | ', .T., '|')
		*!*				Endif
		
		*!*				.aMRUClasses (lnRow, 1) = laList(1)
		*!*				.aMRUClasses (lnRow, 2) = laList(2)
		*!*				.aMRUClasses (lnRow, 3) = laList(3)
		*!*			Endif
		
		*!*		Endfor
		
		*!*	Endwith
		
		*!*	*** JRN 2010-07-17 : Class Libraries
		*!*	With This
		
		*!*		For lnRow = 1 To Alen (.aMRUClassLibs, 1)
		
		*!*			lcName = 'ClassLibMRU' + Transform (lnRow)
		
		*!*			If llPutFlag
		
		*!*				lcText = .aMRUClassLibs (lnRow, 1) + "|" + Transform(.aMRUClassLibs (lnRow, 2)) + "|" + .aMRUClassLibs (lnRow, 3)
		*!*				.PutSetting (lcName, lcText)
		
		*!*			Else
		*!*				lcText = .GetSetting (lcName, ' | | ')
		*!*				If 3 # Alines (laList, lcText, .T., '|')
		*!*					Alines (laList, ' | | ', .T., '|')
		*!*				Endif
		
		*!*				.aMRUClassLibs (lnRow, 1) = laList(1)
		*!*				.aMRUClassLibs (lnRow, 2) = laList(2)
		*!*				.aMRUClassLibs (lnRow, 3) = laList(3)
		*!*			Endif
		
		*!*		Endfor
		
		*!*	Endwith
		
		
		*!*	*** JRN 2010-03-22 : forms
		*!*	With This
		
		*!*		For lnRow = 1 To Alen (.aMRUForms, 1)
		
		*!*			lcName = 'Form MRU' + Transform (lnRow)
		
		*!*			If llPutFlag
		
		*!*				lcText = .aMRUForms (lnRow, 1) + "|" + .aMRUForms (lnRow, 2) + "|" + .aMRUForms (lnRow, 3)
		*!*				.PutSetting (lcName, lcText)
		
		*!*			Else
		*!*				lcText = .GetSetting (lcName, ' | | ')
		*!*				If 3 # Alines (laList, lcText, .T., '|')
		*!*					Alines (laList, ' | | ', .T., '|')
		*!*				Endif
		
		*!*				.aMRUForms (lnRow, 1) = laList(1)
		*!*				.aMRUForms (lnRow, 2) = laList(2)
		*!*				.aMRUForms (lnRow, 3) = laList(3)
		*!*			Endif
		
		*!*		Endfor
		
		*!*	Endwith
		
		*!*	*** JRN 2010-04-15 : Correction for old structure ... forms and classes used to be mixed
		*!*	For lnI = Alen (.aMRUClasses, 1) To 1 Step -1
		*!*		If (Not Empty (.aMRUClasses (lnI,1))) And (Empty (.aMRUClasses (lnI,2)))
		*!*			Ains (.aMRUForms, 1)
		*!*			.aMRUForms (1,1) = .aMRUClasses (lnI, 1)
		*!*			.aMRUForms (1,2) = .aMRUClasses (lnI, 2)
		*!*			.aMRUForms (1,3) = .aMRUClasses (lnI, 3)
		*!*			Adel (.aMRUClasses, lnI)
		*!*			.aMRUClasses (Alen (.aMRUClasses, 1),1) = ''
		*!*			.aMRUClasses (Alen (.aMRUClasses, 1),2) = ''
		*!*			.aMRUClasses (Alen (.aMRUClasses, 1),3) = ''
		*!*		Endif
		*!*	Endfor
		
		*!*	*** JRN 2010-03-29 : Other files
		*!*	With This
		
		*!*		For lnRow = 1 To Alen (.aMRUFiles, 1)
		
		*!*			lcName = 'FileMRU' + Transform (lnRow)
		
		*!*			If llPutFlag
		
		*!*				lcText = .aMRUFiles (lnRow, 1) + "|" + .aMRUFiles (lnRow, 2) + "|" + .aMRUFiles (lnRow, 3)
		*!*				.PutSetting (lcName, lcText)
		
		*!*			Else
		*!*				lcText = .GetSetting (lcName, ' | | ')
		*!*				If 3 # Alines (laList, lcText, .T., '|')
		*!*					Alines (laList, ' | | ', .T., '|')
		*!*				Endif
		
		*!*				.aMRUFiles (lnRow, 1) = laList(1)
		*!*				.aMRUFiles (lnRow, 2) = laList(2)
		*!*				.aMRUFiles (lnRow, 3) = laList(3)
		*!*			Endif
		
		*!*		Endfor
		
		*!*	Endwith
		
		*!*	*** JRN 2010-03-22 : projects
		*!*	With This
		
		*!*		For lnRow = 1 To Alen (.aMRUProjects, 1)
		
		*!*			lcName = 'ProjectMRU' + Transform (lnRow)
		
		*!*			If llPutFlag
		
		*!*				lcText = .aMRUProjects (lnRow, 1) + "|" + .aMRUProjects (lnRow, 2) + "|" + .aMRUProjects (lnRow, 3)
		*!*				.PutSetting (lcName, lcText)
		
		*!*			Else
		*!*				lcText = .GetSetting (lcName, ' | | ')
		*!*				If 3 # Alines (laList, lcText, .T., '|')
		*!*					Alines (laList, ' | | ', .T., '|')
		*!*				Endif
		
		*!*				.aMRUProjects (lnRow, 1) = laList(1)
		*!*				.aMRUProjects (lnRow, 2) = laList(2)
		*!*				.aMRUProjects (lnRow, 3) = laList(3)
		*!*			Endif
		
		*!*		Endfor
		
		*!*	Endwith
		
		*** JRN 2010-03-22 : favorites
		With This
		
		
			For lnRow = 1 To 100
		
				lcName = 'Favorite' + Transform (lnRow)
		
				If llPutFlag
		
					If lnRow <= Alen (.aFavorites, 1) And "C" = Vartype(.aFavorites (lnRow, 1))
						lcText = .aFavorites (lnRow, 1) + "|" + .aFavorites (lnRow, 2) + "|" + .aFavorites (lnRow, 3)
						.PutSetting (lcName, lcText)
					Else
						.PutSetting (lcName, ' ') && necessary if # of favorites has been reduced
						Exit
					Endif
		
				Else
					lcText = .GetSetting (lcName, ' | | ')
					If 3 # Alines (laList, lcText, .T., '|')
						Alines (laList, ' | | ', .T., '|')
					Endif
		
					If Empty (laList(1))
						Exit
					Else
						Dimension .aFavorites(lnRow,3)
						.aFavorites (lnRow, 1) = laList(1)
						.aFavorites (lnRow, 2) = laList(2)
						.aFavorites (lnRow, 3) = laList(3)
					Endif
				Endif
		
			Endfor
		
		Endwith
		
		
	ENDPROC

	PROCEDURE getparentobjects
		Lparameters loObject, laParents
		
		laParents(1) = loObject
		Do While loObject # Thisform.oTopOfForm and This.GetPEMStatus(loObject, 'Parent', 5) and "O" = Type ("loObject.Parent")
			loObject = loObject.Parent
			Dimension laParents( 1 + Alen (laParents))
			Ains (laParents,1)
			laParents (1) = loObject
		Enddo
		
	ENDPROC

	PROCEDURE getpemlist
		Local loObject AS 'Empty'
		
		loObject = Createobject ('Empty')
		AddProperty (loObject, 'PEMList(1)')
		Select  cName				;
			from csrMembers			;
			order By 1				;
			into Array loObject.PemList
		Return loObject
	ENDPROC

	PROCEDURE getpemvalue
		Lparameters loObject, lcPem, lxDefaultValue
		
		If Thisform.GetPemStatus(loObject, lcPem, 5)
			Return Getpem (loObject, lcPem)
		Else
			Return lxDefaultValue
		Endif
		
	ENDPROC

	PROCEDURE getputfilterdefaults
		Lparameters lbUseDefaults
		
		If lbUseDefaults
		
			With This.oPrefs
		
				.lTypeProperty = .lDefaultTypeProperty
				.lTypeMethod= .lDefaultTypeMethod
				.lTypeEvent= .lDefaultTypeEvent
		
				.lHierarchyNative= .lDefaultHierarchyNative
				.lHierarchyInherited= .lDefaultHierarchyInherited
				.lHierarchyCustom= .lDefaultHierarchyCustom
		
				.lMethodViewLocal= .lDefaultMethodViewLocal
				.lMethodViewInherited= .lDefaultMethodViewInherited
				.lMethodViewMethodNone= .lDefaultMethodViewMethodNone
				.lMethodViewEventNone= .lDefaultMethodViewEventNone
				.lFavorites= .lDefaultFavorites
				.lNonDefault= .lDefaultnonDefault
				
				.nGroupID = 1
				.cSubString = ''
				.cSubStringMV = ''
		
			Endwith
		
		Endif
		
	ENDPROC

	PROCEDURE getputsettings
		Lparameters lbPutFlag
		
		With This
		
			* Restore saved sort order and filter criteria.
		
			.GetPutSetting ('cMyVersion', 				'MyVersion', 		'', lbPutFlag)
		
			.GetPutSetting ('nFontSize', 				'nFontSize', 		8, lbPutFlag)
			.GetPutSetting ('cMembersSortOrder', 		'SortOrder4B',  	ccLoc_SortOrder1, lbPutFlag)
			.GetPutSetting ('cMembersSortOrderMethodView', 'SortOrderMethodView4B', ccLoc_SortOrder2, lbPutFlag)
			*.GetPutSetting ('lCloseDebuggerWindows', 	'CloseDebuggerWindows', 	.T., lbPutFlag)
			.GetPutSetting ('lFoundForAll',				'FoundForAll', 		.T., lbPutFlag)
			*.GetPutSetting ('lRestartAfterClearAll',	'RestartAfterClearAll', 	.F., lbPutFlag)
			*.GetPutSetting ('lStartWithDefaultFilters', 'StartWithDefaultFilters', 	.F., lbPutFlag)
			*.GetPutSetting ('lMemberDataKeepType', 		'MemberDataKeepType', 		.F., lbPutFlag)
			*.GetPutSetting ('lPromptAutoRename', 		'PromptAutoRename', 		.T., lbPutFlag)
			*	.GetPutSetting ('lAvoidBufferOverrun', 		'AvoidBufferOverrun', 		.F., lbPutFlag)
		
			.GetPutSetting ('lNoErrorMsgOnMissingVCX',	'NoErrorMsgOnMissingVCX',	.F., lbPutFlag)
		
			*.GetPutSetting ('cOpenMenuKey',				'OpenMenuKey',				ccLOC_Pref_Key_OpenMenu, lbPutFlag)
			*.GetPutSetting ('cViewDefinitionKey',		'ViewDefinitionKey',		ccLOC_Pref_Key_GoToDef, lbPutFlag)
			*.GetPutSetting ('cExtractToMethod', 		'ExtractToMethod', 			ccLOC_Pref_Key_ExtractToMethod, lbPutFlag)
			*.GetPutSetting ('cBeautify', 				'Beautify', 				ccLOC_Pref_Key_Beautify, lbPutFlag)
			*.GetPutSetting ('cIDList', 					'IDList', 					ccLOC_Pref_Key_IDList, lbPutFlag)
		
			*.GetPutSetting ('lBeautifyLocals', 			'BeautifyLocals', 			.F., lbPutFlag)
			*.GetPutSetting ('nLocalsSelectionType', 	'LocalsSelectionType', 		2, lbPutFlag)
			*.GetPutSetting ('lLocalsMultPerLine', 		'LocalsMultPerLine', 		.T., lbPutFlag)
			*.GetPutSetting ('nLocalsLineWidth', 		'LocalsLineWidth', 			100, lbPutFlag)
			*.GetPutSetting ('lMoveLocals', 				'MoveLocals', 				.F., lbPutFlag)
			*.GetPutSetting ('lLocalsAllProcs', 			'LocalsAllProcs', 			.F., lbPutFlag)
		
			*.GetPutSetting ('cWindowDimensions', 		'WindowDimensions', 		'0,0,1000,600', lbPutFlag)
			*.GetPutSetting ('lFixAssignments', 			'FixAssignments', 			.F., lbPutFlag)
			*.GetPutSetting ('lAutoMoveWindow', 			'AutoMoveWindow', 			.F., lbPutFlag)
			*.GetPutSetting ('lEventHandlersEnabled', 	'EventHandlersEnabled', 	.T., lbPutFlag)
			*.GetPutSetting ('lCheckOutSCC', 			'CheckOutSCC', 				.F., lbPutFlag)
		
			*.GetPutSetting ('nSelectIndentation', 		'SelectIndentation', 		1, lbPutFlag)
			*.GetPutSetting ('nCharsAfterSelect', 		'CharsAfterSelect', 		2, lbPutFlag)
			*.GetPutSetting ('nFieldIndent', 			'FieldIndent', 				8, lbPutFlag)
			*.GetPutSetting ('nCharsAfterSET',			'CharsAfterSET', 			1, lbPutFlag)
			*.GetPutSetting ('nSETFieldIndent', 			'SETFieldIndent', 			8, lbPutFlag)
			*.GetPutSetting ('nKeyWordIndent', 			'KeyWordIndent', 			4, lbPutFlag)
			*.GetPutSetting ('nJOINIndent', 				'JOINIndent',	 			4, lbPutFlag)
			*.GetPutSetting ('nSETIndent', 				'SETIndent',	 			4, lbPutFlag)
			*.GetPutSetting ('nUNIONIndent', 			'UNIONIndent', 				4, lbPutFlag)
			*.GetPutSetting ('nSELECTIndent', 			'SELECTIndent', 			4, lbPutFlag)
			*.GetPutSetting ('nHangingIndent', 			'HangingIndent', 			4, lbPutFlag)
			*.GetPutSetting ('nParenIndent', 			'ParenIndent', 				2, lbPutFlag)
			*.GetPutSetting ('nSingleFieldIndent', 		'SingleFieldIndent', 		2, lbPutFlag)
			*.GetPutSetting ('nSingleSETFieldIndent', 	'SingleSETFieldIndent', 	2, lbPutFlag)
			*.GetPutSetting ('nAsColumn', 				'AsColumn', 				0, lbPutFlag)
			*.GetPutSetting ('nSemiColonColumn', 		'SemiColonColumn', 			0, lbPutFlag)
			*.GetPutSetting ('cIgnoreTextOperators', 	'IgnoreTextOperators', 		'$', lbPutFlag)
		
			*.GetPutSetting ('nReplaceIndentation', 		'ReplaceIndentation', 		1, lbPutFlag)
			*.GetPutSetting ('nReplaceFieldIndent', 		'ReplaceFieldIndent', 		8, lbPutFlag)
			*.GetPutSetting ('lAlignWITH', 				'AlignWith', 				.F., lbPutFlag)
			*.GetPutSetting ('nBeforeWith', 				'BeforeWith', 				1, lbPutFlag)
			*.GetPutSetting ('nAfterWith', 				'AfterWith', 				1, lbPutFlag)
			*.GetPutSetting ('lAlignAS', 				'AlignAS', 					.F., lbPutFlag)
			*.GetPutSetting ('nBeforeAS', 				'BeforeAS', 				1, lbPutFlag)
			*.GetPutSetting ('nAfterAS', 				'AfterAS', 					1, lbPutFlag)
			*.GetPutSetting ('nReplaceKeyWords', 		'ReplaceKeyWords', 			4, lbPutFlag)
			*.GetPutSetting ('nReplaceHangingIndent', 	'ReplaceHangingIndent', 	4, lbPutFlag)
			*.GetPutSetting ('nSingleREPLACEFieldIndent','SingleREPLACEFieldIndent',	2, lbPutFlag)
			*.GetPutSetting ('lAlignSemicolons', 		'AlignSemicolons', 			.F., lbPutFlag)
			*.GetPutSetting ('nBeforeSemicolons', 		'BeforeSemicolons', 		1, lbPutFlag)
		
			*.GetPutSetting ('lNativeBeautify', 			'NativeBeautify', 	 		.F., lbPutFlag)
			*.GetPutSetting ('lNoMultiLineSelect', 		'NoMultiLineSelect', 	 	.F., lbPutFlag)
			*.GetPutSetting ('lSpacesAroundOperators', 	'SpacesAroundOperators', 	.T., lbPutFlag)
			*.GetPutSetting ('lSpacesBeforeCommas', 		'SpacesBeforeCommas', 		.T., lbPutFlag)
			*.GetPutSetting ('lBeautifyTEXTasSelect', 	'BeautifyTEXTasSelect', 	.F., lbPutFlag)
			*.GetPutSetting ('nBeforeLeftParens', 		'BeforeLeftParens', 	 	1, lbPutFlag)
			*.GetPutSetting ('nStringDelimiters', 		'StringDelimiters', 	 	1, lbPutFlag)
			*.GetPutSetting ('nDefinitionForNOT', 		'DefinitionForNOT', 	 	1, lbPutFlag)
			*.GetPutSetting ('nDefinitionForNOTEQUAL', 	'DefinitionForNOTEQUAL',  	1, lbPutFlag)
			*.GetPutSetting ('lLocalsOnTop', 			'LocalsOnTop', 	 			.F., lbPutFlag)
			*.GetPutSetting ('lLocalsUseAS', 			'LocalsUseAS', 	 			.F., lbPutFlag)
		
			*.GetPutSetting ('lHandleevent_Caption', 	'HandleEvent_Caption', 		.F., lbPutFlag)
			*.GetPutSetting ('lHandleevent_Resize', 		'HandleEvent_Resize', 		.F., lbPutFlag)
		
		
			If Not lbPutFlag
				.GetPutFilterDefaults(.oPrefs.lStartWithDefaultFilters)
			Endif
		
			.GetPutSetting ('nTreeSort',				'TreeSort',  		2, lbPutFlag)
			.GetPutSetting ('nTreeSortMethods',			'TreeSortMethods',  1, lbPutFlag)
			.GetPutSetting ('lTreeShowCaptions',		'TreeShowCaptions', .T., lbPutFlag)
			.GetPutSetting ('nTreeViewClassInfo',		'TreeViewClassInfo', 2, lbPutFlag)
			.GetPutSetting ('lTreeMemberSort',			'TreeMemberSort', 	.T., lbPutFlag)
			.GetPutSetting ('lExpandAllNodes',			'ExpandAllNodes', 	.F., lbPutFlag)
			*.GetPutSetting ('lToggleEditor',			'ToggleEditor', 	.T., lbPutFlag)
			*.GetPutSetting ('lDebugMode',				'DebugMode', 		.F., lbPutFlag)
			*.GetPutSetting ('nAnchorEditor',			'AnchorEditor', 	2, lbPutFlag)
		
			*.GetPutSetting ('lStartDocTreeView',		'StartDocTreeView', 	.F., lbPutFlag)
		
			.GetPutSetting ('nSplitterTop',				'SplitterTop',		0, lbPutFlag)
			.GetPutSetting ('nSplitterLeft',			'SplitterLeft', 	1000, lbPutFlag)
			.GetPutSetting ('nDescSplitterTop',			'DescSplitterTop', 	0, lbPutFlag)
			.GetPutSetting ('nMethodView',				'MethodViewType2', 	1, lbPutFlag)
		
			* Restore other settings.
		
			*.GetPutSetting ('lStayOnSamePEM',			'StayOnSamePEM', 	.T., lbPutFlag)
			*.GetPutSetting ('lGridAbove',				'GridAbove', 		.F., lbPutFlag)
			*** JRN 06/11/2009 : removed ... not worth supporting
			* .GetPutSetting ('lAllowDescriptionCRs',		'AllowDescriptionCRs', .F., lbPutFlag)
			.GetPutSetting ('lUseCSO',					'UseCSO', 			.T., lbPutFlag)
			.GetPutSetting ('lTreeViewShowMethods',		'TreeViewShowMethods', 	.T., lbPutFlag)
			.GetPutSetting ('lTreeViewAllControls',		'TreeViewAllControls', 	.T., lbPutFlag)
		
			*.GetPutSetting ('lAssignDefaultValue',		'AssignDefault', 	.T., lbPutFlag)
			*.GetPutSetting ('lUseAbbreviations',		'Abbreviated', 		.T., lbPutFlag)
			*.GetPutSetting ('lUseMemberData',			'UseMemberData', 	PEME_IsVersion9(), lbPutFlag)
			.GetPutSetting ('cNewMemberType',			'NewMemberType',	 'P', lbPutFlag)
		
			*.GetPutSetting ('lEscClosesForm',			'EscClosesForm', 	.T., lbPutFlag)
			*.GetPutSetting ('lNotifyNewPemsHidden',		'NotifyNewPemsHidden', .T., lbPutFlag)
		
			* .GetPutSetting ('lCollapsed',				'Collapsed', 		.F., lbPutFlag)
		
			If lbPutFlag
				This.oPrefs.SaveValues()
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE getsettings
		This.GetPutSettings(.F.) && load 'em up
	ENDPROC

	PROCEDURE getwindows
		Local loFoxTabs AS 'foxtabsmanager' OF  'peme_foxtabsmanager.prg'
		
		loFoxTabs = NewObject('foxtabsmanager', 'peme_foxtabsmanager.prg')
		Return loFoxTabs.GetWindows()
		
	ENDPROC

	PROCEDURE GotFocus
		With This
			*!* ******************** Removed 5/21/2013 *****************
			*!* .RefreshTimer.Enabled = .F.
			If .lDocTreeView
				If .DockPosition >= 4 and .oObjectTree.lMustSetFocus
					.oObjectTree.oTree.SetFocus()
				Endif
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE handleevents
		Local loObject As Object
		Local laEvents[1], lcEvent, lcMethod
		
		If Thisform.oPrefs.lEventHandlersEnabled
		
			Aevents (laEvents,0)
			loObject 	= laEvents(1)
			lcEvent		= Lower(laEvents(2))
		
			Do Case
		
				Case Inlist (lcEvent, 'width', 'height') And This.GetPEMStatus (loObject, ccHandlerPrefix + 'resize', 5)
					lcEvent = 'resize'
		
				Case Inlist (lcEvent, 'top', 'left') And This.GetPEMStatus (loObject, ccHandlerPrefix + 'moved', 5)
					lcEvent = 'moved'
		
			Endcase
		
			lcMethod = ccHandlerPrefix + lcEvent
		
			This.ExecuteMethod(loObject, lcMethod)
		
		Endif
		
	ENDPROC

	PROCEDURE handleevents_before
		Local loObject As Object
		Local laEvents[1], lcEvent, lcMethod
		
		If Thisform.oPrefs.lEventHandlersEnabled
		
			Aevents (laEvents,0)
			loObject 	= laEvents(1)
			lcEvent		= Lower(laEvents(2))
		
			Do Case
		
				Case Inlist (lcEvent, 'width', 'height') And This.GetPEMStatus (loObject, ccHandlerPrefix + 'resize', 5)
					lcEvent = 'resize'
		
				Case Inlist (lcEvent, 'top', 'left') And This.GetPEMStatus (loObject, ccHandlerPrefix + 'moved', 5)
					lcEvent = 'moved'
		
			Endcase
		
			lcMethod = ccHandlerPrefix + lcEvent + "_before"
		
			This.ExecuteMethod(loObject, lcMethod)
		
		Endif
		
	ENDPROC

	PROCEDURE ide_eventhandler
		Local loObject As Object
		Local laEvents(1), lcCaption, lcEvent, llAutoNonDefault, llAutoSize, lnHeight, lnHeightIncr, lnLeft
		Local lnNewWidth, lnTop, lnWidth, lnWidthIncr
		
		If Not Thisform.oPrefs.lEventHandlersEnabled
			Return
		Endif
		
		Aevents (laEvents,0)
		loObject 	= laEvents(1)
		lcEvent		= Lower(laEvents(2))
		
		*Debugout loObject.Name, 'after', lcEvent
		Do Case
		
			Case lcEvent == 'caption' And Thisform.oPrefs.lHandleEvent_Caption
		
				With loObject
		
					If Inlist (.Alignment, 1, 5, 8) And 'O' = Vartype(This.oEventHandlerCaption)
						lcCaption 	= .Caption
						With This.oEventHandlerCaption
							llAutoSize  = .AutoSize
							llAutoNonDefault = .AutoSize_nonDefault
							lnLeft 		= .Left
							lnTop 		= .Top
							lnWidth 	= .Width
							lnHeight 	= .Height
						Endwith
		
						If Not llAutoSize
							.AutoSize 	= .T.
						Endif
		
						.Caption 	= lcCaption
						lnNewWidth = .Width
		
						Do Case
							Case llAutoSize
		
							Case llAutoNonDefault
								.AutoSize = .F.
							Otherwise
								.ResetToDefault("Autosize")
						Endcase
		
						If llAutoSize Or lnWidth < lnNewWidth
							.Left		= lnLeft + lnWidth - lnNewWidth
							.Top		= lnTop
							.Width		= lnNewWidth && this is necessary!
						Else
							.Left		= lnLeft
							.Top		= lnTop
							.Width 		= lnWidth
							.Height		= lnHeight
						Endif
		
					Endif
		
					This.oEventHandlerCaption = .Null.
		
				Endwith
		
		
			Case lcEvent == 'autosize' And Thisform.oPrefs.lHandleEvent_Caption
		
				With loObject
		
					If Inlist (.Alignment, 1, 5, 8) And 'O' = Vartype(This.oEventHandlerAutoSize) And .AutoSize
						With This.oEventHandlerAutoSize
							llAutoSize  = .AutoSize
							llAutoNonDefault = .AutoSize_nonDefault
							lnLeft 		= .Left
							lnTop 		= .Top
							lnWidth 	= .Width
							lnHeight 	= .Height
						Endwith
		
						lnNewWidth = .Width
						.Left		= lnLeft + lnWidth - lnNewWidth
		
					Endif
		
					This.oEventHandlerAutoSize = .Null.
				Endwith
		
		
			Case This.lDuringResizeEvent
		
		
			Case lcEvent == 'height'
		
				If loObject = Thisform.oTopOfForm
					lnHeightIncr = loObject.Height - Thisform.nTopOfFormHeight
					Thisform.nTopOfFormHeight = loObject.Height
				Else
					If 'N' = Vartype(This.oEventHandlerHeight)
						lnHeightIncr = loObject.Height - This.oEventHandlerHeight
						This.oEventHandlerHeight = .Null.
					Else
						Return
					Endif
				Endif
				If lnHeightIncr # 0
					This.IDE_ResizeChildren (loObject, lnHeightIncr, 0)
					This.CreateEventbindings(.F.)
				Endif
		
			Case lcEvent == 'width'
		
				If loObject = Thisform.oTopOfForm
					lnWidthIncr = loObject.Width - Thisform.nTopOfFormWidth
					Thisform.nTopOfFormWidth = loObject.Width
				Else
					If 'N' = Vartype(This.oEventHandlerWidth)
						lnWidthIncr = loObject.Width - This.oEventHandlerWidth
						This.oEventHandlerWidth = .Null.
					Else
						Return
					Endif
				Endif
				If lnWidthIncr # 0
					This.IDE_ResizeChildren (loObject, 0, lnWidthIncr)
					This.CreateEventbindings(.F.)
				Endif
		
		Endcase
		
		
		
	ENDPROC

	PROCEDURE ide_eventhandler_before
		Local loInfo As "Empty"
		Local loObject As Object
		Local laEvents(1), lcEvent
		
		If Not Thisform.oPrefs.lEventHandlersEnabled
			Return
		Endif
		
		Aevents (laEvents,0)
		loObject 	= laEvents(1)
		lcEvent		= Lower(laEvents(2))
		
		* Debugout loObject.Name, 'before', lcEvent
		Do Case
		
			Case lcEvent == 'caption' And Thisform.oPrefs.lHandleEvent_Caption
		
				With loObject
					loInfo = Createobject("Empty")
					AddProperty (loInfo, 'AutoSize', .AutoSize)
					AddProperty (loInfo, 'AutoSize_nonDefault', This.GetPEMStatus (loObject, "AutoSize", 0))
					AddProperty (loInfo, 'Left', .Left)
					AddProperty (loInfo, 'Top', .Top)
					AddProperty (loInfo, 'Width', .Width)
					AddProperty (loInfo, 'Height', .Height)
					This.oEventHandlerCaption = loInfo
				Endwith
		
			Case lcEvent == 'autosize' And Thisform.oPrefs.lHandleEvent_Caption
		
				With loObject
					loInfo = Createobject("Empty")
					AddProperty (loInfo, 'AutoSize', .AutoSize)
					AddProperty (loInfo, 'AutoSize_nonDefault', This.GetPEMStatus (loObject, "AutoSize", 0))
					AddProperty (loInfo, 'Left', .Left)
					AddProperty (loInfo, 'Top', .Top)
					AddProperty (loInfo, 'Width', .Width)
					AddProperty (loInfo, 'Height', .Height)
					This.oEventHandlerAutoSize = loInfo
				Endwith
		
			Case This.lDuringResizeEvent
		
			Case lcEvent == 'height'
		
				This.oEventHandlerHeight = loObject.Height
		
			Case lcEvent == 'width'
		
				This.oEventHandlerWidth = loObject.Width
		
		Endcase
		
		
		
	ENDPROC

	PROCEDURE ide_resizechildren
		#Define Bit1 1
		#Define Bit2 2
		#Define Bit3 4
		#Define Bit4 8
		
		Lparameters loObject, lnHeightIncr, lnWidthIncr
		
		Local loChild AS Object
		Local laArray(1), llSuccess, lnAnchor, lnChildHeightIncr, lnChildWidthIncr, lnCount, lnHorzAnchor, lnI
		Local lnVertAnchor
		
		* nothing to do?
		If lnHeightIncr = 0 And lnWidthIncr = 0
			Return
		Endif
		
		* special case for pageframe ... apply to each of the pages
		If Lower (loObject.BaseClass) = 'pageframe'
			For lnI = 1 To loObject.PageCount
				This.IDE_ResizeChildren (loObject.Pages (lnI), lnHeightIncr, lnWidthIncr)
			Endfor
			Return
		Endif
		
		* for all other container types
		With loObject
			Do Case
				Case Not This.GetPEMStatus(loObject, 'Objects', 5)
					lnCount = 0
				Case Inlist(Lower(.BaseClass),[grid],[column])
					lnCount = 0 && a lie! -- but we don't need to worry about these
				Case This.GetPEMStatus(loObject, 'ControlCount', 5)
					lnCount = .ControlCount
				Case Inlist(Lower(.BaseClass),[optiongroup],[commandgroup])
					lnCount = .ButtonCount
				Otherwise
					lnCount = 0
			Endcase
		Endwith
		
		If lnCount # 0 And "O" = Type("loObject.Objects(1)")
		
			For lnI = 1 To lnCount
				loChild = loObject.Objects(lnI)
		
				If This.GetPEMStatus(loChild, 'Anchor', 5)
		
					Unbindevents(loChild)
		
					* apply change to this child
					If Thisform.GetPemstatus(loChild, "_ResizeInfo", 5) And "C" = Vartype(loChild._ResizeInfo)
						lnAnchor = Iif('T' $ loChild._ResizeInfo, 4, 0) ;
							+ Iif('L' $ loChild._ResizeInfo, 8, 0) ;
							+ Iif('H' $ loChild._ResizeInfo, 5, 0) ;
							+ Iif('W' $ loChild._ResizeInfo, 10, 0)
					Else
						lnAnchor = loChild.Anchor
					Endif
		
					Try
						lnChildHeightIncr = 0
						lnChildWidthIncr = 0
						If lnHeightIncr # 0
							lnVertAnchor = Bitand (lnAnchor, Bitor (Bit1, Bit3))
							If lnVertAnchor = 4
								loChild.Top = loChild.Top + lnHeightIncr
							Endif
							If lnVertAnchor = 5
								loChild.Height = loChild.Height + lnHeightIncr
								lnChildHeightIncr = lnHeightIncr
							Endif
						Endif
		
						If lnWidthIncr # 0
							lnHorzAnchor = Bitand (lnAnchor, Bitor (Bit2, Bit4))
							If lnHorzAnchor = 8
								loChild.Left = loChild.Left + lnWidthIncr
							Endif
							If lnHorzAnchor = 10
								loChild.Width = loChild.Width + lnWidthIncr
								lnChildWidthIncr = lnWidthIncr
							Endif
						Endif
						llSuccess = .T.
					Catch
						llSuccess = .F.
					EndTry
					
					* and now the children as well
					If llSuccess And Inlist (Lower (loChild.BaseClass), 'form', 'pageframe', 'container', 'optiongroup', 'commandgroup');
							and 0 = Aevents (laArray, loChild)
						This.IDE_ResizeChildren (loChild, lnChildHeightIncr, lnChildWidthIncr)
					Endif
		
				Endif && This.GetPEMStatus(loChild, 'Anchor', 5)
		
			Endfor && lnI = 1 To lnCount
		Endif && lnCount # 0 And "O" = Type("loObject.Objects(1)")
		
	ENDPROC

	PROCEDURE Init
		Lparameters tnFormNumber, toUtils, toServer, toPrefs
		
		Local lcAppPath
		With This
		
			* Save the parameters.
			Do Case
				Case tnFormNumber = 1
					.Name		  = 'PEMEditor'
					.lPEMEditor	  = .T.
					.lDocTreeView = .F.
					.cFoxUserID	  = 'NEWEDITPROPDLG'
				Case tnFormNumber = 2
					.Name		  = 'DocTreeView'
					.lPEMEditor	  = .F.
					.lDocTreeView = .T.
					.cFoxUserID	  = 'DOC TREEVIEW'
			Endcase
		
			.oUtils   = toUtils
			.oServer = toServer
			.oPrefs  = toPrefs
		
			.SavePositionInfo (This)
			.SavePositionInfo (.cntGridControls, .T.)
			.SavePositionInfo (.cntControls, .T.)
			.SavePositionInfo (.cntIcons, .T.)
		
			* Do the normal things.
		
			DoDefault()
		
			.aDebuggerWindows(1, 1) = ccLOC_WINDOW_TRACE
			.aDebuggerWindows(2, 1) = ccLOC_WINDOW_DEBUG_OUTPUT
			.aDebuggerWindows(3, 1) = ccLOC_WINDOW_WATCH
			.aDebuggerWindows(4, 1) = ccLOC_WINDOW_LOCALS
			.aDebuggerWindows(5, 1) = ccLOC_WINDOW_CALL_STACK
		
			.InitGridHighlighting()
		
			* Create an XML DOM object.
		
			.oXML		= Createobject (ccXML_DOM_CLASS)
			.oXML.Async	= .F.
		
			* Declare the MessageBeep function.
		
			Declare Integer MessageBeep In Win32API Integer wType
		
			.CreateMembersCursor()
			.Scattercursor()
		
			.nStartingTop = .Top
			.Top		  = -2000
			.MousePointer = 0
			.SetOLEToolTips (.cntGridControls.oObjectTree.oTree, .F.)
			.aHandleHistory(1) = 0
		
			Declare short GetKeyState In User32 Integer vKey
		
		Endwith
		
		If Nvl (This.oPersist.Get ('OneTimeAbort'), .F.)
			This.oPersist.Set ('OneTimeAbort', .F.)
		
			With This
				.oPersist.Save (.cFoxUserID, .cFoxUserName)
			Endwith
		
			Return .F.
		Endif
		
		Set Ansi On
		Set Sysformats On
		
		With This
			Set Library To (Home() + 'FoxTools.fll') Additive
			If .lPEMEditor
				If Not .cMyVersion == Thisform.oPrefs.cVersion
					.cMyVersion = Thisform.oPrefs.cVersion
					Thisform.oUtils.AboutPEMEditor()
				Endif
			Endif
		Endwith
		
		This.RefreshTimer.Enabled = .T.
		
	ENDPROC

	PROCEDURE initgridhighlighting
		Local laDefaultColors[1], lcGridHighLights, lnColors, lnRow
		
		This.lUseabbreviations = This.oPrefs.lUseAbbreviations
		
		*** JRN 11/04/2008 : restore grid highlighting parameters (this as default??)
		lnColors = Alines (laDefaultColors, cnDEFAULT_COLORS, .T., ",") / 2
		Dimension laDefaultColors (lnColors, 2)
		
		lcGridHighLights	= Thisform.oPrefs.cGridHighLights
		Alines (Thisform.aGridHighlighting, lcGridHighLights, .T., ",")
		Dimension Thisform.aGridHighlighting (lnColors, 2)
		
		*** JRN 11/20/2008 : Set defaults for missing values
		For lnRow = 1 To lnColors
			If 'L' = Vartype (Thisform.aGridHighlighting (lnRow,1))
				Thisform.aGridHighlighting (lnRow,1) = laDefaultColors(lnRow,1)
			Endif
		
			If 'L' = Vartype (Thisform.aGridHighlighting (lnRow,2))
				Thisform.aGridHighlighting (lnRow,2) = laDefaultColors(lnRow,2)
			Endif
		Next lnRow
		
		
	ENDPROC

	PROCEDURE isdebuggeropen
		Return Wexist(ccLOC_WINDOW_DEBUGGER)		;
			Or Wexist('WATCH')						;
			Or Wexist('TRACE')						;
			Or Wexist('CALL STACK')					;
			Or Wexist('LOCALS')						;
			Or Wexist('DEBUG OUTPUT')
	ENDPROC

	PROCEDURE isshiftorctrldown
		* Left SHIFT key
		#define VK_LSHIFT (0xA0)
		
		* Right SHIFT key
		#define VK_RSHIFT (0xA1)
		
		* Left SHIFT key
		#define VK_LCONTROL (0xA2)
		
		* Right SHIFT key
		#define VK_RCONTROL (0xA3)
		
		
		#define	VK_LSHIFT_DOWN		bittest(GetKeyState(VK_LSHIFT), 31)
		#define	VK_RSHIFT_DOWN		bittest(GetKeyState(VK_RSHIFT), 31)
		
		#define	VK_LCONTROL_DOWN		bittest(GetKeyState(VK_LCONTROL), 31)
		#define	VK_RCONTROL_DOWN		bittest(GetKeyState(VK_RCONTROL), 31)
		
		
		Return VK_LSHIFT_DOWN or VK_RSHIFT_DOWN OR VK_LCONTROL_DOWN or VK_RCONTROL_DOWN 
		
	ENDPROC

	PROCEDURE KeyPress
		*** DougHennig 11/03/2008: set KeyPreview to .T. and added this code to close on Esc
		Lparameters tnKeyCode, ;
			tnShiftAltCtrl
		
		Local lcWindowName
		
		*	Wait Transform(tnKeyCode) + ", " + Transform(tnShiftAltCtrl) Window Nowait
		
		Do Case
			Case Thisform.oMember.InteractiveChanged And tnShiftAltCtrl = 2
				Do Case
						*** CTRL+ENTER
					Case Inlist(tnKeyCode, 10)
						Nodefault
						Keyboard '{ALT+A}'
						*** CTRL+Q
					Case Inlist(tnKeyCode, 17)
						Nodefault
						Keyboard '{ALT+C}'
				Endcase
		
				*** Esc closes form
			Case tnKeyCode = 27 And Thisform.oPrefs.lEscClosesForm
				Thisform.Release()
		
				*** F5 = Refresh
			Case tnKeyCode = -4 And tnShiftAltCtrl = 0
				If This.oObjectTree.lCombotreeOpen or this.lDocTreeView 
					This.oObjectTree.DrawTreeView(.T.)
				Else
					This.RefreshGrid()
				Endif
		
				*** JRN 02/19/2009 : Shift+Ctrl+D shows main form
			Case tnKeyCode = 4 And tnShiftAltCtrl = 3
				lcWindowName = This.oUtils.GetMyWindowName()
				Activate Window (lcWindowName)
				This.oUtils.RestoreMyWindowName()
		
				*** JRN 2010-03-26 : Shift+Ctrl+C ... Open Class
			Case tnKeyCode = 3 And tnShiftAltCtrl = 3
				This.oUtils.DoFormModifyFile("Class")
		
				*** JRN 2010-03-26 : Shift+Ctrl+F ... Open Form
			Case tnKeyCode = 6 And tnShiftAltCtrl = 3
				This.oUtils.DoFormModifyFile("Form")
		
				*** JRN 2010-03-26 : Shift+Ctrl+C ... Open Other
			Case tnKeyCode = 15 And tnShiftAltCtrl = 3
				This.oUtils.DoFormModifyFile("Other")
		
				*** JRN 2010-03-17 : Shift+Ctrl+F4 closed main form
			Case tnKeyCode = 97 And tnShiftAltCtrl = 3
				lcWindowName = This.oUtils.GetMyWindowName()
				Activate Window (lcWindowName)
				This.oUtils.RestoreMyWindowName()
				DoEvents
				Keyboard '{CTRL+F4}'
		
				*** Ctrl-Home
			Case tnKeyCode = 29 And tnShiftAltCtrl = 2
				Nodefault
				With Thisform
					.SetCurrentSelectedObject(Thisform.oTopOfForm)
					.DoQuickTimer('GridFocus')
				Endw
		
				*** Ctrl-End
			Case tnKeyCode = 23 And tnShiftAltCtrl = 2
				Nodefault
				With Thisform
					.SelectLastObject(Thisform.oTopOfForm)
					.DoQuickTimer('GridFocus')
				Endw
		
				*** Ctrl-UpArrow
			Case tnKeyCode = 141 And tnShiftAltCtrl = 2
				Nodefault
				With Thisform
					.SelectNextSibling(-1)
					.DoQuickTimer('GridFocus')
				Endw
		
				*** Ctrl-DnArrow
			Case tnKeyCode = 145 And tnShiftAltCtrl = 2
				Nodefault
				With Thisform
					.SelectNextSibling(+1)
					.DoQuickTimer('GridFocus')
				Endw
		
				*** Ctrl-PgUp
			Case tnKeyCode = 31 And tnShiftAltCtrl = 2
				Nodefault
				With Thisform
					.SelectPreviousObject()
					.DoQuickTimer('GridFocus')
				Endw
		
				*** Ctrl-PgDown
			Case tnKeyCode = 30 And tnShiftAltCtrl = 2
				Nodefault
				With Thisform
					.SelectNextObject()
					.DoQuickTimer('GridFocus')
				Endw
		
				*!*			*** F1
				*!*		Case tnKeyCode = 28 And tnShiftAltCtrl = 0
				*!*			Nodefault
				*!*			With Thisform
				*!*				.ShowHelp()
				*!*			Endw
		
		Endcase
		
	ENDPROC

	PROCEDURE Load
		DoDefault()
		This.OpenNativeTables()
		
		
	ENDPROC

	PROCEDURE locatepem
		Lparameters lcMember
		
		With This
			Select csrMembers
		
			Locate For .JustPem(cName, .T.) == .JustPem(lcMember, .T.)
			If Not Found()
				Set Filter To
				Locate For .JustPem(cName, .T.) == .JustPem(lcMember, .T.)
				If Not Found()
					Locate
				Endif
			Endif Not Found()
			
			.SetProperties()
			.cntGridControls.gridMembers.SetFocus()
		
		Endwith
		
	ENDPROC

	PROCEDURE LostFocus
		Thisform.lRebuildTree = .T.
		
		With This.RefreshTimer
			.Interval = 100 && check up immediately after leaving!
			.Enabled = .T.
		Endwith
		
	ENDPROC

	PROCEDURE memberchanged
		Lparameters tlChanged
		Local llChanged, ;
			llChanged2
		
		With This
			If Pcount() = 0
				llChanged = .T.
			Else
				llChanged = tlChanged
			Endif Pcount() = 0
			*** JRN 12/02/2008 : removed references to .oMember.IsNewMember
		
			If 	.oMember.InteractiveChanged # llChanged
				.oMember.InteractiveChanged = llChanged
				.cntControls.cntFilters.Refresh()
				.cntGridControls.Refresh()
			Endif
		
			With .cntControls
				.cntDescription.lblnnn255.Refresh() && nnn / 255
				.cntCommandButtons.Refresh()
			Endwith
		
		Endwith
		
	ENDPROC

	PROCEDURE memberdatacleaner
		Local lcPrompt, lnNewLen, lnNewMemberData, lnOldLen, lnOldMemberData, lnResponse
		
		lnOldMemberData = Thisform.oTopOfForm._MemberData
		lnOldLen = Len (lnOldMemberData)
		
		lnNewMemberData = PEME_MDCleaner(Thisform.lClass, Thisform.oPrefs.lMemberDataKeepType)
		lnNewLen = Len (lnNewMemberData)
		
		If lnNewLen < lnOldLen
			lcPrompt = ccLOC_CAP_MDCleaner
			lcPrompt = Strtran (lcPrompt, 'XXX', Transform(lnOldLen))
			lcPrompt = Strtran (lcPrompt, 'YYY', Transform(lnNewLen))
			lcPrompt = Strtran (lcPrompt, 'ZZZ', Str( 100 * (1 - lnNewLen / lnOldLen), 3, 0))
		
			lnResponse = Messagebox( lcPrompt, 32 + 4, ccLOC_CAP_MDCleaner_Title)
			If lnResponse = 6
				Thisform.oTopOfForm._MemberData = lnNewMemberData
				Messagebox("MemberData Cleaned", 64, ccLOC_CAP_MDCleaner_Title)
			Endif
		Else
			Messagebox("Nothing to change" + ccCR + "Current length = " + Transform(lnOldLen), 64, ccLOC_CAP_MDCleaner_Title)
		Endif
		
		Thisform.RefreshForm()
		
	ENDPROC

	PROCEDURE memberdatastats
		Local lcPrompt, lnNewLen, lnNewMemberData, lnOldLen, lnOldMemberData, lnResponse
		
		#Define MaxSize (cnMAX_MEMBER_DATA_SIZE - 1)
		
		lnLen = Len (Thisform.oTopOfForm._MemberData)
		
		lcPrompt = '_ MemberData Statistics' + ccCR  + ccCR
		lcPrompt = lcPrompt + 'Maximum size = ' + Transform(MaxSize) + ccCR + ccCR
		lcPrompt = lcPrompt + 'Current size = ' + Transform(lnLen ) + ccCR
		lcPrompt = lcPrompt + 'Available    = ' + Transform(MaxSize - lnLen ) + ccCR + ccCR
		lcPrompt = lcPrompt + 'Percent Used = ' + Str( 100 * (lnLen / MaxSize), 3, 0) + '%' + ccCR
		
		Messagebox(lcPrompt, 64, ccLOC_CAP_MDCleaner_Title)
		
	ENDPROC

	PROCEDURE notemptygrid
		Return Thisform.oMember.IsNewMember Or Not Empty(csrMembers.cName)
		
	ENDPROC

	PROCEDURE notifynewpemshidden
		Lparameters lcFilter
		
		Local lbFilter, lcPrompt, lcType
		
		If "C" # Vartype(lcFilter)
			lcFilter = Filter()
		Endif
		
		If Empty(lcFilter)
			lbFilter = .T.
		Else
			lbFilter = Evaluate(lcFilter)
		Endif
		
		If Thisform.oPrefs.lnotifynewpemshidden And Not lbFilter
			If Thisform.lIsTopOfForm
				lcPrompt = ccLOC_PR_NotifyNewPemsHidden
			Else
				lcPrompt = ccLOC_PR_NotifyNewPemsHiddenCSO
			Endif
		
			lcPrompt = Thisform.insertformorclass(lcPrompt)
			lcPrompt = Strtran (lcPrompt, 'PEM_Name_Place_Holder', Trim(csrMembers.cName))
			lcType = Iif(csrMembers.cType = 'P', ccLOC_CAP_Type_Property, ccLOC_CAP_Type_Method)
			lcPrompt = Strtran (lcPrompt, '<insert3>', lcType)
		
			Messagebox (lcPrompt)
		Endif
		
	ENDPROC

	PROCEDURE opennativetables
		Local lcPath
		
		lcPath = Thisform.cApplicationPath
		Use (lcPath + "Tables\Property List") 				Alias PropertyList 				Again In 0 Shared Order Name
		Use (lcPath + "Tables\Property Values") 			Alias PropertyValues			Again In 0 Shared
		Use (lcPath + "Tables\Default Native Properties") 	Alias DefaultNativeProperties	Again In 0 Shared
		
		Use (lcPath + "Tables\GroupNames") 					Alias GroupNames				Again In 0 Shared
		Use (lcPath + "Tables\PemNameGroups") 				Alias PEMNameGroups				Again In 0 Shared Order PemName
		
		Try
			Use (Thisform.cPlugInPath + "Buffer OverRun Avoidance List") 	Alias BufferOverrunList	Again In 0 Shared
		Catch
			Try
				Use (lcPath + "Buffer OverRun Avoidance List") 	Alias BufferOverrunList	Again In 0 Shared
			Catch
		
			Endtry
		Endtry
		
		Use Home() + 'WIZARDS\FDKEYWRD' Order TOKEN Again Shared In 0 Alias Keywords
		Select TOKEN From Keywords Into Cursor VFP_Keywords Readwrite
		Index On Upper(TOKEN) Tag TOKEN
		Use In Keywords
		
		
	ENDPROC

	PROCEDURE peme_bindevent
		Lparameters loObject, lcEvent, lcHandler, lnFlags
		
		If This.GetPEMStatus (loObject, lcEvent, 5)
			Bindevent (loObject, lcEvent, This, lcHandler, lnFlags)
		Endif
		
	ENDPROC

	PROCEDURE QueryUnload
		Local lcAppPath, lcEditPropertyCode
		If Thisform.oPrefs.lRestartAfterClearAll and Thisform.lPEMEditor
			lcAppPath = Thisform.cApplicationPath + 'PEMEditor.app'
			* Create text that would be used to re-open PEMEditor after Clear All
			Text To lcEditPropertyCode Noshow Textmerge
				Try
					If 'O' # Vartype (_oPEMEditor)
						Release _oPEMEditor
						Public 	_oPEMEditor
		
						loPEMEditor = CreateObject('PEMEditor')
						_oPEMEditor = loPEMEditor.Start()
					Endif
		
					_oPEMEditor.oUtils.ShowForm()
				Catch
				
				EndTry
		
				Define Class PEMEditor as Session
		
					Procedure Start
						Return Newobject('PEMEditor_Main', 'PEME_Main.VCX', '<<lcAppPath>>')
					EndProc
						
				EndDefine 
		
			Endtext
			RestartAfterClearAll (This, lcEditPropertyCode)
		
		Endif
		
	ENDPROC

	PROCEDURE refreshform
		This.Refresh()
	ENDPROC

	PROCEDURE refreshgrid
		Local lcName
		
		With This
			lcName = .oOriginalMember.cName
		
			.lRebuildTree = .F.
			.ActivateForm(.T.)
		
			Locate For cName = lcName
			If Not Found()
				Locate
			Endif
		
			.Refreshform()
		Endwith
		
	ENDPROC

	PROCEDURE removeaccessassign		&& Removes the access and/or assign methods for the property
		lparameters tcMethod
		local lnRecNo, lcFilter
		with This
			Select csrMembers
			lcFilter = Filter()
			Set Filter to 
			lnRecNo = recno()	
			removeproperty(.oTopOfForm, tcMethod)
			locate for lower(alltrim(cName)) == lower(tcMethod)
			if found()
				.removeMemberData(tcMethod)
				delete
			endif found()
			Set Filter to &lcFilter)
			go lnRecNo
		endwith
		
	ENDPROC

	PROCEDURE removemember		&& Called to delete the property or method
		Lparameters tcName, ;
			tlNoDelete,		;
			tlConfirm
		
		Local lcName, ;
			lnVisibility, ;
			lcDescription, ;
			lcCode, ;
			lcCleanName, ;
			lcSuffix
		
		Local lcPrompt, lnMsgBox, lcRoot, lnRecno	
		
		lcName = Alltrim(tcName)
		
		If tlConfirm
			If Thisform.oPrefs.lPromptOnRemoval
				lcPrompt = Iif( 'P' $ ThisForm.oOriginalMember.cType, ccLOC_CAP_Remove_Property,ccLOC_CAP_Remove_Method) + lcName + "?"
				lnMsgBox = Messagebox (lcPrompt, 4+32, Thisform.Caption)
				If lnMsgBox = 7
					Return
				Endif
			Endif
		Endif
		
		* Load the member data so it can be updated.
		
		If Thisform.GetPEMStatus(This.oTopOfForm, [_MemberData], 5) And ;
				not Empty(This.oTopOfForm._MemberData) And ;
				not This.oXML.LoadXML(This.oTopOfForm._MemberData)
			Messagebox(ccLOC_INVALID_XML, MB_OK + MB_ICONEXCLAMATION, This.Caption)
			Return
		Endif Thisform.GetPEMStatus(This.oTopOfForm, [_MemberData], 5) ...
		
		* Although this seems goofy, we have to add the member so the Class/Form
		* Designer actually sees a change.
		
		With This
			lnVisibility  = .oMember.nVisibility
			lcDescription = Alltrim(.oMember.cDescript)
			Try
				If .lMethod
					lcCode = .oTopOfForm.ReadMethod(lcName)
					.oTopOfForm.WriteMethod(lcName, lcCode, .F., lnVisibility, lcDescription)
				Else
					*** TO DO: reference member of oMember rather than oedtDefault.xValue
					.oTopOfForm.AddProperty(lcName, .oedtDefault.xValue, ;
						lnVisibility, lcDescription)
				Endif .lMethod
			Catch
			Endtry
		
			* Remove any Access and Assign methods
		
			lcCleanName = .JustPEM(tcName)
			If ThisForm.oOriginalMember.lAccess
				.RemoveAccessAssign(lcCleanName + [_access])
			Endif ThisForm.oOriginalMember.lAccess
			If ThisForm.oOriginalMember.lAssign
				.RemoveAccessAssign(lcCleanName + [_assign])
			Endif ThisForm.oOriginalMember.lAssign
		
			* If the member we're removing is an Access or Assign method, turn off those
			* settings for the associated property.
		
			lcSuffix = Lower(Right(lcCleanName, 7))
			If lcSuffix = '_access' Or lcSuffix = '_assign'
				lcRoot  = Lower(Left(lcCleanName, Len(lcCleanName) - 7))
				lnRecno = Recno('csrMembers')
				Locate For Lower(Trim(cName)) == lcRoot
				If Not Found()
					Locate For Lower(Trim(cName)) == lcRoot + '[1]'
				Endif Not Found()
				If lcSuffix = '_access'
					Replace lAccess With .F. In csrMembers
				Else
					Replace lAssign With .F. In csrMembers
				Endif lcSuffix = '_access'
				Go lnRecno In csrMembers
			Endif lcSuffix = '_access' ...
		
			* Remove the member data for the member then remove the member itself.
		
			.removeMemberData(lcCleanName)
			Removeproperty(.oTopOfForm, lcCleanName)
		
			* If we're not merely renaming a member, delete the record from the grid and
			* get the properties for the member that's now selected.
		
			If Not tlNoDelete
				Delete In csrMembers
				Skip In csrMembers
				If Eof([csrMembers])
					Go Bottom In csrMembers
				Endif Eof([csrMembers])
				.oGrid.SetFocus()
				.setProperties()
			Endif Not tlNoDelete
		Endwith
		
	ENDPROC

	PROCEDURE removememberdata		&& When we remove the member
		Lparameters tcName
		Local loNode, loRoot
		With This
		
			If .UseMemberData()
				* Get the node for the member if it exists.
		
				loNode = .oXML.selectSingleNode('//' + ccMEMBER_DATA_XML_ELEMENT +;
					'[@name = "' + Lower(Alltrim(tcName)) + '"]')
		
				* If it exists, get a reference to the root node and remove the node for this
				* member.
		
				If Vartype(loNode) = [O]
					loRoot = .oXML.selectSingleNode('/' + ccXML_ROOT_NODE)
					loRoot.RemoveChild( loNode )
		
					* Now see if we have any nodes for any members and if we don't, just blank
					* the _MemberData property.
		
					If loRoot.HasChildNodes
						.oTopOfForm._MemberData = .oXML.XML
					Else
						.oTopOfForm._MemberData = ''
					Endif loRoot.HasChildNodes
				Endif Vartype(loNode) = [O]
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE renamemethodwindow
		Lparameters loObject, lcMethodName
		
		Local lcName
		If "O" # Vartype (Thisform.oTopOfForm)
			Return
		EndIf 
		
		lcName = Thisform.oTopOfForm.Name + Thisform.GetObjectpath (loObject) + "." + Alltrim(lcMethodName)
		Try
			lcName = lcName + " (" + Ttoc (Fdate (Thisform.cSourceFileName, 1)) + ")"
		Catch
		
		EndTry
		
		Do while Len(lcName) >= 100
			lcName = Substr (lcName, At ('.', lcName, 2)) 
		EndDo
		
		This.oUtils.SetWindowTitle (lcName)
		
	ENDPROC

	PROCEDURE resetmembertodefault
		Local loException, loObject, lnI
		
		With Thisform
			Do Case
				Case .lEditingOneProperty
					.aSelectedObjects(Thisform.nObjNumber).ResetToDefault(.cEditPropertyName)
					Replace lNonDefault With .F. In csrMembers
		
				Case .nSelectedObjects = 1
					Try && may not be able to set default ...
						If Thisform.oMember.cType = 'P'
							.oObject.ResetToDefault(Thisform.JustPEM(Thisform.oMember.cName, .T.))
						Else
							.oObject.WriteMethod(Thisform.JustPEM(Thisform.oMember.cName, .T.), '')
						Endif
						Replace lNonDefault With .F. In csrMembers
					Catch To loException
		
					Endtry
				Otherwise
					For lnI = 1 To Alen ( Thisform.aSelectedObjects)
						loObject = Thisform.aSelectedObjects(lnI)
						Try && may not be able to set default ...
							loObject.ResetToDefault(Thisform.JustPEM(Thisform.oMember.cName, .T.))
							Replace lNonDefault With .F. In csrMembers
						Catch To loException
		
						Endtry
					Endfor
			Endcase
		Endwith
		
	ENDPROC

	PROCEDURE Resize
		DoDefault()
		
		ThisForm.cntIcons.Refresh()
		
	ENDPROC

	PROCEDURE resortgrid
	ENDPROC

	PROCEDURE restoredebuggerwindows
		Local lnI
		
		With This
			If .nDebuggerWindows = 1 And .oPrefs.lCloseDebuggerWindows  ;
					and (This.IsDebuggerOpen() Or Not .lDebuggerWasOpen)
				* meaning .. there are some to re-open
				* second line handles case where user has closed debugger on his own
				For lnI = 1 To Alen (.aDebuggerWindows,1)
					If .aDebuggerWindows(lnI,2)
						Try
							Activate Window (.aDebuggerWindows(lnI,1))
						Catch
		
						Endtry
						.aDebuggerWindows(lnI,2) = .F.
					Endif
				Next lnI
			Endif
			.nDebuggerWindows = 0 && meaning .. you'll need to check again next time
		
		Endwith
		
	ENDPROC

	PROCEDURE restorepositioninfo
		Lparameters toObject, tlHasAnchor
		
		With toObject
			If tlHasAnchor
				If PEME_IsVersion9()
					.Anchor 	= 0
				Endif
				.Left		= .nOriginalLeft
				.Top 		= .nOriginalTop
			Endif
		
			.Width		= .nOriginalWidth
			.Height		= .nOriginalHeight
		
			If tlHasAnchor And PEME_IsVersion9()
				.Anchor		= .nOriginalAnchor
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE restoresettings
		* Restore saved settings from FOXUSER.
		
		*** JRN 12/04/2008 : No longer calls DoDefault, since we need to call GetSettings
		* and possibly re-arrange the form before we restore it's size / position
		
		Local lbPutFlag, lnLeft, lnMinHeight, lnMinWidth, lnMultiplier, lnTop
		
		With This
		
			.oPersist.Load(.cFoxUserID, .cFoxUserName)
		
			*** JRN 12/04/2008 : This is needed EARLY!
			.GetPutSettings(.F.)
			.GetMRUSettings()
			.SetDefaultGridSortOrder()
		
			.SetFormAlignment(.T.)
			
			* These must be done late, after docking, if any ..
			lbPutFlag = .F.
			lnTop = .Top
			lnLeft = .Left
		
			If (Not Empty(.nFontSize)) And .nFontSize # 8
				lnMinHeight = .MinHeight
				lnMinWidth = .MinWidth
						
				.MinHeight = 0
				.MinWidth = 0
			
				.ChangeFontSize.Run( .nFontSize, 8)
		
				lnMultiplier = .nFontSize / 8
				With .osplitterV
					.nObject1MinSize = .nObject1MinSize * lnMultiplier
					.nObject2MinSize = .nObject2MinSize * lnMultiplier
				Endwith
		
				With .osplitterH
					.nObject1MinSize = .nObject1MinSize * lnMultiplier
					.nObject2MinSize = .nObject2MinSize * lnMultiplier
				Endwith
		
				With .cntControls.oSplitter
					.nObject1MinSize = .nObject1MinSize * lnMultiplier
					.nObject2MinSize = .nObject2MinSize * lnMultiplier
				EndWith
				
				.MinHeight = lnMinHeight * lnMultiplier
				.MinWidth = lnMinWidth * lnMultiplier
		
			Endif
		
			.GetPutSetting ('Top', 'Top', lnTop, lbPutFlag)
			.GetPutSetting ('Left', 'Left', lnLeft, lbPutFlag)
			.GetPutSetting ('Height', 'Height', .Height, lbPutFlag)
			.GetPutSetting ('Width', 'Width', .Width, lbPutFlag)
		
		Endwith
		
	ENDPROC

	PROCEDURE revertchanges
		* Re-read members from the object, reverting any changes. If we were creating a
		* new member, reselect the former one.
		
		with This
			if not empty(.cFormerMember)
				locate for upper(cName) = upper(.cFormerMember)
			endif not empty(.cFormerMember)
			.ScatterCursor()
			.RefreshForm()
		endwith
		
		
	ENDPROC

	PROCEDURE savedockinginfo
		*** JRN 12/24/2008 : Save all docking info; called by AfterDock and UnDock
		
		Local Array laDock[1]
		Local lnRow, lcDockWindow, lnRowDocked
		
		If "O" # Vartype(ThisForm.oPersist) or not PEME_IsVersion9()
			Return
		EndIf 
		
		With This
		
			* Persist the docking information.
		
			.PutSetting('Dockable', IIF( .Dockable = 1, 1, 2), 1) 
			.PutSetting('Docked',   .Docked, .F.) 
			If .Docked
				Adockstate(laDock)
				lnRow = Ascan(laDock, .Caption, -1, -1, 1, 15)
				*** JRN 12/24/2008 : Remember window that we're docked to
				lcDockWindow = ''
				If lnRow > 0
					.PutSetting('DockPosition', laDock[lnRow, 3])
					If laDock[lnRow, 4] # _Screen.Caption And Not Empty(laDock[lnRow, 4])
						lcDockWindow = laDock[lnRow, 4]
					Else
						lnRowDocked = Ascan(laDock, .Caption, -1, -1, 4, 15)
						If lnRowDocked > 0
							lcDockWindow = laDock[lnRowDocked, 1]
						Endif
					Endif
				Endif lnRow > 0
				.PutSetting('DockWindow', lcDockWindow, '')
				*** JRN 12/24/2008
			Endif .Docked
		
		Endwith
		
	ENDPROC

	PROCEDURE saveparentclasses
		Local laClasses[1], laSplit[1], lcClass, lcClasses, lnCount, lnI
		
		This.AddMRUFile('\-', '', 'MRU44')
		
		lcClasses = This.GetParentCode('', 'oParentage')
		lnCount = Alines(laClasses, lcClasses, .T., Chr(0))
		For lnI = lnCount To 1 Step -1
			lcClass = laClasses(lnI)
			If Not Empty(lcClass)
				This.AddMRUFile(lcClass, '', 'MRU44')
			Endif
		Endfor
		
		MessageBox ("Parent class list saved; see 'Open' menu/icon")
	ENDPROC

	PROCEDURE savepositioninfo
		Lparameters toObject, tlHasAnchor
		
		With toObject
			.AddProperty("nOriginalLeft", 	.Left)
			.AddProperty("nOriginalTop", 	.Top)
			.AddProperty("nOriginalWidth", 	.Width)
			.AddProperty("nOriginalHeight", .Height)
			If tlHasAnchor and PEME_IsVersion9()
				.AddProperty("nOriginalAnchor", .Anchor)
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE savesettings
		Local lcColumnWidths, lcColumnOrder, loColumn, lnI, lbPutFlag
		
		With This
		
			.savedockinginfo()
		
			.nSplitterTop		= .oSplitterV.Top
			.nSplitterLeft		= .oSplitterH.Left
			.nDescSplitterTop	= .cntControls.oSplitter.Top
		
			.GetPutSettings(.T.)
			.GetMRUSettings(.T.)
		
			* These must be done separately, because of docking
			lbPutFlag = .T.
			.GetPutSetting ('Top', 'Top', -1, lbPutFlag)
			.GetPutSetting ('Left', 'Left', -1, lbPutFlag)
			.GetPutSetting ('Height', 'Height', -1, lbPutFlag)
			.GetPutSetting ('Width', 'Width', -1, lbPutFlag)
		
			* Save the column widths and order.
		
			.SaveColumnInfo(.oGrid)
			.PutSetting('NMonitors' , GetSystemMetrics(SM_CMONITORS))
		
			.oPersist.Save(.cFoxUserID, .cFoxUserName)
			
			* Curiously, even if there are no changes, savings causes file explosion, so we pack afterwards
			Try
				Select 0
				Use (This.cPreferencesFile) Exclusive alias Preferences
				Pack
			Catch
				
			Finally
				Use
			
			Endtry
		
		Endwith
		
		
	ENDPROC

	PROCEDURE scattercursor
		* Scatter the current record from crsMembers into our data object oMember
		* and cause appropriate controls to be enabled/disabled.
		
		Lparameters tlNew, ;
			tcType
		With This
			If tlNew
				.cFormerMember = csrMembers.cName
		*!*			Try && in case no records found
		*!*				Go Bottom
		*!*				Skip
		*!*			Catch
		*!*			Endtry
				Scatter Name .oMember 			Memo Blank
				Scatter Name .oOriginalMember 	Memo Blank
				.oMember.nVisibility = IIF(This.lClass, This.oPrefs.nStartVisibility, 1)
				.oMember.cType       = tcType
				.oMember.nFavorites  = 1
				.cOriginalName       = ''
			Else
				Scatter Name .oMember 			Memo
				Scatter Name .oOriginalMember 	Memo
				.cFormerMember = ''
			Endif tlNew
			
			AddProperty (.oMember, "InteractiveChanged", .F.)
			AddProperty (.oMember, "DefaultValue", .F.)
			AddProperty (.oMember, "DefaultChanged", .F.)
			AddProperty (.oMember, "IsNewMember", tlNew)
			AddProperty (.oMember, "ResetToDefault", .F.)
		
			.MemberChanged(.F.)
		Endwith
		
	ENDPROC

	PROCEDURE selectlastobject
		Lparameters loObject
		
		Local loControl As Object
		Local loObject As Object
		Local lnCount
		Local laControls(1)
		
		If "O" # Vartype (loObject)
			Return
		endif
		
		Do While .T.
			lnCount = Thisform.CreateSortedObjectArray (loObject, @laControls)
			If lnCount = 0
				Exit
			Endif
			loObject = loObject.Objects(laControls(lnCount,1))
		Enddo
		
		Thisform.SetCurrentSelectedObject(loObject)
		
		
	ENDPROC

	PROCEDURE selectnextobject
		Local loNextObject AS Object
		Local loObject AS Object
		Local loParent AS Object
		Local llFound, lnCount, lnI 
		Local laControls(1)
		
		loObject = Thisform.oObject
		If "O" # Vartype (loObject)
			Return
		Endif
		
		lnCount = Thisform.CreateSortedObjectArray (loObject, @laControls)
		If lnCount > 0
			loNextObject = loObject.Objects(laControls(1,1))
			Thisform.SetCurrentSelectedObject(loNextObject)
			Return
		Endif
		
		Do While .T.
		
			loParent = loObject.Parent
			lnCount = Thisform.CreateSortedObjectArray (loParent, @laControls)
			llFound = .F.
			For lnI = 1 To lnCount - 1
				If loObject = loParent.Objects(laControls(lnI,1))
					loNextObject = loParent.Objects(laControls(lnI + 1,1))
					llFound = .T.
				Endif
			Endfor
		
			Do Case
				Case llFound
					Exit
				Case loObject = Thisform.oTopOfForm
					loNextObject = loObject
					Exit
				Otherwise
					loObject = loParent
			Endcase
		Enddo
		
		Thisform.SetCurrentSelectedObject(loNextObject)
		
		
	ENDPROC

	PROCEDURE selectnextsibling
		Lparameters lnDirection
		
		Local loNextObject As Object
		Local loObject As Object
		Local loParent As Object
		Local laControls(1), lnCount, lnI, lnMyRow
		
		loObject = Thisform.oObject
		If "O" # Vartype (loObject) Or loObject = Thisform.oTopOfForm
			Return
		Endif
		
		loParent = loObject.Parent
		lnCount = Thisform.CreateSortedObjectArray (loParent, @laControls)
		For lnI = 1 To lnCount
			If loObject = loParent.Objects(laControls(lnI,1))
				lnMyRow = lnI + lnDirection
			Endif
		Endfor
		
		Do Case
			Case 'L' = Vartype(lnMyRow)
				Return
			Case lnMyRow = 0
				lnMyRow = lnCount
			Case lnMyRow > lnCount
				lnMyRow = 1
		Endcase
		
		loNextObject = loParent.Objects(laControls(lnMyRow,1))
		
		Thisform.SetCurrentSelectedObject(loNextObject)
		
	ENDPROC

	PROCEDURE selectpreviousobject
		Local loNextObject As Object
		Local loObject As Object
		Local loParent As Object
		Local llFound, lnCount, lnI
		Local laControls(1)
		
		loObject = Thisform.oObject
		If "O" # Vartype (loObject) Or loObject = Thisform.oTopOfForm
			Return
		Endif
		
		loParent = loObject.Parent
		lnCount = Thisform.CreateSortedObjectArray (loParent, @laControls)
		llFound = .F.
		For lnI = 2 To lnCount
			If loObject = loParent.Objects(laControls(lnI,1))
				loNextObject = loParent.Objects(laControls(lnI - 1,1))
				llFound = .T.
			Endif
		Endfor
		
		If llFound
			Thisform.SelectLastObject (loNextObject)
		Else
			Thisform.SetCurrentSelectedObject(loParent)
		Endif
		
		
		
	ENDPROC

	PROCEDURE setcoverage
		Lparameters llFlag
		
		If llFlag
			Set Coverage To ("c:\temp\coverage\" + Sys(2015) + ".txt")
		Else
			Set Coverage To
		Endif
		
	ENDPROC

	PROCEDURE setcurrentobjectproperty
		Lparameters loTarget, lcMethodName
		
		Local laMethods[1], lcSuffix
		
		This.SetCurrentSelectedObject (loTarget)
		Select csrMEMBERS
		Locate For Upper (cName) = Upper (lcMethodName + ' ')
		If Not Found()
			Locate
		Endif
		
		Alines (laMethods, '_Access,_Assign', .T., ',')
		For Each lcSuffix In laMethods
			lcMethod = lcMethodName + lcSuffix
			Do Case
				Case Not This.GetPEMStatus (loTarget, lcMethod, 5)
				Case Empty (loTarget.ReadMethod (lcMethod))
					This.ViewParentCode (lcMethod, 'Code', , loTarget, .T.)
					* show code
				Otherwise
					This.oUtils.EditMethodCode (This.cSourceFileName, This.oTopOfForm, loTarget, lcMethod, This.lClass)
			Endcase
		Endfor
		
	ENDPROC

	PROCEDURE setcurrentselectedobject
		Lparameters toObject, llNoRecurse
		
		With This
		
			If .lPEMEditor
		
				If .oObject # toObject
					.CloseTreeView(.lTreeViewShowMethods)
					.oUtils.FocusOnControl(toObject)
		
					Declare Sleep In kernel32 Integer dwMilliseconds
					Sleep (25)
		
					.SetDesignerObjects()
		
					Dimension .aSelectedObjects(1)
					.aSelectedObjects(1) = toObject
					.nSelectedObjects = 1
		
					.oObject = toObject
		
				Endif
		
				If .lUseCSO Or Not llNoRecurse
					.lUseCSO 		= .T.
					.lRebuildTree 	= .F.
		
					.oObject 		= toObject
					.ActivateForm (.T.)
					If (Not PEME_IsVersion9()) Or .DockPosition < 4 Or Not llNoRecurse
						.oGrid.SetFocus()
					Endif
					If Pcount() = 1
						Try
							This.oUtils.oDocTreeView.SetCurrentSelectedObject(toObject, .T.)
						Catch
		
						Endtry
					Endif
				Endif
		
			Else
				.SaveNodeHighlighting(.oObjectTree.oTree, 'Restore')
				If Pcount() = 1
					.SaveNodeHighlighting(.oObjectTree.oTree, 'Selected')
					Try
						This.oUtils.oPEMEditor.SetCurrentSelectedObject(toObject, .T.)
					Catch
		
					Endtry
				Else
					.SaveNodeHighlighting(.oObjectTree.oTree, 'Find', .GetObjectPath(toObject))
				Endif
		
				Declare Sleep In kernel32 Integer dwMilliseconds
				Sleep (25)
		
				.SetDesignerObjects()
		
				Dimension .aSelectedObjects(1)
				.aSelectedObjects(1) = toObject
				.nSelectedObjects = 1
		
				.oObject = toObject
		
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE setdefaultgridsortorder
		*** JRN 03/05/2009 : Custom PRG to handle this?
		Local lcCustomPRG, lcMembersSortOrder
		
		With This
		
			lcCustomPRG =  This.oUtils.GetPlugInPath ("SetGridSortOrder")
		
			lcMembersSortOrder = ccLoc_SortOrder1
			If Not Empty (lcCustomPRG)
				Try
					lcMembersSortOrder = Execscript(Filetostr(lcCustomPRG), lcMembersSortOrder, 1)
					.cMembersSortOrder = lcMembersSortOrder
				Catch To loException
					Thisform.ShowErrorMsg(loException, 'Set Grid Sort Order', lcCustomPRG)
				Endtry
			Endif
		
			lcMembersSortOrder = ccLoc_SortOrder2
			If Not Empty (lcCustomPRG)
				Try
					lcMembersSortOrder = Execscript(Filetostr(lcCustomPRG), lcMembersSortOrder, 2)
					.cMembersSortOrderMethodView = lcMembersSortOrder
				Catch To loException
					Thisform.ShowErrorMsg(loException, 'Set Grid Sort Order', lcCustomPRG)
				Endtry
			Endif
		
		Endw
		
	ENDPROC

	PROCEDURE setdesignerobjects
		Local laObjects(1)
		
		If 0 # Aselobj (laObjects) Or 0 # Aselobj (laObjects,1)
			With This
				Dimension .aDesignerObjects(1)
				.aDesignerObjects(1) = laObjects(1)
				.nDesignerObjects = 1
			EndWith
		Endif
		
		
	ENDPROC

	PROCEDURE setfilter
		Lparameters tlNoSetProperties
		Local lcCustomPRG, lcField, lcFilter, lcFilter1, lcFilter2, lcKey, lcMembersSortOrder, lcSearch
		Local lcSubString, lnMethodView, lnRecno, lcCaseFilter
		
		This.lFilterInEffect = (Thisform.oPrefs.lFavorites # Thisform.oPrefs.lDefaultFavorites);
			Or (Thisform.oPrefs.lNonDefault # Thisform.oPrefs.lDefaultnonDefault)
		
		****************************************************************
		* Created 10/25/2008 by Jim Nelson
		* Sets filter for grid based on filter settings
		* Also re-sorts and tries to find the same record
		With Thisform
		
			*!*		If Thisform.nSelectedObjects > 1
			*!*			lnMethodView = 1
			*!*		Else
			*!*			lnMethodView = .nMethodView
			*!*		Endif
			lnMethodView = .nMethodView
		
			Do Case
				Case lnMethodView = 1
					lcFilter1 = Iif (.oPrefs.lTypeProperty, 'P', '') + ;
						Iif (.oPrefs.lTypeMethod , 'M', '') + ;
						Iif (.oPrefs.lTypeEvent, 'E', '')
					lcFilter1 = "cType $ '" + lcFilter1 + "'"
		
					lcFilter2 = Iif (.oPrefs.lHierarchyNative, 'N', '') + ;
						Iif (.oPrefs.lHierarchyInherited, 'I', '') + ;
						Iif (.oPrefs.lHierarchyCustom, 'C', '')
					lcFilter2 = "IIF (lNative, 'N', IIF(lInherited, 'I', 'C')) $ '" + lcFilter2 + "'"
		
					lcFilter = lcFilter1 + Iif (Not Empty (lcFilter1) And Not Empty (lcFilter2), " and ", '') + lcFilter2
		
					lcSubString = Chrtran (	Thisform.cSubString, ['], [])
		
					This.lFilterInEffect = This.lFilterInEffect ;
						or (.oPrefs.lTypeProperty       # .oPrefs.lDefaultTypeProperty) ;
						or (.oPrefs.lTypeMethod         # .oPrefs.lDefaultTypeMethod);
						or (.oPrefs.lTypeEvent          # .oPrefs.lDefaultTypeEvent);
						or (.oPrefs.lHierarchyNative    # .oPrefs.lDefaultHierarchyNative) ;
						or (.oPrefs.lHierarchyInherited # .oPrefs.lDefaultHierarchyInherited) ;
						or (.oPrefs.lHierarchyCustom    # .oPrefs.lDefaultHierarchyCustom)
		
				Case lnMethodView = 2
					lcFilter = Iif (.oPrefs.lmethodviewlocal, '1', '') + ;
						Iif (.oPrefs.lmethodviewinherited , '2', '') + ;
						Iif (.oPrefs.lmethodviewmethodnone , '3', '') + ;
						Iif (.oPrefs.lmethodviewEventnone , '4', '')
		
					lcFilter = "IIF(cType = 'P', '0', IIF(lNonDefault, '1', IIF(lHasCode, '2', IIF(Not lNative, '3', '4')))) $ '" + lcFilter + "'"
		
					lcSubString = Chrtran (	Thisform.cSubStringMV, ['], [])
		
					This.lFilterInEffect = This.lFilterInEffect ;
						or (.oPrefs.lmethodviewlocal      # .oPrefs.lDefaultMethodViewLocal) ;
						or (.oPrefs.lmethodviewinherited  # .oPrefs.lDefaultMethodViewInherited) ;
						or (.oPrefs.lmethodviewmethodnone # .oPrefs.lDefaultMethodViewMethodNone) ;
						or (.oPrefs.lmethodviewEventnone  # .oPrefs.lDefaultMethodViewEventNone)
			Endcase
		
		Endwith
		
		If Not This.lEditingOneProperty
		
			If Substr(lcSubString,2,1) $ '=$'
				lcKey = Upper(Substr(lcSubString,1,2))
				lcSearch = Substr (lcSubString,3)
			Else
				lcKey = 'N$'
				lcSearch = lcSubString
			Endif
		
			If Left(lcKey, 1) $ 'UL' And Substr(lcKey,2,1) $ '=$'
				Do Case
					Case lcKey = 'U=' && starts with uppercase
						lcCaseFilter = 'IsUpper(cName)'
		
					Case lcKey = 'U$' && uppercase anywhere
						lcCaseFilter = '(Upper(cName)  # cName)'
		
					Case lcKey = 'L=' && starts with lowercase
						lcCaseFilter = '(Not IsUpper(cName))'
		
					Case lcKey = 'L$' && all lowercase
						lcCaseFilter = '(Upper(cName) = cName)'
		
				Endcase
		
				lcFilter = lcFilter + Iif (Not Empty (lcFilter), " and ", '') + lcCaseFilter
		
				If Substr(lcSubString,2,1) $ '=$'
					lcKey = Upper(Substr(lcSubString,1,2))
					lcSearch = Substr (lcSubString,3)
				Else
					lcKey = 'N$'
					lcSearch = lcSubString
				Endif
		
			Endif
		
			If Not Empty (lcSearch)
				Do Case
					Case lcKey = 'D'
						lcField = 'Upper(cDescript)'
					Case lcKey = 'V'
						lcField = "Upper(IIF (cType = 'P', Thisform.GetValue(cName, lNative, 'Display',,cDescript), ''))"
					Otherwise
						lcField = 'Upper(cName)'
				Endcase
		
				If Substr(lcKey,2,1) = '='
					lcFilter = lcFilter + Iif (Not Empty (lcFilter), " and ", '') + lcField + [ = '] + lcSearch + [']
				Else
					lcFilter = lcFilter + Iif (Not Empty (lcFilter), " and ", '') + ['] + lcSearch + [' $ ] + lcField
				Endif
				This.lFilterInEffect = .T.
			Endif
		Endif
		
		
		If Thisform.oPrefs.lFavorites
			lcFilter = lcFilter + Iif (Not Empty (lcFilter), " and ", '') + [nFavorites  # 1]
		Endif
		
		If Thisform.oPrefs.lNonDefault And lnMethodView = 1
			lcFilter = lcFilter + Iif (Not Empty (lcFilter), " and ", '') + [lNonDefault]
		Endif
		
		Select csrMembers
		lnRecno = Recno( [csrMembers] )
		
		Delete Tag All
		Set Filter To
		Set Relation To
		
		If lnMethodView = 1
			lcMembersSortOrder = Thisform.cMembersSortOrder
		Else
			lcMembersSortOrder = Thisform.cMembersSortOrderMethodView
		Endif
		
		****************************************************************
		
		Try
			Index On &lcMembersSortOrder Tag cName
		Catch To loException
			If Thisform.nMethodView = 1
				This.cMembersSortOrder = ccLoc_SortOrder1
				lcMembersSortOrder = This.cMembersSortOrder
			Else
				This.cMembersSortOrderMethodView = ccLoc_SortOrder2
				lcMembersSortOrder = This.cMembersSortOrderMethodView
			Endif
		
			Index On &lcMembersSortOrder Tag cName
		Endtry
		
		****************************************************************
		*** JRN 2011-02-13 : 'Group' selection
		If This.oPrefs.nGroupID > 1
		
			Set Relation To Upper(cName) Into crsr_PEMNameGroups
			Do Case
				Case This.oPrefs.nGroupID = 6 && Layout / Other
					Set Filter To GroupID <= 4 In crsr_PEMNameGroups
					lcFilter = lcFilter + Iif (Not Empty (lcFilter), " and ", '') + [(Found ('crsr_PEMNameGroups'))]
				Case This.oPrefs.nGroupID = 7 && Other
					Set Filter To GroupID <= 5 In crsr_PEMNameGroups
					lcFilter = lcFilter + Iif (Not Empty (lcFilter), " and ", '') + [(Not Found ('crsr_PEMNameGroups'))]
				Otherwise
					lcGroupID = Transform(This.oPrefs.nGroupID)
					Set Filter To GroupID = &lcGroupID  In crsr_PEMNameGroups
					lcFilter = lcFilter + Iif (Not Empty (lcFilter), " and ", '') + [(Found ('crsr_PEMNameGroups'))]
			Endcase
		
			This.lFilterInEffect = .T.
		
		Endif
		****************************************************************
		
		Set Filter To &lcFilter
		
		Locate For Recno() = lnRecno && checked
		If Not Found()
			Locate && checked
		Endif
		
		If Not tlNoSetProperties
			This.setProperties()
		Endif Not tlNoSetProperties
		
		Thisform.cntNoneFound.Refresh()
		
		
	ENDPROC

	PROCEDURE setfont
		Lparameters tnNewFontName, tnNewFontSize
		
		With This
			.SetAll("FontName", tnNewFontName, "Grid")
			.SetAll("FontName", tnNewFontName, "basetextbox")
			.SetAll("FontName", tnNewFontName, "baseeditbox")
		
			.SetAll("FontSize", tnNewFontSize, "Grid")
			.SetAll("FontSize", tnNewFontSize, "basetextbox")
			.SetAll("FontSize", tnNewFontSize, "baseeditbox")
		Endwith
		
	ENDPROC

	PROCEDURE setformalignment
		Lparameters tlFirstTime
		
		Local lnAnchor, lnAnchorControls, lnAnchorGrid, lnAnchorIcons, lnAnchorSplitter, lnGridIncr, lnWidth
		
		With This
			.MinWidth  = -1
			.MinHeight = -1
		Endwith
		
		If This.lDocTreeView
			With This.cntIcons
				.lSaveAnchor = .T.
				.Left		 = This.Width - .Width
				.lSaveAnchor = .F.
			Endwith
		
			Return
		Endif
		
		With This
		
			If Not tlFirstTime
				.RestorePositionInfo(This)
				.RestorePositionInfo(.cntGridControls, .T.)
				.RestorePositionInfo(.cntControls, .T.)
				.RestorePositionInfo(.cntIcons, .T.)
			Endif
		
			If .oPrefs.lGridAbove
		
				*** JRN 12/04/2008 : Move the three major controls, grid on top, then splitter, then cntControls
				.cntGridControls.lSaveAnchor	= .T.
				.oSplitterV.lSaveAnchor 		= .T.
				.cntControls.lSaveAnchor 		= .T.
				.cntIcons.lSaveAnchor 			= .T.
		
				lnWidth 			= Max (.cntGridControls.Width, .cntControls.Width)
				lnGridIncr			= lnWidth - .cntGridControls.Width
				.cntGridControls.Width	= lnWidth
				.cntGridControls.Height	= 250
				.oSplitterV.Top 	= .cntGridControls.Top + .cntGridControls.Height
				.oSplitterV.Width	= lnWidth
				.oSplitterV.nObject1MinSize = 250
				.oSplitterV.nObject2MinSize = .cntControls.Height
				.cntControls.Top 	= .oSplitterV.Top + .oSplitterV.Height
				.cntControls.Left	= .cntGridControls.Left
		
				.cntIcons.Left		= .cntGridControls.Width - .cntIcons.Width
		
				.Height 			= .cntControls.Top + .cntControls.Height
				.Width				= lnWidth + 12
		
				.cntGridControls.lSaveAnchor	= .F.
				.oSplitterV.lSaveAnchor 		= .F.
				.cntControls.lSaveAnchor 		= .F.
				.cntIcons.lSaveAnchor 			= .F.
		
			Else
		
				If Not tlFirstTime
					.oSplitterH.lSaveAnchor 	= .T.
					.oSplitterH.Left 	= .cntGridControls.Left + .cntGridControls.Width
					.oSplitterH.Height	= .cntGridControls.Height
					.oSplitterH.lSaveAnchor 	= .F.
				Endif
		
				*  .oSplitterH.nObject1MinSize = .cntGridControls.Width
				.oSplitterH.nObject2MinSize = .cntControls.Width
				If PEME_IsVersion9()
					.cntControls.Anchor = 13
				Endif
		
			Endif
		
			With .cntNoneFound
				.lSaveAnchor 	= .T.
				.Top 		= This.cntGridControls.Top + (This.cntGridControls.Height - .Height) / 2
				.Left 		= This.cntGridControls.Left + (This.cntGridControls.Width - .Width) / 2
				.lSaveAnchor 	= .F.
			Endwith
		
			.MinWidth  = .Width
			.MinHeight = .Height
		
			.Height = .Height && don't ask ...
			.oObjectTree.SaveHeightInfo()
		
		Endwith
		
	ENDPROC

	PROCEDURE setglobalfavorite
		Lparameters tcName
		Local llAddToFavorites, llInFavorites, lnSelect, lcMemberData, loNode
		
		llAddToFavorites = Inlist (Thisform.oMember.nFavorites, 3, 4)
		llInFavorites = Inlist (Thisform.oOriginalMember.nFavorites, 3, 4)
		If llAddToFavorites = llInFavorites
			Return
		Endif
		
		With This
			lnSelect = Select()
			Use (_Foxcode) Again Shared In 0 Alias Foxcode
		
			Select Foxcode
			Locate For Upper(abbrev)=Upper(tcName) And Type = 'E'
			If Found() And Not Empty (Tip)
				loNode = .oXML.LoadXML(Tip)
				loNode = .oXML.selectSingleNode('//memberdata[@name = "' + Lower(tcName) + '"]')
				If llAddToFavorites
					loNode.setAttribute('favorites', ccXML_TRUE)
				Else
					loNode.setAttribute('favorites', ccXML_FALSE)
				Endif
				lcMemberData = .oXML.XML
				Replace Tip With lcMemberData
		
			Else
				.oXML.Load('')
				loNode = .createMemberDataNode(tcName)
				If llAddToFavorites
					loNode.setAttribute('favorites', ccXML_TRUE)
				Else
					loNode.setAttribute('favorites', ccXML_FALSE)
				Endif
				lcMemberData = .oXML.XML
		
				Insert Into (_Foxcode);
					(Type, abbrev, Tip);
					VALUES;
					('E', Upper (tcName), lcMemberData)
			Endif
			Use In Foxcode
		
			Select (lnSelect)
		Endwith
		
		
	ENDPROC

	PROCEDURE setgridhighlighting
		*** JRN 11/04/2008 : Sets the various .DynamicFont??? based on user preferences
		
		Local lcBackColor, lcBackColorSuffix, lcBgColor, lcBold, lcCode, lcColor, lcCustomPRG, lcDynBackColor
		Local lcDynForeColor, lcFgColor, lcField, lcForeColor, lcForeColorSuffix, lcItalic, lcStrikeThru
		Local lcType, lnRow
		
		****************************************************************
		Store [] To lcBold, lcItalic, lcStrikeThru
		
		lcBgColor = Transform(Thisform.nHighlightBackColor)
		lcFgColor = Transform(Thisform.nHighlightForeColor)
		lcForeColor = 'IIF(!This.Enabled, Rgb(128, 128, 128), IIF(Recno() = This.nCurrentRecno and This.HighlightStyle # 2, ' + lcFgColor + ', ' && if disabled, all gray
		lcBackColor = 'IIF(!This.Enabled, Rgb(212, 208, 200), IIF(Recno() = This.nCurrentRecno and This.HighlightStyle # 2, ' + lcBgColor + ', ' && if disabled, all gray
		
		lcForeColorSuffix = Transform (Thisform.oGrid.ForeColor) + "))"
		lcBackColorSuffix = Transform (Thisform.oGrid.BackColor) + "))"
		
		*** JRN 12/12/2008 : Following odd construct allows control over order or rows
		Local laRowList(1), lcRowList, lnCounter
		If Thisform.nMethodview = 1 Or Thisform.nSelectedObjects > 1
			lcRowList = '1,2,3,4,5,6,7'
		Else
			lcRowList = '8,9,10,11,6,7'
		Endif
		
		Alines(laRowList, lcRowList, .T., ',')
		For lnCounter = 1 To Alen(laRowList)
		
			lnRow = Val(laRowList(lnCounter))
			lcType 	= Thisform.aGridHighlighting (lnRow,1)
			lcColor = Thisform.aGridHighlighting (lnRow,2)
		
			Do Case
				Case lnRow = 1
					lcField = "csrMembers.cType = 'P'"
				Case lnRow = 2
					lcField = "csrMembers.cType # 'P'"
				Case lnRow = 3
					lcField = "(Not csrMembers.lInherited)"
				Case lnRow = 4
					lcField = "(csrMembers.lInherited and not csrMembers.lNative)"
				Case lnRow = 5
					lcField = "csrMembers.lNative"
				Case lnRow = 6
					lcField = "csrMembers.lNonDefault"
				Case lnRow = 7
					lcField = "csrMembers.nFavorites # 1"
				Case lnRow = 8
					lcField = "csrMembers.lNonDefault"
				Case lnRow = 9
					lcField = "csrMembers.lHasCode and not csrMembers.lNonDefault"
				Case lnRow = 10
					lcField = "(not (csrMembers.lHasCode or csrMembers.lNonDefault) and not csrMembers.lNative)"
				Case lnRow = 11
					lcField = "(not (csrMembers.lHasCode or csrMembers.lNonDefault) and     csrMembers.lNative)"
				Otherwise
					lcField = ''
			Endcase
		
			*** JRN 11/20/2008 : Bold /Italics previously used AND .. should be OR
			Do Case
				Case lcType = 'ForeColor'
					lcForeColor = lcForeColor + "IIF(" + lcField + "," + Transform (lcColor) + ","
					lcForeColorSuffix = lcForeColorSuffix + ")"
				Case lcType = 'BackColor'
					lcBackColor = lcBackColor + "IIF(" + lcField + "," + Transform (lcColor) + ","
					lcBackColorSuffix = lcBackColorSuffix + ")"
				Case lcType = 'Bold'
					lcBold = Iif(Empty (lcBold), '', lcBold + " OR ") + lcField
				Case lcType = 'Italic'
					lcItalic = Iif(Empty (lcItalic), '', lcItalic + " OR ") + lcField
				Case lcType = 'StrikeThru'
					lcStrikeThru = Iif(Empty (lcStrikeThru), '', lcStrikeThru + " OR ") + lcField
		
			Endcase
		
		Next lnI
		
		With This.oGrid
			lcDynForeColor = Iif (Empty (lcForeColor) , [], lcForeColor + lcForeColorSuffix)
			.SetAll("DynamicForeColor", lcDynForeColor, "Column")
		
			lcDynBackColor = Iif (Empty (lcBackColor), [], lcBackColor + lcBackColorSuffix)
			.SetAll("DynamicBackColor", lcDynBackColor, "Column")
		
			.SetAll("DynamicFontBold", lcBold, "Column")
			.SetAll("DynamicFontItalic", lcItalic, "Column")
			.SetAll("DynamicFontStrikethru", lcStrikeThru, "Column")
		
			.ColValue.DynamicFontItalic = 'lReadOnly'
		
		Endwith
		
		*	lcCustomPRG =  Thisform.cApplicationPath + "SetGridHighlighting.PRG"
		lcCustomPRG =  This.oUtils.GetPlugInPath ("SetGridHighlighting")
		
		If Not Empty (lcCustomPRG)
			Try
				lcCode = Execscript(Filetostr(lcCustomPRG), This.oGrid, "ThisForm.oObject", Thisform.nMethodview)
			Catch To loException
				Thisform.ShowErrorMsg(loException, 'Set Grid Highlighting', lcCustomPRG)
			Endtry
		Endif
		
	ENDPROC

	PROCEDURE setmessageto
		Lparameters loObject
		Local lcName, lcVals
		
		lcName = This.GetObjectPath(loObject)
		lcVals = ''
		
		If This.GetPemstatus(loObject, 'Top', 5)
			lcVals = lcVals + 'Top:  ' + Transform(loObject.Top) + '   '
		Endif
		
		If This.GetPemstatus(loObject, 'Left', 5)
			lcVals = lcVals + 'Left:  ' + Transform(loObject.Left) + '   '
		Endif
		
		If This.GetPemstatus(loObject, 'Height', 5)
			lcVals = lcVals + 'Height:  ' + Transform(loObject.Height) + '   '
		Endif
		
		If This.GetPemstatus(loObject, 'Width', 5)
			lcVals = lcVals + 'Width:  ' + Transform(loObject.Width) + '   '
		Endif
		
		If This.GetPemstatus(loObject, 'Top', 5) And  This.GetPemstatus(loObject, 'Height', 5)
			lcVals = lcVals + 'Bottom:  ' + Transform(loObject.Top + loObject.Height) + '   '
		Endif
		
		If This.GetPemstatus(loObject, 'Left', 5) And This.GetPemstatus(loObject, 'Width', 5)
			lcVals = lcVals + 'Right:  ' + Transform(loObject.Left + loObject.Width) + '   '
		Endif
		
		Set Message To ('  ' + Thisform.Name + lcName + ':  ' + lcVals)
		
	ENDPROC

	PROCEDURE setproperties		&& Set the form properties for the item currently selected in the grid
		Lparameters lbRefreshGrid
		
		Local lcName
		
		* Flag whether this member has a default value/code or not.
		
		With This
			.FixNonDefaultFlags()
			.ScatterCursor()
			.cOriginalName  = Alltrim(csrMembers.cName)
			.nOriginalVisibility = csrMembers.nVisibility
			If lbRefreshGrid
				.oGrid.Refresh()
				.cntControls.Refresh()
			Else
				.RefreshForm()
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE Show
		* Restore the Dockable setting if we're not being invoked modally. We have to
		* do it here because the form becomes visible as soon as Dockable is set to 1,
		* so we don't want this done earlier.
		
		Lparameters tnStyle
		Local lcDockWindow, llDocked, lnDockPosition, lnLeft, lnMaxHeight, lnMaxLeft, lnMaxTop, lnMaxWidth
		Declare Integer GetSystemMetrics In user32 Integer nIndex
		
		Try
			With This
				lnLeft         = .Left
				If PEME_IsVersion9() And (Vartype(tnStyle) <> 'N' Or tnStyle <> 1)
					.Dockable      = Nvl(.oPersist.Get('Dockable'), 2)
					llDocked       = Nvl(.oPersist.Get('Docked'), .F.)
					lnDockPosition = Nvl(.oPersist.Get('DockPosition'), -1)
					If .Dockable = 1 And llDocked
						*** JRN 12/24/2008 : Tab docking
						lcDockWindow = Nvl(.oPersist.Get('DockWindow'), '')
						Do Case
							Case Not Empty(lcDockWindow)
								Try
									Dock Name Thisform position 4 Window &lcDockWindow
								Catch
		
								Endtry
							Case  Between(lnDockPosition, 0, 3)
								.Dock(lnDockPosition)
						Endcase
						*** JRN 12/24/2008
					Endif .Dockable = 1 ...
		
				Endif PEME_IsVersion9() And (Vartype(tnStyle) <> 'N' Or tnStyle <> 1)
		
				.Left = lnLeft
				.Top  = .nStartingTop
				.InsureFormVisible()
		
				DoDefault(tnStyle)
		
				If This.lPEMEditor
					If .oPrefs.lGridAbove
						If .nSplitterTop <> .oSplitterV.Top
							.oSplitterV.MoveSplitterToPosition(.nSplitterTop)
						Endif .nSplitterTop <> .oSplitterV.Top
					Else
						If .nSplitterLeft <> .oSplitterH.Top
							.oSplitterH.MoveSplitterToPosition(.nSplitterLeft)
						Endif .nSplitterLeft <> .oSplitterH.Top
					Endif
		
					If .nDescSplitterTop <> .cntControls.oSplitter.Top
						.cntControls.oSplitter.MoveSplitterToPosition(.nDescSplitterTop)
					Endif .nDescSplitterTop <> .cntControls.oSplitter.Top
				Endif
		
			Endwith
		Catch To loException
			Thisform.ShowErrorMsg(loException)
		Endtry
		
		If This.lPEMEditor
			If This.oPrefs.lGridAbove
				This.oSplitterV.Collapse( This.lCollapsed)
			Else
				This.oSplitterH.Collapse( This.lCollapsed)
			Endif
		Endif
		
	ENDPROC

	PROCEDURE showeditcontextmenu
		*!* * Removed 07/12/2011 
		*!* *!* ShowEditContextMenu()
		
		*!* *** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		*!* This.CreateContextMenu("EditContextMenu")
		
		*!* Define Bar _Med_undo Of EditContextMenu Prompt ccLOC_MENU_UNDO ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_undo) ;
		*!* 	PictRes _Med_undo
		
		*!* Define Bar _Med_cut Of EditContextMenu Prompt ccLOC_MENU_CUT ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_cut) ;
		*!* 	PictRes _Med_cut
		
		*!* Define Bar _Med_copy Of EditContextMenu Prompt ccLOC_MENU_COPY ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_copy) ;
		*!* 	PictRes _Med_copy
		
		*!* Define Bar _Med_paste Of EditContextMenu Prompt ccLOC_MENU_PASTE ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_paste) ;
		*!* 	PictRes _Med_paste
		
		*!* Define Bar _Med_clear Of EditContextMenu Prompt ccLOC_MENU_CLEAR ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_clear) ;
		*!* 	PictRes _Med_clear
		
		*!* Define Bar 6 Of EditContextMenu Prompt "\-"
		
		*!* Define Bar _Med_slcta Of EditContextMenu Prompt ccLOC_MENU_SELECT_ALL ;
		*!* 	Skip For Skpbar("_MEDIT", _Med_slcta) ;
		*!* 	PictRes _Med_slcta
		
		*!* Activate Popup EditContextMenu
		
		*!* Release Popups EditContextMenu
		
	ENDPROC

	PROCEDURE showerrormsg
		Lparameters loException, lcTitleBar, lcPRGName, lcAddlInfo
		
		Messagebox('Error: ' + Transform(loException.ErrorNo) 	+ ccCRLF + ;
			'Message: ' + loException.Message 					+ ccCRLF + ;
			'Procedure: ' + IIF(Empty (lcPRGName), loException.Procedure, JustFname (lcPRGName)) + ccCRLF + ;
			'Line: ' + Transform(loException.Lineno) 			+ ccCRLF + ;
			'Code: ' + loException.LineContents 						   ;
			+ IIF(Empty (lcAddlInfo), '', ccCRLF +'NOTES: ' + lcAddlInfo)  ;
			, MB_OK + MB_ICONEXCLAMATION, Evl(lcTitleBar, 'Error'))
		
	ENDPROC

	PROCEDURE sortgrid
		Lparameters lcMainSortField, lcAltSortField
		
		****************************************************************
		* Created 10/25/2008 by Jim Nelson
		* Invoked by click on header of any column
		* Updates .cMembersSortOrder with new sort criteria
		* First parameter is the "normal" sort order for the column being sorted on
		* Second is the alternate (if any) to cause reverse sorting if grid
		* is already sorted on the main column.
		
		Local lcSortField, lcMembersSortOrder, lcName
		
		lcName = csrMembers.cName
		
		With This
			If Thisform.nMethodView = 1
				lcMembersSortOrder = .cMembersSortOrder
			Else
				lcMembersSortOrder = .cMembersSortOrderMethodView
			Endif
		
			If Pcount() > 0
				If Pcount() = 2 And lcMembersSortOrder = "+" + lcMainSortField
					lcSortField = lcAltSortField
				Else
					lcSortField = lcMainSortField
				Endif
		
				lcMembersSortOrder = "+" + lcSortField + Strtran( lcMembersSortOrder, "+" + lcSortField, "")
		
				If Thisform.nMethodView = 1
					.cMembersSortOrder = lcMembersSortOrder
				Else
					.cMembersSortOrderMethodView = lcMembersSortOrder
				Endif
			Endif
		
			.SetFilter()
		
			Locate For cName = lcName
			If Not Found()
				Locate
			Endif
		
			.oGrid.SetFocus()
		
		Endwith
		
	ENDPROC

	PROCEDURE startdocumenttreeview
		This.oUtils.ShowForm(2)
		Doevents 
	ENDPROC

	PROCEDURE thiscontroldeletable
		Lparameters loControl
		
		Do Case
			Case loControl = Thisform.oTopOfForm
				Return .F.
			Case Upper(loControl.baseclass) = Upper('DataEnvironment')
				Return .F.
			Case Inlist(Lower (loControl.BaseClass), 'column', 'pageframe', 'optionbutton') and Thisform.oTopOfForm # loControl.Parent
				Return Not Thisform.GetPEMStatus (loControl.Parent, 'Name', 1)
			Case Lower (loControl.Parent.BaseClass) = 'column' and Thisform.oTopOfForm # loControl.Parent.Parent
				Return Not Thisform.GetPEMStatus (loControl.Parent.Parent, 'Name', 1)
			Otherwise
				Return Not Thisform.GetPEMStatus (loControl, 'Name', 1)
		Endcase
		
		
	ENDPROC

	PROCEDURE usememberdata
		Return This.oPrefs.lUseMemberData Or ("O" = Vartype(This.oTopOfForm) and Thisform.GetPEMStatus (This.oTopOfForm, "_MemberData", 5))
		
	ENDPROC

	PROCEDURE validatename		&& Validates a PEM name (that is, that the name could be the name of a PEM)
		Lparameters tcName
		
		Local laLines[1], lcChar, lcFirstChar, lcName, lcText, lnFirst, lnI, lnJ, lnNLines
		
		lcName = Alltrim (tcName)
		
		lnFirst = Min (								;
			Evl (At ('(', lcName), 1000)			;
			,Evl (At ('[', lcName), 1000)			;
			,Evl (At (',', lcName), 1000)			;
			,Evl (At (']', lcName), 1000)			;
			,Evl (At (')', lcName), 1000)			;
			)
		
		lcFirstChar  = Left (lcName, 1)
		
		Do Case
		
			Case Not (Isalpha(lcFirstChar) Or lcFirstChar = '_')
				Return ''
		
			Case lnFirst = 1
				Return ''
		
			Case lnFirst <= Len (lcName)
		
				lcChar = Substr (lcName , lnFirst, 1)
		
				* Match at end?
				If Right (lcName, 1) # Iif ( lcChar = '(', ')', Iif(lcChar = '[', ']', Chr(13)))
					Return ''
				Endif
		
				lnNLines = Alines (laLines, Substr(lcName, lnFirst + 1, Len(lcName) - lnFirst - 1), .T., ',')
				* check that each dimension is all numeric
				If Between (lnNLines,1,2)
					For lnI = 1 To lnNLines
						lcText = laLines(lnI)
						If Val(lcText) # 0
							For lnJ = 1 To Len (lcText)
								If Not Isdigit (Substr (lcText, lnJ, 1))
									Return ''
								Endif
							Endfor lnJ
						Else
							Return ''
						Endif
					Endfor lnI
				Else
					Return ''
				Endif
		
		Endcase
		
		Return lcName
		
	ENDPROC

	PROCEDURE writememberdata
		Lparameters loXML
		
		Local lcXML
		
		With This
			* Put the XML into _MemberData as long as it doesn't exceed the maximum length.
			lcXML = loXML.XML
			If Right (lcXML, 2) = ccCR + ccLF
				lcXML = Left (lcXML, Len (lcXML) - 2)
			Endif
		
			If Len(lcXML) >= cnMAX_MEMBER_DATA_SIZE
				Messagebox(ccLOC_STRING_TOO_LONG, MB_OK + MB_ICONEXCLAMATION, ;
					.Caption)
			Else
				If Not Thisform.getpemstatus(.oTopOfForm, '_MemberData', 5)
					.oTopOfForm.AddProperty('_MemberData', '')
				Endif
				.oTopOfForm._MemberData = lcXML
			Endif Len(lcXML) >= cnMAX_MEMBER_DATA_SIZE
		Endwith
		
	ENDPROC

	PROCEDURE zapmemberscursor
		Select csrMembers
		* Modified 10/28/2008 by Jim Nelson
		* Delete all tags and remove filter before zapping
		Delete Tag All
		Set Filter To
		Set Relation to
		Zap
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmprogress AS baseformnew OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="imgAnimation" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDescription" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: setdescription
		*p: lcancel
		*p: nseconds
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	AutoCenter = .F.
	Caption = "Progress"
	cfoxuserid = PROGRESS
	cfoxusername = PROGRESS
	ControlBox = .F.
	Desktop = .T.
	DoCreate = .T.
	Height = 58
	MaxButton = .F.
	MinButton = .F.
	Name = "frmprogress"
	nseconds = 0
	Width = 378
	changefontsize.Name = "changefontsize"

	ADD OBJECT 'imgAnimation' AS image WITH ;
		Height = 45, ;
		Left = 10, ;
		Name = "imgAnimation", ;
		Picture = ..\images\findcomp.gif, ;
		Top = 5, ;
		Width = 48
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblDescription' AS baselabel WITH ;
		Caption = "Description goes here (do not localize!)", ;
		Height = 16, ;
		Left = 80, ;
		Name = "lblDescription", ;
		Top = 20, ;
		Visible = .T., ;
		Width = 190
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />
	
	PROCEDURE Init
		LPARAMETERS cText
		
		DoDefault()
		
		THIS.BorderStyle = 2  && fixed dialog
		
		** We check to see if a description was passed
		IF VARTYPE(m.cText) == 'C'
			THIS.SetDescription(m.cText)
		ENDIF
		
		
	ENDPROC

	PROCEDURE setdescription
		LPARAMETERS cText
		
		IF VARTYPE(m.cText) == 'C'
			THIS.lblDescription.Caption = LEFT(m.cText, 255)
			THIS.lblDescription.Visible = .T.
		ELSE
			THIS.lblDescription.Caption = ''
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmsearchresults AS frmpeme_base OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdObjects" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Basecheckbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Basecommandbutton1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Basecombobox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addpem
		*m: addpems
		*m: creategridrows
		*m: dynvalue
		*m: getcurrentobject
		*m: handlenamedoubleclick
		*m: removecolumn
		*m: setlockcolumns
		*p: ceditpropertyname
		*p: cparentname
		*p: csearchcolumns
		*p: llockcolumns
		*p: opemeditor
		*a: arowsource[1,0]
		*a: aselectedobjectnames[1,0]
	*</DefinedPropArrayMethod>

	Caption = "Multiple Objects Detail"
	ceditpropertyname = 
	cfoxuserid = SEARCHRESULTS
	cfoxusername = SEARCHRESULTS
	cparentname = 
	csearchcolumns = 
	DataSession = 1
	Desktop = .T.
	DoCreate = .T.
	Height = 194
	leditingoneproperty = .T.
	llockcolumns = .F.
	Name = "frmsearchresults"
	opemeditor = .NULL.
	Visible = .T.
	Width = 480
	_memberdata = <VFPData>
		<memberdata name="getcurrentobject" display="GetCurrentObject"/>
		<memberdata name="aselectedobjectnames" display="aSelectedObjectNames"/>
		</VFPData>
	changefontsize.Left = 32
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 71

	ADD OBJECT 'Basecheckbox1' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Lock Columns", ;
		ControlSource = "Thisform.oMySettings.lLockColumns", ;
		Left = 251, ;
		Name = "Basecheckbox1", ;
		nanchor = 0, ;
		ToolTipText = "Keeps the object name column fixed.  However, must be turned off in order to move columns.", ;
		Top = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Basecombobox1' AS basecombobox WITH ;
		DisplayCount = 25, ;
		Height = 22, ;
		Left = 94, ;
		Name = "Basecombobox1", ;
		RowSource = "Thisform.aRowSource", ;
		RowSourceType = 0, ;
		Top = 5, ;
		Width = 96
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'Basecommandbutton1' AS basecommandbutton WITH ;
		Caption = "Save Column Settings", ;
		Height = 25, ;
		Left = 347, ;
		Name = "Basecommandbutton1", ;
		nanchor = 0, ;
		ToolTipText = "Saves the current column settings (names, order, and widths) as the default.", ;
		Top = 4, ;
		Width = 121
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		AutoSize = .F., ;
		Caption = "PEM to add:", ;
		Height = 16, ;
		Left = 33, ;
		Name = "Baselabel1", ;
		Top = 9, ;
		Width = 58
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'grdObjects' AS gridobjects WITH ;
		AllowCellSelection = .T., ;
		GridLines = 3, ;
		Height = 157, ;
		HighlightStyle = 2, ;
		Left = 3, ;
		Name = "grdObjects", ;
		nanchor = 15, ;
		RecordSource = "crsr_SearchResults", ;
		Top = 35, ;
		Width = 474, ;
		ColName.ControlSource = "", ;
		ColName.Header1.FontBold = .T., ;
		ColName.Header1.Name = "Header1", ;
		ColName.Name = "ColName", ;
		ColName.Text1.Name = "Text1", ;
		ColTypeIcon.ControlSource = "", ;
		ColTypeIcon.Header1.Name = "Header1", ;
		ColTypeIcon.imgHolder.Name = "imgHolder", ;
		ColTypeIcon.Name = "ColTypeIcon", ;
		ColTypeIcon.Width = 17
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="grid" />

	ADD OBJECT 'imgFind' AS basecommandbutton WITH ;
		Caption = "", ;
		Height = 19, ;
		Left = 210, ;
		Name = "imgFind", ;
		nanchor = 0, ;
		Picture = ..\images\find.bmp, ;
		PicturePosition = 13, ;
		SpecialEffect = 2, ;
		Top = 7, ;
		Width = 21
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />
	
	PROCEDURE addpem
		Lparameters tcPEM
		
		Local lcPEM, llFound, lnCol, lnNextCol, lnPos, lnWidth
		
		If '=' $ tcPEM
			lnPos	= At ('=', tcPEM)
			lcPEM	= Alltrim (Left (tcPEM, lnPos - 1))
			lnWidth	= Val (Substr (tcPEM, lnPos + 1))
		Else
			lcPEM	= Alltrim (tcPEM)
			lnWidth	= 0
		Endif
		
		If Empty (lcPEM)
			Return
		Endif
		
		llFound = .F.
		With This.grdObjects
			For lnCol = 1 To .ColumnCount
				If .Columns (lnCol).lFixedColumn or not .Columns (lnCol).Visible
					Loop
				Endif
		
				If Lower (.Columns (lnCol).cPEMName) = Lower (lcPEM)
					llFound = .T.
				Endif
			Endfor
		Endwith
		
		If llFound
			Return
		Endif
		
		With This.grdObjects
			lnNextCol = 1 + .ColumnCount
			.AddColumn (lnNextCol)
			.Columns (lnNextCol).SetPEM (lcPEM, lnWidth)
		Endwith
		
	ENDPROC

	PROCEDURE addpems
		Lparameters lcSearchColumns
		
		Local laSearchColumns[1], tcPEM
		
		Alines (laSearchColumns, lcSearchColumns, .T., ',')
		For Each tcPEM In laSearchColumns
			This.AddPEM (tcPEM)
		Endfor
		
	ENDPROC

	PROCEDURE assignselectedcontrols
		Lparameters lcPem, luNewValue
		
		Local loObject
		loObject = Thisform.GetCurrentObject (Thisform.nobjnumber)
		
		This.Update1Property (loObject, lcPem, luNewValue)
		
		Return
		
		
	ENDPROC

	PROCEDURE creategridrows
		Lparameters llSort
		
		Select crsr_SearchResults
		Set Order to NumOrder
		Replace all nObjNumber with 0
		
		Local lcObjName, lcParent, lnI, lnPos
		For lnI = 1 To Alen (This.aSelectedObjectNames)
			lcObjName = This.aSelectedObjectNames (lnI)
			Insert Into crsr_SearchResults		;
				(nObjNumber, cObjName)			;
				Values							;
				(lnI, lcObjName)
		
			If lnI = 1
				lcParent = Juststem (lcObjName)
			Else
				Do While lcObjName # lcParent
					lnPos	 = Rat ('.', lcParent)
					lcParent = Left (lcParent, lnPos - 1)
				Enddo
			Endif
		Endfor
		
		Replace All cObjName With Substr (cObjName, 2 + Len (lcParent))
		If llSort
			Set Order to CharOrder
		Endif
		
		Goto Top
		
		If Empty (lcParent)
			lcParent = IIf (This.lClass, '(Class)', '(Form)')
		Endif
		
		This.cParentName						= lcParent
		This.nSelectedObjects					= Alen (This.aSelectedObjectNames)
		This.grdObjects.ColName.Header1.Caption	= lcParent
		
	ENDPROC

	PROCEDURE Destroy
		Local lnI
		With This
		
			.oTopOfForm		  = .Null.
			.oPrefs           = .Null.
			.oPEMEditor		  = .Null.
			.oUtils.oSearchResults 	= .Null.
			.oUtils  		  = .Null.
			
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE dynvalue
		Lparameters lcColumnName
		
		Return This.grdObjects.DynValue (This.grdObjects.&lcColumnName)
		
		
	ENDPROC

	PROCEDURE getcurrentobject
		Lparameters tnObjNumber
		
		Local lcObject, loTopOfForm
		If Between (tnObjNumber, 1, Alen (Thisform.aSelectedObjectNames))
		
			lcObject = Thisform.aSelectedObjectNames (tnObjNumber)
		
			loTopOfForm = Thisform.oUtils.FindTopMostParent()
			If 'O' = Type ('loTopofForm' + lcObject)
				Return Evaluate ('loTopofForm' + lcObject)
			Else
				Return .Null.
			Endif
		
		Endif
		
	ENDPROC

	PROCEDURE getvalue
		Lparameters lcName, tbNative, tcResultType, tnObjNumber
		
		Local loResult As 'Empty'
		Local lbTransform, lcPem, lcTypes, lcValue, lnBlue, lnGreen, lnRed, loObject, lxValue
		
		lcPem		= Thisform.JustPEM (lcName)
		lbTransform	= .T.
		
		Thisform.nObjNumber = tnObjNumber
		loObject = Thisform.GetCurrentObject (tnObjNumber)
		
		lcPem	 = Thisform.cEditPropertyName
		lcValue	 = loObject.ReadExpression (lcPem)
		lxValue	 = This.Get1Value (loObject, lcPem)
		lcTypes	 = Vartype (lxValue)
		
		If lbTransform And Empty (lcValue)
			Do Case
					* handle null values
				Case Isnull (lxValue)
					lcValue = '.NULL.'
					* Special handling for native colors
				Case 'N' = Vartype (lxValue) And Thisform.IsNativeColor (lcPem, tbNative)
					lnRed	= Bitand (lxValue, 255)
					lnGreen	= Bitrshift (Bitand (lxValue, 256 * 255), 8)
					lnBlue	= Bitrshift (Bitand (lxValue, 256 * 256 * 255), 16)
					lcValue	= Transform (lnRed) + ',' + Transform (lnGreen) + ',' + Transform (lnBlue)
				Case 'C' = Vartype (lxValue) And 0 = Len (lxValue) And tcResultType = 'Display'
					lcValue = '(None)'
				Case 'D' # Vartype (lxValue)
					lcValue = Transform ( lxValue )
				Case Empty (lxValue)
					lcValue = '{}'
				Otherwise
					lcValue = '{^' + Transform (Year (lxValue)) + '/' + Transform (Month (lxValue)) + '/' + Transform (Day (lxValue)) + '}'
			Endcase
		Endif
		
		Do Case
			Case tcResultType = 'Display'
				Return Left (lcValue, 100)
			Case tcResultType = 'Full Value'
				Return lcValue
			Case tcResultType = 'For Editing'
				loResult = Createobject ('Empty')
				AddProperty (loResult, 'Value', lxValue)
				AddProperty (loResult, 'CharValue', lcValue)
				AddProperty (loResult, 'Type', lcTypes)
				AddProperty (loResult, 'SingleValue', lbTransform)
				Return loResult
		Endcase
		
	ENDPROC

	PROCEDURE handlenamedoubleclick
		Local lnIndex, loControl, loObject, loTopOfForm
		
		loObject = Thisform.GetCurrentObject (nObjNumber)
		
		If 'O' = Vartype (loObject)
			This.Hide()
			This.oUtils.FocusOnControl(loObject)
			If 'O' = Vartype(This.oPEMEditor)
				This.oPEMEditor.SetCurrentSelectedObject (loObject)
			EndIf 
			This.Show()
		Endif
		
	ENDPROC

	PROCEDURE Init
		Lparameters loUtils
		
		Local laSearchColumns[1], tcPEM, lcFontName, lcStyle
		
		With This
			.oUtils = loUtils
			DoDefault()
		
			* Restore the saved font?
			.RestoreFont(.grdObjects)
		
			.AddPEMs (ThisForm.oMySettings.cSearchColumns)
			
			.grdObjects.ColTypeIcon.Header1.Caption = ''
			.grdObjects.ColName.Header1.FontBold = .T.
			.grdObjects.ColName.Width = ThisForm.oMySettings.nNameWidth
			
			.SetLockColumns()
				
		Endwith
		
	ENDPROC

	PROCEDURE Load
		DoDefault()
		
		If Used('crsr_SearchResults')
			Use In crsr_SearchResults
		Endif
		
		Create Cursor crsr_SearchResults (;
			nObjNumber 		N(4)	,;
			cObjName 		C(250)  ,;
			cDescript		C(250)	,;
			cName			C(128)   ,;
			cScript         C(1)    ,;
			cType			C(1)    ,;
			lNative			L		 ;
			)
		
		Index On Upper (Left (cObjName, 128)) Tag CharOrder For nObjNumber > 0
		Index On nObjNumber Tag NumOrder For nObjNumber > 0
		
	ENDPROC

	PROCEDURE removecolumn
		Lparameters loColumn
		loColumn.Visible = .F.
		
	ENDPROC

	PROCEDURE savecolumninfo
		Lparameters loGrid
		
		Local laColumns[1], lcNew, lcSearchColumns, lnColumnCount, lnI, loColumn
		With loGrid
			lnColumnCount = 0
			For lnI = 1 To .ColumnCount
				loColumn = .Columns (lnI)
				If loColumn.Visible And Not loColumn.lFixedColumn
					lnColumnCount = lnColumnCount + 1
					Dimension laColumns (lnColumnCount, 4)
					With loColumn
						laColumns (lnColumnCount, 1) = .ColumnOrder
						laColumns (lnColumnCount, 2) = .cPEMName
						laColumns (lnColumnCount, 3) = .Width
					Endwith
				Endif
			Endfor
		Endwith
		
		lcSearchColumns = ''
		If lnColumnCount > 0
			Asort (laColumns, 1, -1, 0, 0)
			For lnI = 1 To lnColumnCount
				lcNew			= Trim (laColumns (lnI, 2)) + '=' + Transform (laColumns (lnI, 3))
				lcSearchColumns	= lcSearchColumns + IIf (lnI = 1, '', ', ') + lcNew
			Endfor
		Endif
		
		With ThisForm.oMySettings
			.cSearchColumns	= lcSearchColumns
			.nNameWidth		= loGrid.ColName.Width
		EndWith 
		
		
	ENDPROC

	PROCEDURE setdefaults
		Local loCombo AS Object
		Local lcStyle
		
		.cSearchColumns	= 'Caption=150, ControlSource=150, Enabled=60, Visible=60, Init'
		.nNameWidth		=  120
		.lLockColumns	= .T.
		
		loCombo = This.grdObjects 
		lcStyle = IIf(loCombo.FontBold, 'B', '') + IIf(loCombo.FontItalic, 'I', '')
		
		.cFontName = loCombo.FontName
		.nFontSize = loCombo.FontSize
		.cFontStyle = lcStyle
		
	ENDPROC

	PROCEDURE setlockcolumns
		Do Case
			Case Not PEME_IsVersion9()
		
			Case ThisForm.oMySettings.lLockColumns
				This.grdObjects.LockColumns = 2
			Otherwise
				This.grdObjects.LockColumns = 0
		Endcase
	ENDPROC

	PROCEDURE update1property
		Lparameters toObject, tcPem, tuVal
		Local loException, lcExpression
		
		*** JRN 12/21/2008 : for some native properties, not all values entered are valid
		* See also editpropertydialog.ApplyChanges
		If Not This.GetPEMStatus (toObject, tcPem, 5)
			Return
		Endif
		
		Try && for some native properties, not all values entered are valid
			Do Case
				Case Vartype(tuVal) = 'C' And tuVal = ['] And Not ['] $ Substr(tuVal,2)
					toObject.WriteExpression (tcPem, [='] + Substr(tuVal,2) + [']) 
				Case Vartype(tuVal) = 'C' And tuVal = '='
					toObject.WriteExpression (tcPem, tuVal)
				Otherwise
					If Not Empty(toObject.ReadExpression (tcPem))
						toObject.WriteExpression (tcPem, '') && clear out all expression, if any.
					Endif
					*** JRN 12/23/2008 : assignment rather than AddProperty, since that fails on OLEs
					With toObject
						lcExpression = "." + tcPem + " = tuVal"
						&lcExpression && note that macro expansion works here
					Endwith
			Endcase
		
		Catch To loException
			Messagebox(ccLOC_AddProperty_Failed + ccCRLF + ;
				'Message: ' + loException.Message + ccCRLF,  ;
				MB_OK + MB_ICONEXCLAMATION, 'Set Property!! Failure')
		Endtry
		
	ENDPROC

	PROCEDURE Basecheckbox1.Refresh
		This.Visible = PEME_IsVersion9()
	ENDPROC

	PROCEDURE Basecheckbox1.Valid
		DoDefault()
		Thisform.SetLockColumns()
	ENDPROC

	PROCEDURE Basecombobox1.Click
		DoDefault()
		Thisform.addpem(This.Value)
		This.DisplayValue = ''
		
	ENDPROC

	PROCEDURE Basecombobox1.Refresh
		Local loPEMList AS Object
		Local loTopOfForm AS Object
		Local lnI
		
		If 0 = This.RowSourceType
		
			loTopOfForm = Thisform.oUtils.FindTopMostParent()
		
			Do Case
				Case 'O' # Vartype(loTopOfForm)
					* nothing to do
		
				Case 'O' = Vartype(Thisform.oUtils.oPEMEditor)
					loPEMList = Thisform.oUtils.oPEMEditor.GetPEMList()
					Acopy(loPEMList.PEMList, Thisform.aRowSource)
					For lnI = 1 To Alen(Thisform.aRowSource)
						Thisform.aRowSource(lnI) = Alltrim(Thisform.aRowSource(lnI))
					Endfor
					This.RowSourceType = 5
		
				Case 'O' = Type('loTopOfForm' + Thisform.aSelectedObjectNames(1))
					Amembers(Thisform.aRowSource, Evaluate('loTopOfForm' + Thisform.aSelectedObjectNames(1)))
					This.RowSourceType = 5
		
			Endcase
		
		Endif
		
	ENDPROC

	PROCEDURE Basecommandbutton1.Click
		Thisform.SaveColumnInfo (Thisform.grdObjects )
		Messagebox ('Saved', 64)
	ENDPROC

	PROCEDURE imgFind.Click
		Thisform.oUtils.Find()
		
	ENDPROC

	PROCEDURE imgFind.Init
		With This
			.ToolTipText = ccLOC_CAP_Find
		EndWith 
		
		DoDefault()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridcompareclass AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ColName.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColName.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.imgHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColValue.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColValue.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColSelect.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColSelect.Basecheckbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColSelect.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCurValue.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCurValue.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColSame.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColSame.Text1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: getvalue
		*m: headerrightclick
		*m: setbmp
		*m: setcolumnheadings
		*p: lfirsttime
		*p: nanchor
		*p: ncurrentrecno
	*</DefinedPropArrayMethod>

	ColumnCount = 6
	DeleteMark = .F.
	FontSize = 8
	GridLines = 0
	Height = 276
	HighlightRow = .F.
	lfirsttime = .T.
	Name = "gridcompareclass"
	nanchor = 15
	ncurrentrecno = 0
	Panel = 1
	RecordMark = .F.
	RecordSource = "csrCompareClass"
	RecordSourceType = 1
	RowHeight = 17
	SplitBar = .F.
	TabIndex = 1
	Width = 535
	ZOrderSet = 0
	Column1.ColumnOrder = 4
	Column1.ControlSource = "csrCompareClass.cName"
	Column1.FontSize = 8
	Column1.Name = "ColName"
	Column1.ReadOnly = .T.
	Column1.Width = 120
	Column2.ColumnOrder = 3
	Column2.ControlSource = ""
	Column2.CurrentControl = "imgHolder"
	Column2.DynamicFontShadow = "This.SetBMP()"
	Column2.FontSize = 8
	Column2.Name = "ColTypeIcon"
	Column2.ReadOnly = .T.
	Column2.Sparse = .F.
	Column2.Width = 16
	Column3.ColumnOrder = 5
	Column3.ControlSource = "csrCompareClass.cValueCol"
	Column3.CurrentControl = "Text1"
	Column3.FontSize = 8
	Column3.Name = "ColValue"
	Column3.ReadOnly = .T.
	Column3.Width = 150
	Column4.Alignment = 2
	Column4.ColumnOrder = 1
	Column4.ControlSource = "csrCompareClass.lSelect"
	Column4.FontSize = 8
	Column4.Name = "ColSelect"
	Column4.Sparse = .F.
	Column4.Width = 30
	Column5.ColumnOrder = 6
	Column5.ControlSource = "csrCompareClass.cInheritValueCol"
	Column5.FontSize = 8
	Column5.Name = "ColCurValue"
	Column5.ReadOnly = .T.
	Column5.Width = 150
	Column6.Alignment = 2
	Column6.ColumnOrder = 2
	Column6.ControlSource = "IIF(csrCompareClass.lIdentical, 'Y', '')"
	Column6.FontSize = 8
	Column6.Name = "ColSame"
	Column6.Width = 35

	ADD OBJECT 'ColCurValue.Header1' AS header WITH ;
		Caption = "Value in Parent Class", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColCurValue.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColName.Header1' AS header WITH ;
		Caption = "Name", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColName.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColSame.Header1' AS header WITH ;
		Caption = "Same?", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColSame.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColSelect.Basecheckbox1' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		Centered = .T., ;
		FontSize = 8, ;
		Left = 23, ;
		lupdatecontrolsourceonchange = .T., ;
		Name = "Basecheckbox1", ;
		Top = 55
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'ColSelect.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColSelect.Label1' AS label WITH ;
		Caption = "", ;
		Height = 17, ;
		Left = 19, ;
		Name = "Label1", ;
		Top = 44, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'ColTypeIcon.Header1' AS header WITH ;
		Caption = " ", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColTypeIcon.imgHolder' AS image WITH ;
		Height = 16, ;
		Left = 57, ;
		Name = "imgHolder", ;
		Picture = ..\images\propty.bmp, ;
		Top = 83, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'ColValue.Header1' AS header WITH ;
		Caption = "Value", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColValue.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T., ;
		Value = 'abcv'
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE getvalue
		Lparameters lnRow
		
		lcType = Thisform.oServer.aCopiedProperties (lnRow, ccPasteTypeCol)
		lcValue = Thisform.oServer.aCopiedProperties (lnRow, ccPasteValueCol)
		
		Do Case
			Case lcType = 'M'
				Return '[User Procedure]'
			Case lcType = 'X'
				Return ''
			Case 'C' = Vartype (lcValue) And Empty (lcValue)
				Return '(None)'
			Otherwise
				Return Left(Transform(lcValue), 100)
		Endcase
		
	ENDPROC

	PROCEDURE headerrightclick
	ENDPROC

	PROCEDURE Init
		With This
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE setbmp
		Local  ;
			loControl As Object
		Local lcBMPName, lcFile, lcPath
		
		Do Case
			Case Thisform.lEditingOneProperty
				If Between (nObjNumber, 1, Alen (Thisform.aSelectedObjects))
					loControl = Thisform.aSelectedObjects(nObjNumber)
					If 'O' = Vartype (loControl)
						lcBMPName = Lower(loControl.BaseClass)
					Endif
				Endif
			Case cType = 'P'
				lcBMPName = Iif (nVisibility = 1, 'Propty', Iif(nVisibility = 2, 'PropProt', 'PropHidden'))
			Case cType = 'M'
				lcBMPName = Iif (nVisibility = 1, 'Method', Iif(nVisibility = 2, 'MethodProt', 'MethodHidden'))
			Otherwise
				lcBMPName = 'Event'
		Endcase
		
		lcPath = ThisForm.cApplicationPath + "images\"
		lcFile = lcPath + Evl (lcBMPName, '') + ".bmp"
		If Not File(lcFile)
			lcFile = ''
		Endif
		
		This.colTypeIcon.imgHolder.Picture = lcFile
		
		Return .F.
		
	ENDPROC

	PROCEDURE setcolumnheadings
	ENDPROC

	PROCEDURE ColName.Header1.Click
		thisform.SortGrid( [CName], [Upper(CName)])
	ENDPROC

	PROCEDURE ColName.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_NameTip
		
	ENDPROC

	PROCEDURE ColName.Header1.RightClick
		This.Parent.Parent.HeaderRightClick ( [CName], [Upper(CName)], ccLOC_GCH_Name,.T.)
		
	ENDPROC

	PROCEDURE ColSame.Header1.Click
		Thisform.SortGrid( [IIF(lIdentical, 'A', 'B')], [IIF(lIdentical, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColSelect.Basecheckbox1.anychange
		This.Parent.Parent.Refresh()
	ENDPROC

	PROCEDURE ColSelect.Header1.Click
		Thisform.SortGrid( [IIF(lSelect, 'A', 'B')], [IIF(lSelect, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColTypeIcon.Header1.Click
		thisform.SortGrid( [IIF(CType # 'P', 'A', 'B')], [IIF(CType = 'P', 'A', 'B')])
		
	ENDPROC

	PROCEDURE ColTypeIcon.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [IIF(CType # 'P', 'A', 'B')], [IIF(CType = 'P', 'A', 'B')])
		
	ENDPROC

	PROCEDURE ColValue.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_ValueTip
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridcompareproperties AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ColName.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColName.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.imgHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColValue.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColValue.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCurValue.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCurValue.Text1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: getvalue
		*m: headerrightclick
		*m: setbmp
		*m: setcolumnheadings
		*p: lfirsttime
		*p: nanchor
		*p: ncurrentrecno
	*</DefinedPropArrayMethod>

	ColumnCount = 4
	DeleteMark = .F.
	FontSize = 8
	GridLines = 0
	Height = 276
	HighlightRow = .F.
	lfirsttime = .T.
	Name = "gridcompareproperties"
	nanchor = 15
	ncurrentrecno = 0
	Panel = 1
	ReadOnly = .T.
	RecordMark = .F.
	RecordSource = "csrCompareObject"
	RecordSourceType = 1
	RowHeight = 17
	SplitBar = .F.
	TabIndex = 1
	Width = 535
	ZOrderSet = 0
	Column1.ColumnOrder = 2
	Column1.ControlSource = "cName"
	Column1.FontSize = 8
	Column1.Name = "ColName"
	Column1.ReadOnly = .T.
	Column1.Width = 120
	Column2.ColumnOrder = 1
	Column2.ControlSource = ""
	Column2.CurrentControl = "imgHolder"
	Column2.DynamicFontShadow = "This.SetBMP()"
	Column2.FontSize = 8
	Column2.Name = "ColTypeIcon"
	Column2.ReadOnly = .T.
	Column2.Sparse = .F.
	Column2.Width = 16
	Column3.ColumnOrder = 3
	Column3.ControlSource = "DisplayA"
	Column3.CurrentControl = "Text1"
	Column3.FontSize = 8
	Column3.Name = "ColValue"
	Column3.ReadOnly = .T.
	Column3.Width = 150
	Column4.ColumnOrder = 4
	Column4.ControlSource = "DisplayB"
	Column4.FontSize = 8
	Column4.Name = "ColCurValue"
	Column4.ReadOnly = .T.
	Column4.Width = 150

	ADD OBJECT 'ColCurValue.Header1' AS header WITH ;
		Caption = "Value in Parent Class", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColCurValue.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColName.Header1' AS header WITH ;
		Caption = "Name", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColName.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColTypeIcon.Header1' AS header WITH ;
		Caption = " ", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColTypeIcon.imgHolder' AS image WITH ;
		Height = 16, ;
		Left = 57, ;
		Name = "imgHolder", ;
		Picture = ..\images\propty.bmp, ;
		Top = 83, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'ColValue.Header1' AS header WITH ;
		Caption = "Value", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColValue.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T., ;
		Value = 'abcv'
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE getvalue
		Lparameters lnRow
		
		lcType = Thisform.oServer.aCopiedProperties (lnRow, ccPasteTypeCol)
		lcValue = Thisform.oServer.aCopiedProperties (lnRow, ccPasteValueCol)
		
		Do Case
			Case lcType = 'M'
				Return '[User Procedure]'
			Case lcType = 'X'
				Return ''
			Case 'C' = Vartype (lcValue) And Empty (lcValue)
				Return '(None)'
			Otherwise
				Return Left(Transform(lcValue), 100)
		Endcase
		
	ENDPROC

	PROCEDURE headerrightclick
	ENDPROC

	PROCEDURE Init
		With This
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE setbmp
		Local  ;
			loControl As Object
		Local loControl AS Object
		Local lcBMPName, lcFile, lcPath, lcType, lnVisibility
		
		lcType = Evl (VarTypeA, VarTypeB)
		lnVisibility = 1
		
		Do Case
			Case Thisform.lEditingOneProperty
				If Between (nObjNumber, 1, Alen (Thisform.aSelectedObjects))
					loControl = Thisform.aSelectedObjects(nObjNumber)
					If 'O' = Vartype (loControl)
						lcBMPName = Lower(loControl.BaseClass)
					Endif
				Endif
			Case lcType = 'P'
				lcBMPName = Iif (lnVisibility = 1, 'Propty', Iif(lnVisibility = 2, 'PropProt', 'PropHidden'))
			Case lcType = 'M'
				lcBMPName = Iif (lnVisibility = 1, 'Method', Iif(lnVisibility = 2, 'MethodProt', 'MethodHidden'))
			Otherwise
				lcBMPName = 'Event'
		Endcase
		
		lcPath = ThisForm.cApplicationPath + "images\"
		lcFile = lcPath + Evl (lcBMPName, '') + ".bmp"
		If Not File(lcFile)
			lcFile = ''
		Endif
		
		This.colTypeIcon.imgHolder.Picture = lcFile
		
		Return .F.
		
	ENDPROC

	PROCEDURE setcolumnheadings
	ENDPROC

	PROCEDURE ColName.Header1.Click
		thisform.SortGrid( [CName], [Upper(CName)])
	ENDPROC

	PROCEDURE ColName.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_NameTip
		
	ENDPROC

	PROCEDURE ColName.Header1.RightClick
		This.Parent.Parent.HeaderRightClick ( [CName], [Upper(CName)], ccLOC_GCH_Name,.T.)
		
	ENDPROC

	PROCEDURE ColTypeIcon.Header1.Click
		thisform.SortGrid( [IIF(CType # 'P', 'A', 'B')], [IIF(CType = 'P', 'A', 'B')])
		
	ENDPROC

	PROCEDURE ColTypeIcon.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [IIF(CType # 'P', 'A', 'B')], [IIF(CType = 'P', 'A', 'B')])
		
	ENDPROC

	PROCEDURE ColValue.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_ValueTip
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridcontrols AS basecontainer OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="chkAllControls" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblControlCount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkMethodView" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oObjectTree" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gridMembers" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCSO" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgParent" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFavoritesFound" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDocumentView" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFoundForAll" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: expandsubnodes
		*m: saveparentclasses
		*p: ltreeviewcurrent
	*</DefinedPropArrayMethod>

	Height = 260
	ltreeviewcurrent = .F.
	Name = "gridcontrols"
	nanchor = 15
	Width = 320

	ADD OBJECT 'chkAllControls' AS editpropertycheckbox WITH ;
		Alignment = 0, ;
		Caption = "Show All controls", ;
		ControlSource = "Thisform.lTreeViewAllControls", ;
		Left = 90, ;
		Name = "chkAllControls", ;
		TabIndex = 2, ;
		Top = 7, ;
		Visible = .F., ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkCSO' AS editpropertycheckbox WITH ;
		Alignment = 0, ;
		AutoSize = .F., ;
		Caption = "Current Control", ;
		ControlSource = "Thisform.lUseCSO", ;
		Height = 16, ;
		Left = 0, ;
		Name = "chkCSO", ;
		TabIndex = 1, ;
		Top = 7, ;
		Visible = .F., ;
		Width = 100, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkDocumentView' AS editpropertycheckbox WITH ;
		Alignment = 0, ;
		Caption = "Show Methods", ;
		ControlSource = "Thisform.lTreeViewShowMethods", ;
		Left = 12, ;
		Name = "chkDocumentView", ;
		TabIndex = 5, ;
		Top = 7, ;
		Visible = .F., ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkFoundForAll' AS editpropertycheckbox WITH ;
		Alignment = 0, ;
		Caption = "Only properties found for ALL controls", ;
		ControlSource = "Thisform.lFoundForAll", ;
		Left = 104, ;
		Name = "chkFoundForAll", ;
		TabIndex = 4, ;
		Top = 33, ;
		Visible = .F., ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkMethodView' AS editpropertycheckbox WITH ;
		Alignment = 0, ;
		Caption = "Method View", ;
		Left = 104, ;
		Name = "chkMethodView", ;
		TabIndex = 3, ;
		Top = 7, ;
		Visible = .F., ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="checkbox" />

	ADD OBJECT 'gridMembers' AS gridmembers WITH ;
		Height = 203, ;
		Left = 0, ;
		Name = "gridMembers", ;
		TabIndex = 9, ;
		Top = 57, ;
		Width = 320, ;
		ZOrderSet = 5, ;
		ColName.Header1.Name = "Header1", ;
		ColName.Name = "ColName", ;
		ColName.Text1.Name = "Text1", ;
		ColType.Header1.Name = "Header1", ;
		ColType.Name = "ColType", ;
		ColType.Text1.Name = "Text1", ;
		ColAccess.Header1.Name = "Header1", ;
		ColAccess.Name = "ColAccess", ;
		ColAccess.Text1.Name = "Text1", ;
		ColAssign.Header1.Name = "Header1", ;
		ColAssign.Name = "ColAssign", ;
		ColAssign.Text1.Name = "Text1", ;
		ColVisibility.Header1.Name = "Header1", ;
		ColVisibility.Name = "ColVisibility", ;
		ColVisibility.Text1.Name = "Text1", ;
		ColHierarchy.Header1.Name = "Header1", ;
		ColHierarchy.Name = "ColHierarchy", ;
		ColHierarchy.Text1.Name = "Text1", ;
		ColFavorite.Header1.Name = "Header1", ;
		ColFavorite.Name = "ColFavorite", ;
		ColFavorite.Text1.Name = "Text1", ;
		ColNonDefault.Header1.Name = "Header1", ;
		ColNonDefault.Name = "ColNonDefault", ;
		ColNonDefault.Text1.Name = "Text1", ;
		ColTypeIcon.Header1.Name = "Header1", ;
		ColTypeIcon.imgHolder.Height = 16, ;
		ColTypeIcon.imgHolder.Name = "imgHolder", ;
		ColTypeIcon.imgHolder.Width = 16, ;
		ColTypeIcon.Name = "ColTypeIcon", ;
		ColValue.Header1.Name = "Header1", ;
		ColValue.Name = "ColValue", ;
		ColValue.Text1.Name = "Text1", ;
		ColCode.Header1.Name = "Header1", ;
		ColCode.Name = "ColCode", ;
		ColCode.Text1.Name = "Text1", ;
		ColMethodName.Header1.Name = "Header1", ;
		ColMethodName.Name = "ColMethodName", ;
		ColMethodName.Text1.Name = "Text1", ;
		ColMultValue.Header1.Name = "Header1", ;
		ColMultValue.Name = "ColMultValue", ;
		ColMultValue.Text1.Name = "Text1"
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="grid" />

	ADD OBJECT 'imgParent' AS baseimage WITH ;
		BackStyle = 0, ;
		Height = 16, ;
		Left = 300, ;
		Name = "imgParent", ;
		nanchor = 8, ;
		Picture = ..\images\up1lvl.bmp, ;
		Top = 34, ;
		Visible = .F., ;
		Width = 16, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'lblControlCount' AS baselabel WITH ;
		AutoSize = .T., ;
		Caption = "Value", ;
		Left = 116, ;
		Name = "lblControlCount", ;
		TabIndex = 10, ;
		Top = 8, ;
		Visible = .F., ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblFavoritesFound' AS baselabel WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		Caption = "Objects Found", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 4, ;
		Name = "lblFavoritesFound", ;
		TabIndex = 11, ;
		Top = 34, ;
		Visible = .F., ;
		Width = 87, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'oObjectTree' AS peme_sfcombotree WITH ;
		BackStyle = 1, ;
		Height = 24, ;
		lcloseonclick = .T., ;
		Left = 0, ;
		lshowtag = .T., ;
		MousePointer = 0, ;
		Name = "oObjectTree", ;
		nanchor = 10, ;
		ncombowidthdifference = 24, ;
		TabIndex = 6, ;
		TabStop = .F., ;
		Top = 29, ;
		Visible = .F., ;
		Width = 320, ;
		ZOrderSet = 4, ;
		cboCombo.Height = 24, ;
		cboCombo.Left = 0, ;
		cboCombo.Name = "cboCombo", ;
		cboCombo.nanchor = 10, ;
		cboCombo.Top = 0, ;
		cboCombo.Width = 296, ;
		oTree.Height = 0, ;
		oTree.Left = 5, ;
		oTree.Name = "oTree", ;
		oTree.Top = 29, ;
		oTree.Width = 308, ;
		shpTreeView.Name = "shpTreeView", ;
		oImageList.Height = 100, ;
		oImageList.Left = 120, ;
		oImageList.Name = "oImageList", ;
		oImageList.Top = 40, ;
		oImageList.Width = 100
		*< END OBJECT: ClassLib="peme_sfcombotree.vcx" BaseClass="container" />
	
	PROCEDURE expandsubnodes
		Lparameters tnIndex, toTV, tnExpandLevels
		
		* tnExpandLevels -- number of levels of sub-nodes to expand
		
		*** JRN 05/08/09 : Borrowed (and then modified) from code posted on UT by Cetin Basoz
		Local lnIndex, lnLastIndex
		With toTV
			.Nodes(tnIndex).Expanded = .T.
			If .Nodes(tnIndex).Children > 0 And tnExpandLevels > 0
		
				lnIndex  = .Nodes(tnIndex).Child.Index
				lnLastIndex = .Nodes(tnIndex).Child.LastSibling.Index
				This.ExpandSubNodes(lnIndex, toTV, tnExpandLevels - 1)
		
				Do While lnIndex # lnLastIndex
					lnIndex = .Nodes(lnIndex).Next.Index
					This.ExpandSubNodes(lnIndex, toTV, tnExpandLevels - 1)
				Enddo
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE Refresh
		DoDefault()
		
		This.imgParent.Visible = (Not Thisform.lIsTopOfForm) 	;
			and (Not Isnull (Thisform.oObject))					;
			and Thisform.nSelectedObjects <= 1					;
			and Upper(Thisform.oObject.BaseClass) # Upper('DataEnvironment')
			
		This.Enabled = Thisform.lDocTreeView or ;
			('L' = Type("Thisform.oMember.InteractiveChanged") and Not Thisform.oMember.InteractiveChanged)
		
		
	ENDPROC

	PROCEDURE saveparentclasses
	ENDPROC

	PROCEDURE chkAllControls.Init
		With This
			.Caption 		= ccLOC_CAP_All_Controls
			.ToolTipText 	= ccLOC_Tip_All_Controls
		EndWith
		
		DoDefault()
	ENDPROC

	PROCEDURE chkAllControls.Refresh
		With This
			.Enabled = .Parent.oObjectTree.lCombotreeOpen and Thisform.lTreeViewShowMethods
			.Visible = .Parent.oObjectTree.lCombotreeOpen and Thisform.lTreeViewShowMethods
		Endwith
		
		
	ENDPROC

	PROCEDURE chkAllControls.Valid
		With Thisform
			.oPersist.Set('TreeViewAllControls', This.Value)
		EndWith
		
		With this.Parent.oObjectTree
			.DrawTreeView(.T.)
		EndWith 
		
		This.Parent.Refresh()
	ENDPROC

	PROCEDURE chkCSO.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		* Set the caption to a localized string.
		
		With This
			.ToolTipText 	= Thisform.InsertFormOrClass(ccLOC_Tip_USE_CSO)
		EndWith
		
		DoDefault()
	ENDPROC

	PROCEDURE chkCSO.Refresh
		* Set the caption to a localized string.
		
		With This
			If Thisform.nSelectedObjects <= 1
				.Caption 		= ccLOC_CAP_USE_CSO
			Else
				.Caption 		= ccLOC_CAP_USE_CSO_Plural
			Endif
			.Enabled = Thisform.nSelectedObjects <= 1 And Not Thisform.lEditingOneProperty
			.Visible = Thisform.lPEMEditor and Thisform.nSelectedObjects <= 1 ;
				and (Not .Parent.oObjectTree.lCombotreeOpen) ;
				And (Not Thisform.lEditingOneProperty) ;
				And Not Thisform.lDataEnvironment
		Endwith
		
		
	ENDPROC

	PROCEDURE chkCSO.Valid
		With Thisform
			.lRebuildTree = .T.	
			.oPersist.Set('UseCSO', This.Value)
			.ActivateForm(.T.)
			.Refresh()
		Endwith
		
	ENDPROC

	PROCEDURE chkDocumentView.Init
		With This
			.Caption 	= ccLOC_CAP_Show_Methods 
		EndWith
		
		DoDefault()
	ENDPROC

	PROCEDURE chkDocumentView.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		* Set the caption to a localized string.
		
		With This
			.ToolTipText 	= Thisform.InsertFormOrClass(ccLOC_Tip_Show_Methods)
		EndWith
		
		DoDefault()
	ENDPROC

	PROCEDURE chkDocumentView.Refresh
		With This
			.Enabled = .Parent.oObjectTree.lCombotreeOpen
			.Visible = .Parent.oObjectTree.lCombotreeOpen
		Endwith
		
		
	ENDPROC

	PROCEDURE chkDocumentView.Valid
		With Thisform
			.oPersist.Set('TreeViewShowMethods', This.Value)
		EndWith
		
		With this.Parent.oObjectTree
			.DrawTreeView(.T.)
		EndWith 
		
		This.Parent.Refresh()
	ENDPROC

	PROCEDURE chkFoundForAll.Init
		* Set the caption to a localized string.
		
		With This
			.Caption 		= ccLoc_Cap_FoundForAll
		EndWith
		
		
	ENDPROC

	PROCEDURE chkFoundForAll.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		* Set the caption to a localized string.
		
		With This
			.ToolTipText 	= Thisform.InsertFormOrClass(ccLoc_Tip_FoundForAll)
		EndWith
		
		DoDefault() 
	ENDPROC

	PROCEDURE chkFoundForAll.Refresh
		With this
			.Visible = Thisform.nSelectedObjects > 1 and (not Thisform.lEditingOneProperty)
			.Enabled = Thisform.nSelectedObjects > 1
		EndWith 
	ENDPROC

	PROCEDURE chkFoundForAll.Valid
		With Thisform
			.oPersist.Set('FoundForAll', This.Value)
			.ActivateForm(.T.)
			.Refresh()
		Endwith
		
	ENDPROC

	PROCEDURE chkMethodView.Init
		* Set the caption to a localized string.
		
		With This
			.Caption 		= ccLOC_CAP_MethodView
			.ToolTipText	= ccLOC_Tip_MethodView
		EndWith
		
		
	ENDPROC

	PROCEDURE chkMethodView.Refresh
		With This
		*!*		.enabled = Thisform.nSelectedObjects <= 1
		*!*		.Value = Thisform.nMethodView = 2 and Thisform.nSelectedObjects <= 1
		*!*		.Visible = .enabled and not .Parent.oObjectTree.lCombotreeOpen
		
			.enabled = .T. && Thisform.nSelectedObjects <= 1
			.Value = Thisform.nMethodView = 2 
			.Visible = Thisform.lPEMEditor and .enabled and not .Parent.oObjectTree.lCombotreeOpen
		EndWith 
		
	ENDPROC

	PROCEDURE chkMethodView.Valid
		With Thisform
			.nMethodView = IIF(this.Value, 2, 1)
			.cntControls.Refresh()
			.SetFilter()
			.SetGridHighlighting()
			Locate
			.ScatterCursor()
			.Refresh()
		EndWith 
		
	ENDPROC

	PROCEDURE gridMembers.When
		This.HighlightStyle = 2
	ENDPROC

	PROCEDURE imgParent.Click
		With Thisform
			If Not .lIsTopOfForm
				.SetCurrentSelectedObject(.oObject.Parent) 
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE imgParent.Init
		DoDefault() 
		
		This.ToolTipText = ccLOC_Tip_Parent
		
	ENDPROC

	PROCEDURE lblControlCount.Refresh
		With This
		
			With This
				.Visible = .Parent.oObjectTree.lCombotreeOpen 	;
					and (Not Thisform.lTreeViewShowMethods)
			Endwith
		
			.Caption = Transform (.Parent.oObjectTree.oTree.Nodes.Count - 1) + ' controls'
		
		Endwith
		
	ENDPROC

	PROCEDURE lblFavoritesFound.Refresh
		With This
			If Thisform.nSelectedObjects > 1 and (not Thisform.lEditingOneProperty)
				.Visible = .T.
				.Caption = Transform (Thisform.nSelectedObjects) + ccLoc_Cap_MultSelect
			Else
				.Visible = .F.
			EndIf 
		Endw
		
	ENDPROC

	PROCEDURE oObjectTree.afterclosecontrol
		Thisform.cntControls.Refresh()
		
	ENDPROC

	PROCEDURE oObjectTree.afteropencontrol
		Thisform.cntControls.Refresh()
		
	ENDPROC

	PROCEDURE oObjectTree.cboCombo.DropDown
		Local lbReDraw
		
		*** JRN 05/28/09 : Always redraw -- fast!
		lbReDraw = .T. &&  not (Thisform.lTreeViewShowMethods and This.Parent.Parent.lTreeviewCurrent)
		
		DoDefault()
		
		If lbReDraw
			This.Parent.DrawTreeview (.T.)
		EndIf 
		
		This.Parent.Parent.Refresh()
		
		Thisform.DoQuickTimer("MousePointer")
		
		
	ENDPROC

	PROCEDURE oObjectTree.cboCombo.Refresh
		Local loObject, loTopOfForm, lcCaption, lcClassInfo, lcClassName
		
		If Isnull(Thisform.oObject) Or Isnull(Thisform.oTopOfForm)
			Return
		Endif
		
		loObject 	= Thisform.oObject
		lcClassinfo = Thisform.AddClassInfo(loObject, '')
		
		lcCaption = ThisForm.GetObjectPath(loObject)
		Thisform.cCurrentObjectName = lcCaption
		
		If (Not Thisform.lUseCSO) Or loObject = Thisform.oTopOfForm
			This.Value = ' ' + Proper(Thisform.InsertFormOrClass('<insert2>')) + " " + Thisform.oTopOfForm.Name + lcClassInfo
		Else
			This.Value = ' ' + lcCaption + lcClassInfo
		Endif
		
		With This
			.Picture = Justpath (Thisform.ClassLibrary) + '\bmps\' + Thisform.oObject.BaseClass + '.bmp'
			.PictureSelectionDisplay = 3
			.DisplayValue = This.Value
			.FontItalic = Not Thisform.lUseCSO
		Endwith
		
	ENDPROC

	PROCEDURE oObjectTree.cboCombo.RightClick
		Private loForm
		Local laDataEnvironment[1], laMRU[1], lcAppPath, lcAutoRename, lcChoice, lcClass, lcFileName, lcLink
		Local lcPath, lcPrompt, llEnabled, lnBar, lnBar2, lnBar3, lnMsgBox, loHyperlink
		loForm = Thisform
		
		
		lnBar	 = 0
		lcChoice = ''
		
		If This.Parent.lComboTreeOpen
			This.Parent.CloseControl (.F., .F.)
		Endif This.lComboTreeOpen ...
		
		Thisform.CreateContextMenu ('ComboContextMenu')
		
		****************************************************************
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOG_CMG_Show_TreeView
		On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Show TreeView (Click)'
		
		If 'O' # Vartype (Thisform.oUtils.oDocTreeView)
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_DocumentTreeView
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Document TreeView'
		Endif
		
		*** JRN 03/10/2009 : See comments in ThisControlDeletable
		If Not Thisform.lIsTopOfForm
			lnBar = lnBar + 1
			If Thisform.ThisControlDeletable (Thisform.oObject)
				lcPrompt = ccLOC_CMG_DeleteControl
			Else
				lcPrompt = '\' + ccLOC_CMG_DeleteControl
			Endif
			Define Bar (lnBar) Of ComboContextMenu Prompt lcPrompt
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'DeleteControl'
		Endif
		
		****************************************************************
		lcAutoRename = Thisform.AutoRenameControls (Thisform.oObject, , .T.)
		Do Case
			Case Empty (lcAutoRename)
		
			Case lcAutoRename = 'Both'
		
				lnBar = lnBar + 1
				Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_AutoRename
				On Bar (lnBar) Of ComboContextMenu Activate Popup AutoRenameMenu
				Define Popup AutoRenameMenu SHORTCUT Relative
		
				lnBar2 = 0
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of AutoRenameMenu Prompt ccLOC_CMG_AutoRenameThisSub
				On Selection Bar (lnBar2) Of AutoRenameMenu lcChoice = 'Auto-Rename This'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of AutoRenameMenu Prompt ccLOC_CMG_AutoRenameKidsSub
				On Selection Bar (lnBar2) Of AutoRenameMenu lcChoice = 'Auto-Rename Kids'
		
			Case lcAutoRename = 'Name'
				lnBar = lnBar + 1
				Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_AutoRenameThis
				On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Auto-Rename This'
		
			Case lcAutoRename = 'Children'
				lnBar = lnBar + 1
				Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_AutoRenameKids
				On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Auto-Rename Kids'
		
		Endcase
		****************************************************************
		
		*!*	* renaming not always possible, or appropriate
		*!*	If Thisform.AutoRenameControls(Thisform.oObject, .T.)
		*!*		*!*	lnBar = lnBar + 1
		*!*		*!*	Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_Rename
		*!*		*!*	On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Rename'
		
		*!*		lnBar = lnBar + 1
		*!*		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_AutoRename
		*!*		On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Auto-Rename'
		
		*!*	Endif
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_EventHandlersEnabled
		On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Event Handlers Enabled'
		Set Mark Of Bar (lnBar) Of ComboContextMenu To Thisform.oPrefs.lEventHandlersEnabled
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt '\-'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_Copy
		On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Copy Object'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_CopyFiltered
		On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Copy Filtered Properties'
		
		If Thisform.lUseCSO And Not Thisform.lIsTopOfForm
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_NameToClipBoard
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'NameToClipBoard'
		Endif
		
		If Alen (Thisform.oServer.aCopiedProperties, 2) > 1
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt '\-'
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_Compare
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Compare Properties'
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_Paste
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Paste Properties'
		
			If Thisform.nSelectedObjects = 1
				If (Not Empty (Thisform.oServer.cCopyClass)) And (ThisForm.GetPEMStatus (Thisform.oObject, 'objects', 5) Or Not Thisform.lIsTopOfForm)
					*!*	lnBar = lnBar + 1
					*!*	Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_CopyObject
					*!*	On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Copy Object'
		
					lnBar = lnBar + 1
					Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_PasteObject
					On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Paste Object'
				Endif
			Endif
		
		Endif
		
		If Thisform.nSelectedObjects = 1
			llEnabled = Inlist (Lower (Thisform.oObject.BaseClass) + ' ', 'form', 'container', 'page ', 'column')
			lnBar	  = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt IIf (llEnabled, '', '\') + 'Add Object'
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Add Object'
		Endif
		
		If Not Empty (Thisform.oObject.Class)
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt '\-'
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt 'Edit Parent and Containing Classes'
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Save Parent Class(es)'
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_CompareClass
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Compare Class'
		
			llEnabled = Thisform.ThisControlDeletable (Thisform.oObject)  ;
				And 0 = Thisform.GetControlCount (Thisform.oObject)		  ;
				And Upper (Thisform.oObject.BaseClass) # 'OLE'
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt IIf (llEnabled, '', '\') + ccLOC_CMG_ChangeClass
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Re-Define Parent Class'
		
		Endif
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt '\-'
		
		****************************************************************
		If Thisform.nSelectedObjects = 1
		
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt 'Cross References (all methods)'
			On Bar (lnBar) Of ComboContextMenu Activate Popup CrossRefs
		
			Define Popup CrossRefs SHORTCUT Relative
			lnBar2 = 1
			If .T. && indents sub-menu
				lcName = IIf(Thisform.lClass, 'class', 'form')
				If Thisform.lIsTopOfForm
					lnBar2 = lnBar2 + 1
					Define Bar (lnBar2) Of CrossRefs Prompt ('This ' + lcName)
					On Selection Bar (lnBar2) Of CrossRefs lcChoice = 'CrossRef Form'
		
					If Thisform.oUtils.GetControlCount(Thisform.oObject) > 1
						lnBar2 = lnBar2 + 1
						Define Bar (lnBar2) Of CrossRefs Prompt ('This ' + lcName + ' and its children')
						On Selection Bar (lnBar2) Of CrossRefs lcChoice = 'CrossRef FormKids'
					Endif
				Else
					lnBar2 = lnBar2 + 1
					Define Bar (lnBar2) Of CrossRefs Prompt ('This object')
					On Selection Bar (lnBar2) Of CrossRefs lcChoice = 'Crossref Object'
		
					If Thisform.oUtils.GetControlCount(Thisform.oObject) > 1
						lnBar2 = lnBar2 + 1
						Define Bar (lnBar2) Of CrossRefs Prompt ('This object and its children')
						On Selection Bar (lnBar2) Of CrossRefs lcChoice = 'CrossRef ObjectKids'
					Endif
		
					lnBar2 = lnBar2 + 1
					Define Bar (lnBar2) Of CrossRefs Prompt ('This ' + lcName + ' and its children')
					On Selection Bar (lnBar2) Of CrossRefs lcChoice = 'CrossRef FormKids'
		
				Endif
		
			Endif
		
		Endif
		
		****************************************************************
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_Exports
		On Bar (lnBar) Of ComboContextMenu Activate Popup ComboContextExports
		
		If .T. && indents sub-menu
			Define Popup ComboContextExports  SHORTCUT Relative
			lnBar2 = 1
		
			If (Thisform.nMethodView = 2 And Thisform.nSelectedObjects = 1) Or Thisform.oPrefs.lTypeMethod Or Thisform.oPrefs.lTypeEvent
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of ComboContextExports Prompt ccLOC_CMG_ExportMethods
				On Selection Bar (lnBar2) Of ComboContextExports lcChoice = 'Method Code'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of ComboContextExports Prompt ccLOC_CMG_ExportParentMethods
				On Selection Bar (lnBar2) Of ComboContextExports lcChoice = 'Full Method Code'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of ComboContextExports Prompt ccLOC_CMG_ExportChildMethods
				On Selection Bar (lnBar2) Of ComboContextExports lcChoice = 'Children Method Code'
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of ComboContextExports Prompt '\-'
		
			Else
		
				lnBar2 = lnBar2 + 1
				Define Bar (lnBar2) Of ComboContextExports Prompt ccLOC_CMG_ExportChildMethods
				On Selection Bar (lnBar2) Of ComboContextExports lcChoice = 'Children Method Code'
		
			Endif
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of ComboContextExports  Prompt ccLOC_CMG_ViewParentage
			On Selection Bar (lnBar2) Of ComboContextExports  loForm.ViewParentCode ('', 'Parentage')
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of ComboContextExports Prompt ccLOC_CMG_ExportPEMList
			On Bar (lnBar2) Of ComboContextExports Activate Popup ComboContextExports2
			lnBar3 = 0
		
			If .T.
				Define Popup ComboContextExports2 SHORTCUT Relative
				lnBar3 = lnBar3 + 1
				Define Bar (lnBar3) Of ComboContextExports2 Prompt ccLOC_CMG_ExportPEMListHTML
				On Selection Bar (lnBar3) Of ComboContextExports2 lcChoice = 'HTML List of PEMs'
		
				lnBar3 = lnBar3 + 1
				Define Bar (lnBar3) Of ComboContextExports2 Prompt ccLOC_CMG_ExportPEMListText
				On Selection Bar (lnBar3) Of ComboContextExports2 lcChoice = 'List of PEMs'
		
			Endif
		
			*	If 0 # Reccount ('csrTempFiles')
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of ComboContextExports  Prompt '\-'
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of ComboContextExports  Prompt ccLOC_CMG_Close_All
			On Selection Bar (lnBar2) Of ComboContextExports  lcChoice = 'Close All'
			*	Endif
		
		Endif
		
		****************************************************************
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_MemberDataTools
		On Bar (lnBar) Of ComboContextMenu Activate Popup MemberDataTools
		
		Define Popup MemberDataTools SHORTCUT Relative
		lnBar2 = 1
		
		lnBar2 = lnBar2 + 1
		Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_MemberData2
		On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'MemberData'
		
		If Thisform.GetPEMStatus (Thisform.oTopOfForm, '_MemberData', 5)		   ;
				And Thisform.GetPEMStatus (Thisform.oTopOfForm, '_MemberData', 0)  ;
				And Not Empty (Thisform.oTopOfForm._MemberData)
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_CleanseMemberData
			On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Cleanse MemberData'
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_CleanseMemberStats
			On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Stats for MemberData'
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of MemberDataTools Prompt ccLOC_CMG_BrowseMemberData
			On Selection Bar (lnBar2) Of MemberDataTools lcChoice = 'Browse MemberData'
		Endif
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_VFP_Default
		On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'VFP Default'
		
		If Not Thisform.lClass
			lnBar = lnBar + 1
			Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMT_DataEnvironment
			On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Data Environment'
			Set Mark Of Bar (lnBar) Of ComboContextMenu To Thisform.lDataEnvironment
		Endif
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt '\-'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_Videos
		On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'Videos'
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of ComboContextMenu Prompt ccLOC_CMG_About
		On Selection Bar (lnBar) Of ComboContextMenu lcChoice = 'About'
		
		****************************************************************
		
		
		****************************************************************
		****************************************************************
		
		Activate Popup ComboContextMenu
		Release Popups ComboContextMenu, ComboContextExports
		
		****************************************************************
		****************************************************************
		
		Do Case
		
			Case lcChoice = 'Close All'
				Thisform.oUtils.ClearTempFilesList()
		
			Case lcChoice = 'DeleteControl'
				Thisform.DeleteThisControl()
		
		*!*		Case lcChoice = 'Rename'
		*!*			lcPath	  = Addbs (Justpath ((This.ClassLibrary )))
		*!*			lcAppPath = Forcepath ('PEMEditor.app', lcPath)
		*!*			Release _oZoom
		*!*			Public _oZoom
		*!*			_oZoom = Newobject ('ZoomDialog', 'EditProperty.vcx', lcAppPath, Thisform.oObject, 'Name', .T.)
		*!*			_oZoom.Show()
		*!*			This.Refresh()
		
			Case lcChoice = 'Auto-Rename This'
				If Thisform.oPrefs.lPromptAutoRename
					lnMsgBox = Messagebox (ccLOC_ASK_CMG_AutoRenameThis, 4 + 32, Thisform.Caption)
				Else
					lnMsgBox = 6
				Endif
				If lnMsgBox = 6
					Thisform.AutoRenameControls (Thisform.oObject, .T.)
					Thisform.RefreshForm()
				Endif
		
			Case lcChoice = 'Auto-Rename Kids'
				If Thisform.oPrefs.lPromptAutoRename
					lnMsgBox = Messagebox (ccLOC_ASK_CMG_AutoRename, 4 + 32, Thisform.Caption)
				Else
					lnMsgBox = 6
				Endif
				If lnMsgBox = 6
					Thisform.AutoRenameControls (Thisform.oObject)
					Thisform.RefreshForm()
				Endif
		
			Case lcChoice = 'NameToClipBoard'
				_Cliptext = Thisform.cCurrentObjectName
		
			Case lcChoice = 'Event Handlers Enabled'
				With Thisform
					.oPrefs.lEventHandlersEnabled = Not .oPrefs.lEventHandlersEnabled
					.CreateEventBindings (.T.)
					.RefreshGrid()
				Endwith
		
			Case lcChoice = 'List of PEMs'
				loForm.ExportListofPEMs()
		
			Case lcChoice = 'HTML List of PEMs'
				loForm.ExportHTMLListofPEMs()
		
			Case lcChoice = 'Method Code'
				Thisform.ExportMethodCode (.F.)
		
			Case lcChoice = 'Children Method Code'
				Thisform.ExportMethodCode (.F., .T.)
		
			Case lcChoice = 'Full Method Code'
				Thisform.ExportMethodCode (.T.)
		
			Case lcChoice = 'Show TreeView (Click)'
				This.DropDown()
		
			Case lcChoice = 'Document TreeView'
				Thisform.StartDocumentTreeView()
		
				*!*		Case lcChoice = 'Copy Properties'
				*!*			Set Step On
				*!*			Thisform.CopyProperties ("aCopiedProperties")
				*!*			With Thisform.oServer
				*!*				.cCopyClass				= ''
				*!*				.cCopyClassLibrary 		= ''
				*!*				.cCopyClassBaseClass 	= ''
				*!*			Endwith
		
			Case lcChoice = 'Copy Filtered Properties'
				Thisform.oUtils.CopyProperties ('aCopiedProperties', Filter('csrMembers'))
				With Thisform.oServer
					.cCopyClass			 = ''
					.cCopyClassLibrary	 = ''
					.cCopyClassBaseClass = ''
				Endwith
		
			Case lcChoice = 'Paste Properties'
				Thisform.oUtils.PasteProperties()
		
			Case lcChoice = 'Compare Properties'
				Thisform.oUtils.CompareProperties()
		
			Case lcChoice = 'Copy Object'
				Thisform.oUtils.CopyProperties ('aCopiedProperties')
				*!*	With Thisform.oServer
				*!*		.cCopyClass			 = ''
				*!*		.cCopyClassLibrary	 = ''
				*!*		.cCopyClassBaseClass = ''
				*!*	Endwith
		
				*!*	If Thisform.nSelectedObjects = 1
				*!*		With Thisform.oServer
				*!*			.cCopyClass			= Thisform.oObject.Class
				*!*			If Thisform.lClass And Thisform.lIsTopOfForm
				*!*				.cCopyClassLibrary 	= Thisform.cSourceFileName
				*!*			Else
				*!*				.cCopyClassLibrary 	= Thisform.oObject.ClassLibrary
				*!*			Endif
				*!*			.cCopyClassBaseClass = Thisform.oObject.BaseClass
				*!*		Endwith
				*!*	Endif
		
			Case lcChoice = 'Paste Object'
				Thisform.oUtils.PasteObject()
		
			Case lcChoice = 'Add Object'
				Thisform.oUtils.AddControl()
		
			Case lcChoice = 'Compare Class'
				Thisform.oUtils.CompareClass()
		
			Case lcChoice = 'MemberData'
				Thisform.lDontDisableMe = .T.
				Do (_Builder) With Thisform.oTopOfForm, 'MemberData', 1
				Thisform.lDontDisableMe = .F.
				Thisform.RefreshForm()
		
			Case lcChoice = 'Cleanse MemberData'
				Thisform.MemberDataCleaner()
		
			Case lcChoice = 'Stats for MemberData'
				Thisform.memberdatastats()
		
			Case lcChoice = 'Browse MemberData'
				Xmltocursor (Thisform.oTopOfForm._MemberData, 'Browse_MemberData')
				Index On Name Tag Name
				Browse Normal Noappend Nodelete Nomodify
				Select csrMembers
		
			Case lcChoice = 'VFP Default'
				lcPrompt = ccLOC_VFP_Default_Prompt
				lnMsgBox = Messagebox (lcPrompt, 3 + 32, ccLOC_VFP_Default)
				If lnMsgBox = 6
					With Thisform
						.oPersist.Set ('OneTimeAbort', .T.)
						.oPersist.Save (.cFoxUserID, .cFoxUserName)
					Endwith
					Thisform.Release()
				Endif
		
			Case lcChoice = 'Data Environment'
				With Thisform
					If .lDataEnvironment
						.lrebuildtree	  = .T.
						.lDataEnvironment = .F.
					Else
						Aselobj (laDataEnvironment, 2)
						.oObject		  = laDataEnvironment(1)
						.lrebuildtree	  = .F.
						.lDataEnvironment = .T.
					Endif
					.activateform (.T.)
				Endwith
		
			Case lcChoice = 'Save Parent Class(es)'
				Thisform.oUtils.EditParentClasses()
		
			Case lcChoice = 'Re-Define Parent Class'
				Thisform.oUtils.ChangeParentClass()
		
			Case lcChoice = 'About'
				Thisform.lDontDisableMe = .T.
				Thisform.oUtils.AboutPEMEditor()
				Thisform.lDontDisableMe = .F.
		
			Case lcChoice = 'Videos'
				lcLink		= 'http://jordanmachine.com/PEM_Editor_Videos.html'
				loHyperlink	= Createobject ('Hyperlink')
				loHyperlink.NavigateTo (lcLink)
		
			Case lcChoice == 'CrossRef Form'
				Thisform.oUtils.oBeautifyX.PEME_CreateObjectIDList (Thisform.oTopOfForm, .F.;
					, Thisform.cSourceFileName, IIf(Thisform.lClass, Thisform.oTopOfForm.Name, ''))
		
			Case lcChoice == 'CrossRef FormKids'
				Thisform.oUtils.oBeautifyX.PEME_CreateObjectIDList (Thisform.oTopOfForm, .T.;
					, Thisform.cSourceFileName, IIf(Thisform.lClass, Thisform.oTopOfForm.Name, ''))
		
			Case lcChoice == 'CrossRef Object'
				Thisform.oUtils.oBeautifyX.PEME_CreateObjectIDList (Thisform.oObject, .F.;
					, Thisform.cSourceFileName, IIf(Thisform.lClass, Thisform.oTopOfForm.Name, ''))
		
			Case lcChoice == 'CrossRef ObjectKids'
				Thisform.oUtils.oBeautifyX.PEME_CreateObjectIDList (Thisform.oObject, .T.;
					, Thisform.cSourceFileName, IIf(Thisform.lClass, Thisform.oTopOfForm.Name, ''))
		
		Endcase
		
		
	ENDPROC

	PROCEDURE oObjectTree.closecontrol
		* After the user has selected an object, display its image in the combobox.
		Lparameters tlKeepFocus, tlSelected
		
		Local lcTag, loObject
		DoDefault(tlKeepFocus, tlSelected)
		If tlSelected
			This.cboCombo.Picture = '..\images\' + This.oTree.SelectedItem.Image + '.bmp'
			This.cboCombo.PictureSelectionDisplay = 3
			This.NodeSelected(This.oTree.SelectedItem)
		Endif tlSelected
		
		This.Parent.Refresh()
		
	ENDPROC

	PROCEDURE oObjectTree.drawtreeview
		Lparameters lbForceIt, llRebuildTree
		
		With This
			If lbForceIt Or Not .lCombotreeOpen
				lnSeconds = Seconds()
				.otree.Nodes.Clear && remove any previous entries
		
				.Enabled = .F.
				.MousePointer = 11
				.SetAll ("MousePointer", 11)
		
				lnBackColor = .BackColor
				.BackColor = Rgb(255,255,255)
				lnLeft = .otree.Left
				.otree.Left = - (.otree.Width + 100)
		
				.LoadTree()
		
				.otree.Left = lnLeft
				.BackColor = lnBackColor
		
				.Enabled = .T.
				.MousePointer = 0
				.SetAll ("MousePointer", 0)
		
				Thisform.lRebuildTree = llRebuildTree
				.Parent.lTreeviewCurrent = .T.
				*	Wait (Seconds() - lnSeconds) Window Nowait
			Endif
		Endwith
		
		
	ENDPROC

	PROCEDURE oObjectTree.Init
		* Load the images we want to display.
		Thisform.oObjectTree = this
		
		Local Array laImages[1]
		Local lcPath, lnImages, lcImage, lnI
		
		lcPath = ThisForm.cApplicationPath + "images\"
		lnImages = Adir(laImages, lcPath + '*.bmp')
		For lnI = 1 To lnImages
			lcImage = laImages[lnI, 1]
			This.oImageList.ListImages.Add(lnI, Lower(Juststem(lcImage)), ;
				loadpicture(lcPath + lcImage))
		Next lnI
		
		This.AddProperty("lFirstTime", .T.)
		This.AddProperty ("lOriginalCollapsed", Thisform.lCollapsed)
		This.AddProperty ("cThisFormCaption", ThisForm.Caption)
		
		DoDefault()
		
	ENDPROC

	PROCEDURE oObjectTree.loadtree
		* Load the TreeView with the objects. We'll use the object name as both the
		* text and the key and an image with that same name as the image. We'll store
		* the object path to Tag.
		
		*** JRN 02/14/2009 : Modified so that the key is NOT the name of the object,
		* since there can be duplicate names.  Name of nodes are ROOT, NODE2, NODE3, NODE4
		* and the name of the parent is the third parameter
		
		Lparameters toParent, 	;
			tcPath,				;
			tcParentKey
		
		Return Thisform.loadtree (This.oTree, toParent,	tcPath, tcParentKey) 
		
		
	ENDPROC

	PROCEDURE oObjectTree.LostFocus
		* Nothing here ... ignore default behavior
	ENDPROC

	PROCEDURE oObjectTree.nodeselected
		*** JRN 02/15/2009 : Handle the selected object .. our control
		Lparameters loNode
		Local lcObject, loObject, lcProcess, loTag, lcMethodName, loTop
		
		If This.nMouseButton # 1
			This.nMouseButton = - This.nMouseButton && liar!! negative means mouseclick on node
			Return
		Endif
		
		If thisform.lDataEnvironment
			Local laDataEnvironment(1)
			Aselobj(laDataEnvironment,2)
			loParent = laDataEnvironment(1)
			loTop = 'loParent'
		Else
			loTop = 'ThisForm.oTopOfForm'
		EndIf 
		
		If loNode.Index = 1
			If Empty(Thisform.cTreeStartNode)
				loObject = Evaluate(loTop)
				lcProcess = 'Object'
			Else
				loObject = Evaluate(loTop + Thisform.cTreeStartNode)
				lcProcess = 'Object'
			Endif
		Else
			loTag = loNode.Tag
			lcObject = loTop + loTag.Path
		
			Do Case
				Case loTag.Type = 'Object' And 'O' = Type (lcObject)
					loObject = Evaluate (lcObject)
					lcProcess = 'Object'
					Thisform.lUseCSO = .T.
				Case loTag.Type = 'Method' And 'O' = Type (lcObject)
					loObject = Evaluate (lcObject)
					lcProcess = 'Method'
					lcMethodName = loTag.MethodName
				Otherwise
					lcProcess = 'Not Found'
			Endcase
		Endif
		
		Do Case
		
			Case lcProcess = 'Object'
			
				With Thisform
					.SetCurrentSelectedObject(loObject)
				Endwith
		
			Case lcProcess = 'Method' And This.nMouseShift = 0
				Thisform.EditMethodCode (lcMethodName, loObject)
		
			Case lcProcess = 'Method' And This.nMouseShift = 2
				Thisform.ViewParentCode(lcMethodName, 'Code' ,, loObject)
		
		Endcase
		
		Return
		
		
		
		
	ENDPROC

	PROCEDURE oObjectTree.onclosecontrol
		If Thisform.oPrefs.lGridAbove
			Thisform.oSplitterV.Collapse(This.lOriginalCollapsed)
		Endif
		
		
	ENDPROC

	PROCEDURE oObjectTree.onopencontrol
		This.lOriginalCollapsed = Thisform.lCollapsed
		
		If Thisform.oPrefs.lGridAbove
			Thisform.oSplitterV.Collapse(.T.)
		Endif
		
		
	ENDPROC

	PROCEDURE oObjectTree.oTree.KeyDown
		*** ActiveX Control Event ***
		Lparameters tnKeyCode , Shift
		
		* ignoring parent-class behavior to handle Escape
		
	ENDPROC

	PROCEDURE oObjectTree.oTree.KeyPress
		*** ActiveX Control Event ***
		LPARAMETERS keyascii
		
	ENDPROC

	PROCEDURE oObjectTree.oTree.MouseUp
		*** ActiveX Control Event ***
		Lparameters Button, Shift, x, Y
		
		If Abs(This.Parent.nMouseButton) # 2  && for right-click only ... negative means on node
			Return
		Endif
		
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Nodefault
		
		Local loNode As Object
		Local loObject As Object
		Local loTag As Object
		Local laLines(1), lcChoice, lcMethodName, lcObject, lcProcess, lnBar, lnBar2, lnCount, lnNewValue, lnStartBar, llRedrawTree
		
		lnBar = 0
		lnBar2 = 0
		lcChoice = 'None'
		Thisform.CreateContextMenu("TreeContextMenu")
		
		If This.Parent.nMouseButton = -2 && node click
			****************************************************************
		
			loNode = This.SelectedItem
			If loNode.Index = 1
				If Empty(Thisform.cTreeStartNode)
					loObject = Thisform.oTopOfForm
					lcProcess = 'Object'
				Else
					loObject = Evaluate('ThisForm.oTopOfForm' + Thisform.cTreeStartNode)
					lcProcess = 'Object'
				Endif
				loTag = loNode.Tag
			Else
				loTag = loNode.Tag
				lcObject = 'ThisForm.oTopOfForm' + loTag.Path
		
				Do Case
					Case loTag.Type = 'Object' And 'O' = Type (lcObject)
						loObject = Evaluate (lcObject)
						lcProcess = 'Object'
					Case loTag.Type = 'Method' And 'O' = Type (lcObject)
						loObject = Evaluate (lcObject)
						lcProcess = 'Method'
						lcMethodName = Trim (loTag.MethodName)
					Otherwise
						lcProcess = 'Not Found'
				Endcase
			Endif
			****************************************************************
		
			Do Case
				Case lcProcess = 'Object'
					lnStartBar = lnBar
					lnCount = Thisform.GetControlCount(loObject)
		
					If Not Empty(Thisform.cTreeStartNode)
						lnBar = lnBar + 1
						Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_ShowEntireTree
						On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Show Entire Tree'
					Endif
		
					If lnCount # 0 And loObject # Thisform.oTopOfForm
						lnBar = lnBar + 1
						Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_ShowPartialTree
						On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Show Partial Tree'
					Endif
		
					If loObject # Thisform.oTopOfForm
						lnBar = lnBar + 1
						Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_ShowParentPartialTree
						On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Show Parent Partial Tree'
					Endif
		
					If lnCount # 0
						lnBar = lnBar + 1
						Define Bar (lnBar) Of TreeContextMenu Prompt ccLOG_CMG_TreeView_ExpandChildren
						On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Expand children (one level)'
		
						lnBar = lnBar + 1
						Define Bar (lnBar) Of TreeContextMenu Prompt ccLOG_CMG_TreeView_ExpandAll
						On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Expand sub-nodes (all levels)'
					Endif
		
					If lnStartBar # lnBar
						lnBar = lnBar + 1
						Define Bar (lnBar) Of TreeContextMenu Prompt "\-"
					Endif
		
					lnBar = lnBar + 1
					Define Bar (lnBar) Of TreeContextMenu Prompt ccLOC_CMG_EDIT_Object_Tree
					On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Object'
		
				Case lcProcess = 'Method'
					lnBar = lnBar + 1
					Define Bar (lnBar) Of TreeContextMenu Prompt ccLOC_CMG_EDIT_METHOD_Tree
					On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Edit Method'
		
					lnBar = lnBar + 1
					Define Bar (lnBar) Of TreeContextMenu Prompt ccLOC_CMG_VIEW_PARENT_Tree
					On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Parent Tree'
		
					lnBar = lnBar + 1
					Define Bar (lnBar) Of TreeContextMenu Prompt ccLOC_Pref_CAP_ResetToDefault
					On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Reset To Default'
		
					If Thisform.GetPEMStatus (loObject, lcMethodName, 4) And Not Thisform.GetPEMStatus (loObject, lcMethodName, 6)
						lnBar = lnBar + 1
						Define Bar (lnBar) Of TreeContextMenu Prompt ccLOC_CAP_Remove_Method + ' ' + lcMethodName
						On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Remove Method'
					Endif
		
			Endcase
		
		*!*		lnBar = lnBar + 1
		*!*		Define Bar (lnBar) Of TreeContextMenu Prompt "\-"
		Endif
		
		****************************************************************
		If thisform.lPEMEditor
			lnBar = lnBar + 1
			Define Bar (lnBar) Of TreeContextMenu Prompt ccLOG_CMG_Hide_TreeView
			On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Hide TreeView'
		EndIf
		
		****************************************************************
		
		If lnBar > 0
			lnBar = lnBar + 1
			Define Bar (lnBar) Of TreeContextMenu Prompt "\-"
		EndIf 
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_ExpandAllNodes
		On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Expand All Nodes'
		Set Mark Of Bar (lnBar) Of TreeContextMenu To (Thisform.oPrefs.lExpandAllNodes)
		
		*
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_SortOrderMethods
		On Bar (lnBar) Of TreeContextMenu Activate Popup TreeContextSortMethodsMenu
		
		If .T. && indents sub-menu
			Define Popup TreeContextSortMethodsMenu SHORTCUT Relative
			lnBar2 = 0
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMethodsMenu Prompt ccLoc_CMT_Alphabetical
			On Selection Bar (lnBar2) Of TreeContextSortMethodsMenu lcChoice = ccLoc_CMT_Alphabetical
			Set Mark Of Bar (lnBar2) Of TreeContextSortMethodsMenu To (Thisform.oPrefs.nTreeSortMethods = 2)
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMethodsMenu Prompt ccLoc_CMT_AlphabeticalUseCase
			On Selection Bar (lnBar2) Of TreeContextSortMethodsMenu lcChoice = ccLoc_CMT_AlphabeticalUseCase
			Set Mark Of Bar (lnBar2) Of TreeContextSortMethodsMenu To (Thisform.oPrefs.nTreeSortMethods = 1)
		
		Endif
		
		*
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_SortOrder
		On Bar (lnBar) Of TreeContextMenu Activate Popup TreeContextSortMenu
		
		If .T. && indents sub-menu
			Define Popup TreeContextSortMenu SHORTCUT Relative
			lnBar2 = 0
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMenu Prompt ccLoc_CMT_Natural
			On Selection Bar (lnBar2) Of TreeContextSortMenu lcChoice = 1
			Set Mark Of Bar (lnBar2) Of TreeContextSortMenu To (Thisform.oPrefs.nTreeSort = 1)
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMenu Prompt ccLoc_CMT_Alphabetical
			On Selection Bar (lnBar2) Of TreeContextSortMenu lcChoice = 2
			Set Mark Of Bar (lnBar2) Of TreeContextSortMenu To (Thisform.oPrefs.nTreeSort = 2)
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMenu Prompt ccLoc_CMT_AlphabeticalUseCase
			On Selection Bar (lnBar2) Of TreeContextSortMenu lcChoice = 6
			Set Mark Of Bar (lnBar2) Of TreeContextSortMenu To (Thisform.oPrefs.nTreeSort = 6)
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMenu Prompt ccLoc_CMT_TabIndex
			On Selection Bar (lnBar2) Of TreeContextSortMenu lcChoice = 3
			Set Mark Of Bar (lnBar2) Of TreeContextSortMenu To (Thisform.oPrefs.nTreeSort = 3)
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMenu Prompt ccLoc_CMT_TopToBottom
			On Selection Bar (lnBar2) Of TreeContextSortMenu lcChoice = 4
			Set Mark Of Bar (lnBar2) Of TreeContextSortMenu To (Thisform.oPrefs.nTreeSort = 4)
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMenu Prompt ccLoc_CMT_LeftToRight
			On Selection Bar (lnBar2) Of TreeContextSortMenu lcChoice = 5
			Set Mark Of Bar (lnBar2) Of TreeContextSortMenu To (Thisform.oPrefs.nTreeSort = 5)
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMenu Prompt "\-"
		
			lnBar2 = lnBar2 + 1
			Define Bar (lnBar2) Of TreeContextSortMenu Prompt ccLoc_CMT_MemberSort
			On Selection Bar (lnBar2) Of TreeContextSortMenu lcChoice = 'MemberClass'
			Set Mark Of Bar (lnBar2) Of TreeContextSortMenu To (Thisform.oPrefs.lTreeMemberSort)
		
		Endif
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt ccLOC_CAP_FONT
		On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Font'
		
		****************************************************************
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_ShowCaptions
		On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Captions'
		Set Mark Of Bar (lnBar) Of TreeContextMenu To (Thisform.oPrefs.lTreeShowCaptions)
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_ShowClassName
		On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'Show Class Name'
		Set Mark Of Bar (lnBar) Of TreeContextMenu To (Thisform.oPrefs.nTreeViewClassInfo = 1)
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt ccLoc_CMT_ShowClassLib
		On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'ShowClassLib'
		Set Mark Of Bar (lnBar) Of TreeContextMenu To (Thisform.oPrefs.nTreeViewClassInfo = 2)
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt 'Show all custom methods'
		On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'AllCustomMethods'
		Set Mark Of Bar (lnBar) Of TreeContextMenu To (Thisform.oPrefs.lShowAllCustomMethods)
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt 'Show methods w/inherited code; this ' + IIF(ThisForm.lClass, 'class', 'form') 
		On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'ShowAllInheritedCode'
		Set Mark Of Bar (lnBar) Of TreeContextMenu To (Thisform.oPrefs.lShowAllInheritedCode)
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of TreeContextMenu Prompt 'Show methods w/inherited code; all objects'
		On Selection Bar (lnBar) Of TreeContextMenu lcChoice = 'ShowChildInheritedCode'
		Set Mark Of Bar (lnBar) Of TreeContextMenu To (Thisform.oPrefs.lShowChildInheritedCode)
		
		****************************************************************
		
		This.Parent.nMouseButton = 0
		This.Parent.lNoClose = .T.
		Activate Popup TreeContextMenu
		This.Parent.lNoClose = .F.
		
		Release Popups TreeContextMenu, TreeContextSortMenu
		
		****************************************************************
		
		Do Case
		
			Case "N" = Vartype (lcChoice)
				Thisform.oPrefs.nTreeSort = lcChoice
				Thisform.oPersist.Set("TreeSort", lcChoice)
				llRedrawTree = .T.
		
			Case lcChoice = ccLoc_CMT_Alphabetical
				Thisform.oPrefs.nTreeSortMethods = 2
				Thisform.oPersist.Set("TreeSortMethods", 2)
				llRedrawTree = .T.
		
			Case lcChoice = ccLoc_CMT_AlphabeticalUseCase
				Thisform.oPrefs.nTreeSortMethods = 1
				Thisform.oPersist.Set("TreeSortMethods", 1)
				llRedrawTree = .T.
		
			Case lcChoice = 'MemberClass'
				Thisform.oPrefs.lTreeMemberSort = Not Thisform.oPrefs.lTreeMemberSort
				llRedrawTree = .T.
		
			Case lcChoice = 'Object'
				With This.Parent
					.nMouseButton = 1
					.nMouseShift = 0
					.NodeSelected (loNode)
				Endwith
		
			Case lcChoice = 'Edit Method'
				With This.Parent
					.nMouseButton = 1
					.nMouseShift = 0
					.NodeSelected (loNode)
				Endwith
		
			Case lcChoice = 'Parent Tree'
				With This.Parent
					.nMouseButton = 1
					.nMouseShift = 2
					.NodeSelected (loNode)
				Endwith
		
			Case lcChoice = 'Hide TreeView'
				Thisform.CloseTreeView()
		
			Case lcChoice = 'Captions'
				Thisform.oPrefs.lTreeShowCaptions = Not Thisform.oPrefs.lTreeShowCaptions
				Thisform.oPersist.Set("TreeShowCaptions", Thisform.oPrefs.lTreeShowCaptions)
				llRedrawTree = .T.
		
			Case lcChoice = 'Font'
		
				Local lcFont, laLines(1), lcFontName, lcFontSize
		
				lcFont = Getfont (This.Parent.cboCombo.FontName, This.Parent.cboCombo.FontSize)
		
				If Empty (lcFont)
					Return
				Endif
		
				Alines (laLines, lcFont, .T., ',')
				This.Parent.cboCombo.FontName = laLines(1)
				This.Parent.cboCombo.FontSize = Val(laLines(2))
		
				This.Font.Name 	= laLines(1)
				This.Font.Size 	= Val (laLines(2))
		
				With Thisform
					.oPersist.Set('TreeFontName', laLines(1))
					.oPersist.Set('TreeFontSize', laLines(2))
				Endwith
		
			Case lcChoice = 'Expand sub-nodes (all levels)'
				This.Parent.Parent.ExpandSubNodes( loNode.Index, This, 1000)
				This.SelectedItem.EnsureVisible()
		
			Case lcChoice = 'Show Entire Tree'
				Thisform.cTreeStartNode = ''
				llRedrawTree = .T.
		
			Case lcChoice = 'Show Partial Tree'
				With Thisform
					.cTreeStartNode = loTag.Path
					.oObject = loObject
				Endwith
				llRedrawTree = .T.
		
			Case lcChoice = 'Show Parent Partial Tree'
				With Thisform
					.cTreeStartNode = Left(loTag.Path, Rat(".", loTag.Path) -1 )
					.oObject = loObject
				Endwith
				llRedrawTree = .T.
		
			Case lcChoice = 'Expand children (one level)'
				Local toNode, loChildNode AS Object
				toNode = This.SelectedItem
				toNode.Expanded = .T.
				IF toNode.Children > 0
				  loChildNode = toNode.Child
				  DO WHILE VARTYPE( loChildNode ) = [O]
				    loChildNode.Expanded = .T.
				    loChildNode = loChildNode.Next
				  ENDDO
				ENDIF		
		
			Case lcChoice = 'Expand All Nodes'
				lnNewValue = Not Thisform.oPrefs.lExpandAllNodes
				Thisform.oPrefs.lExpandAllNodes= lnNewValue
				Thisform.oPersist.Set("ExpandAllNodes", lnNewValue)
				llRedrawTree = .T.
		
			Case lcChoice = 'Show Class Name'
				lnNewValue = IIf (Thisform.oPrefs.nTreeViewClassInfo # 1, 1, 0)
				Thisform.oPrefs.nTreeViewClassInfo = lnNewValue
				Thisform.oPersist.Set("TreeViewClassInfo", lnNewValue)
				llRedrawTree = .T.
		
			Case lcChoice = 'ShowClassLib'
				lnNewValue = IIf (Thisform.oPrefs.nTreeViewClassInfo # 2, 2, 0)
				Thisform.oPrefs.nTreeViewClassInfo = lnNewValue
				Thisform.oPersist.Set("TreeViewClassInfo", lnNewValue)
				llRedrawTree = .T.
		
			Case lcChoice = 'ShowAllInheritedCode'
				lnNewValue = Not Thisform.oPrefs.lShowAllInheritedCode
				Thisform.oPrefs.lShowAllInheritedCode = lnNewValue
				llRedrawTree = .T.
		
			Case lcChoice = 'ShowChildInheritedCode'
				lnNewValue = Not Thisform.oPrefs.lShowChildInheritedCode
				Thisform.oPrefs.lShowChildInheritedCode = lnNewValue
				llRedrawTree = .T.
		
			Case lcChoice = 'AllCustomMethods'
				lnNewValue = Not Thisform.oPrefs.lShowAllCustomMethods
				Thisform.oPrefs.lShowAllCustomMethods = lnNewValue
				llRedrawTree = .T.
		
			Case lcChoice = 'Reset To Default'
				Try
					loObject.WriteMethod (lcMethodName, '')
				Catch
				Endtry
				llRedrawTree = .T.
		
			Case lcChoice = 'Remove Method'
				Try
					RemoveProperty (loObject, lcMethodName)
				Catch
				Endtry
				llRedrawTree = .T.
		
		Endcase
		
		If llRedrawTree
			This.Nodes.Clear && remove any previous entries
			With This.Parent
				.LoadTree()
				.Refresh()
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE oObjectTree.oTree.Refresh
		*** ActiveX Control Method ***
		
	ENDPROC

	PROCEDURE oObjectTree.Refresh
		This.Enabled = .T. && Thisform.lUseCSO
		
		With This
		
			If .lFirstTime
				.lFirstTime = .F.
				With Thisform
					This.cboCombo.FontName = Nvl (.oPersist.Get('TreeFontName'), This.cboCombo.FontName)
					This.cboCombo.FontSize = Nvl (Val(.oPersist.Get('TreeFontSize')), Thisform.nFontSize)
		
					This.oTree.Font.Name = Nvl (.oPersist.Get('TreeFontName'), This.oTree.Font.Name)
					This.oTree.Font.Size = Nvl (Val (.oPersist.Get('TreeFontSize')), Thisform.nFontSize)
				Endwith
			Endif
		
			If Isnull (Thisform.oObject)
				This.Visible = .F.
			Else
				This.Visible = Thisform.nSelectedObjects <= 1
			Endif
		Endwith
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridmembers AS basegridmembers OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ColName.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColName.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColType.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColType.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColAccess.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColAccess.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColAssign.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColAssign.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColVisibility.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColVisibility.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColHierarchy.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColHierarchy.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColFavorite.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColFavorite.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColNonDefault.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColNonDefault.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.imgHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColValue.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColValue.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCode.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCode.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColMethodName.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColMethodName.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColMultValue.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColMultValue.Text1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	ColumnCount = 13
	Height = 276
	HighlightStyle = 2
	lfirsttime = .T.
	Name = "gridmembers"
	nanchor = 15
	ncurrentrecno = 0
	RecordSource = "csrMembers"
	RecordSourceType = 1
	RowHeight = 18
	TabIndex = 1
	Width = 873
	ZOrderSet = 0
	Column1.ColumnOrder = 2
	Column1.ControlSource = "csrMembers.cName"
	Column1.Name = "ColName"
	Column1.ReadOnly = .T.
	Column1.Width = 120
	Column2.Alignment = 2
	Column2.ColumnOrder = 9
	Column2.ControlSource = "(ThisForm.SpellType(csrMembers.cType))"
	Column2.Name = "ColType"
	Column2.ReadOnly = .T.
	Column2.Width = 70
	Column3.Alignment = 2
	Column3.ColumnOrder = 10
	Column3.ControlSource = "(ThisForm.SpellYes(csrMembers.lAccess))"
	Column3.Name = "ColAccess"
	Column3.ReadOnly = .T.
	Column3.Width = 50
	Column4.Alignment = 2
	Column4.ColumnOrder = 11
	Column4.ControlSource = "(ThisForm.SpellYes(csrMembers.lAssign))"
	Column4.Name = "ColAssign"
	Column4.ReadOnly = .T.
	Column4.Width = 45
	Column5.Alignment = 2
	Column5.ColumnOrder = 12
	Column5.ControlSource = "(Thisform.SpellVisibility (csrMembers.nVisibility))"
	Column5.Name = "ColVisibility"
	Column5.ReadOnly = .T.
	Column5.Width = 60
	Column6.Alignment = 2
	Column6.ColumnOrder = 8
	Column6.ControlSource = "(Thisform.SpellHierarchy(csrMembers.lNative, csrMembers.lInherited))"
	Column6.Name = "ColHierarchy"
	Column6.ReadOnly = .T.
	Column6.Width = 60
	Column7.Alignment = 2
	Column7.ColumnOrder = 13
	Column7.ControlSource = "(ThisForm.SpellFavorites(csrMembers.nFavorites))"
	Column7.Name = "ColFavorite"
	Column7.ReadOnly = .T.
	Column7.Width = 55
	Column8.Alignment = 2
	Column8.ColumnOrder = 6
	Column8.ControlSource = "(ThisForm.SpellYes(csrMembers.lNonDefault))"
	Column8.Name = "ColNonDefault"
	Column8.ReadOnly = .T.
	Column8.Width = 59
	Column9.ColumnOrder = 1
	Column9.ControlSource = ""
	Column9.CurrentControl = "imgHolder"
	Column9.DynamicFontShadow = "This.SetBMP()"
	Column9.Name = "ColTypeIcon"
	Column9.ReadOnly = .T.
	Column9.Sparse = .F.
	Column9.Width = 16
	Column10.ColumnOrder = 4
	Column10.Comment = ""
	Column10.ControlSource = "IIF (cType = 'P', Thisform.GetValue(cName, lNative, 'Display', nObjNumber, cDescript), ThisForm.GetMethodValue(lNonDefault, lHasCode))"
	Column10.CurrentControl = "Text1"
	Column10.Name = "ColValue"
	Column10.ReadOnly = .T.
	Column10.Width = 120
	Column11.Alignment = 2
	Column11.ColumnOrder = 7
	Column11.ControlSource = "(Thisform.SpellYes(lHasCode and cType # 'P'))"
	Column11.Name = "ColCode"
	Column11.ReadOnly = .T.
	Column11.Width = 50
	Column12.ColumnOrder = 3
	Column12.ControlSource = "csrMembers.cName"
	Column12.Name = "ColMethodName"
	Column12.ReadOnly = .T.
	Column12.Width = 120
	Column13.ColumnOrder = 5
	Column13.ControlSource = "csrMembers.cValue"
	Column13.Name = "ColMultValue"
	Column13.ReadOnly = .T.
	Column13.Width = 120

	ADD OBJECT 'ColAccess.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Access", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColAccess.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColAssign.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Assign", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColAssign.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColCode.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Code", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColCode.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColFavorite.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Favorite", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColFavorite.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColHierarchy.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Origin", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColHierarchy.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColMethodName.Header1' AS header WITH ;
		Caption = "Name", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColMethodName.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColMultValue.Header1' AS header WITH ;
		Caption = "Header1", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColMultValue.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColName.Header1' AS header WITH ;
		Caption = "Name", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColName.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ControlSource = "csrMembers.cName", ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColNonDefault.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Non-Default", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColNonDefault.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColType.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Type", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColType.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColTypeIcon.Header1' AS header WITH ;
		Caption = " ", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColTypeIcon.imgHolder' AS image WITH ;
		Height = 16, ;
		Left = 57, ;
		Name = "imgHolder", ;
		Picture = ..\images\propty.bmp, ;
		Top = 83, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'ColValue.Header1' AS header WITH ;
		Caption = "Value", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColValue.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T., ;
		Value = 'abcv'
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColVisibility.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Visibility", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColVisibility.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE AfterRowColChange
		Lparameters nColIndex
		This.ncurrentrecno = Recno()
		Thisform.SetProperties()
		Thisform.DoQuickTimer("MousePointer")
		*	PEME_ClearWaitCursor()
		
	ENDPROC

	PROCEDURE DblClick
		If Thisform.nSelectedObjects > 1 and csrMembers.cType # 'P'
			Return
		EndIf 
		
		This.editpem()
		*	PEME_ClearWaitCursor()
		
	ENDPROC

	PROCEDURE Init
		Thisform.oGrid = This
		
		DoDefault()
		
	ENDPROC

	PROCEDURE KeyPress
		Lparameters tnKeyCode, ;
			tnShiftAltCtrl
		
		#Define DoubleClickLimit 4 * _Dblclick
		
		Local lnRecno
		With Thisform
			Do Case
		
					* CR = same as double-click
		
				Case tnKeyCode = 13
		
					This.editpem()
					Nodefault
		
					* If we have a character keystroke, do an incremental search.
		
				Case Between(tnKeyCode, Asc(' '), 127)
		
					* Save some other things and set them the way we want.
		
					lnRecno = Recno()
		
					* If the user pressed BackSpace, delete the last character from the search
					* string (if there is one).
		
					Do Case
						Case tnKeyCode = 127 And Len(.cSearchString) > 0
							.cSearchString = Left(.cSearchString, Len(.cSearchString) ;
								- 1)
		
							* If the user is entering characters within the "double click" time period,
							* add them to the search string.
		
						Case Seconds() - .nKeyTime <= DoubleClickLimit
							.cSearchString = .cSearchString + Chr(tnKeyCode)
		
							* The search string is just the characters entered.
		
						Otherwise
							.cSearchString = Chr(tnKeyCode)
					Endcase
					.nKeyTime = Seconds()
		
					* Look for the search string: if we can't find it, try seeking on the
					* UPPER() function.
		
					Locate For Upper(cName) = Upper(.cSearchString)
					If Not Found()
						Go lnRecno
					Endif Not Found()
		
					* Refresh the column.
		
					This.ncurrentrecno = Recno()
					Thisform.SetProperties(.T.)
					Nodefault
		
					* If the user pressed Home, move to the first record.
		
				Case tnKeyCode = 1
					Go Top
					This.ncurrentrecno = Recno()
					Thisform.SetProperties(.T.)
					Nodefault
		
					* If the user pressed End, move to the last record.
		
				Case tnKeyCode = 6
					Go Bottom
					This.ncurrentrecno = Recno()
					Thisform.SetProperties(.T.)
					Nodefault
		
					*** Ctrl-Home
				Case tnKeyCode = 29 And tnShiftAltCtrl = 2
					Nodefault
		
					*** Ctrl-End
				Case tnKeyCode = 23 And tnShiftAltCtrl = 2
					Nodefault
		
					*** Ctrl-Up / UpArrow
				Case Inlist(tnKeyCode, 141, 31) And tnShiftAltCtrl = 2
					Nodefault
		
					*** Ctrl-Down / DnArrow
				Case Inlist(tnKeyCode, 145, 30) And tnShiftAltCtrl = 2
					NoDefault
					
			Endcase
		
		Endwith
		
		
	ENDPROC

	PROCEDURE Refresh
		Local Array laColumnWidths[1]
		Local Array laColumnOrder[1]
		Local loColumn As Object
		Local lcColumnOrder, lcColumnWidths, lnColumnOrder, lnColumnWidths, lnI, lnRecno
		
		With This
		
			If .lFirstTime
				.lFirstTime = .F.
				.FontName	= Nvl(Thisform.oPersist.Get('GridFontName'), ccFontSizeName)
				.FontSize	= Nvl(Thisform.oPersist.Get('GridFontSize'), Thisform.nFontSize)
				.RowHeight  = .RowHeight - 1
		
				* Restore grid column widths and order.
		
				lcColumnWidths = Nvl(Thisform.oPersist.Get('ColumnWidths'), [])
				lnColumnWidths = Alines(laColumnWidths, Alltrim (lcColumnWidths), .T., " ")
				If lnColumnWidths < 10
					Alines(laColumnWidths, " ", .T., " ")
				Endif lnColumnWidths < 10
				lcColumnOrder = Nvl(Thisform.oPersist.Get('ColumnOrder'), [])
				lnColumnOrder = Alines(laColumnOrder, Alltrim(lcColumnOrder), .T., " ")
				If lnColumnOrder < 11
					Alines(laColumnOrder, " ", .T., " ")
				Endif lnColumnOrder < 11
		
				For lnI = 1 To .ColumnCount
					loColumn = .Columns(lnI)
					If lnI <= lnColumnWidths 								;
							And Vartype(laColumnWidths[lnI]) = 'C' 			;
							And Vartype(Val(laColumnWidths[lnI])) = 'N'		;
							and Not Empty (laColumnWidths[lnI])
						loColumn.Width = Val(laColumnWidths[lnI])
					Else
						loColumn.Width = loColumn.nWidth
					Endif lnI <= lnColumnWidths ...
		
					If Thisform.lUseAbbreviations And Not Inlist(lnI, 1, 9, 10, 12, 13) And loColumn.Width >= loColumn.nWidth
						loColumn.Width = 25
					Endif
		
					If .ColumnCount = lnColumnOrder And Vartype(laColumnOrder[lnI]) = 'C' And ;
							vartype(Val(laColumnOrder[lnI])) = 'N'
						loColumn.ColumnOrder = Val(laColumnOrder[lnI])
					Endif lnI <= lnColumnOrder ...
				Next lnI
		
			Endif
		
			.SetColumnHeadings()
		
			*** JRN 12/11/2008 : constructions take care of when none are checked as well
			If Thisform.nMethodView = 1 && Or Thisform.nSelectedObjects > 1
				.ColAccess.Visible = Thisform.oPrefs.lTypeProperty Or Not (Thisform.oPrefs.lTypeMethod Or Thisform.oPrefs.lTypeEvent)
				.ColAssign.Visible = Thisform.oPrefs.lTypeProperty Or Not (Thisform.oPrefs.lTypeMethod Or Thisform.oPrefs.lTypeEvent)
				.ColValue.Visible = Thisform.oPrefs.lTypeProperty Or Not (Thisform.oPrefs.lTypeMethod Or Thisform.oPrefs.lTypeEvent)
				.ColMultValue.Visible = Thisform.oPrefs.lTypeProperty Or Not (Thisform.oPrefs.lTypeMethod Or Thisform.oPrefs.lTypeEvent)
				.ColCode.Visible = Thisform.oPrefs.lTypeMethod Or Thisform.oPrefs.lTypeEvent Or Not Thisform.oPrefs.lTypeProperty
			Else
				.ColAccess.Visible = .F.
				.ColAssign.Visible = .F.
				.ColValue.Visible = .F.
				.ColMultValue.Visible = .F.
				.ColCode.Visible = .T.
			Endif
		
			.ColName.Visible = Thisform.nMethodView = 1
			.ColMethodName.Visible = Thisform.nMethodView = 2
		
			.ColValue.Visible = .ColValue.Visible And Not Thisform.lEditingOneProperty
			.ColMultValue.Visible = .ColMultValue.Visible And Thisform.lEditingOneProperty
		
			.nCurrentRecno = Recno()
		
			If "O" = Type("Thisform.oMember") And Thisform.oMember.IsNewMember And Thisform.oMember.InteractiveChanged
				This.HighlightStyle = 1
			Endif
		
			If Thisform.lEditingOneProperty
				lnRecno = Recno()
				Thisform.LockScreen = .T.
				Replace All cValue With IIf (;
					cType = 'P', Thisform.GetValue(cName, lNative, 'Display', nObjNumber, cDescript), ;
					Thisform.GetMethodValue(lNonDefault, lHasCode))
				Try
					Goto (lnRecno)
				Catch
					Locate
				Endtry
				Thisform.LockScreen = .F.
			Endif
		
		Endwith
		
		DoDefault()
		
	ENDPROC

	PROCEDURE ColAccess.Header1.Click
		thisform.SortGrid( [IIF(lAccess, 'A', 'B')], [IIF(lAccess, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColAccess.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_AccessTip
		
		
		
	ENDPROC

	PROCEDURE ColAccess.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [IIF(lAccess, 'A', 'B')], [IIF(lAccess, 'B', 'A')], ccLOC_GCH_Access)
		
	ENDPROC

	PROCEDURE ColAssign.Header1.Click
		thisform.SortGrid( [IIF(lAssign, 'A', 'B')], [IIF(lAssign, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColAssign.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_AssignTip
		
	ENDPROC

	PROCEDURE ColAssign.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [IIF(lAssign, 'A', 'B')], [IIF(lAssign, 'B', 'A')], ccLOC_GCH_Assign)
		
	ENDPROC

	PROCEDURE ColCode.Header1.Click
		If Thisform.nMethodView = 1 or Thisform.nSelectedObjects > 1
			Thisform.SortGrid( [IIF(cType = 'P', 'Z', IIF(lHasCode, 'A', 'B'))], [IIF(cType = 'P', 'Z', IIF(lHasCode, 'B', 'A'))])
		Else
			Thisform.SortGrid( 			;
				[IIF(cType = 'P', '0', IIF(lNonDefault, '1', IIF(lHasCode, '2', IIF(Not lNative, '3', '4'))))]		;
				, [IIF(cType = 'P', '4', IIF(lNonDefault, '3', IIF(lHasCode, '2', IIF(Not lNative, '1', '0'))))]	;
				) 
		Endif
		
	ENDPROC

	PROCEDURE ColCode.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = Thisform.InsertFormOrClass( ccLOC_GCH_CodeOriginTip)
		
	ENDPROC

	PROCEDURE ColCode.Header1.RightClick
		If Thisform.nMethodView = 1 Or Thisform.nSelectedObjects > 1
			This.Parent.Parent.HeaderRightClick( [IIF(cType = 'P', 'Z', IIF(lHasCode, 'A', 'B'))], [IIF(cType = 'P', 'Z', IIFlHasCode, 'B', 'A'))], ccLOC_GCH_CodeOrigin)
		Else
			This.Parent.Parent.HeaderRightClick( 			;
				[IIF(cType = 'P', '0', IIF(lNonDefault, '1', IIF(lHasCode, '2', IIF(Not lNative, '3', '4'))))]		;
				, [IIF(cType = 'P', '4', IIF(lNonDefault, '3', IIF(lHasCode, '2', IIF(Not lNative, '1', '0'))))]	;
				, ccLOC_GCH_CodeOrigin)
		Endif
		
	ENDPROC

	PROCEDURE ColFavorite.Header1.Click
		thisform.SortGrid( [IIF(nFavorites # 1, 'A', 'B')], [IIF(nFavorites # 1, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColFavorite.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_FavoriteTip
		
		
	ENDPROC

	PROCEDURE ColFavorite.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [IIF(nFavorites # 1, 'A', 'B')], [IIF(nFavorites # 1, 'B', 'A')], ccLOC_GCH_Favorite)
		
	ENDPROC

	PROCEDURE ColHierarchy.Header1.Click
		thisform.SortGrid( [IIF(csrMembers.lNative,'C', IIF(csrMembers.lInherited,'B', 'A'))], [IIF(csrMembers.lNative,'A', IIF(csrMembers.lInherited,'B', 'C'))]) 
		
	ENDPROC

	PROCEDURE ColHierarchy.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = Thisform.InsertFormOrClass( ccLOC_GCH_HierarchyTip)
		
		
	ENDPROC

	PROCEDURE ColHierarchy.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [IIF(csrMembers.lNative,'C', IIF(csrMembers.lInherited,'B', 'A'))], [IIF(csrMembers.lNative,'A', IIF(csrMembers.lInherited,'B', 'C'))], ccLOC_GCH_Hierarchy)
		
	ENDPROC

	PROCEDURE ColMethodName.Header1.Click
		thisform.SortGrid( [CName], [Upper(CName)])
	ENDPROC

	PROCEDURE ColMethodName.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_NameTip
		
	ENDPROC

	PROCEDURE ColMethodName.Header1.RightClick
		This.Parent.Parent.HeaderRightClick ( [CName], [Upper(CName)], ccLOC_GCH_Name,.T.)
		
	ENDPROC

	PROCEDURE ColMultValue.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_ValueTip
		
	ENDPROC

	PROCEDURE ColName.Header1.Click
		thisform.SortGrid( [CName], [Upper(CName)])
	ENDPROC

	PROCEDURE ColName.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_NameTip
		
	ENDPROC

	PROCEDURE ColName.Header1.RightClick
		This.Parent.Parent.HeaderRightClick ( [CName], [Upper(CName)], ccLOC_GCH_Name,.T.)
		
	ENDPROC

	PROCEDURE ColNonDefault.Header1.Click
		thisform.SortGrid( [IIF(lNonDefault, 'A', 'B')], [IIF(lNonDefault, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColNonDefault.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_NonDefaultTip
		
		
	ENDPROC

	PROCEDURE ColNonDefault.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [IIF(lNonDefault, 'A', 'B')], [IIF(lNonDefault, 'B', 'A')], ccLOC_GCH_NonDefault)
		
	ENDPROC

	PROCEDURE ColType.Header1.Click
		thisform.SortGrid( [IIF(CType = 'P', 'A', IIF(CType = 'E', 'B', 'C'))], [IIF(CType = 'P', 'C', IIF(CType = 'E', 'B', 'A'))])
		
		
	ENDPROC

	PROCEDURE ColType.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_TypeTip
		
	ENDPROC

	PROCEDURE ColType.Header1.RightClick
		This.Parent.Parent.headerrightclick ( [IIF(CType = 'P', 'A', IIF(CType = 'E', 'B', 'C'))], [IIF(CType = 'P', 'E', IIF(CType = 'E', 'D', 'C'))], ccLOC_GCH_Type)
		
	ENDPROC

	PROCEDURE ColTypeIcon.Header1.Click
		thisform.SortGrid( [IIF(CType # 'P', 'A', 'B')], [IIF(CType = 'P', 'A', 'B')])
		
	ENDPROC

	PROCEDURE ColTypeIcon.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [IIF(CType # 'P', 'A', 'B')], [IIF(CType = 'P', 'A', 'B')])
		
	ENDPROC

	PROCEDURE ColValue.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_ValueTip
		
	ENDPROC

	PROCEDURE ColVisibility.Header1.Click
		Thisform.SortGrid( [Str(nVisibility,2,0)], [Str(9-nVisibility,2,0)])
		
	ENDPROC

	PROCEDURE ColVisibility.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_VisibilityTip
		
	ENDPROC

	PROCEDURE ColVisibility.Header1.RightClick
		This.Parent.Parent.HeaderRightClick( [Str(nVisibility,2,0)], [Str(9-nVisibility,2,0)], ccLOC_GCH_Visibility)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridobjects AS basegridmembers OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ColName.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColName.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.imgHolder" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: dynbackcolor
		*m: dynfontbold
		*m: dynfontitalic
		*m: dynvalue
		*m: handlepropertydblclick
		*m: handlepropertymouseup
		*m: handlepropertyrightclick
		*m: setuprow
		*p: capplicationpath
		*p: lavooidbufferoverrun
	*</DefinedPropArrayMethod>

	capplicationpath = 
	ColumnCount = 2
	Height = 101
	lavooidbufferoverrun = .F.
	MemberClass = "ObjectColumn"
	MemberClassLibrary = peme_basecontrols.prg
	Name = "gridobjects"
	Panel = 1
	RecordSource = "crsr_Grid"
	Width = 320
	Objectcolumn1.ColumnOrder = 2
	Objectcolumn1.ControlSource = ""
	Objectcolumn1.LFIXEDCOLUMN = .T.
	Objectcolumn1.Movable = .F.
	Objectcolumn1.Name = "ColName"
	Objectcolumn1.Width = 120
	Objectcolumn2.ColumnOrder = 1
	Objectcolumn2.ControlSource = ""
	Objectcolumn2.CurrentControl = "imgHolder"
	Objectcolumn2.DynamicFontShadow = "This.SetBMP()"
	Objectcolumn2.FontSize = 8
	Objectcolumn2.LFIXEDCOLUMN = .T.
	Objectcolumn2.Movable = .F.
	Objectcolumn2.Name = "ColTypeIcon"
	Objectcolumn2.ReadOnly = .T.
	Objectcolumn2.Resizable = .F.
	Objectcolumn2.Sparse = .F.
	Objectcolumn2.Width = 16

	ADD OBJECT 'ColName.Header1' AS header WITH ;
		Caption = "Object Name", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColName.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColTypeIcon.Header1' AS header WITH ;
		Caption = "", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColTypeIcon.imgHolder' AS image WITH ;
		Height = 17, ;
		Left = -86, ;
		Name = "imgHolder", ;
		Top = 54, ;
		Width = 100
		*< END OBJECT: BaseClass="image" />
	
	PROCEDURE dynbackcolor
		Lparameters loColumn
		
		This.SetupRow (loColumn, nObjNumber)
		Return IIF (loColumn.lExists, Rgb(255,255,255), Rgb(192,192,192))
		
	ENDPROC

	PROCEDURE dynfontbold
		Lparameters loColumn
		
		This.SetupRow (loColumn, nObjNumber)
		Return loColumn.lNonDefault and not loColumn.lReadOnly
		
	ENDPROC

	PROCEDURE dynfontitalic
		Lparameters loColumn
		
		This.SetupRow (loColumn, nObjNumber)
		Return loColumn.lReadOnly
		
	ENDPROC

	PROCEDURE dynvalue
		Lparameters loColumn
		
		If nObjNumber = 0
			Return 0
		Else
			This.SetupRow (loColumn, nObjNumber)
			Return Left(loColumn.cValue, 250)
		Endif
		
	ENDPROC

	PROCEDURE editpem
		Lparameters loCursor
		
		Local lcPem, lcExpression, loValue
		lcPem = Trim (loCursor.cName)
		
		loValue = Thisform.GetValue (lcPem, loCursor.lNative, 'For Editing', Thisform.nObjNumber)
		
		Do Case
		
			Case loCursor.cType $ 'ME'
				Thisform.EditMethodCode(lcPem, ThisForm.GetCurrentObject(ThisForm.nObjNumber))
		
			Case '[' $ lcPem Or '(' $ lcPem && Array
		
				****************************************************************
				* Cases where there is nothing to do, either not a property or is read only
		
				****************************************************************
				* Various varieties of editors; order is important
		
			Case This.DOPEPropertyEditors (lcPem, lcPem, loValue, loCursor.cDescript)
		
			Case This.PlugInPrg(lcPem, lcPem, loValue)
		
			Case This.IntrinsicPropertyEditors(lcPem, lcPem, loValue) && toggle and anchor editors
		
			Case This.NativePropertyHandler(lcPem, lcPem, loCursor.lNative, loValue, loCursor.cDescript)
		
			Case This.OldStylePropertyHandler(lcPem, loValue, loCursor.cScript)  && not recommended, but still available
		
			Otherwise
				This.Zoom(lcPem, Thisform.nObjNumber, loCursor.cDescript)
				This.RefreshControls()
		
		Endcase
		
		
	ENDPROC

	PROCEDURE handlepropertydblclick
		Local laEvents[1], lnObjNumber, loColumn, loCursor, loThis
		
		= Aevents (laEvents, 0)
		loThis		= laEvents[1]
		loColumn	= loThis.Parent
		lnObjNumber	= nObjNumber
		Thisform.nObjNumber = lnObjNumber
		
		This.SetupRow (loColumn, lnObjNumber, .T.)
		Scatter Name loCursor
		
		If Not loColumn.lExists
			Return
		Endif
		
		If loColumn.lReadOnly
			Return
		Endif
		
		loColumn.nCurrentObjNumber = 0 && attempt to cause value to be redisplayed
		Thisform.cEditPropertyName = Trim (loColumn.cPEMName)
		This.EditPem(loCursor)
		
		
	ENDPROC

	PROCEDURE handlepropertymouseup
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		Local loColumn AS Object
		Local loCursor AS Object
		Local loObject AS Object
		Local loThis AS Object
		Local laEvents(1), lcName, lnObjNumber
		
		= Aevents (laEvents, 0)
		loThis		= laEvents[1]
		loColumn	= loThis.Parent
		lnObjNumber	= nObjNumber
		Thisform.nObjNumber = lnObjNumber
		If lnObjNumber = 0
			Return
		EndIf 
		
		This.SetupRow (loColumn, lnObjNumber, .T.)
		Scatter Name loCursor
		
		If Not loColumn.lExists
			Return
		Endif
		
		loColumn.nCurrentObjNumber = 0 && attempt to cause value to be redisplayed
		loObject = Thisform.GetCurrentObject (lnObjNumber)
		Thisform.cEditPropertyName = Trim (loColumn.cPEMName)
		lcName = Trim(loCursor.cName)
		
		Do Case
		
				* ctrl click
			Case nButton = 1 And nShift = 2 And loCursor.cType $ 'ME'
				Thisform.ViewParentCode(lcName, 'Code',,loObject)
		
			Case nButton = 1 And nShift = 2 And loCursor.cType $ 'P'
				Thisform.ViewParentCode(lcName, 'Value',,loObject)
		
				* alt click
			Case nButton = 1 And nShift = 4
				Thisform.ViewParentCode('', 'Parentage',,loObject)
		
		Endcase
		
		
		
	ENDPROC

	PROCEDURE handlepropertyrightclick
		Local laEvents[1], lcChoice, lcPEM, lnBar, lnObjNumber, loColumn, loCursor, loObject, loThis
		
		= Aevents (laEvents, 0)
		loThis				= laEvents[1]
		loColumn			= loThis.Parent
		lnObjNumber			= nObjNumber
		Thisform.nObjNumber	= lnObjNumber
		
		This.SetupRow (loColumn, lnObjNumber, .T.)
		Scatter Name loCursor
		
		loObject				   = Thisform.GetCurrentObject (lnObjNumber)
		lcPEM					   = loColumn.cPEMName
		Thisform.cEditPropertyName = Trim (loColumn.cPEMName)
		loColumn.nCurrentObjNumber = 0 && attempt to cause value to be redisplayed
		
		****************************************************************
		Thisform.CreateContextMenu ('GridContextMenu')
		lnBar = 0
		
		****************************************************************
		If loColumn.lExists And Not loColumn.lReadOnly
		
			lnBar = lnBar + 1
			If loColumn.cType $ 'ME'
				Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_EDIT_METHOD
				On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Edit'
			Else
				Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_Zoom
				On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Edit'
			Endif
		
			If loColumn.lNonDefault
				lnBar = lnBar + 1
				Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_ResetToDefault
				On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'ResetToDefault'
			Endif
		
			If loColumn.cOrigin = 'C'
				lnBar = lnBar + 1
				Define Bar (lnBar) Of GridContextMenu Prompt ccLOC_CMG_REMOVE
				On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Remove PEM'
			Endif
		
		Endif
		
		****************************************************************
		If lnBar # 0
			lnBar = lnBar + 1
			Define Bar (lnBar) Of GridContextMenu Prompt '\-'
		Endif
		
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt 'Remove this column'
		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Remove this column'
		
		****************************************************************
		lcChoice = ''
		Activate Popup GridContextMenu
		Release Popups GridContextMenu
		
		****************************************************************
		****************************************************************
		
		Do Case
		
			Case Empty (lcChoice)
		
			Case lcChoice = 'Remove this column'
				Thisform.RemoveColumn (loColumn)
		
			Case lcChoice = 'Edit'
				This.EditPem (loCursor)
		
			Case lcChoice = 'ResetToDefault'
				loObject.ResetToDefault (lcPEM)
		
			Case lcChoice = 'Remove this column PEM'
				Removeproperty (loObject, lcPEM)
		
		Endcase
		
		loColumn.nCurrentObjNumber = 0 && attempt to cause value to be redisplayed
		
	ENDPROC

	PROCEDURE handlerightclick
		* Nothing
	ENDPROC

	PROCEDURE headerrightclick
		Local laEvents[1], lnBar, lnObjNumber, loColumn, loCursor, loThis
		
		= Aevents (laEvents, 0)
		loThis				= laEvents[1]
		loColumn			= loThis.Parent
		lnObjNumber			= nObjNumber
		Thisform.nObjNumber	= lnObjNumber
		
		This.SetupRow (loColumn, lnObjNumber, .T.)
		Scatter Name loCursor
		
		****************************************************************
		Thisform.CreateContextMenu ('GridContextMenu')
		lnBar = 0
		
		* find out what row we're over
		lnBar = lnBar + 1
		Define Bar (lnBar) Of GridContextMenu Prompt 'Remove this column'
		On Selection Bar (lnBar) Of GridContextMenu lcChoice = 'Remove this column'
		
		Activate Popup GridContextMenu
		Release Popups GridContextMenu
		
		****************************************************************
		****************************************************************
		
		Do Case
		
			Case Empty (lcChoice)
		
			Case lcChoice = 'Remove this column'
				Thisform.RemoveColumn(loColumn)
		
		Endcase
		
		
	ENDPROC

	PROCEDURE refreshcontrols
		* Do Nothing
	ENDPROC

	PROCEDURE setbmp
		Local loControl As Object
		Local loTopOfForm As Object
		Local lcBMPName, lcFile, lcObject, lcPath, loObject
		
		loControl = Thisform.GetCurrentObject (nObjNumber)
		
		If 'O' = Vartype (loControl)
			lcBMPName = Lower (loControl.BaseClass)
		Endif
		
		lcPath = Thisform.cApplicationPath + 'images\'
		lcFile = lcPath + Evl (lcBMPName, '') + '.bmp'
		If Not File (lcFile)
			lcFile = ''
		Endif
		
		This.colTypeIcon.imgHolder.Picture = lcFile
		
		Return .F.
		
	ENDPROC

	PROCEDURE setuprow
		Lparameters loColumn, tnObjNumber, tlGetDescription
		
		Local laLines[1], lcPEM, llChanged, llReadOnly, lnRow, loObject
		
		If tnObjNumber = 0
			With loColumn
				.lExists	 = .F.
				.lHasCode	 = .F.
				.lNonDefault = .F.
				.lReadonly	 = .F.
				.cValue		 = ''
				.cOrigin	 = ' '
				.cType		 = ' '
			Endwith
			Return
		Endif
		
		With loColumn
			If .nCurrentObjNumber # tnObjNumber
				loObject = Thisform.GetCurrentObject (tnObjNumber)
				lcPEM	 = .cPEMName
		
				If 'O' = Vartype (loObject) And Thisform.GetPEMStatus (loObject, lcPEM, 5)
					.lExists = .T.
					.cOrigin = IIf ( Not Thisform.GetPEMStatus (loObject, lcPEM, 4), 'N', IIf (Thisform.GetPEMStatus (loObject, lcPEM, 6), 'I', 'C'))
					.cType	 = Left (Thisform.GetPEMStatus (loObject, lcPEM, 3), 1)
		
					llChanged  = Thisform.GetPEMStatus (loObject, lcPEM, 0)
					llReadOnly = Thisform.GetPEMStatus (loObject, lcPEM, 1)
					.lChanged  = llChanged
		
					Do Case
						Case .cType $ 'P'
							.lNonDefault = llChanged Or .cOrigin = 'C'
							.lHasCode	 =  .F.
							.lReadonly	 =  llReadOnly
		
							.cValue		 = Transform (Getpem (loObject, lcPEM))
							If 'C' = Vartype (.cValue) And 0 = Len (.cValue)
								.cValue = '(None)'
							Endif
						Case llChanged
							.lNonDefault =  Not Empty (loObject.ReadMethod (lcPEM))
							.lHasCode	 =  llChanged Or .cOrigin = 'C'
							.lReadonly	 =  llReadOnly
							Do Case
								Case .lNonDefault
									.cValue = '[User Procedure]'
								Case .lHasCode
									.cValue = '[Inherited]'
								Otherwise
									.cValue = ''
							Endcase
						Otherwise
							.lNonDefault =  .F.
							.lHasCode	 =  .F.
							.lReadonly	 =  llReadOnly
							.cValue		 =  ' '
					Endcase
				Else
					.lExists	 = .F.
					.lHasCode	 = .F.
					.lNonDefault = .F.
					.lReadonly	 = .F.
					.cValue		 = ''
					.cOrigin	 = ' '
					.cType		 = ' '
				Endif
		
				.nCurrentObjNumber = tnObjNumber
			Endif
		
			If tlGetDescription 
				loObject = Thisform.GetCurrentObject (tnObjNumber)
				lcPEM	 = .cPEMName
		
				Replace										;
						cName	 With  .cPEMName			;
						lNative	 With  .cOrigin = 'N'		;
						cType	 With  .cType
		
				If Not Thisform.lAvoidBufferOverrun
					*** JRN 04/08/2009 : oops .. this fails on grids in Version 8
					Try
						Amembers ( laLines, loObject, 3 )
					Catch
					Endtry
		
					If Alen (laLines) >= 4
						lnRow = Ascan ( laLines, lcPEM, 1, -1, 1, 15 )
						If lnRow > 0
							Replace cDescript With laLines[ lnRow, 4 ]
						Endif
					Endif
				Endif
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE ColName.Text1.DblClick
		Thisform.HandleNameDoubleClick()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridpastemembers AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ColName.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColName.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColType.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColType.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColAccess.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColAccess.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColAssign.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColAssign.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColVisibility.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColVisibility.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColHierarchy.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColHierarchy.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColFavorite.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColFavorite.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColNonDefault.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColNonDefault.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColTypeIcon.imgHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColValue.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColValue.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCode.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCode.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColSelect.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColSelect.Basecheckbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColSelect.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColNew.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColNew.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCurValue.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ColCurValue.Text1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: getvalue
		*m: headerrightclick
		*m: setbmp
		*m: setcolumnheadings
		*p: lfirsttime
		*p: nanchor
		*p: ncurrentrecno
	*</DefinedPropArrayMethod>

	ColumnCount = 14
	DeleteMark = .F.
	FontSize = 8
	GridLines = 0
	Height = 276
	HighlightRow = .F.
	lfirsttime = .T.
	Name = "gridpastemembers"
	nanchor = 15
	ncurrentrecno = 0
	Panel = 1
	RecordMark = .F.
	RecordSource = "csrMembers"
	RecordSourceType = 1
	RowHeight = 17
	SplitBar = .F.
	TabIndex = 1
	Width = 484
	ZOrderSet = 0
	Column1.ColumnOrder = 4
	Column1.ControlSource = "csrMembers.cName"
	Column1.DynamicFontBold = "csrMembers.lSelect"
	Column1.FontSize = 8
	Column1.Name = "ColName"
	Column1.ReadOnly = .T.
	Column1.Width = 120
	Column2.Alignment = 2
	Column2.ColumnOrder = 9
	Column2.ControlSource = "(ThisForm.SpellType(csrMembers.cType))"
	Column2.DynamicFontBold = "csrMembers.lSelect"
	Column2.FontSize = 8
	Column2.Name = "ColType"
	Column2.ReadOnly = .T.
	Column2.Width = 70
	Column3.Alignment = 2
	Column3.ColumnOrder = 10
	Column3.ControlSource = "(ThisForm.SpellYes(csrMembers.lAccess))"
	Column3.DynamicFontBold = "csrMembers.lSelect"
	Column3.FontSize = 8
	Column3.Name = "ColAccess"
	Column3.ReadOnly = .T.
	Column3.Width = 50
	Column4.Alignment = 2
	Column4.ColumnOrder = 11
	Column4.ControlSource = "(ThisForm.SpellYes(csrMembers.lAssign))"
	Column4.DynamicFontBold = "csrMembers.lSelect"
	Column4.FontSize = 8
	Column4.Name = "ColAssign"
	Column4.ReadOnly = .T.
	Column4.Width = 45
	Column5.Alignment = 2
	Column5.ColumnOrder = 12
	Column5.ControlSource = "(Thisform.SpellVisibility (csrMembers.nVisibility))"
	Column5.DynamicFontBold = "csrMembers.lSelect"
	Column5.FontSize = 8
	Column5.Name = "ColVisibility"
	Column5.ReadOnly = .T.
	Column5.Width = 60
	Column6.Alignment = 2
	Column6.ColumnOrder = 8
	Column6.ControlSource = "(Thisform.SpellHierarchy(csrMembers.lNative, csrMembers.lInherited))"
	Column6.DynamicFontBold = "csrMembers.lSelect"
	Column6.FontSize = 8
	Column6.Name = "ColHierarchy"
	Column6.ReadOnly = .T.
	Column6.Width = 60
	Column7.Alignment = 2
	Column7.ColumnOrder = 13
	Column7.ControlSource = "(ThisForm.SpellFavorites(csrMembers.nFavorites))"
	Column7.DynamicFontBold = "csrMembers.lSelect"
	Column7.FontSize = 8
	Column7.Name = "ColFavorite"
	Column7.ReadOnly = .T.
	Column7.Width = 55
	Column8.Alignment = 2
	Column8.ColumnOrder = 14
	Column8.ControlSource = "(ThisForm.SpellYes(csrMembers.lNonDefault))"
	Column8.DynamicFontBold = "csrMembers.lSelect"
	Column8.FontSize = 8
	Column8.Name = "ColNonDefault"
	Column8.ReadOnly = .T.
	Column8.Visible = .F.
	Column8.Width = 59
	Column9.ColumnOrder = 3
	Column9.ControlSource = ""
	Column9.CurrentControl = "imgHolder"
	Column9.DynamicFontShadow = "This.SetBMP()"
	Column9.FontSize = 8
	Column9.Name = "ColTypeIcon"
	Column9.ReadOnly = .T.
	Column9.Sparse = .F.
	Column9.Width = 16
	Column10.ColumnOrder = 5
	Column10.ControlSource = "csrMembers.cValue"
	Column10.CurrentControl = "Text1"
	Column10.DynamicFontBold = "csrMembers.lSelect"
	Column10.FontSize = 8
	Column10.Name = "ColValue"
	Column10.ReadOnly = .T.
	Column10.Width = 120
	Column11.Alignment = 2
	Column11.ColumnOrder = 7
	Column11.ControlSource = "(Thisform.SpellYes(lHasCode and cType # 'P'))"
	Column11.DynamicFontBold = "csrMembers.lSelect"
	Column11.FontSize = 8
	Column11.Name = "ColCode"
	Column11.ReadOnly = .T.
	Column11.Width = 50
	Column12.ColumnOrder = 1
	Column12.ControlSource = "csrMembers.lSelect"
	Column12.FontSize = 8
	Column12.Name = "ColSelect"
	Column12.Sparse = .F.
	Column12.Width = 30
	Column13.Alignment = 2
	Column13.ColumnOrder = 2
	Column13.ControlSource = "(Thisform.SpellYes(lNew))"
	Column13.FontSize = 8
	Column13.Name = "ColNew"
	Column13.ReadOnly = .T.
	Column13.Width = 30
	Column14.ColumnOrder = 6
	Column14.ControlSource = "csrMembers.cCurValue"
	Column14.FontSize = 8
	Column14.Name = "ColCurValue"
	Column14.ReadOnly = .T.
	Column14.Width = 129

	ADD OBJECT 'ColAccess.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Access", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColAccess.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColAssign.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Assign", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColAssign.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColCode.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Code", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColCode.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColCurValue.Header1' AS header WITH ;
		Caption = "Current Value", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColCurValue.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColFavorite.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Favorite", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColFavorite.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColHierarchy.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Origin", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColHierarchy.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColName.Header1' AS header WITH ;
		Caption = "Name", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColName.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ControlSource = "csrMembers.cName", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColNew.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "New?", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColNew.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColNonDefault.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Non-Default", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColNonDefault.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T., ;
		Visible = .F.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColSelect.Basecheckbox1' AS basecheckbox WITH ;
		Alignment = 2, ;
		Caption = "", ;
		FontSize = 8, ;
		Left = 23, ;
		lupdatecontrolsourceonchange = .T., ;
		Name = "Basecheckbox1", ;
		Top = 55
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'ColSelect.Header1' AS header WITH ;
		Caption = " ", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColSelect.Label1' AS label WITH ;
		Caption = "", ;
		Height = 17, ;
		Left = 19, ;
		Name = "Label1", ;
		Top = 44, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'ColType.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Type", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColType.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColTypeIcon.Header1' AS header WITH ;
		Caption = " ", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColTypeIcon.imgHolder' AS image WITH ;
		Height = 16, ;
		Left = 57, ;
		Name = "imgHolder", ;
		Picture = ..\images\propty.bmp, ;
		Top = 83, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'ColValue.Header1' AS header WITH ;
		Caption = "New Value", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColValue.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T., ;
		Value = 'abcv'
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'ColVisibility.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Visibility", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'ColVisibility.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE getvalue
		Lparameters lnRow
		
		lcType = Thisform.oServer.aCopiedProperties (lnRow, ccPasteTypeCol)
		lcValue = Thisform.oServer.aCopiedProperties (lnRow, ccPasteValueCol)
		
		Do Case
			Case lcType = 'M'
				Return '[User Procedure]'
			Case lcType = 'X'
				Return ''
			Case 'C' = Vartype (lcValue) And Empty (lcValue)
				Return '(None)'
			Otherwise
				Return Left(Transform(lcValue), 100)
		Endcase
		
	ENDPROC

	PROCEDURE headerrightclick
	ENDPROC

	PROCEDURE Init
		Local lcBackColorSuffix, lcBgColor, lcDynBackColor, lcDynForeColor, lcFgColor, lcForeColorSuffix
		
		With This
		
			.SetColumnHeadings()
		
			If PEME_IsVersion9()
				.Anchor = .nAnchor
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE setbmp
		Local  ;
			loControl As Object
		Local lcBMPName, lcFile, lcPath
		
		Do Case
			Case Thisform.lEditingOneProperty
				If Between (nObjNumber, 1, Alen (Thisform.aSelectedObjects))
					loControl = Thisform.aSelectedObjects(nObjNumber)
					If 'O' = Vartype (loControl)
						lcBMPName = Lower(loControl.BaseClass)
					Endif
				Endif
			Case cType = 'P'
				lcBMPName = Iif (nVisibility = 1, 'Propty', Iif(nVisibility = 2, 'PropProt', 'PropHidden'))
			Case cType = 'M'
				lcBMPName = Iif (nVisibility = 1, 'Method', Iif(nVisibility = 2, 'MethodProt', 'MethodHidden'))
			Otherwise
				lcBMPName = 'Event'
		Endcase
		
		lcPath = ThisForm.cApplicationPath + "images\"
		lcFile = lcPath + Evl (lcBMPName, '') + ".bmp"
		If Not File(lcFile)
			lcFile = ''
		Endif
		
		This.colTypeIcon.imgHolder.Picture = lcFile
		
		Return .F.
		
	ENDPROC

	PROCEDURE setcolumnheadings
		Local llUseAbbreviations
		
		With This
		
			llUseAbbreviations = Thisform.lUseAbbreviations 
		
			.Columns[ 1].Header1.Caption = IIF(Thisform.lEditingOneProperty, ccLOC_GCH_Control ,ccLOC_GCH_Name)
			.Columns[ 2].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_TypeA,       ccLOC_GCH_Type)
			.Columns[ 3].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_AccessA,     ccLOC_GCH_Access)
			.Columns[ 4].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_AssignA,     ccLOC_GCH_Assign)
			.Columns[ 5].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_VisibilityA, ccLOC_GCH_Visibility)
			.Columns[ 6].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_HierarchyA,  ccLOC_GCH_Hierarchy)
			.Columns[ 7].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_FavoriteA,   ccLOC_GCH_Favorite)
			.Columns[ 8].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_NonDefaultA, ccLOC_GCH_NonDefault)
			.Columns[ 9].Header1.Caption = " "
			.Columns[10].Header1.Caption = IIF(Thisform.lEditingOneProperty, Thisform.cEditPropertyName, ccLOC_GCH_Value)
			.Columns[11].Header1.Caption = Iif(llUseAbbreviations, ccLOC_GCH_CodeOriginA, ccLOC_GCH_CodeOrigin)
		
		Endwith
		
		
	ENDPROC

	PROCEDURE ColAccess.Header1.Click
		thisform.SortGrid( [IIF(lAccess, 'A', 'B')], [IIF(lAccess, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColAccess.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_AccessTip
		
		
		
	ENDPROC

	PROCEDURE ColAssign.Header1.Click
		thisform.SortGrid( [IIF(lAssign, 'A', 'B')], [IIF(lAssign, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColAssign.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_AssignTip
		
	ENDPROC

	PROCEDURE ColCode.Header1.Click
		If Thisform.nMethodView = 1 or Thisform.nSelectedObjects > 1
			Thisform.SortGrid( [IIF(cType = 'P', 'Z', IIF(lHasCode, 'A', 'B'))], [IIF(cType = 'P', 'Z', IIF(lHasCode, 'B', 'A'))])
		Else
			Thisform.SortGrid( 			;
				[IIF(cType = 'P', '0', IIF(lNonDefault, '1', IIF(lHasCode, '2', IIF(Not lNative, '3', '4'))))]		;
				, [IIF(cType = 'P', '4', IIF(lNonDefault, '3', IIF(lHasCode, '2', IIF(Not lNative, '1', '0'))))]	;
				) 
		Endif
		
	ENDPROC

	PROCEDURE ColCode.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = Thisform.InsertFormOrClass( ccLOC_GCH_CodeOriginTip)
		
	ENDPROC

	PROCEDURE ColFavorite.Header1.Click
		thisform.SortGrid( [IIF(nFavorites # 1, 'A', 'B')], [IIF(nFavorites # 1, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColFavorite.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_FavoriteTip
		
		
	ENDPROC

	PROCEDURE ColHierarchy.Header1.Click
		thisform.SortGrid( [IIF(csrMembers.lNative,'C', IIF(csrMembers.lInherited,'B', 'A'))], [IIF(csrMembers.lNative,'A', IIF(csrMembers.lInherited,'B', 'C'))]) 
		
	ENDPROC

	PROCEDURE ColHierarchy.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = Thisform.InsertFormOrClass( ccLOC_GCH_HierarchyTip)
		
		
	ENDPROC

	PROCEDURE ColName.Header1.Click
		thisform.SortGrid( [CName], [Upper(CName)])
	ENDPROC

	PROCEDURE ColName.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_NameTip
		
	ENDPROC

	PROCEDURE ColNew.Header1.Click
		thisform.SortGrid( [IIF(lNew, 'A', 'B')], [IIF(lNew, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColNonDefault.Header1.Click
		thisform.SortGrid( [IIF(lNonDefault, 'A', 'B')], [IIF(lNonDefault, 'B', 'A')])
		
	ENDPROC

	PROCEDURE ColNonDefault.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_NonDefaultTip
		
		
	ENDPROC

	PROCEDURE ColSelect.Basecheckbox1.anychange
		This.Parent.Parent.Refresh()
	ENDPROC

	PROCEDURE ColSelect.Header1.Click
		Thisform.SortGrid( [IIF(lSelect 'C', IIF(lSelect, lSelect], [IIF(lReadOnly, 'C', IIF(lSelect, 'B', 'A'))])
		
	ENDPROC

	PROCEDURE ColType.Header1.Click
		thisform.SortGrid( [IIF(CType = 'P', 'A', IIF(CType = 'E', 'B', 'C'))], [IIF(CType = 'P', 'C', IIF(CType = 'E', 'B', 'A'))])
		
		
	ENDPROC

	PROCEDURE ColType.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_TypeTip
		
	ENDPROC

	PROCEDURE ColTypeIcon.Header1.Click
		thisform.SortGrid( [IIF(CType # 'P', 'A', 'B')], [IIF(CType = 'P', 'A', 'B')])
		
	ENDPROC

	PROCEDURE ColValue.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_ValueTip
		
	ENDPROC

	PROCEDURE ColVisibility.Header1.Click
		Thisform.SortGrid( [Str(nVisibility,2,0)], [Str(9-nVisibility,2,0)])
		
	ENDPROC

	PROCEDURE ColVisibility.Header1.MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = ccLOC_GCH_VisibilityTip
		
	ENDPROC

ENDDEFINE

DEFINE CLASS highlightercombobox AS basecombobox OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: sethighlights
		*p: nrow
	*</DefinedPropArrayMethod>

	BoundColumn = 2
	ControlSource = "Thisform.oCallingForm.aGridHighlighting[This.nRow, 1]"
	Name = "highlightercombobox"
	nrow = 0
	RowSource = "This.aItems"
	RowSourceType = 5
	
	PROCEDURE Init
		with This
			dimension .aItems[5, 2]
			.aItems[1, 1] = ccLOC_STR_NONE
			.aItems[1, 2] = 'None'
			.aItems[2, 1] = ccLOC_STR_FORECOLOR
			.aItems[2, 2] = 'ForeColor'
			.aItems[3, 1] = ccLOC_STR_BACKCOLOR
			.aItems[3, 2] = 'BackColor'
			.aItems[4, 1] = ccLOC_STR_BOLD
			.aItems[4, 2] = 'Bold'
			.aItems[5, 1] = ccLOC_STR_ITALIC
			.aItems[5, 2] = 'Italic'
		EndWith
		
		
	ENDPROC

	PROCEDURE Refresh
		This.SetHighlights()
		
	ENDPROC

	PROCEDURE sethighlights
		local lcValue
		with This
			.ForeColor  = rgb(0, 0, 0)
			.BackColor  = rgb(255, 255, 255)
			.FontBold   = .F.
			.FontItalic = .F.
			lcValue     = Thisform.oCallingForm.aGridHighlighting[This.nRow, 1]
			do case
				case lcValue = 'ForeColor'
					This.ForeColor = val(Thisform.oCallingForm.aGridHighlighting[This.nRow, 2])
				case lcValue = 'BackColor'
					This.BackColor = val(Thisform.oCallingForm.aGridHighlighting[This.nRow, 2])
				case lcValue = 'Bold'
					This.FontBold = .T.
				case lcValue = 'BackColor'
					This.ForeItalic = .T.
			endcase	
		endwith
		
	ENDPROC

	PROCEDURE Valid
		Thisform.SaveHighLightSettings()
		This.SetHighlights()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS highlightercommandbutton AS basecommandbutton OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*p: nrow
	*</DefinedPropArrayMethod>

	Caption = ""
	Height = 23
	Name = "highlightercommandbutton"
	nrow = 0
	Picture = ..\images\color2_16x16.bmp
	Width = 32
	
	PROCEDURE Click
		Local lnColor, lnNewColor
		lnColor = Val(Thisform.oCallingForm.aGridHighlighting[This.nRow, 2])
		lnNewColor = Getcolor(lnColor)
		If lnNewColor < 0
			Return
		Endif lnNewColor < 0
		Thisform.oCallingForm.aGridHighlighting[This.nRow, 2] = Transform(lnNewColor)
		Thisform.SaveHighLightSettings()
		With Thisform.oCallingForm
			.SetGridHighlighting()
			.cntGridControls.Refresh()
		Endwith
		Thisform.RefreshForm()
		
	ENDPROC

	PROCEDURE Refresh
		This.Visible = inlist(Thisform.oCallingForm.aGridHighlighting[This.nRow, 1], "ForeColor", "BackColor")
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS listzoom AS baseformnew OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFont" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baseeditbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstZoom" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: isnativecolor
		*m: isuserdefined
		*m: str2val		&& Attempt to convert the character string in the zoom window to the appropriate data type
		*p: cdescription
		*p: cpem		&& a Property to save the PEM passed to the form in its init
		*p: lonlyone		&& If .T., then only set the value for the object passed as the parameter; otherwise, use ASelObj to indicate which objects to change
		*p: ncombovalue
		*p: nreturnvalue
		*p: oobject		&& Object reference to the thing open in the designer
		*a: acombolist[1,0]
	*</DefinedPropArrayMethod>

	Caption = "Zoom"
	cdescription = 
	cfoxuserid = NEWLISTZOOM
	cfoxusername = NewListZoom
	cpem = 		&& a Property to save the PEM passed to the form in its init
	Desktop = .T.
	DoCreate = .T.
	Height = 166
	KeyPreview = .T.
	lonlyone = .F.		&& If .T., then only set the value for the object passed as the parameter; otherwise, use ASelObj to indicate which objects to change
	lpersistsizeposition = .T.
	lsavesettings = .T.
	MinHeight = 90
	MinWidth = 260
	Name = "listzoom"
	ncombovalue = 0
	nreturnvalue = .F.
	oobject = .NULL.		&& Object reference to the thing open in the designer
	Width = 260
	WindowType = 1
	changefontsize.Left = 225
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 10

	ADD OBJECT 'Baseeditbox1' AS baseeditbox WITH ;
		ControlSource = "Thisform.cDescription", ;
		Height = 50, ;
		IntegralHeight = .F., ;
		Left = 6, ;
		Name = "Baseeditbox1", ;
		nanchor = 14, ;
		ReadOnly = .T., ;
		TabIndex = 3, ;
		Top = 81, ;
		Width = 247
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		FontBold = .T., ;
		FontSize = 9, ;
		Height = 17, ;
		Left = 12, ;
		Name = "Baselabel1", ;
		TabIndex = 1, ;
		Top = 6, ;
		Width = 40
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cmdCancel' AS basecommandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 89, ;
		Name = "cmdCancel", ;
		nanchor = 260, ;
		TabIndex = 5, ;
		Top = 139
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdFont' AS basecommandbutton WITH ;
		Caption = "Font...", ;
		Left = 173, ;
		Name = "cmdFont", ;
		nanchor = 36, ;
		TabIndex = 6, ;
		Top = 139
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS basecommandbutton WITH ;
		Caption = "OK", ;
		Default = .T., ;
		Left = 6, ;
		Name = "cmdOK", ;
		nanchor = 132, ;
		TabIndex = 4, ;
		Top = 139
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lstZoom' AS baselistbox WITH ;
		BoundColumn = 2, ;
		BoundTo = .T., ;
		ColumnCount = 1, ;
		ColumnLines = .F., ;
		ControlSource = "Thisform.nComboValue", ;
		Height = 50, ;
		IntegralHeight = .F., ;
		Left = 6, ;
		Name = "lstZoom", ;
		nanchor = 15, ;
		RowSource = "Thisform.aComboList", ;
		RowSourceType = 5, ;
		TabIndex = 2, ;
		Top = 25, ;
		Width = 247
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="listbox" />
	
	PROCEDURE getvalue
		Lparameters lcName, tbNative, tcResultType
		
		Local lcPem, lbFirst, lcValue, lxValue, lcNewValue, lxNewValue, lnRed, lnGreen, lnBlue
		Local loObject, lbTransform, laDesignerObjects(1), lnI, loResult
		
		*** JRN 03/18/2009 : Slightly modified version of inherited code
		*   Uses Thisform.lOnlyOne and AselObj in next few lines, else the same
		lcPem = Thisform.JustPEM(lcName)
		lbTransform = .T.
		*** JRN 11/14/2008 : ReadExpression; handles problem of '='
		
		If Not Thisform.lOnlyOne
			lbFirst = .T.
			Aselobj(laDesignerObjects)
			For lnI = 1 To Alen (laDesignerObjects)
				loObject = laDesignerObjects(lnI)
				Do Case
					Case Not Thisform.GetPEMStatus (loObject, lcPem, 5)
		
					Case lbFirst
						lcValue = loObject.ReadExpression (lcPem)
						lxValue = This.Get1Value (loObject, lcPem)
						lbFirst = .F.
					Otherwise
						lcNewValue = loObject.ReadExpression (lcPem)
						lxNewValue = This.Get1Value (loObject, lcPem)
						If (Not lcValue == lcNewValue)							;
								or Vartype (lxValue) # Vartype (lxNewValue)		;
								or lxValue # lxNewValue
							lcValue = ' '
							lbTransform = .F.
							Exit
						Endif
				Endcase
			Endfor
		Else
			lcValue = Thisform.oObject.ReadExpression (lcPem)
			lxValue = This.Get1Value (Thisform.oObject, lcPem)
		Endif
		
		If lbTransform And Empty (lcValue)
			Do Case
					* handle null values
				Case Isnull(lxValue)
					lcValue = '.NULL.'
					* Special handling for native colors
				Case 'N' = Vartype (lxValue) And Thisform.IsNativeColor(lcPem, tbNative)
					lnRed   = Bitand(lxValue, 255)
					lnGreen = Bitrshift(Bitand(lxValue, 256 * 255), 8)
					lnBlue  = Bitrshift(Bitand(lxValue, 256 * 256 * 255), 16)
					lcValue = Transform(lnRed) + ',' + Transform(lnGreen) + ',' + Transform(lnBlue)
				Case 'C' = Vartype (lxValue) And 0 = Len(lxValue) And tcResultType= 'Display'
					lcValue = '(None)'
				Case 'D' # Vartype (lxValue)
					lcValue = Transform( lxValue )
				Case Empty (lxValue)
					lcValue = '{}'
				Otherwise
					lcValue = '{^' + Transform(Year(lxValue)) + "/" + Transform(Month(lxValue)) + "/" + Transform(Day(lxValue)) + "}"
			Endcase
		Endif
		
		Do Case
			Case tcResultType= 'Display'
				Return Left (lcValue, 100)
			Case tcResultType= 'Full Value'
				Return lcValue
			Case tcResultType= 'For Editing'
				loResult = Createobject("Empty")
				AddProperty (loResult, "Value", lxValue)
				AddProperty (loResult, "CharValue", lcValue)
				AddProperty (loResult, "Type", lcTypes)
				AddProperty (loResult, "SingleValue", lbTransform)
				Return loResult
		Endcase
		
	ENDPROC

	PROCEDURE Init
		Lparameters tcPem,		;
			taValues,			;
			tnValue,			;
			tnFontSize,			;
			tcDescription
		
		Local lnHeight, lnLeft, lnTop, lnWidth, lnZoomFontSize
		External Array taValues
		
		With This
			.cPEM      = tcPem
			.MinHeight = .Height
			.MinWidth  = .Width
			.Caption   = ccLOC_CAP_ZOOM + tcPem
		
			Do Case
				Case Empty(tcDescription)
					.cDescription = ''
				Case 0 # At('***', tcDescription)
					.cDescription = Left( tcDescription, At('***', tcDescription) - 1) 
				Otherwise
					.cDescription = tcDescription
			Endcase
		
			If Not Empty (tnFontSize) And tnFontSize # 8
				.ChangeFontSize.Run(tnFontSize, 8)
			Endif
		
			DoDefault()
		
			.Height = .MinHeight * Evl(tnFontSize, 8) / 8
		
			* Restore the saved font?
			.RestoreFont(.lstZoom)
		
			Dimension .aComboList(Alen (taValues,1),2)
			For lnI = 1 To Alen (taValues,1)
				.aComboList(lnI,1) = taValues (lnI,2)
				.aComboList(lnI,2) = taValues (lnI,1)
			Next lnI
		
			With This.lstzoom
				.RowSource = .RowSource
				.ListIndex = .ListCount
				Do While ( .TopIndex != 1 )
					.Height = .Height + 4
					This.Height = This.Height + 4
					.ListIndex = 1
					.ListIndex = .ListCount
				Enddo
			Endwith
		
			.nComboValue = tnValue
		
			.Refresh()
		
		Endwith
		
	ENDPROC

	PROCEDURE isnativecolor
		Lparameters tcName, tbNative
		
		Return tbNative and InList (tcName,	;
			  'BackColor', 					;
			  'ForeColor', 					;
			  'BorderColor', 				;
			  'DisabledBackColor', 			;
			  'DisabledForeColor', 			;
			  'DisabledItemBackColor', 		;
			  'DisabledItemForeColor', 		;
			  'FillColor', 					;
			  'GridLineColor', 				;
			  'HighlightBackColor', 		;
			  'HighlightForeColor', 		;
			  'ItemBackColor', 				;
			  'ItemForeColor', 				;
			  'SelectedItemBackColor',		;
			  'SelectedItemForeColor'		;
			  )
			  
		
	ENDPROC

	PROCEDURE isuserdefined
		Lparameters loObject, lcPem
		
		Local lbResult
		
		Try
			lbResult = Thisform.GetPEMStatus( This.oObject, lcPem, 4 )
		Catch
			lbResult = .F.
		Endtry
		
		Return lbResult
		
	ENDPROC

	PROCEDURE KeyPress
		Lparameters tnKeyCode, tnShiftAltCtrl
		
		Do Case
			Case tnKeyCode=13
				Thisform.cmdOK.SetFocus()
				Thisform.cmdOK.Click()
			Otherwise
				DoDefault(tnKeyCode, tnShiftAltCtrl)
		Endcase
		
		
		
	ENDPROC

	PROCEDURE setdefaults
		Local loObject As Object
		Local lcStyle
		
		loObject = This.lstZoom
		lcStyle = IIf(loObject.FontBold, 'B', '') + IIf(loObject.FontItalic, 'I', '')
		
		.cFontName = loObject.FontName
		.nFontSize = loObject.FontSize
		.cFontStyle = lcStyle
		
	ENDPROC

	PROCEDURE str2val		&& Attempt to convert the character string in the zoom window to the appropriate data type
		lparameters tcStr
		local luRetVal
		do case
			case inlist(upper(alltrim(tcStr)), [.T.], [.F.])
			luRetVal = tcStr = [.T.]
			case chrtran(tcStr, chrtran(tcStr, [0123456789], []), []) = tcStr
				luRetVal = int(val(tcStr))
			otherwise
				luRetVal = tcStr
		endcase
		return luRetVal
		
	ENDPROC

	PROCEDURE Unload
		Return this.nReturnValue 
	ENDPROC

	PROCEDURE Baselabel1.Refresh
		This.Caption = Thisform.cPEM
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Release()
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = ccLOC_CAP_CANCEL
		dodefault()
		
	ENDPROC

	PROCEDURE cmdFont.Click
		Thisform.ChangeFont(This.lstZoom)
		
	ENDPROC

	PROCEDURE cmdFont.Init
		This.Caption = ccLOC_CAP_FONT
		dodefault()
		
	ENDPROC

	PROCEDURE cmdOK.Click
		If "N" = Vartype (Thisform.nComboValue)
			Thisform.nReturnValue = Int(Thisform.nComboValue)
		Else
			Thisform.nReturnValue = Thisform.nComboValue
		Endif
		
		Thisform.Release()
		
	ENDPROC

	PROCEDURE cmdOK.Init
		This.Caption = ccLOC_CAP_OK
		dodefault()
		
	ENDPROC

	PROCEDURE lstZoom.DblClick
		Thisform.cmdOK.Click()
	ENDPROC

ENDDEFINE

DEFINE CLASS refreshtimer AS timer 
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: resetinterval
		*p: iregularinterval
		*p: itraceinterval
	*</DefinedPropArrayMethod>

	Height = 23
	iregularinterval = 1000
	itraceinterval = 15000
	Name = "refreshtimer"
	Width = 23
	
	PROCEDURE resetinterval
		If Wvisible(ccLOC_WINDOW_TRACE) Or  ;
				WVISIBLE(ccLOC_WINDOW_DEBUGGER) Or ;
				WVISIBLE(ccLOC_WINDOW_CALL_STACK) Or ;
				WVISIBLE(ccLOC_WINDOW_WATCH) Or ;
				WVISIBLE(ccLOC_WINDOW_LOCALS)
		
			If This.Interval # This.iTraceInterval
				This.iRegularInterval = This.Interval
				This.Interval = This.iTraceInterval
			Endif
		
		Else
		
			If This.Interval = This.iTraceInterval
				This.Interval = This.iRegularInterval
			Endif
			This.iRegularInterval = This.Interval
		
		Endif
		
		
	ENDPROC

	PROCEDURE Timer
		This.ResetInterval()
	ENDPROC

ENDDEFINE

DEFINE CLASS spinnerzoom AS baseform OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baseeditbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="spnValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel2" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: getdecimalplaces
		*m: getdigits
		*m: isnativecolor
		*m: isuserdefined
		*m: str2val		&& Attempt to convert the character string in the zoom window to the appropriate data type
		*p: cdescription
		*p: cpem		&& a Property to save the PEM passed to the form in its init
		*p: lonlyone		&& If .T., then only set the value for the object passed as the parameter; otherwise, use ASelObj to indicate which objects to change
		*p: ncombovalue
		*p: nmaxvalue
		*p: nminvalue
		*p: nreturnvalue
		*p: nspinnervalue
		*p: oobject		&& Object reference to the thing open in the designer
		*a: acombolist[1,0]
	*</DefinedPropArrayMethod>

	Caption = "Spinner Zoom"
	cdescription = 
	cfoxuserid = NEWSPINNERZOOM
	cfoxusername = NewSpinnerZoom
	cpem = 		&& a Property to save the PEM passed to the form in its init
	Desktop = .T.
	DoCreate = .T.
	Height = 148
	KeyPreview = .T.
	lonlyone = .F.		&& If .T., then only set the value for the object passed as the parameter; otherwise, use ASelObj to indicate which objects to change
	lpersistsizeposition = .T.
	lsavesettings = .T.
	MinHeight = 90
	MinWidth = 260
	Name = "spinnerzoom"
	ncombovalue = 0
	nmaxvalue = 0
	nminvalue = 0
	nreturnvalue = .F.
	nspinnervalue = 0
	oobject = .NULL.		&& Object reference to the thing open in the designer
	Width = 260
	WindowType = 1
	changefontsize.Left = 225
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 10

	ADD OBJECT 'Baseeditbox1' AS baseeditbox WITH ;
		ControlSource = "Thisform.cDescription", ;
		Height = 50, ;
		IntegralHeight = .F., ;
		Left = 6, ;
		Name = "Baseeditbox1", ;
		nanchor = 14, ;
		ReadOnly = .T., ;
		TabIndex = 3, ;
		Top = 63, ;
		Width = 247
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		FontBold = .T., ;
		FontSize = 9, ;
		Height = 17, ;
		Left = 12, ;
		Name = "Baselabel1", ;
		TabIndex = 1, ;
		Top = 6, ;
		Width = 40
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Baselabel2' AS baselabel WITH ;
		FontSize = 9, ;
		Height = 17, ;
		Left = 106, ;
		Name = "Baselabel2", ;
		TabIndex = 1, ;
		Top = 33, ;
		Width = 40
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cmdCancel' AS basecommandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 89, ;
		Name = "cmdCancel", ;
		nanchor = 260, ;
		TabIndex = 5, ;
		Top = 121
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS basecommandbutton WITH ;
		Caption = "OK", ;
		Default = .T., ;
		Left = 6, ;
		Name = "cmdOK", ;
		nanchor = 132, ;
		TabIndex = 4, ;
		Top = 121
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'spnValue' AS basespinner WITH ;
		ControlSource = "Thisform.nSpinnerValue", ;
		Left = 30, ;
		Name = "spnValue", ;
		TabIndex = 2, ;
		Top = 30, ;
		Width = 65
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="spinner" />
	
	PROCEDURE getdecimalplaces
		* Added: 06/15/2009
		*========================
		Lparameters lnValue
		Local lcValue, lnDot
		
		lcValue = Transform (lnValue)
		lnDot = At (".", lcValue)
		If lnDot = 0
			Return 0
		Else
			Return Len (lcValue) - lnDot
		Endif
		
		
	ENDPROC

	PROCEDURE getdigits
		* Added: 06/15/2009
		*========================
		Lparameters lnValue
		Local lcValue, lnDot
		
		Return Len (Transform (Int(lnValue)))
		
		
	ENDPROC

	PROCEDURE getvalue
		Lparameters lcName, tbNative, tcResultType
		
		Local lcPem, lbFirst, lcValue, lxValue, lcNewValue, lxNewValue, lnRed, lnGreen, lnBlue
		Local loObject, lbTransform, laDesignerObjects(1), lnI, loResult
		
		*** JRN 03/18/2009 : Slightly modified version of inherited code
		*   Uses Thisform.lOnlyOne and AselObj in next few lines, else the same
		lcPem = Thisform.JustPEM(lcName)
		lbTransform = .T.
		*** JRN 11/14/2008 : ReadExpression; handles problem of '='
		
		If Not Thisform.lOnlyOne
			lbFirst = .T.
			Aselobj(laDesignerObjects)
			For lnI = 1 To Alen (laDesignerObjects)
				loObject = laDesignerObjects(lnI)
				Do Case
					Case Not Thisform.GetPEMStatus (loObject, lcPem, 5)
		
					Case lbFirst
						lcValue = loObject.ReadExpression (lcPem)
						lxValue = This.Get1Value (loObject, lcPem)
						lbFirst = .F.
					Otherwise
						lcNewValue = loObject.ReadExpression (lcPem)
						lxNewValue = This.Get1Value (loObject, lcPem)
						If (Not lcValue == lcNewValue)							;
								or Vartype (lxValue) # Vartype (lxNewValue)		;
								or lxValue # lxNewValue
							lcValue = ' '
							lbTransform = .F.
							Exit
						Endif
				Endcase
			Endfor
		Else
			lcValue = Thisform.oObject.ReadExpression (lcPem)
			lxValue = This.Get1Value (Thisform.oObject, lcPem)
		Endif
		
		If lbTransform And Empty (lcValue)
			Do Case
					* handle null values
				Case Isnull(lxValue)
					lcValue = '.NULL.'
					* Special handling for native colors
				Case 'N' = Vartype (lxValue) And Thisform.IsNativeColor(lcPem, tbNative)
					lnRed   = Bitand(lxValue, 255)
					lnGreen = Bitrshift(Bitand(lxValue, 256 * 255), 8)
					lnBlue  = Bitrshift(Bitand(lxValue, 256 * 256 * 255), 16)
					lcValue = Transform(lnRed) + ',' + Transform(lnGreen) + ',' + Transform(lnBlue)
				Case 'C' = Vartype (lxValue) And 0 = Len(lxValue) And tcResultType= 'Display'
					lcValue = '(None)'
				Case 'D' # Vartype (lxValue)
					lcValue = Transform( lxValue )
				Case Empty (lxValue)
					lcValue = '{}'
				Otherwise
					lcValue = '{^' + Transform(Year(lxValue)) + "/" + Transform(Month(lxValue)) + "/" + Transform(Day(lxValue)) + "}"
			Endcase
		Endif
		
		Do Case
			Case tcResultType= 'Display'
				Return Left (lcValue, 100)
			Case tcResultType= 'Full Value'
				Return lcValue
			Case tcResultType= 'For Editing'
				loResult = Createobject("Empty")
				AddProperty (loResult, "Value", lxValue)
				AddProperty (loResult, "CharValue", lcValue)
				AddProperty (loResult, "Type", lcTypes)
				AddProperty (loResult, "SingleValue", lbTransform)
				Return loResult
		Endcase
		
	ENDPROC

	PROCEDURE Init
		Lparameters 			;
			tcPem,				;
			tnValue,			;
			tnMinValue,			;
			tnMaxValue,			;
			tnIncrement,		;
			tnFontSize,			;
			tcDescription
		
		With This
		
			.cPEM      = tcPem
			.MinHeight = .Height
			.MinWidth  = .Width
			.Caption   = ccLOC_CAP_ZOOM + tcPem
		
			.nMinValue = tnMinValue
			.nMaxValue = tnMaxValue
		
			With .spnValue
				.Increment = Evl (tnIncrement, 1)
		
				.KeyboardLowValue = Floor (tnMinValue)
				.KeyboardHighValue = Ceiling (tnMaxValue)
		
				.SpinnerLowValue = Floor (tnMinValue * 100) / 100
				.SpinnerHighValue = Ceiling (tnMaxValue * 100) / 100
				
				lnDigits = Max ( This.GetDigits(tnMinValue), This.GetDigits(tnMaxValue)) 
				lnDecimalPlaces = Max ( This.GetDecimalPlaces(tnMinValue), This.GetDecimalPlaces(tnMaxValue), This.GetDecimalPlaces(tnIncrement))
				.InputMask = Replicate ("9", lnDigits) + Iif (lnDecimalPlaces = 0, '', "." + Replicate ("9", lnDecimalPlaces))
			Endwith
		
			.nSpinnerValue = tnValue
		
			Do Case
				Case Empty(tcDescription)
					.cDescription = ''
				Case 0 # At('***', tcDescription)
					.cDescription = Left( tcDescription, At('***', tcDescription) - 1) 
				Otherwise
					.cDescription = tcDescription
			Endcase
		
			If Not Empty (tnFontSize) And tnFontSize # 8
				.ChangeFontSize.Run(tnFontSize, 8)
			Endif
		
			DoDefault()
		
			.Height = .MinHeight * Evl(tnFontSize, 8) / 8
		
		Endwith
		
	ENDPROC

	PROCEDURE isnativecolor
		Lparameters tcName, tbNative
		
		Return tbNative and InList (tcName,	;
			  'BackColor', 					;
			  'ForeColor', 					;
			  'BorderColor', 				;
			  'DisabledBackColor', 			;
			  'DisabledForeColor', 			;
			  'DisabledItemBackColor', 		;
			  'DisabledItemForeColor', 		;
			  'FillColor', 					;
			  'GridLineColor', 				;
			  'HighlightBackColor', 		;
			  'HighlightForeColor', 		;
			  'ItemBackColor', 				;
			  'ItemForeColor', 				;
			  'SelectedItemBackColor',		;
			  'SelectedItemForeColor'		;
			  )
			  
		
	ENDPROC

	PROCEDURE isuserdefined
		Lparameters loObject, lcPem
		
		Local lbResult
		
		Try
			lbResult = Thisform.GetPEMStatus( This.oObject, lcPem, 4 )
		Catch
			lbResult = .F.
		Endtry
		
		Return lbResult
		
	ENDPROC

	PROCEDURE KeyPress
		Lparameters tnKeyCode, tnShiftAltCtrl
		
		Do Case
			Case tnKeyCode=13
				Thisform.cmdOK.SetFocus()
				Thisform.cmdOK.Click()
			Otherwise
				DoDefault(tnKeyCode, tnShiftAltCtrl)
		Endcase
		
		
		
	ENDPROC

	PROCEDURE str2val		&& Attempt to convert the character string in the zoom window to the appropriate data type
		lparameters tcStr
		local luRetVal
		do case
			case inlist(upper(alltrim(tcStr)), [.T.], [.F.])
			luRetVal = tcStr = [.T.]
			case chrtran(tcStr, chrtran(tcStr, [0123456789], []), []) = tcStr
				luRetVal = int(val(tcStr))
			otherwise
				luRetVal = tcStr
		endcase
		return luRetVal
		
	ENDPROC

	PROCEDURE Unload
		Return this.nReturnValue 
	ENDPROC

	PROCEDURE Baselabel1.Refresh
		This.Caption = Thisform.cPEM
	ENDPROC

	PROCEDURE Baselabel2.Refresh
		This.Caption = '(' + Transform(Thisform.nminvalue) + ' - ' + Transform(Thisform.nmaxvalue) + ')'
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Release()
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = ccLOC_CAP_CANCEL
		dodefault()
		
	ENDPROC

	PROCEDURE cmdOK.Click
		If Between(Thisform.nSpinnerValue, Thisform.nMinValue, Thisform.nMaxValue)
			Thisform.nReturnValue = Thisform.nSpinnerValue
			Thisform.Release()
		Endif
		
	ENDPROC

	PROCEDURE cmdOK.Init
		This.Caption = ccLOC_CAP_OK
		dodefault()
		
	ENDPROC

	PROCEDURE spnValue.RangeHigh
		Return Min (Thisform.nMaxvalue, This.Value)
		
	ENDPROC

	PROCEDURE spnValue.RangeLow
		Return Max (Thisform.nMinvalue, This.Value)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS zoomdialog AS baseformnew OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="edtZoom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFont" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baseeditbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: isnativecolor
		*m: isuserdefined
		*m: str2val		&& Attempt to convert the character string in the zoom window to the appropriate data type
		*p: cdescription
		*p: cpem		&& a Property to save the PEM passed to the form in its init
		*p: lonlyone		&& If .T., then only set the value for the object passed as the parameter; otherwise, use ASelObj to indicate which objects to change
		*p: oobject		&& Object reference to the thing open in the designer
		*p: otopofform
	*</DefinedPropArrayMethod>

	Caption = "Zoom"
	cdescription = 
	cfoxuserid = NEWZOOM
	cfoxusername = NewZoom
	cpem = 		&& a Property to save the PEM passed to the form in its init
	Desktop = .T.
	DoCreate = .T.
	Height = 166
	KeyPreview = .T.
	lonlyone = .F.		&& If .T., then only set the value for the object passed as the parameter; otherwise, use ASelObj to indicate which objects to change
	lpersistsizeposition = .T.
	lsavesettings = .T.
	MinHeight = 90
	MinWidth = 260
	Name = "zoomdialog"
	oobject = .NULL.		&& Object reference to the thing open in the designer
	otopofform = .F.
	Width = 260
	WindowType = 1
	changefontsize.Left = 225
	changefontsize.Name = "changefontsize"
	changefontsize.Top = 10

	ADD OBJECT 'Baseeditbox1' AS baseeditbox WITH ;
		ControlSource = "Thisform.cDescription", ;
		Height = 50, ;
		IntegralHeight = .F., ;
		Left = 6, ;
		Name = "Baseeditbox1", ;
		nanchor = 14, ;
		ReadOnly = .T., ;
		TabIndex = 3, ;
		Top = 81, ;
		Width = 247
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		FontBold = .T., ;
		FontSize = 9, ;
		Height = 17, ;
		Left = 12, ;
		Name = "Baselabel1", ;
		TabIndex = 1, ;
		Top = 6, ;
		Width = 40
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'cmdCancel' AS basecommandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 89, ;
		Name = "cmdCancel", ;
		nanchor = 260, ;
		TabIndex = 5, ;
		Top = 139
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdFont' AS basecommandbutton WITH ;
		Caption = "Font...", ;
		Left = 173, ;
		Name = "cmdFont", ;
		nanchor = 36, ;
		TabIndex = 6, ;
		Top = 139
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS basecommandbutton WITH ;
		Caption = "OK", ;
		Default = .T., ;
		Left = 6, ;
		Name = "cmdOK", ;
		nanchor = 132, ;
		TabIndex = 4, ;
		Top = 139
		*< END OBJECT: ClassLib="peme_basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtZoom' AS defaulteditbox WITH ;
		AllowTabs = .T., ;
		Height = 50, ;
		IntegralHeight = .F., ;
		Left = 6, ;
		luseintellisensex = .T., ;
		Name = "edtZoom", ;
		nanchor = 15, ;
		TabIndex = 2, ;
		Top = 25, ;
		Width = 247
		*< END OBJECT: ClassLib="editproperty.vcx" BaseClass="editbox" />
	
	PROCEDURE Activate
		*!* * Removed 8/2/2012 / JRN
		*!* Local lcPem, lbNative, lcValue
		
		*!* lcPem = This.cPEM
		*!* lbNative = Thisform.IsNativeColor(lcPem, This.IsUserDefined( This.oObject, lcPem))
		*!* lcValue = Thisform.GetValue(lcPem, lbNative,  'Full Value')
		
		*!* This.edtZoom.Value = lcValue
		
	ENDPROC

	PROCEDURE getvalue
		Lparameters lcName, tbNative, tcResultType
		
		Local lcPem, lbFirst, lcValue, lxValue, lcNewValue, lxNewValue, lnRed, lnGreen, lnBlue
		Local loObject, lbTransform, laDesignerObjects(1), lnI, loResult
		
		*** JRN 03/18/2009 : Slightly modified version of inherited code
		*   Uses Thisform.lOnlyOne and AselObj in next few lines, else the same
		lcPem = Thisform.JustPEM(lcName)
		lbTransform = .T.
		*** JRN 11/14/2008 : ReadExpression; handles problem of '='
		
		If Not Thisform.lOnlyOne
			lbFirst = .T.
			Aselobj(laDesignerObjects)
			For lnI = 1 To Alen (laDesignerObjects)
				loObject = laDesignerObjects(lnI)
				Do Case
					Case Not Thisform.GetPEMStatus (loObject, lcPem, 5)
		
					Case lbFirst
						lcValue = loObject.ReadExpression (lcPem)
						lxValue = This.Get1Value (loObject, lcPem)
						lbFirst = .F.
					Otherwise
						lcNewValue = loObject.ReadExpression (lcPem)
						lxNewValue = This.Get1Value (loObject, lcPem)
						If (Not lcValue == lcNewValue)							;
								or Vartype (lxValue) # Vartype (lxNewValue)		;
								or lxValue # lxNewValue
							lcValue = ' '
							lbTransform = .F.
							Exit
						Endif
				Endcase
			Endfor
		Else
			lcValue = Thisform.oObject.ReadExpression (lcPem)
			lxValue = This.Get1Value (Thisform.oObject, lcPem)
		Endif
		
		If lbTransform And Empty (lcValue)
			Do Case
					* handle null values
				Case Isnull(lxValue)
					lcValue = '.NULL.'
					* Special handling for native colors
				Case 'N' = Vartype (lxValue) And Thisform.IsNativeColor(lcPem, tbNative)
					lnRed   = Bitand(lxValue, 255)
					lnGreen = Bitrshift(Bitand(lxValue, 256 * 255), 8)
					lnBlue  = Bitrshift(Bitand(lxValue, 256 * 256 * 255), 16)
					lcValue = Transform(lnRed) + ',' + Transform(lnGreen) + ',' + Transform(lnBlue)
				Case 'C' = Vartype (lxValue) And 0 = Len(lxValue) And tcResultType= 'Display'
					lcValue = '(None)'
				Case 'D' # Vartype (lxValue)
					lcValue = Transform( lxValue )
				Case Empty (lxValue)
					lcValue = '{}'
				Otherwise
					lcValue = '{^' + Transform(Year(lxValue)) + "/" + Transform(Month(lxValue)) + "/" + Transform(Day(lxValue)) + "}"
			Endcase
		Endif
		
		Do Case
			Case tcResultType= 'Display'
				Return Left (lcValue, 100)
			Case tcResultType= 'Full Value'
				Return lcValue
			Case tcResultType= 'For Editing'
				loResult = Createobject("Empty")
				AddProperty (loResult, "Value", lxValue)
				AddProperty (loResult, "CharValue", lcValue)
				AddProperty (loResult, "Type", lcTypes)
				AddProperty (loResult, "SingleValue", lbTransform)
				Return loResult
		Endcase
		
	ENDPROC

	PROCEDURE Init
		Lparameters toObject, 	;
		    toTopOfForm,        ;
			tcPEM,				;
			tlOnlyOne,			;
			tnFontSize,			;
			tcDescription
		
		Local lnHeight, lnLeft, lnTop, lnWidth, lnZoomFontSize
		
		
		With This
			.cPEM      = tcPEM
			.oObject   = toObject
			.oTopOfForm= toTopOfForm
			.lOnlyOne  = tlOnlyOne or Pcount() <= 2
			.MinHeight = .Height
			.MinWidth  = .Width
			.Caption   = ccLOC_CAP_ZOOM + tcPEM
			.cDescription = Evl(tcDescription, '')
		
			If Not Empty (tnFontSize)
				.ChangeFontSize.Run(tnFontSize, 8)
			Endif
		
			DoDefault()
		
			* Restore the saved font?
			.RestoreFont(.edtZoom)
		
			.Refresh()
		
		Endwith
		
		Local lcPem, lbNative, lcValue
		
		lcPem = This.cPEM
		lbNative = Thisform.IsNativeColor(lcPem, This.IsUserDefined( This.oObject, lcPem))
		lcValue = Thisform.GetValue(lcPem, lbNative,  'Full Value')
		
		This.edtZoom.Value = lcValue
		
	ENDPROC

	PROCEDURE isnativecolor
		Lparameters tcName, tbNative
		
		Return tbNative and InList (tcName,	;
			  'BackColor', 					;
			  'ForeColor', 					;
			  'BorderColor', 				;
			  'DisabledBackColor', 			;
			  'DisabledForeColor', 			;
			  'DisabledItemBackColor', 		;
			  'DisabledItemForeColor', 		;
			  'FillColor', 					;
			  'GridLineColor', 				;
			  'HighlightBackColor', 		;
			  'HighlightForeColor', 		;
			  'ItemBackColor', 				;
			  'ItemForeColor', 				;
			  'SelectedItemBackColor',		;
			  'SelectedItemForeColor'		;
			  )
			  
		
	ENDPROC

	PROCEDURE isuserdefined
		Lparameters loObject, lcPem
		
		Local lbResult
		
		Try
			lbResult = Thisform.GetPEMStatus( This.oObject, lcPem, 4 )
		Catch
			lbResult = .F.
		Endtry
		
		Return lbResult
		
	ENDPROC

	PROCEDURE KeyPress
		Lparameters tnKeyCode, tnShiftAltCtrl
		
		Do Case
			Case tnKeyCode=13
				Thisform.cmdOK.SetFocus()
				Thisform.cmdOK.Click()
			Otherwise
				DoDefault(tnKeyCode, tnShiftAltCtrl)
		Endcase
		
		
		
	ENDPROC

	PROCEDURE setdefaults
		Local loObject As Object
		Local lcStyle
		
		loObject = This.edtZoom
		lcStyle = IIf(loObject.FontBold, 'B', '') + IIf(loObject.FontItalic, 'I', '')
		
		.cFontName = loObject.FontName
		.nFontSize = loObject.FontSize
		.cFontStyle = lcStyle
		
	ENDPROC

	PROCEDURE str2val		&& Attempt to convert the character string in the zoom window to the appropriate data type
		lparameters tcStr
		local luRetVal
		do case
			case inlist(upper(alltrim(tcStr)), [.T.], [.F.])
			luRetVal = tcStr = [.T.]
			case chrtran(tcStr, chrtran(tcStr, [0123456789], []), []) = tcStr
				luRetVal = int(val(tcStr))
			otherwise
				luRetVal = tcStr
		endcase
		return luRetVal
		
	ENDPROC

	PROCEDURE Baselabel1.Refresh
		This.Caption = Thisform.cPEM
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Release()
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = ccLOC_CAP_CANCEL
		dodefault()
		
	ENDPROC

	PROCEDURE cmdFont.Click
		Thisform.ChangeFont(Thisform.edtZoom)
		
	ENDPROC

	PROCEDURE cmdFont.Init
		This.Caption = ccLOC_CAP_FONT
		dodefault()
		
	ENDPROC

	PROCEDURE cmdOK.Click
		Local lxValue
		
		With Thisform
			lxValue = Iif ( Inlist (Upper (.cPem), ccCharacterProperties), .edtZoom.Value, .edtZoom.xValue)
		Endwith
		
		If Thisform.lOnlyOne And Not Thisform.CheckForNewProperty (lxValue, Thisform.cPem, ThisForm.oObject, Thisform.oTopOfForm)
			Return
		Endif
		
		With Thisform
			.UpdateSelectedControls (.oObject, .cPem, lxValue, .lOnlyOne)
		Endwith
		
		Thisform.Release()
		
	ENDPROC

	PROCEDURE cmdOK.Init
		This.Caption = ccLOC_CAP_OK
		dodefault()
		
	ENDPROC

	PROCEDURE edtZoom.RightClick
		*** JRN 11/20/2008 : Creation of context menu moved to method CreateContextMenu
		Local loThis, lnBar
		loThis = this
		
		lnBar = 0
		ThisForm.CreateContextMenu("EditContextMenu")
		
		lnBar = lnBar + 1
		Define Bar _Med_undo Of EditContextMenu Prompt ccLOC_MENU_UNDO ;
			Skip For Skpbar("_MEDIT", _Med_undo) ;
			PictRes _Med_undo
		
		lnBar = lnBar + 1
		Define Bar _Med_cut Of EditContextMenu Prompt ccLOC_MENU_CUT ;
			Skip For Skpbar("_MEDIT", _Med_cut) ;
			PictRes _Med_cut
		
		lnBar = lnBar + 1
		Define Bar _Med_copy Of EditContextMenu Prompt ccLOC_MENU_COPY ;
			Skip For Skpbar("_MEDIT", _Med_copy) ;
			PictRes _Med_copy
		
		lnBar = lnBar + 1
		Define Bar _Med_paste Of EditContextMenu Prompt ccLOC_MENU_PASTE ;
			Skip For Skpbar("_MEDIT", _Med_paste) ;
			PictRes _Med_paste
		
		lnBar = lnBar + 1
		Define Bar _Med_clear Of EditContextMenu Prompt ccLOC_MENU_CLEAR ;
			Skip For Skpbar("_MEDIT", _Med_clear) ;
			PictRes _Med_clear
		
		lnBar = lnBar + 1
		Define Bar 6 Of EditContextMenu Prompt "\-"
		
		lnBar = lnBar + 1
		Define Bar _Med_slcta Of EditContextMenu Prompt ccLOC_MENU_SELECT_ALL ;
			Skip For Skpbar("_MEDIT", _Med_slcta) ;
			PictRes _Med_slcta
			
		*!*	lnBar = lnBar + 1
		*!*	Define Bar (lnBar) Of EditContextMenu Prompt ccLOC_CAP_FONT
		*!*	On Selection Bar (lnBar) Of EditContextMenu loThis.SetFont()
		
		Activate Popup EditContextMenu
		
		Release Popups EditContextMenu
		
	ENDPROC

	PROCEDURE edtZoom.setxvalue
		*** JRN 11/11/2008 : Store default value into This.xValue
		*  converted from character to logical, etc.
		*  Note that values beginning with '=' are later stored with WriteExpression instead
		Local m.vNewVal, lcPem
		
		m.vNewVal = This.Value
		lcPem = ThisForm.cPEM
		
		If "C" = Vartype (m.vNewVal)
			This.xValue = This.Str2Val( m.vNewVal, Thisform.IsNativeColor(lcPem, ThisForm.IsUserDefined( ThisForm.oObject, lcPem)))
		Else
			This.xValue = m.vNewVal
		Endif
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS zoomdialogsearch AS zoomdialog OF "editproperty.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	cfoxuserid = NEWZOOMSEARCH
	cfoxusername = NewZoomSearch
	DoCreate = .T.
	Name = "zoomdialogsearch"
	changefontsize.Name = "changefontsize"
	edtZoom.Name = "edtZoom"
	CMDOK.Name = "CMDOK"
	CMDCANCEL.Name = "CMDCANCEL"
	CMDFONT.Name = "CMDFONT"
	Baseeditbox1.Name = "Baseeditbox1"
	Baselabel1.Name = "Baselabel1"

ENDDEFINE
