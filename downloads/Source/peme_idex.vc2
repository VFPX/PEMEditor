*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="peme_idex.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pemeditor_idex AS basecustom OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addmrumenus
		*m: addopenfiles
		*m: addopenmrufavorites
		*m: addopenmrumenuitems
		*m: addopenmruwindows
		*m: addvfpmrus
		*m: closeallhandles
		*m: createfavoritesmenu
		*m: createmrumenu
		*m: createopenmenu
		*m: createopenmrumenu
		*m: createsystemmenu
		*m: createwindowsmenu
		*m: dynamicsnippet
		*m: editthorproc
		*m: endcontrolstructure
		*m: enhancedcutcopy
		*m: extracttomethod
		*m: findwith
		*m: getcssfile
		*m: getcurrenthighlightedtext
		*m: getdisplayrelativepath
		*m: gethtmlheader
		*m: gethtmlmainheader
		*m: gotodef
		*m: gotodefcreateobject
		*m: gotodefcurlybraces
		*m: gotodeffindclass
		*m: gotodeffindclassinpath
		*m: gotodeffindconstant
		*m: gotodeffindfile
		*m: gotodeffindprogram
		*m: gotodefineclass
		*m: gotodefinition
		*m: gotodeflocal
		*m: gotodeflocateline
		*m: gotodefnewobject
		*m: gotodefprocessinclude
		*m: gotodefprocessprg
		*m: gotodefprocessprgforclass
		*m: gotodefprocessvcxforclass
		*m: gotoisxclassdefinition
		*m: highlightcontrolstructure
		*m: movewindow
		*m: navigatehandles
		*m: pasteandpositioncursor
		*m: processopenmrumenuitems
		*m: quickaddmethod
		*m: quickaddpem
		*m: removequotes
		*m: savehandlehistory
		*m: setonkeylabel
		*m: setonkeylabels
		*p: capplication
		*p: capplicationpath
		*p: cpluginpath
		*p: csnippetpath
		*p: csourcefilename
		*p: csourcepath
		*p: lclass
		*p: lresetprevnexthistory
		*p: nlefthighlightpos
		*p: nrighthighlightpos
		*p: obeautifyx
		*p: odoctreeview
		*p: odynamicsnippet
		*p: oeditorwin
		*p: opemeditor
		*p: oprefs
		*p: oserver
		*p: outils
		*a: ahandlehistory[1,0]
		*a: aproclines[1,0]
	*</DefinedPropArrayMethod>

	HIDDEN Height,HelpContextID,Init
	capplication = .F.
	capplicationpath = 
	cpluginpath = .F.
	csnippetpath = 
	csourcefilename = 
	csourcepath = 
	lclass = .F.
	lresetprevnexthistory = .T.
	Name = "pemeditor_idex"
	nlefthighlightpos = 0
	nrighthighlightpos = 0
	obeautifyx = .NULL.
	odoctreeview = .NULL.
	odynamicsnippet = .NULL.
	oeditorwin = .NULL.
	opemeditor = .NULL.
	oprefs = .NULL.
	oserver = .NULL.
	outils = .NULL.
	_memberdata = <VFPData>
		<memberdata name="capplicationpath" display="cApplicationPath"/>
		<memberdata name="csourcepath" display="cSourcePath"/>
		<memberdata name="csnippetpath" display="cSnippetPath"/>
		<memberdata name="opemeditor" display="oPEMEditor"/>
		<memberdata name="odoctreeview" display="oDocTreeview"/>
		<memberdata name="odynamicsnippet" display="oDynamicSnippet"/>
		<memberdata name="oeditorwin" display="oEditorWin"/>
		<memberdata name="oserver" display="oServer"/>
		<memberdata name="obeautifyx" display="oBeautifyX"/>
		<memberdata name="addmrufile" display="AddMRUFile"/>
		<memberdata name="getcssfile" display="GetCSSFile"/>
		<memberdata name="gethtmlheader" display="GetHTMLHeader"/>
		<memberdata name="showhelp" display="ShowHelp"/>
		<memberdata name="oprefs" display="oPrefs"/>
		<memberdata name="cpluginpath" display="cPluginPath"/>
		<memberdata name="capplication" display="cApplication"/>
		<memberdata name="createopenmrumenu" display="CreateOpenMRUMenu"/>
		<memberdata name="addvfpmrus" display="AddVFPMRUs"/>
		<memberdata name="getmrulist" display="GetMRUList"/>
		<memberdata name="getdisplayrelativepath" display="GetDisplayRelativePath"/>
		<memberdata name="diskfilename" display="DiskFileName"/>
		<memberdata name="getrelativepath" display="GetRelativePath"/>
		<memberdata name="addopenmrumenuitems" display="AddOpenMRUMenuItems"/>
		<memberdata name="processopenmrumenuitems" display="ProcessOpenMRUMenuItems"/>
		<memberdata name="addopenmruwindows" display="AddOpenMRUWindows"/>
		<memberdata name="addopenmrufavorites" display="AddOpenMRUFavorites"/>
		<memberdata name="showerrormsg" display="ShowErrorMsg"/>
		<memberdata name="extracttomethod" display="ExtractToMethod"/>
		<memberdata name="csourcefilename" display="cSourceFileName"/>
		<memberdata name="lclass" display="lClass"/>
		<memberdata name="findwith" display="FindWith"/>
		<memberdata name="getcurrenthighlightedtext" display="GetCurrentHighlightedText"/>
		<memberdata name="striptabs" display="StripTabs"/>
		<memberdata name="aproclines" display="aProcLines"/>
		<memberdata name="isnamechar" display="IsNameChar"/>
		<memberdata name="gotodefinition" display="GoToDefinition"/>
		<memberdata name="gotodef" display="GoToDef"/>
		<memberdata name="getcontrolcount" display="GetControlCount"/>
		<memberdata name="getpemstatus" display="GetPEMStatus"/>
		<memberdata name="gotodeflocateline" display="GoToDefLocateLine"/>
		<memberdata name="gotodefprocessprg" display="GoToDefProcessPRG"/>
		<memberdata name="gotodeffindprogram" display="GoToDefFindProgram"/>
		<memberdata name="gotodefprocessinclude" display="GoToDefProcessInclude"/>
		<memberdata name="gotodeffindconstant" display="GoToDefFindConstant"/>
		<memberdata name="editsourcex" display="EditSourceX"/>
		<memberdata name="openurl" display="OpenURL"/>
		<memberdata name="closeallhandles" display="CloseAllHandles"/>
		<memberdata name="dynamicsnippet" display="DynamicSnippet"/>
		<memberdata name="enhancedcutcopy" display="EnhancedCutCopy"/>
		<memberdata name="movewindow" display="MoveWindow"/>
		<memberdata name="navigatehandles" display="NavigateHandles"/>
		<memberdata name="pasteandpositioncursor" display="PasteAndPositionCursor"/>
		<memberdata name="savehandlehistory" display="SaveHandleHistory"/>
		<memberdata name="ahandlehistory" display="aHandleHistory"/>
		<memberdata name="lresetprevnexthistory" display="lResetPrevNextHistory"/>
		<memberdata name="outils" display="oUtils"/>
		<memberdata name="createsystemmenu" display="CreateSystemMenu"/>
		<memberdata name="setonkeylabel" display="SetOnKeyLabel"/>
		<memberdata name="setonkeylabels" display="SetOnKeyLabels"/>
		<memberdata name="nlefthighlightpos" display="nLeftHighlightPos"/>
		<memberdata name="nrighthighlightpos" display="nRightHighlightPos"/>
		<memberdata name="gotodeffindfile" display="GoToDefFindFile"/>
		<memberdata name="gotodefnewobject" display="GoToDefNewObject"/>
		<memberdata name="gotodefcreateobject" display="GoToDefCreateObject"/>
		<memberdata name="removequotes" display="RemoveQuotes"/>
		<memberdata name="gotodefprocessprgforclass" display="GoToDefProcessPRGForClass"/>
		<memberdata name="gotodeffindclass" display="GoToDefFindClass"/>
		<memberdata name="gotodeffindclassinpath" display="GoToDefFindClassInPath"/>
		<memberdata name="gotodefprocessvcxforclass" display="GoToDefProcessVCXForClass"/>
		<memberdata name="createmrumenu" display="CreateMRUMenu"/>
		<memberdata name="createopenmenu" display="CreateOpenMenu"/>
		<memberdata name="createwindowsmenu" display="CreateWindowsMenu"/>
		<memberdata name="createfavoritesmenu" display="CreateFavoritesMenu"/>
		<memberdata name="addopenfiles" display="AddOpenFiles"/>
		<memberdata name="addmrumenus" display="AddMRUMenus"/>
		<memberdata name="gethtmlmainheader" display="GetHTMLMainHeader"/>
		<memberdata name="gotodefthis" display="GoToDefThis"/>
		<memberdata name="getthis" display="GetThis"/>
		<memberdata name="quickaddpem" display="QuickAddPEM"/>
		<memberdata name="quickaddmethod" display="QuickAddMethod"/>
		<memberdata name="gotodeflocal" display="GoToDefLocal"/>
		<memberdata name="gotodefcurlybraces" display="GoToDefCurlyBraces"/>
		<memberdata name="gotoisxclassdefinition" display="GoToISXClassDefinition"/>
		<memberdata name="gotodefineclass" display="GoToDefineClass"/>
		</VFPData>
	
	PROCEDURE addmrumenus
		Lparameters loMenu, llHasSubMenu
		
		With This
			.AddVFPMRUs (loMenu, ccLOC_Pref_CAP_MRUClassLibs, 'MRU2')
			.AddVFPMRUs (loMenu, ccLOC_Pref_CAP_MRUClasses, 'VCX')
			.AddVFPMRUs (loMenu, ccLOC_Pref_CAP_MRUForms, 'SCX')
			.AddVFPMRUs (loMenu, 'PRGs', 'PRG')
		
			If llHasSubMenu
				loMenu.AddSubMenu ('    More')
			Else
				loMenu.AddMenuItem()
			Endif
		
			.AddVFPMRUs (loMenu, 'Projects', 'PJX')
			.AddVFPMRUs (loMenu, 'Reports', 'FRX')
			.AddVFPMRUs (loMenu, 'Menus', 'MNX')
			.AddVFPMRUs (loMenu, 'Files', 'XXX')
		
			If llHasSubMenu
				loMenu.EndSubMenu()
			Endif
		EndWith 
		
	ENDPROC

	PROCEDURE addopenfiles
		Lparameters loMenu
		
		loMenu.AddMenuItem (ccLOC_Pref_CAP_MRUOpenClasses, 'Open Class')
		loMenu.AddMenuItem (ccLOC_Pref_CAP_MRUOpenForms, 'Open Form')
		loMenu.AddMenuItem (ccLOC_Pref_CAP_MRUOpenProject, 'Open Project')
		loMenu.AddMenuItem (ccLOC_Pref_CAP_MRUOpenOther, 'Open Other')
		
	ENDPROC

	PROCEDURE addopenmrufavorites
		Lparameters loMenu, llAsSubMenu
		
		Local laArray(1), laFavorites(1), laRow(1), laSelObj(1), lcClass, lcClassInfo, lcFile, lcFilename
		Local lcParameters, lcPrompt, lnCount, lnI, lnRowCount, lnSelObj
		
		lnCount	   = Alines (laFavorites, This.oPrefs.cFavorites, .T.)
		lnRowCount = 0
		
		For lnI = 1 To lnCount
			If Not Empty (laFavorites (lnI))
				Alines (laRow, laFavorites (lnI) + '| ', .T., '|')
				lcFile	= laRow(1)
				lcClass	= laRow(2)
				Do Case
					Case Not File (lcFile)
		
					Case Empty (lcClass)
						lnRowCount = lnRowCount + 1
						Dimension laArray (lnRowCount, 3)
						laArray (lnRowCount, 1) = lcFile
						laArray (lnRowCount, 2) = ' '
						laArray (lnRowCount, 3) = IIf ('SCX' = Upper (Justext (lcFile)), 3, 1)
		
					Otherwise
						lnRowCount = lnRowCount + 1
						Dimension laArray (lnRowCount, 3)
						laArray (lnRowCount, 1) = lcFile
						laArray (lnRowCount, 2) = lcClass
						laArray (lnRowCount, 3) = 2
				Endcase
			Endif
		Endfor
		
		If llAsSubMenu
			loMenu.AddSubMenu ('Favorites')
		Endif
		
		If lnRowCount > 0
			Asort (laArray, 2, -1, 0)
			Asort (laArray, 1, -1, 0)
			Asort (laArray, 3, -1, 0)
		
			For lnI = 1 To lnRowCount
				If lnI = 1 Or laArray (lnI - 1, 3) # laArray (lnI, 3)
					loMenu.AddSubMenu (IIf (laArray (lnI, 3) = 1, 'Libraries', IIf (laArray (lnI, 3) = 2, 'Classes', 'Forms')))
				Endif
		
				lcFile = laArray(lnI,1)
				lcClass = laArray(lnI,2)
				lcPrompt	 = This.GetDisplayRelativePath (lcFile)
				lcParameters = lcFile + '|' + lcClass
				If Not Empty(lcClass)
					lcPrompt = Evl (lcClass, '?') + '  of  ' + lcPrompt
				Endif
		
				loMenu.AddMenuItem (lcPrompt, 'MRU', lcParameters)
		
				If lnI = lnRowCount Or laArray (lnI, 3) # laArray (lnI + 1, 3)
					loMenu.EndSubMenu()
				Endif
			Endfor
		Endif
		
		lnSelObj = Aselobj(laSelObj,3)
		
		If lnSelObj > 0
			If lnRowCount > 0
				loMenu.AddMenuItem()
			Endif
			lcFilename = Lower(laSelObj(2))
			If 'vcx' = Lower(Justext(lcFilename))
				lcClass = Lower(laSelObj(1).Name)
		
				lcClassInfo = lcFilename + '|' + lcClass
				If (CR + lcClassInfo + CR) $ (CR + This.oPrefs.cFavorites + CR)
					loMenu.AddMenuItem(pmain_LOC_CAP_MRURemoveClass, 'Remove Favorite', lcClassInfo)
				Else
					loMenu.AddMenuItem(pmain_LOC_CAP_MRUAddClass, 'Add Favorite', lcClassInfo)
				Endif
		
				If (CR + lcFilename + CR) $ (CR + This.oPrefs.cFavorites + CR)
					loMenu.AddMenuItem(pmain_LOC_CAP_MRURemoveClassLib, 'Remove Favorite', lcFilename)
				Else
					loMenu.AddMenuItem(pmain_LOC_CAP_MRUAddClassLib, 'Add Favorite', lcFilename)
				Endif
		
			Else
				If (CR + lcFilename + CR) $ (CR + This.oPrefs.cFavorites + CR) 
					loMenu.AddMenuItem(pmain_LOC_CAP_MRURemoveForm, 'Remove Favorite', lcFilename)
				Else
					loMenu.AddMenuItem(pmain_LOC_CAP_MRUAddForm, 'Add Favorite', lcFilename)
				Endif
			Endif
		
		Endif
		
		If llAsSubMenu
			loMenu.EndSubMenu()
		Endif
		
		Return
		
	ENDPROC

	PROCEDURE addopenmrumenuitems
		Lparameters loMenu
		
		With This
		
			This.AddMRUMenus(loMenu, .T.)
		
			.AddVFPMRUs (loMenu, 'MRU Parent Classes', 'MRU44')
		
			loMenu.AddMenuItem()
		
			This.AddOpenFiles(loMenu)
		
			loMenu.AddMenuItem()
		
			.AddOpenMRUWindows(loMenu, .T.)
			.AddOpenMRUFavorites(loMenu, .T.)
		
		Endwith
		
	ENDPROC

	PROCEDURE addopenmruwindows
		Lparameters loMenu, llAsSubMenu
		
		Local laWindows[1], lcChoice, lnBar2, lnI, lnType, loWindows
		loWindows = This.oEditorWin.GetOpenWindows()
		
		If loWindows.Count > 0
			If llAsSubMenu
				loMenu.AddSubMenu ('Windows')
			Endif
		
			Dimension laWindows (loWindows.Count, 4)
			For lnI = 1 To loWindows.Count
				laWindows (lnI, 1) = loWindows (lnI).nWHandleType
				laWindows (lnI, 2) = loWindows (lnI).nWHandle
				laWindows (lnI, 3) = loWindows (lnI).WindowName
				laWindows (lnI, 4) = (10000 * loWindows (lnI).nWHandleType)
			Endfor
		
			Asort (laWindows, 3, -1)
			Asort (laWindows, 4, -1)
			lnType = laWindows(1, 1)
			lnBar2 = 0
			For lnI = 1 To loWindows.Count
				If lnType # laWindows (lnI, 1)
					lnType = laWindows (lnI, 1)
					loMenu.AddMenuItem()
				Endif
				loMenu.AddMenuItem (laWindows (lnI, 3), 'Select', laWindows (lnI, 2))
			Endfor
		
			If llAsSubMenu
				loMenu.EndSubMenu()
			Endif
		
		Else
		
			Return .F.
		
		Endif
		
	ENDPROC

	PROCEDURE addvfpmrus
		Lparameters loMenu, lcPrompt, lcID
		
		Local lcClass, lcFileName, lnI, lnPos, loCollection
		
		If loMenu.AddSubMenu (lcPrompt)
		
			loCollection = This.GetMRUList (lcID)
			For lnI = 1 To loCollection.Count
				lcFileName = loCollection.Item (lnI)
				Do Case
					Case Empty (lcFileName)
						Loop
					Case lcFileName = '\-'
						lcPrompt = '\-'
					Case '|' $ lcFileName
						lnPos	   = At ('|', lcFileName)
						lcClass	   = Substr (lcFileName, lnPos + 1)
						lcFileName = Left  (lcFileName, lnPos - 1)
						If Not File (lcFileName)
							Loop
						Endif
						lcPrompt = This.GetDisplayRelativePath (lcFileName)
						lcPrompt = Lower(Evl (lcClass, '?')) + '  of  ' + lcPrompt
					Otherwise
						If Not File (lcFileName)
							Loop
						Endif
						lcPrompt = This.GetDisplayRelativePath (lcFileName)
						lcClass	 = ''
				Endcase
		
				loMenu.AddMenuItem (lcPrompt, 'MRU', lcFileName + '|' + Evl (lcClass, ' '))
		
			Endfor
			loMenu.EndSubMenu()
		
		Endif
		
	ENDPROC

	PROCEDURE closeallhandles
		Lparameters tlKeepTopWindow
		
		Local loWindows As Object
		Local lnHandle, lnHandleToKeep, lnI, loEditorWin
		
		loEditorWin = This.oEditorWin
		loWindows   = loEditorWin.GetOpenWindows()
		
		Do Case
			Case 'N' = Vartype (tlKeepTopWindow)
				lnHandleToKeep = -1
			Case tlKeepTopWindow
				loEditorWin.FindLastWindow()
				lnHandleToKeep = loEditorWin.nHandle
			Otherwise
				lnHandleToKeep = -1
		Endcase
		
		For lnI = 1 To loWindows.Count
			If Inlist (loWindows (lnI).nWHandleType, 1, 10)
				If 'N' = Vartype (tlKeepTopWindow) And loWindows (lnI).nWHandleType # tlKeepTopWindow
					Loop
				Endif
				lnHandle = loWindows (lnI).nWHandle
				If lnHandle # lnHandleToKeep
					Try
						loEditorWin.SelectWindow (lnHandle)
						loEditorWin.CloseWindow (lnHandle)
					Catch
					Endtry
				Endif
				DoEvents
			Endif
		Endfor
		
	ENDPROC

	PROCEDURE createfavoritesmenu
		Local loMenu As 'ContextMenu' Of 'PEME_Menu.vcx'
		Local lcKeyword, lcParameters
		
		loMenu = Newobject ('ContextMenu', 'PEME_Menu.vcx')
		
		This.AddOpenMRUFavorites (loMenu)
		
		If loMenu.Activate()
			lcKeyword	 = loMenu.KeyWord
			lcParameters = loMenu.Parameters
			This.ProcessOpenMRUMenuItems (lcKeyword, lcParameters)
		Endif
		
	ENDPROC

	PROCEDURE createmrumenu
		Local loMenu As 'ContextMenu' Of 'PEME_Menu.vcx'
		Local lcKeyword, lcParameters
		
		loMenu = Newobject ('ContextMenu', 'PEME_Menu.vcx')
		
		This.AddMRUMenus (loMenu)
		
		If loMenu.Activate()
			lcKeyword	 = loMenu.KeyWord
			lcParameters = loMenu.Parameters
			This.ProcessOpenMRUMenuItems (lcKeyword, lcParameters)
		Endif
		
	ENDPROC

	PROCEDURE createopenmenu
		Local loMenu As 'ContextMenu' Of 'PEME_Menu.vcx'
		Local lcKeyword, lcParameters
		
		loMenu = Newobject ('ContextMenu', 'PEME_Menu.vcx')
		
		This.AddOpenFiles (loMenu)
		
		If loMenu.Activate()
			lcKeyword	 = loMenu.KeyWord
			lcParameters = loMenu.Parameters
			This.ProcessOpenMRUMenuItems (lcKeyword, lcParameters)
		Endif
		
	ENDPROC

	PROCEDURE createopenmrumenu
		Local loMenu As 'ContextMenu' Of 'PEME_Menu.vcx'
		Local lcKeyword, lcParameters
		
		loMenu = Newobject ('ContextMenu', 'PEME_Menu.vcx')
		
		This.AddOpenMRUMenuItems (loMenu)
		
		If loMenu.Activate()
			lcKeyword	 = loMenu.KeyWord
			lcParameters = loMenu.Parameters
			This.ProcessOpenMRUMenuItems (lcKeyword, lcParameters)
		Endif
		
	ENDPROC

	PROCEDURE createsystemmenu
		Local loMenu As 'ContextMenu' Of 'PEME_Menu.vcx'
		Local lcCommand, lcHotKey, lcMenuName, lcPrefixBeautify, lcPrefixIDEx, lcPrefixUtils, lcPrompt
		Local lcSkipNew, lcStart, lcSuffix, llThorStuff
		
		lcMenuName = 'PEMEditor'
		
		Try
			lcThorStuff = ExecScript (_Screen.cThorDispatcher, '?')
			llThorStuff = .T.
		Catch
			lcThorStuff = .F.
		EndTry
		
		Do Case
		
			Case llThorStuff
				Return
		
			Case This.oPrefs.nToolsPlacement = 1
				Define Pad _PEMEditor Of _Msysmenu Prompt pmain_LOC_SysMenu_Main Before _Mwindow
				On Pad _PEMEditor Of _Msysmenu Activate Popup (lcMenuName)
				Define Popup (lcMenuName) Margin Relative Shadow Color Scheme 4
		
			Case This.oPrefs.nToolsPlacement = 2
				Define Bar 1729 Of _mtools Prompt 'PEM Editor Tools'
				On Bar 1729 Of _mtools Activate Popup (lcMenuName)
				Define Popup (lcMenuName) Margin Relative Shadow Color Scheme 4
		
			Case This.oPrefs.nToolsPlacement = 3
				This.SetOnKeyLabels()
				Return
		
			Case This.oPrefs.nToolsPlacement = 4
				Return
		
			Otherwise
				Return
		
		Endcase
		
		****************************************************************
		
		loMenu = Newobject ('ContextMenu', 'PEME_Menu.vcx', '', lcMenuName)
		
		lcPrefixUtils	 = [Evaluate(Iif("O" = Vartype(_oPEMEditor), "_oPemEditor.oUtils.]
		lcPrefixIDEx	 = [Evaluate(Iif("O" = Vartype(_oPEMEditor), "_oPemEditor.oUtils.oIDEx.]
		lcPrefixBeautify = [Evaluate(Iif("O" = Vartype(_oPEMEditor), "_oPemEditor.oUtils.oBeautifyX.]
		lcSkipNew		 = ["O" # Vartype(_oPEMEditor)]
		
		lcSuffix	 = [", "0"))]
		
		****************************************************************
		With loMenu
		
			lcPrompt  = pmain_LOC_SysMenu_GoToDef
			lcCommand = lcPrefixIDEx + 'GoToDefinition()' + lcSuffix
			lcHotKey  = This.oPrefs.cViewDefinitionKey
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
			lcPrompt  = pmain_LOC_SysMenu_Beautify
			lcCommand = lcPrefixBeautify + 'PEME_Beautify()' + lcSuffix
			lcHotKey  = This.oPrefs.cBeautify
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
			lcPrompt  = pmain_LOC_SysMenu_Locals
			lcCommand = lcPrefixBeautify + 'PEME_CreateLocals()' + lcSuffix
			lcHotKey  = This.oPrefs.cLocals
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
			lcPrompt  = pmain_LOC_SysMenu_ExtractToMethod
			lcCommand = lcPrefixIDEx + 'ExtractToMethod()' + lcSuffix
			lcHotKey  = This.oPrefs.cExtractToMethod
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
			If .AddSubMenu ('Enhanced Cut / Copy', lcSkipNew)
		
				lcPrompt  = pmain_LOC_SysMenu_CtrlX
				lcCommand = lcPrefixIDEx + "EnhancedCutCopy('Cut')" + lcSuffix
				lcHotKey  = This.oPrefs.cEnhancedCtrlX
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = pmain_LOC_SysMenu_CtrlC
				lcCommand = lcPrefixIDEx + "EnhancedCutCopy('Copy')" + lcSuffix
				lcHotKey  = This.oPrefs.cEnhancedCtrlC
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = pmain_LOC_SysMenu_CtrlX + ' / Additive'
				lcCommand = lcPrefixIDEx + "EnhancedCutCopy('Cut', .T.)" + lcSuffix
				lcHotKey  = This.oPrefs.cEnhancedCtrlXAdditive
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = pmain_LOC_SysMenu_CtrlC + ' / Additive'
				lcCommand = lcPrefixIDEx + "EnhancedCutCopy('Copy', .T.)" + lcSuffix
				lcHotKey  = This.oPrefs.cEnhancedCtrlCAdditive
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				.EndSubMenu()
			Endif
		
			If .AddSubMenu ('Control Structures')
				lcPrompt  = 'Highlight current structure'
				lcCommand = lcPrefixIDEx + 'HighlightControlStructure()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = 'Close current structure'
				lcCommand = lcPrefixIDEx + 'EndControlStructure()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
				.EndSubMenu()
			Endif
		
			If .AddSubMenu ('Cross References', lcSkipNew)
		
				lcPrompt  = 'This method'
				lcCommand = lcPrefixBeautify + 'PEME_CreateIDList()' + lcSuffix
				lcHotKey  = This.oPrefs.cIDList
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = 'This form/class'
				lcCommand = lcPrefixUtils + 'CreateObjectIDList(.T., .F.)' + lcSuffix
				lcHotKey  = This.oPrefs.cIDList
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				lcPrompt  = 'This form/class and children'
				lcCommand = lcPrefixUtils + 'CreateObjectIDList(.T., .T.)' + lcSuffix
				lcHotKey  = This.oPrefs.cIDList
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				lcPrompt  = 'Current Object'
				lcCommand = lcPrefixUtils + 'CreateObjectIDList(.F., .F.)' + lcSuffix
				lcHotKey  = This.oPrefs.cIDList
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				lcPrompt  = 'Current Object and children'
				lcCommand = lcPrefixUtils + 'CreateObjectIDList(.F., .T.)' + lcSuffix
				lcHotKey  = This.oPrefs.cIDList
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				.EndSubMenu()
		
			Endif
		
			lcPrompt  = 'Dynamic Snippets'
			lcCommand = lcPrefixIDEx + 'DynamicSnippet()' + lcSuffix
			lcHotKey  = This.oPrefs.cDoubleHash
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
			****************************************************************
		
			.AddMenuItemExec ()
		
			If .AddSubMenu ('Copy / Paste', lcSkipNew)
		
				lcPrompt  = 'Copy (for comparing and pasting)'
				lcCommand = lcPrefixUtils + 'CopyProperties()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				lcPrompt  = "Copy full object name to clipboard"
				lcCommand = lcPrefixUtils + 'FullObjectNameToClipboard()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				.AddMenuItemExec ()
		
				lcPrompt  = 'Compare with copied object'
				lcCommand = lcPrefixUtils + 'CompareProperties()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				lcPrompt  = 'Paste properties and method code'
				lcCommand = lcPrefixUtils + 'PasteProperties()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				lcPrompt  = 'Paste object'
				lcCommand = lcPrefixUtils + 'PasteObject()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				.EndSubMenu()
			Endif
		
			If .AddSubMenu ('Parent Classes', lcSkipNew)
		
				lcPrompt  = 'Compare with Parent Class'
				lcCommand = lcPrefixUtils + 'CompareClass()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				lcPrompt  = 'Modify Parent Class'
				lcCommand = lcPrefixUtils + 'EditParentClasses()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				lcPrompt  = 'Change Parent Class'
				lcCommand = lcPrefixUtils + 'ChangeParentClass()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
				.EndSubMenu()
			Endif
		
			lcPrompt  = 'Find Objects'
			lcCommand = lcPrefixUtils + 'Find()' + lcSuffix
			lcHotKey  = This.oPrefs.cIDList
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
			lcPrompt  = 'Add Object'
			lcCommand = lcPrefixUtils + 'AddControl()' + lcSuffix
			lcHotKey  = ''
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, '')
		
			lcPrompt  = "Format Size and Position"
			lcCommand = lcPrefixUtils + [ShowForm('FormatMenu')] + lcSuffix
			lcHotKey  = This.oPrefs.cFormatMenuKey
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
			****************************************************************
			.AddMenuItemExec ()
		
			If .AddSubMenu('Open files, favorites, MRUs', lcSkipNew)
				lcPrompt  = 'MRUs'
				lcCommand = lcPrefixIDEx + 'CreateMRUMenu()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = 'Open forms, classes, etc.'
				lcCommand = lcPrefixIDEx + 'CreateOpenMenu()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = 'Windows'
				lcCommand = lcPrefixIDEx + 'CreateWindowsMenu()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = 'Favorites'
				lcCommand = lcPrefixIDEx + 'CreateFavoritesMenu()' + lcSuffix
				lcHotKey  = ''
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				.AddMenuItemExec ()
		
				lcPrompt  = 'All'
				lcCommand = lcPrefixIDEx + 'CreateOpenMRUMenu()' + lcSuffix
				lcHotKey  = This.oPrefs.cOpenMenuKey
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				.EndSubMenu()
			Endif
		
			If .AddSubMenu ('Window manipulation', lcSkipNew)
		
				lcPrompt  = pmain_LOC_SysMenu_Back
				lcCommand = lcPrefixIDEx + "NavigateHandles('-')" + lcSuffix
				lcHotKey  = This.oPrefs.cPrevMethodWindow
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = pmain_LOC_SysMenu_Next
				lcCommand = lcPrefixIDEx + "NavigateHandles('+')" + lcSuffix
				lcHotKey  = This.oPrefs.cNextMethodWindow
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = pmain_LOC_SysMenu_CloseAllWindows
				lcCommand = lcPrefixIDEx + 'CloseAllHandles()' + lcSuffix
				lcHotKey  = This.oPrefs.cCloseAllWindows
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				lcPrompt  = pmain_LOC_SysMenu_MoveWindow
				lcCommand = lcPrefixIDEx + 'MoveWindow()' + lcSuffix
				lcHotKey  = This.oPrefs.cMoveWindow
				.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew, lcHotKey)
		
				.EndSubMenu()
			Endif
		
		
			If .AddSubMenu('PEM Editor forms')
				lcStart = Addbs (This.oUtils.cApplicationPath) + 'Source\_StartPEMEditor.PRG'
		
				If File (lcStart)
		
					lcPrompt  = pmain_LOC_SysMenu_Launch
					lcCommand = "Do '" + lcStart + "' with '" + This.oUtils.cApplicationPath + "'"
					lcHotKey  = This.oPrefs.cLaunchKey
					.AddMenuItemExec (lcPrompt, lcCommand, , lcHotKey)
		
					lcPrompt  = pmain_LOC_SysMenu_LaunchDocTreeView
					lcCommand = "Do '" + lcStart + "' with '" + This.oUtils.cApplicationPath + "', 2"
					lcHotKey  = This.oPrefs.cLaunchDocTreeView
					.AddMenuItemExec (lcPrompt, lcCommand, , lcHotKey)
		
					lcPrompt  = "Format Size and Position"
					lcCommand = "Do '" + lcStart + "' with '" + This.oUtils.cApplicationPath + "', 'FormatMenu'"
					lcHotKey  = This.oPrefs.cFormatMenuKey
					.AddMenuItemExec (lcPrompt, lcCommand, , lcHotKey)
		
				Endif
		
				lcPrompt  = 'Close PEM Editor form(s)'
				lcCommand = lcPrefixUtils + "CloseForms()" + lcSuffix
				lcHotKey  = This.oPrefs.cCloseBothForms
				.AddMenuItemExec (lcPrompt, lcCommand, , lcHotKey)
		
				.EndSubMenu()
			Endif
		
			****************************************************************
			.AddMenuItemExec ()
		
			lcPrompt  = 'Hot Keys and Preferences'
			lcCommand = lcPrefixUtils + 'EditPreferences(4)' + lcSuffix
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew)
		
			lcPrompt  = 'Help'
			lcCommand = lcPrefixUtils + 'ShowHelp()' + lcSuffix
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew)
		
			lcPrompt  = 'About ...'
			lcCommand = lcPrefixUtils + 'AboutPEMEditor()' + lcSuffix
			.AddMenuItemExec (lcPrompt, lcCommand, lcSkipNew)
		
		Endwith
		
		Return
		
	ENDPROC

	PROCEDURE createwindowsmenu
		Local loMenu As 'ContextMenu' Of 'PEME_Menu.vcx'
		Local lcKeyword, lcParameters
		
		loMenu = Newobject ('ContextMenu', 'PEME_Menu.vcx')
		
		If This.AddOpenMRUWindows (loMenu)
			If loMenu.Activate()
				lcKeyword	 = loMenu.KeyWord
				lcParameters = loMenu.Parameters
				This.ProcessOpenMRUMenuItems (lcKeyword, lcParameters)
			Endif
		Endif
		
	ENDPROC

	PROCEDURE dynamicsnippet
		Local lcCurrentLine, lcKeyword, lcNewText, lcOldClipText, lcParameters, lcText, lnPos, lnSelEnd
		Local lnSelStart, lnStartOfLine, loEditorWin
		
		loEditorWin = This.oEditorWin
		
		* Find current window; exit if none
		If loEditorWin.FindWindow() < 0
			Return
		Endif
		
		* Current cursor position
		lnSelStart = loEditorWin.GetSelStart()
		
		* Start of current line
		lnStartOfLine = loEditorWin.SkipLine (lnSelStart, 0)
		
		* Text of current line, up to cursor
		lcCurrentLine = loEditorWin.GetString (lnStartOfLine, lnSelStart)
		
		* Find double-hash; extract from line
		lnSelEnd   = lnSelStart
		lnPos = Rat (This.oPrefs.cDynamicSnippetMarker, lcCurrentLine)
		If lnPos # 0
			* Determine Hash keyword and parameters
			lnSelStart = lnStartOfLine + lnPos - 1
			lcText	   = loEditorWin.GetString (lnSelStart, lnSelEnd)
			lcText = Alltrim (Substr (lcText, 1 + Len (This.oPrefs.cDynamicSnippetMarker)))
		Else
			* Determine Hash keyword and parameters
			lnSelStart = lnStartOfLine
			lcText	   = loEditorWin.GetString (lnSelStart, lnSelEnd)
		Endif
		
		lcText = Alltrim (lcText, 1, ' ', Tab, CR, LF)
		lcText = Chrtran (lcText, CRLF, '')
		lcText = Chrtran (lcText, Tab, ' ')
		
		Do Case
			Case Getwordcount (lcText) >= 2
				lnPos		 = At (' ', lcText)
				lcKeyword	 = Upper (Alltrim (Left (lcText, lnPos)))
				lcParameters = Alltrim (Substr (lcText, lnPos))
			Case Getwordcount (lcText) = 1
				lcKeyword	 = Upper (Alltrim (lcText))
				lcParameters = ''
			Otherwise
				Return
		Endcase
		
		* pass parameters to routine
		loEditorWin.Select (lnSelStart, lnSelEnd)
		lcNewText	 = This.oDynamicSnippet.HandleDoubleHash (lcKeyword, lcParameters)
		
		lcOldClipText = _Cliptext
		
		Do Case
			Case 'C' = Vartype (lcNewText)
		
				* Select our text
				loEditorWin.Select (lnSelStart, lnSelEnd)
		
				* and paste in the new text
				If 0 = Len (lcNewText)
					loEditorWin.Cut()
				Else
					This.PasteAndPositionCursor ( lcNewText)
				Endif
		
			Case Not lcNewText
				loEditorWin.Select (lnSelEnd, lnSelEnd)
		
		Endcase
		
		_Cliptext = lcOldClipText
		
	ENDPROC

	PROCEDURE editthorproc
		Lparameters lcMethodName
		
		Local lcFile, lcFullPRGName, lcToolFolder
		If Upper(lcMethodName) = Upper('Thor_Proc_')
		
			lcToolFolder  = Execscript(_Screen.cThorDispatcher, "Tool Folder=")
			lcFile		   = Forceext (lcMethodName, 'prg')
		
			lcFullPRGName = Forcepath (lcFile, lcToolFolder + 'My Tools')
			If File(lcFullPRGName)
				This.EditSourceX(lcFullPRGName)
				Return .T.
			Endif
		
			lcFullPRGName = Forcepath (lcFile, lcToolFolder + 'Procs')
			If File(lcFullPRGName)
				This.EditSourceX(lcFullPRGName)
				Return .T.
			Endif
		
			lcFullPRGName = Forcepath (lcFile, lcToolFolder)
			If File(lcFullPRGName)
				This.EditSourceX(lcFullPRGName)
				Return .T.
			Endif
		
		Endif
		Return .F.
		
	ENDPROC

	PROCEDURE endcontrolstructure
		#Define ccCursorMarker '^^^'
		* Get the current window, code, and start and end of selected text
		Local  ;
			loControlStructures As Object	,;
			loEditorWin As Object	,;
			loItem As Object	,;
			loMainItem As Object
		Local lcCase, lcCodeSource, lcECSPlugIn, lcEndWord, lcEntireBlock, lcIndentation, lcMatchEndWords
		Local lcMatchStartWords, lcPasteText, lcPreText, lcTextOfThisLine, lcThisLine, llEndOfFile
		Local llStructureLine, lnCaseSelection, lnEndOfThisLine, lnI, lnIndex, lnLevel, lnLineNumber
		Local lnPosition, lnSelEnd, lnSelStart, lnStartIndex, lnStartofNextLine, lnStartOfThisLine
		Local lnStartSelect
		
		* Get the current window, code, and start and end of selected text
		loEditorWin = This.oEditorWin
		If 0 >= loEditorWin.FindWindow()
			Return
		Endif
		
		With loEditorWin
			lnSelStart	 = .GetSelStart()
			lnSelEnd	 = .GetSelEnd()
			lcCodeSource = .GetString (0, 1000000)
			lnLineNumber = .GetLineNumber(lnSelStart)
		Endwith
		
		* Get the collection of control structure positions
		loControlStructures = This.oUtils.GetControlStructurePositions (lcCodeSource)
		
		* and find which item therein immediately precedes start of selected text
		For lnIndex = loControlStructures.Count To 1 Step - 1
			loMainItem = loControlStructures.Item (lnIndex)
			If loMainItem.LineNumber <= lnLineNumber
				Exit
			Endif
		Endfor
		
		* Find the starting item for the current control structure
		Do Case
		
				* Procedure, Function, Define class
			Case loMainItem.ProcedureBoundary
				lnLevel = 0
		
				* If, Scan, Do Case, etc.  ... on same line
			Case loMainItem.StartStructure And loMainItem.LineNumber = lnLineNumber
				lnLevel			= 0
				llStructureLine	= .T.
				* following allows for repeated applications ... each time, finding next largest control structure
				If lnSelStart # lnSelEnd And lnSelStart = loEditorWin.GetByteOffset(loMainItem.LineNumber)
					lnLevel = -1
				Endif
		
				* Line following If, Scan, Do Case, etc.
			Case loMainItem.StartStructure
				lnLevel			= 0
				llStructureLine	= .F.
		
				* Endif, EndScan, EndCase, etc ... on same line
			Case loMainItem.EndStructure And loMainItem.LineNumber = lnLineNumber
				lnLevel			= 0
				llStructureLine	= .T.
		
				* Line following Endif, EndScan, EndCase, etc
			Case loMainItem.EndStructure
				lnLevel			= 0
				llStructureLine	= .F.
		
				* Else, Catch, Case, Otherwise ... on same line
			Case loMainItem.LineNumber = lnLineNumber
				lnLevel			= 0
				llStructureLine	= .T.
		
				* Line following Else, Catch, Case, Otherwise
			Otherwise
				lnLevel			= 0
				llStructureLine	= .F.
		
		Endcase
		
		For lnI = lnIndex To 1 Step - 1
			loItem = loControlStructures.Item (lnI)
			Do Case
				Case loItem.ProcedureBoundary
					lnLevel = lnLevel + 1
					If lnLevel > 0
						lnStartIndex = lnI
						Exit
					Else
						lnLevel = 0
					Endif
				Case loItem.StartStructure
					lnLevel = lnLevel + 1
					If lnLevel > 0
						lnStartIndex = lnI
						Exit
					Endif
				Case loItem.EndStructure
					lnLevel = lnLevel - 1
			Endcase
		Endfor
		
		If 'C' # Vartype(loItem.Text)
			Return
		Endif
		
		****************************************************************
		
		lcPreText = ''
		For lnI = 1 To Len (loItem.Text)
			If Empty (Substr (loItem.Text, lnI, 1))
				lcPreText = lcPreText + Substr (loItem.Text, lnI, 1)
			Else
				Exit
			Endif
		Endfor
		
		lcMatchStartWords = ' TEXT    DOCASE  DOWHILE IF    FOR    SCAN    TRY   WITH    PROCEDURE FUNCTION CLASS'
		lcMatchEndWords	  = ' EndText Endcase Enddo   Endif Endfor Endscan Endtry Endwith Endproc   Endfunc  Enddefine'
		
		lcEndWord = Getwordnum (Substr (lcMatchEndWords, At ((' ' + Upper(loItem.Type)), lcMatchStartWords) + 1), 1)
		This.oUtils.oBeautifyX.SetBeautifyOptions()
		lnCaseSelection = This.oUtils.oBeautifyX.nBeautifyOptions(2)
		Do Case
			Case lnCaseSelection = 1
				lcEndWord = Upper (lcEndWord)
			Case lnCaseSelection = 2
				lcEndWord = Lower (lcEndWord)
		Endcase
		
		If loItem.ClosingExtraText
			lcThisLine	  = Alltrim (Chrtran (loItem.Text, CR + LF + Tab, '   '))
			lcThisLine	  = Alltrim (Substr (lcThisLine, At (' ', lcThisLine) + 1))
			lcEntireBlock = loEditorWin.GetString (loEditorWin.GetByteOffset(loItem.LineNumber), loEditorWin.GetLineStart (lnSelStart, 1))
		
			lcECSPlugIn = This.oUtils.GetPlugInPath ('CloseControlStructure')
			If Not Empty (lcECSPlugIn)
				lcEndWord = Execscript (Filetostr (lcECSPlugIn)	 ;
					, loItem.Type								 ;
					, lcEndWord								 ;
					, lcThisLine								 ;
					, lcEntireBlock)
				If Empty (lcEndWord)
					Return
				Endif
			Endif
		Endif
		
		****************************************************************
		lcPasteText = _Cliptext
		
		lnLineNumber      = loEditorWin.GetLineNumber(lnSelStart)
		lnStartOfThisLine = loEditorWin.GetLineStart (lnSelStart, 0)
		lnStartofNextLine = loEditorWin.GetLineStart (lnSelStart, 1)
		lcTextOfThisLine  = loEditorWin.GetString (lnStartOfThisLine, lnStartofNextLine - 1)
		lnEndOfThisLine	  = lnStartOfThisLine + Len(Rtrim(lcTextOfThisLine, 0, CR, LF))
		llEndOfFile		  = Empty(loEditorWin.GetString (lnEndOfThisLine, lnEndOfThisLine + 200))
		
		If Empty (lcTextOfThisLine)
			lnStartSelect = lnStartOfThisLine
			loEditorWin.Select (lnStartSelect, lnEndOfThisLine)
			If llEndOfFile
				lcPasteText = lcPreText + lcEndWord + CR + lcPreText + ccCursorMarker
			Else
				lcPasteText = lcPreText + lcEndWord + ccCursorMarker
			Endif
		Else
			lnStartSelect = lnEndOfThisLine
			loEditorWin.Select (lnStartSelect)
			Do Case
				Case lnLineNumber <= loItem.LineNumber
					lcIndentation = Execscript(_Screen.cThorDispatcher, 'Thor_Proc_GetNormalIndentation')
					If Upper(loItem.Type) = 'DOCASE'
						Do Case
							Case lnCaseSelection = 1
								lcCase= 'CASE'
							Case lnCaseSelection = 2
								lcCase= 'case'
							Otherwise
								lcCase = 'Case'
						Endcase
						lcPasteText = CR + lcPreText + lcIndentation + lcCase + ' ' + ccCursorMarker + CR + lcPreText + lcEndWord + CR + lcPreText
					Else
						lcPasteText = CR + lcPreText + lcIndentation + ccCursorMarker + CR + lcPreText + lcEndWord + CR + lcPreText
					Endif
				Case llEndOfFile
					lcPasteText = CR + lcPreText + lcEndWord + CR + lcPreText  + ccCursorMarker
				Otherwise
					lcPasteText = CR + lcPreText + lcEndWord + ccCursorMarker
			Endcase
		Endif
		
		lnPosition = lnStartSelect + At(ccCursorMarker, lcPasteText) - 1
		loEditorWin.Paste(Strtran(lcPasteText, ccCursorMarker, ''))
		loEditorWin.SetInsertionPoint(lnPosition)
		
		Return
		
	ENDPROC

	PROCEDURE enhancedcutcopy
		*** JRN 2010-04-02 : From Sergey
		Lparameters lcCutOrCopy, llAdditive
		
		Local lcCliptext, lnCurrentLineStart, lnFollowingLineStart, lnSelEnd, lnSelStart, loEditorWin
		
		loEditorWin = This.oEditorWin
		If 0 > loEditorWin.FindWindow()
			Return
		Endif
		
		lnSelStart = loEditorWin.GetSelStart()
		lnSelEnd   = loEditorWin.GetSelEnd()
		
		If lnSelStart = lnSelEnd
			* find the start of the current line
			lnCurrentLineStart = loEditorWin.SkipLine (lnSelStart, 0)
			* and of the following line
			lnFollowingLineStart = loEditorWin.SkipLine (lnSelStart, 1)
			* Mark the desired text
			loEditorWin.Select (lnCurrentLineStart, lnFollowingLineStart)
		Endif
		
		lcCliptext = _Cliptext
		Do Case
			Case lcCutOrCopy = 'Cut'
				loEditorWin.Cut()
			Case lcCutOrCopy = 'Copy'
				loEditorWin.Copy()
				loEditorWin.Select (lnSelStart, lnSelEnd)
		Endcase
		
		If llAdditive
			_Cliptext = lcCliptext + _Cliptext
		Endif
		
	ENDPROC

	PROCEDURE extracttomethod
		Local loCurrentObject AS Object
		Local loEditorWin AS Object
		Local loException AS Object
		Local loTopOfForm AS Object
		Local laTitle(1), lcCodeSource, lcIndent, lcName, lcNewCode, lcNewHeader, lcNewMethodName
		Local lcOldClipText, llFailed, lnNewPosition, lnSelEnd, lnSelStart 
		
		loEditorWin = This.oEditorWin
		If 10 # loEditorWin.FindWindow()
			Return
		Endif
		
		lnSelStart = loEditorWin.GetSelStart()
		lnSelEnd   = loEditorWin.GetSelEnd()
		
		If lnSelStart = lnSelEnd
			Return
		Endif
		
		loTopOfForm = This.oUtils.FindTopMostParent()
		If Isnull (loTopOfForm)
			Return
		Endif
		
		If Upper (Right (This.cSourceFileName, 4)) == '.TMP'
			Messagebox (ccLOC_CAP_Cant_Edit)
			Return
		Endif
		
		****************************************************************
		
		lcCodeSource = loEditorWin.GetString (lnSelStart, lnSelEnd - 1)
		loCurrentObject = This.oUtils.GetThis()
		
		lcOldClipText = _Cliptext
		* prompt for name of new method
		lcNewMethodName = Inputbox ('Name for New Method') &&, loTopOfForm.Caption)
		If Empty (lcNewMethodName)
			Return
		Endif
		
		* verify
		Try
			If This.GetPEMStatus (loTopOfForm, lcNewMethodName, 5)
				Messagebox (lcNewMethodName + ' already exists', 16, loTopOfForm.Caption)
				llFailed = .T.
			Else
				llFailed = .F.
			Endif
		Catch To loException
			This.ShowErrorMsg (loException)
			llFailed = .T.
		Endtry
		
		If llFailed
			Return
		Endif
		
		If not This.oUtils.CreateNewPEM('M', lcNewMethodName, '*', loTopOfForm)
			Return
		EndIf 
		
		****************************************************************
		* put reference to this new method back in the original code
		
		Do Case
			Case Upper (loTopOfForm.BaseClass) = 'FORM'
				lcNewHeader = 'ThisForm'
			Case 'O' = VarType(loCurrentObject)
				lcName = This.oUtils.GetObjectPath(loCurrentObject)
				lcNewHeader = 'This' + Replicate ('.Parent', Occurs('.', lcName))
			Case 2 < Alines (laTitle, loEditorWin.GetTitle (), .T., '.')
				lcNewHeader = 'This' + Replicate ('.Parent', Alen (laTitle) - 2)
			Otherwise
				lcNewHeader = 'This'
		Endcase
		
		lcIndent = Left(lcCodeSource, At(GetWordNum(lcCodeSource, 1), lcCodeSource) - 1)
		lcNewCode = lcIndent + lcNewHeader + '.' + lcNewMethodName + '()'
		Do Case
			Case Right (lcCodeSource, 2) = CRLF
				lcNewCode = lcNewCode + CRLF
			Case Right (lcCodeSource, 1) = CR
				lcNewCode = lcNewCode + CR
		Endcase
		
		_Cliptext = lcNewCode
		
		loEditorWin.Paste()
		lnNewPosition = lnSelStart + At ('(', lcNewCode)
		loEditorWin.Select (lnNewPosition, lnNewPosition)
		loEditorWin.SetInsertionPoint (lnNewPosition)
		
		* and edit it
		This.oUtils.EditLocalMethodCode (This.oUtils.cSourceFileName, loTopOfForm, loTopOfForm, lcNewMethodName, This.oUtils.lClass)
		
		If 10 # loEditorWin.FindWindow()
			Return
		Endif
		
		If Not Isnull (This.oUtils.oPEMEditor)
			This.oUtils.oPEMEditor.DoRefresh()
		Endif
		
		_Cliptext = This.oUtils.GetNewMethodHeader (lcNewMethodName) + lcCodeSource
		
		With loEditorWin
			.Select (0, 1)
			.Paste()
			.SetInsertionPoint(0)
			.WinShow()
		Endwith
		
		_Cliptext = lcOldClipText
		
	ENDPROC

	PROCEDURE findwith
		*** JRN 2010-04-03 : From Tamar's ControlRenamer
		* modified to remove any annoying tabs
		
		Lparameters nStartLine
		
		* Find the first occurrence of WITH preceding
		* the specified line and extract the referenced object
		
		Local cContainer, cObject, cWithLine, nLine, nNamePos, nWITHLevel
		
		If nStartLine <= 1
			Return ''
		Endif
		
		*** JRN 2010-04-04 : corrected for WITH on first line
		* also handles intervening (and ignorable) WITH/ENDWITHs
		nWITHLevel = 0
		For nLine = nStartLine - 1 To 1 Step - 1
			cWithLine = This.StripTabs (This.aProcLines[nLine])
		
			Do Case
				Case Upper(cWithLine) = "WITH " And nWITHLevel = 0
					nNamePos = At(" ", Alltrim(cWithLine))
					cObject = Alltrim(Substr(cWithLine, nNamePos + 1))
					* Remove trailing period
					If Right(cObject,1)="."
						cObject = Left(cObject, Len(cObject)-1)
					Endif
					If Left(cObject, 1) = "."
						* Nested WITH, keep going back
						cContainer = This.FindWith(nLine)
						cObject = cContainer + cObject
					Endif
					Return cObject
				Case Upper(cWithLine) = "ENDW"
					nWITHLevel = nWITHLevel + 1
				Case Upper(cWithLine) = "WITH "
					nWITHLevel = nWITHLevel - 1
			Endcase
		
		Endfor && nLine = nStartLine - 1 To 1 Step - 1
		
		Return ''
		
	ENDPROC

	PROCEDURE getcssfile
		Lparameters lcFileName
		
		If Empty (lcFileName)
			lcStyleSheet = ''
		Else
			TEXT TO lcStyleSheet NOSHOW TEXTMERGE 
			<link rel="stylesheet" type="text/css" href="file:///<<Strtran(lcFileName, ' ', '%20')>>" />
			EndText 
		EndIf 
		
		Return lcStyleSheet + CRLF
	ENDPROC

	PROCEDURE getcurrenthighlightedtext
		Lparameters llFullObjectName, llSavePositions
		
		*** JRN 10/16/2010 : llFullObjectName captures full reference,
		*   meaning including dots and handling of WITH/ENDWITH
		
		Local lcChar, lcEnds, lcPreviousCode, lcResult, lnPosition, lnSelEnd, lnSelStart, lnWindowType
		Local cContainer, nLineCount
		lnWindowType = This.oEditorWin.FindWindow()
		If 0 > m.lnWindowType
			Return ''
		Endif
		
		lnSelStart = This.oEditorWin.GetSelStart()
		lnSelEnd   = This.oEditorWin.GetSelEnd()
				
		If m.llSavePositions and InList(m.lnWindowType, 1, 8, 10) 
			If PemStatus(_Screen, 'aGoToDefinitionHistory', 5) = .F.
				_Screen.AddProperty('aGoToDefinitionHistory[1, 4]')
			EndIf 
			lnNewRow = Alen(_Screen.aGoToDefinitionHistory, 1) + 1
			Dimension _Screen.aGoToDefinitionHistory[lnNewRow, 4]
			_Screen.aGoToDefinitionHistory[lnNewRow, 1] = This.oEditorWin.GetTitle()
			_Screen.aGoToDefinitionHistory[lnNewRow, 2] = This.oEditorWin.GetWindowHandle()
			_Screen.aGoToDefinitionHistory[lnNewRow, 3] = lnSelStart
			_Screen.aGoToDefinitionHistory[lnNewRow, 4] = lnSelEnd
		Else 
			lnNewRow = 1 && A LIE!  but simplifies capture of Start/end text later  
		EndIf 
		
		****************************************************************
		*** JRN 2010-04-04 : remainder of this code specific to extracting the full object path,
		*   removing extra chars, etc
		If lnSelStart < lnSelEnd && any highlighted text?
		
			lcResult = This.oEditorWin.GetString (lnSelStart, lnSelEnd - 1)
		
			If Not Empty(This.RemoveQuotes(lcResult))
				This.nLeftHighlightPos	= lnSelStart
				This.nRightHighlightPos	= lnSelEnd
				If m.llSavePositions and InList(m.lnWindowType, 1, 8, 10) 
					_Screen.aGoToDefinitionHistory[lnNewRow, 3] = lnSelStart
					_Screen.aGoToDefinitionHistory[lnNewRow, 4] = lnSelEnd 
				EndIf
				Return ['] + Substr(lcResult, 2, Len(lcResult) - 2) + [']
			Endif
		
			* remove trailing garbage characters
			If '(' $ lcResult && first, anything after a (
				lnSelEnd = lnSelStart + At ('(', lcResult) - 1
				lcResult = This.oEditorWin.GetString (lnSelStart, lnSelEnd - 1)
			Endif
		
			*!* ******************** Removed 11/18/2014 *****************
			*!* lnSelStart = lnSelEnd
			*!* Do While Not This.IsNameChar (Right (lcResult, 1))
			*!* 	If Empty (lcResult)
			*!* 		Return ''
			*!* 	Else
			*!* 		lcResult   = Left (lcResult, Len (lcResult) - 1)
			*!* 		lnSelStart = lnSelStart - 1
			*!* 	Endif
			*!* Enddo
		
			This.nRightHighlightPos	= lnSelEnd - 1
			*!* lcResult = '' && because we march to the left from here ...
		
		Else &&  JRN 2010-04-02  no highlighted text ... add characters to right
			lcResult = ''
		
			lnPosition = lnSelStart
			Do While .T.
				lcChar = This.oEditorWin.GetCharacter (lnPosition)
				If This.IsNameChar (lcChar)
					lcResult   = lcResult + lcChar
					lnPosition = lnPosition + 1
				Else
					Exit
				Endif
			Enddo
		
			This.nRightHighlightPos	= lnPosition - 1
		
		Endif
		
		*** JRN 2010-04-02 : add in preceding characters
		For lnPosition = lnSelStart - 1 To 0 Step - 1
			lcChar = This.oEditorWin.GetCharacter (lnPosition)
			If This.IsNameChar (lcChar) Or lcChar = '.'
				lcResult = lcChar + lcResult
			Else
				Exit
			Endif
		Endfor
		
		This.nLeftHighlightPos	= lnPosition + 1
		
		If llFullObjectName
		
			*!* ******************** Removed 11/18/2014 *****************
			*!* *** JRN 2010-04-04 : get rid of macro substitutions
			*!* If '..' $ lcResult
			*!* 	lcResult = Substr (lcResult, Rat ('.', lcResult) + 1)
			*!* Endif
		
			* Need to look backwards for WITH ???
			If Left (lcResult + '.', 1) = '.' ;
					and This.oEditorWin.GetEnvironment[25] > 0 ;
					and not InList(Upper(lcResult), '.T.', '.F.') 
					
				lcPreviousCode = This.oEditorWin.GetString (0, lnSelEnd - 1)
				nLineCount	   = Alines (This.aProcLines, lcPreviousCode + ' ') && ensure trailing line
				If nLineCount > 1
					cContainer = This.FindWith (nLineCount)
					lcResult   = cContainer + lcResult
				Endif
			Endif
		Endif
		
		If m.llSavePositions and InList(m.lnWindowType, 1, 8, 10) 
			_Screen.aGoToDefinitionHistory[lnNewRow, 3] = This.nLeftHighlightPos
			_Screen.aGoToDefinitionHistory[lnNewRow, 4] = Max(This.nRightHighlightPos + 1, This.nLeftHighlightPos + 3)
		EndIf
		Return lcResult
		
	ENDPROC

	PROCEDURE getdisplayrelativepath
		Lparameters lcFileName, lcFolder, lcClass
		* returns the display form of a file name
		Local lcFileDisplayName, lcFName, lcQuote, lcResult
		
		lcFileDisplayName = This.GetRelativePath (This.DiskFileName(lcFileName), Evl (lcFolder, Curdir()))
		lcFName = Justfname (lcFileDisplayName)
		lcQuote = Iif (" " $ lcFName, ['], '')
		If lcFName == lcFileDisplayName
			lcResult = lcQuote + lcFName + lcQuote
		Else
			lcResult = lcQuote + lcFName + lcQuote + "  from  " + Justpath (lcFileDisplayName)
		Endif
		
		Return lcResult 
		
	ENDPROC

	PROCEDURE gethtmlheader
		Local lcFileName, lcStyleSheets, lcText 
		lcStyleSheets = ''
		
		lcFileName =  Addbs(This.oUtils.cApplicationPath) + 'Source\Pemeditor.css'
		If File (lcFileName)
			lcStyleSheets = lcStyleSheets + This.GetCSSFile (lcFileName)
		EndIf 
		
		lcFileName =  This.oUtils.GetPlugInPath ("Pemeditor.css")
		If not Empty (lcFileName)
			lcStyleSheets = lcStyleSheets + This.GetCSSFile (lcFileName)
		EndIf 
		
		lcText= ''
		****************************************************************
		TEXT TO lcText NOSHOW TEXTMERGE
		
		<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
		<html xmlns="http://www.w3.org/1999/xhtml">
		
		<head>
		<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
		<<lcStyleSheets>>
		EndText
		
		Return lcText
		
	ENDPROC

	PROCEDURE gethtmlmainheader
		Local loObject AS Object
		Local loTopOfForm AS Object
		Local lcText, lcTitle 
		
		With This.oUtils
			loObject = .GetOneSelectedObject()
			loTopOfForm = .FindTopMostParent()
			If .lClass
				lcTitle = "Class " + loTopOfForm.Name + " of " + .cSourceFileName
			Else
				lcTitle = 'Form ' + Justfname(.cSourceFileName)
			Endif
		
			lcTitle = lcTitle + " - " + Transform(Datetime())
			If loObject # loTopOfForm
				lcTitle = lcTitle +  '<br> Object: ' + .GetObjectPath (loObject)
			Endif
		Endwith
		
		****************************************************************
		TEXT TO lcText NOSHOW TEXTMERGE
		
		<title> <<lcTitle>> </title>
		
		<style type="text/css">.GridHeader {
			background-color: #C0C0C0;
		}
		.BodyTextStyle {
			font-family: Arial, Helvetica, sans-serif;
			font-size: 9pt;
			font-weight: normal;
		}
		
		td {
		 vertical-align:top;
		}
		
		</style>
		
		</head>
		
		<body class="BodyTextStyle">
		
		<h2>
		<<lcTitle>>
		</h2>
		
		ENDTEXT
		****************************************************************
		
		Return This.GetHTMLHeader() + lcText
		
	ENDPROC

	PROCEDURE gotodef
		Lparameters loObject, lcObjectName, lcMethodName, loTopOfForm, llDoDefault
		
		Local loChild As Object
		Local loPEMEditor As Object
		Local loTarget As Object
		Local lcPossibleObject, lcTarget, lnControlCount, lnHeight, lnI, lnLeft, lnTop, lnWidth, loEditorWin
		
		lcTarget	= 'loObject' + lcObjectName
		loPEMEditor	= This.oUtils.oPEMEditor
		
		If 'O' = Type (lcTarget)
			loTarget		 = Evaluate (lcTarget)
			lcPossibleObject = 'loTarget' + Iif(Empty(lcMethodName), '', '.' + lcMethodName)
		
			Do Case
		
					* Object
				Case 'O' = Type (lcPossibleObject)
					If Not Isnull (loPEMEditor)
						loPEMEditor.SetCurrentSelectedObject (Evaluate (lcPossibleObject))
					Else
						This.oUtils.FocusOnControl(Evaluate (lcPossibleObject))
					Endif
					Return .T.
		
					* not a PEM
				Case Not This.GetPEMStatus (loTarget, lcMethodName, 5)
		
					* Property
				Case This.GetPEMStatus (loTarget, lcMethodName, 3) = 'Property'
					If Not Isnull (loPEMEditor)
						loPEMEditor.SetCurrentObjectProperty (loTarget, lcMethodName)
					Endif
		
					Return .T.
		
					* not a method or event
				Case Not Inlist (This.GetPEMStatus (loTarget, lcMethodName, 3), 'Method', 'Event')
		
					* no code, or only wanting to show parent code
				Case llDoDefault
					This.oUtils.ViewParentCode (lcMethodName, loTarget, .T., llDoDefault)
					This.MoveWindow()
					Return .T.
		
					* show code
				Otherwise
					This.oUtils.EditLocalMethodCode (This.oUtils.cSourceFileName, loTopOfForm, loTarget, lcMethodName, This.oUtils.lClass)
					This.MoveWindow()
		
					If Empty (loTarget.ReadMethod (lcMethodName))					;
							And This.GetPEMStatus (loTarget, lcMethodName, 6)		;
							And This.GetPEMStatus (loTarget, lcMethodName, 0)
		
						* find the editor window just opened (is default)
						loEditorWin = This.oEditorWin
						loEditorWin.FindWindow()
						lnLeft	 = loEditorWin.GetLeft()
						lnTop	 = loEditorWin.GetTop()
						lnWidth	 = loEditorWin.GetWidth()
						lnHeight = loEditorWin.GetHeight()
		
						This.oUtils.ViewParentCode (lcMethodName, loTarget, .T., llDoDefault)
		
						* and move the parent code window below it
						loEditorWin.FindWindow()
						loEditorWin.MoveWindow (lnLeft + 30, lnTop + 60)
						loEditorWin.ReSizeWindow (lnWidth - 20, Max(lnHeight - 60, 100))
		
					Endif
					Return .T.
		
					*!* * Removed 4/7/2013 / JRN
					*!* * no code, or only wanting to show parent code
					*!* 		Case llDoDefault Or (								;
					*!* 	Empty (loTarget.ReadMethod (lcMethodName))				;
					*!* 	And This.GetPEMStatus (loTarget, lcMethodName, 6)		;
					*!* 	And This.GetPEMStatus (loTarget, lcMethodName, 0)		;
					*!* 	)
					*!* This.oUtils.ViewParentCode (lcMethodName, loTarget, .T., llDoDefault)
					*!* This.MoveWindow()
					*!* Return .T.
		
					*!* * show code
					*!* 		Otherwise
					*!* This.oUtils.EditLocalMethodCode (This.oUtils.cSourceFileName, loTopOfForm, loTarget, lcMethodName, This.oUtils.lClass)
					*!* This.MoveWindow()
					*!* Return .T.
		
			Endcase
		
		Endif
		
		lnControlCount = This.GetControlCount (loObject)
		If lnControlCount # 0 And 'O' = Type ('loObject.Objects(1)')
		
			For lnI = 1 To lnControlCount
				loChild = loObject.Objects (lnI)
				If This.GoToDef (loChild, lcObjectName, lcMethodName, loTopOfForm, llDoDefault)
					Return .T.
				Endif
			Endfor
		
		Endif
		
		Return .F.
		
	ENDPROC

	PROCEDURE gotodefcreateobject
		Local lcClass, lcText, lnEndPos
		
		lnEndPos = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 1)
		lcText	 = This.oEditorWin.GetString (This.nRightHighlightPos + 1, lnEndPos)
		
		If '(' $ lcText
			lcText = Substr (lcText, 1 + At ('(', lcText))
		Endif
		
		If ')' $ lcText
			lcText = Left (lcText, At (')', lcText) - 1)
		Endif
		
		If Alines (laLines, lcText, .T., ',', ';') >= 1
			lcClass	   = This.RemoveQuotes (Alltrim (laLines(1)))
			Return This.GoToDefFindClass (lcClass)
		Else
			Return .F.
		Endif
		
	ENDPROC

	PROCEDURE gotodefcurlybraces
		Lparameters lcMethodName
		
		Local laWords[1], lcCLass, lcClassLib, lcCommand, lcDoubles, lcFullName, lcQuote, lnEndPos
		Local lnStartPos, lnWordCount
		
		lnStartPos = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 0)
		lnEndPos   = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 1)
		lcCommand  = This.oEditorWin.GetString (m.lnStartPos, m.lnEndPos)
		
		lcDoubles = Strextract(m.lcCommand, '{{', '}}')
		If Empty(m.lcDoubles) Or Not Upper(Getwordnum(m.lcDoubles, 1, ' =' + Tab)) == Upper(m.lcMethodName)
			Return .F.
		Endif
		
		lnWordCount	= Alines(laWords, Strextract(m.lcDoubles, '{', '}'), 5, ',')
		lcCLass		= m.laWords[1]
		lcClassLib	= ''
		
		If m.lnWordCount > 1
			lcClassLib = m.laWords[2]
			lcQuote	   = Left(m.lcClassLib, 1)
			If m.lcQuote $  ['"] + '['
				lcClassLib = Substr(m.lcCommand, Atc(m.lcClassLib, m.lcCommand))
				lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
			Endif
			lcFullName = Fullpath (m.lcClassLib)
			If File (m.lcFullName)
				This.EditSourceX (m.lcFullName, m.lcCLass)
				Return .T.
			Else
				Return .F.
			Endif
		
		Else
			Return This.GoToDefFindClass (m.lcCLass)
		Endif
		
	ENDPROC

	PROCEDURE gotodeffindclass
		Lparameters tcName
		
		Local loInclude AS 'Empty'
		Local lcFileName, lcMethodCode, lcName, llFound, lnCharPosition 
		* Create an object to hold return values.
		
		loInclude = Createobject ('Empty')
		AddProperty (loInclude, 'File', '')
		AddProperty (loInclude, 'CharPosition', 0)
		
		lcName		 = Upper (tcName)
		
		* This a PRG?  
		If loInclude.CharPosition = 0 and This.oEditorWin.GetEnvironment(25) = 1
			lcMethodCode = Upper (This.oEditorWin.Getstring(0, 10000000))
			This.GoToDefProcessPRGForClass ('', lcName, loInclude, lcMethodCode)
		Endif
		
		If loInclude.CharPosition = 0
			This.GoToDefFindClassInPath (lcName, loInclude)
		Endif
		
		lcFileName	   = loInclude.File
		lnCharPosition = loInclude.CharPosition
		
		Do Case
		
			Case Empty (lcFileName) And Empty (lnCharPosition)
				llFound = .F.
		
			Case Empty (lcFileName)
				llFound = .T.
				With This.oEditorWin
					.Select (lnCharPosition -1, lnCharPosition + Len (lcName) - 1)
					.ShowPosition()
				Endwith
		
			Case Empty (lnCharPosition)
				llFound = .T.
				This.EditsourceX (lcFileName, tcName)
		
			Otherwise
				llFound = .T.
				This.EditsourceX (lcFileName, , ,lnCharPosition, lnCharPosition + Len (lcName))
				ExecScript(_Screen.cThorDispatcher, 'THOR_PROC_SelectText', lnCharPosition - 1, lnCharPosition + Len (lcName) - 1)
		Endcase
		
		Return llFound
		
	ENDPROC

	PROCEDURE gotodeffindclassinpath
		Lparameters tcName, toInclude
		
		Local laLines[1], lcPRG, lcProcedures, lcVCX, llFound, lnI, lnLines, loFile
		
		* Check all open class libraries.
		
		If Not llFound
			lcProcedures = Set ('ClassLib')
			lcProcedures = Strtran (lcProcedures, ';', ',')
			lnLines		 = Alines (laLines, lcProcedures, .T., ',')
			For lnI = 1 To lnLines
				If Not Empty (laLines[lnI])
					lcVCX = Alltrim (laLines[lnI])
					Do Case
						Case '"' $ lcVCX
							lcVCX = Substr (lcVCX, 2, At ('"', lcVCX, 2) - 2)
						Case ' ALIAS ' $ Upper (lcVCX)
							lcVCX = Left (lcVCX, At (' ALIAS ', lcVCX) - 1)
					Endcase
		
					If Inlist (Upper (Justext (laLines[lnI])), 'VCX')
						If File (lcVCX)
							This.GoToDefProcessVCXForClass (lcVCX, tcName, toInclude)
							If Not Empty (toInclude.File)
								Exit
							Endif Not Empty (toInclude.File)
						Endif
					Endif
				Endif
			Next lnI
		Endif Not llFound
		
		
		* Check all open procedure files.
		
		If Not llFound
			lcProcedures = Set ('Procedure')
			lcProcedures = Strtran (lcProcedures, ';', ',')
			lnLines		 = Alines (laLines, lcProcedures, .T., ',')
			For lnI = 1 To lnLines
				If Not Empty (laLines[lnI])
					If Inlist (Upper (Justext (laLines[lnI])), 'PRG', 'FXP')
						lcPRG = Forceext (laLines[lnI], 'PRG')
						If File (lcPRG)
							This.GoToDefProcessPRGForClass (lcPRG, tcName, toInclude, Upper (Filetostr (lcPRG)))
							If Not Empty (toInclude.File)
								Exit
							Endif Not Empty (toInclude.File)
						Endif
					Endif
				Endif
			Next lnI
		Endif Not llFound
		
		
		* Check all VCXs in the active project.
		
		If Not llFound And Type ('_vfp.ActiveProject') = 'O'
			For Each loFile In _vfp.ActiveProject.Files
				If Not llFound And loFile.Type = 'V'
					This.GoToDefProcessVCXForClass (loFile.Name, tcName, toInclude)
					If Not Empty (toInclude.File)
						llFound = .T.
						Exit
					Endif Not Empty (toInclude.File)
				Endif loFile.Type = 'P'
			Next loFile
		
			* Check all PRGs in the active project.
		
			For Each loFile In _vfp.ActiveProject.Files
				If Not llFound And loFile.Type = 'P'
					lcPRG = loFile.Name
					This.GoToDefProcessPRGForClass (lcPRG, tcName, toInclude, Upper (Filetostr (lcPRG)))
					If Not Empty (toInclude.File)
						llFound = .T.
						Exit
					Endif Not Empty (toInclude.File)
				Endif loFile.Type = 'P'
			Next loFile
		Endif Not llFound ...
		
		Return
		
	ENDPROC

	PROCEDURE gotodeffindconstant
		*** JIM: remove the second parameter and use "This" instead of toPEM everywhere it occurs
		Lparameters tcName
		
		*** Doug Hennig 2010-11-18
		
		* Get the include file for the form/class being edited.
		
		Local loInclude As 'Empty'
		Local laLines[1], lcFileName, lcInclude, lcIncludeFile, lcMethodCode, lcName, lcObjectFile, llFound
		Local lnCharPosition, lnI, lnLines
		
		* Create an object to hold return values.
		
		loInclude = Createobject ('Empty')
		AddProperty (loInclude, 'File', '')
		AddProperty (loInclude, 'CharPosition', 0)
		
		lcName		 = Upper (tcName)
		
		* Start with the current method.
		If InList(This.oEditorWin.GetEnvironment(25), 1, 10)
			lcMethodCode = Upper (This.oEditorWin.Getstring(0, 10000000))
			This.GoToDefProcessInclude ('', lcMethodCode, lcName, loInclude)
		Endif
		
		If loInclude.CharPosition = 0
			lcInclude	 = This.oUtils.GetCurrentIncludeFile()
			If File (lcInclude)
				This.GoToDefProcessInclude (lcInclude, Filetostr (lcInclude), lcName, loInclude)
			Endif
		Endif
		
		* This a PRG?  If so, there can be PROCs and FUNCs here
		If loInclude.CharPosition = 0 And This.oEditorWin.GetEnvironment(25) = 1
			This.GoToDefProcessPRG ('', lcName, loInclude, lcMethodCode)
		Endif
		
		If loInclude.CharPosition = 0
			This.GoToDefFindProgram (lcName, loInclude)
		Endif
		
		lcFileName	   = loInclude.File
		lnCharPosition = loInclude.CharPosition
		
		Do Case
		
			Case Empty (lcFileName) And Empty (lnCharPosition)
				llFound = .F.
		
			Case Empty (lcFileName)
				llFound = .T.
				ExecScript(_Screen.cThorDispatcher, 'THOR_PROC_SelectText', lnCharPosition - 1, lnCharPosition + Len (lcName) - 1)
		
				*!* ******************** Removed 11/29/13 *****************
				*!* With This.oEditorWin
				*!* 	.Select (lnCharPosition - 1, lnCharPosition + Len (lcName) - 1)
				*!* 	.ShowPosition()
				*!* Endwith
		
			Case Empty (lnCharPosition)
				llFound = .T.
				This.EditsourceX (lcFileName)
				This.MoveWindow()
		
			Otherwise
				llFound = .T.
				This.EditsourceX (lcFileName, , ,lnCharPosition, lnCharPosition + Len (lcName))
				ExecScript(_Screen.cThorDispatcher, 'THOR_PROC_SelectText', lnCharPosition - 1, lnCharPosition + Len (lcName) - 1)
				This.MoveWindow()
		Endcase
		
		Return llFound
		
	ENDPROC

	PROCEDURE gotodeffindfile
		Lparameters lcFileName
		
		Local loFile As Object
		Local lcFullName, llFound
		
		If Empty(Justext(lcFileName))
			lcFileName = Forceext(lcFileName, '.SCX')
		Endif
		
		llFound = .F.
		If Not llFound And Type ('_vfp.ActiveProject') = 'O' and not '\' $ lcFileName 
			For Each loFile In _vfp.ActiveProject.Files
				If Not llFound
					lcFullName = loFile.Name
					If Lower(Justfname(lcFullName)) == Lower(Justfname(lcFileName))
						llFound = .T.
						Exit
					Endif 
				Endif
			Next loFile
		Endif
		
		If Not llFound
			lcFullName = Fullpath (lcFileName)
		Endif
		
		If File (lcFullName)
			This.EditSourceX (lcFullName)
			Return .T.
		Else
			Return .F.
		Endif
		
	ENDPROC

	PROCEDURE gotodeffindprogram
		Lparameters tcName, toInclude
		
		Local loFile AS Object
		Local laLines(1), lcFile, lcFileName, lcProcedures, llFound, lnI, lnLines 
		
		* Check all PRGs in the active project. We may have to look in procedure files.
		
		If Not llFound And Type ('_vfp.ActiveProject') = 'O'
			For Each loFile In _vfp.ActiveProject.Files
				If loFile.Type = 'P'
					This.GoToDefProcessPRG (loFile.Name, tcName, toInclude)
					If Not Empty (toInclude.File)
						llFound = .T.
						Exit
					Endif Not Empty (toInclude.File)
				Endif loFile.Type = 'P'
			Next loFile
		Endif Not llFound ...
		
		* All open procedure files.
		
		If Not llFound
			lcProcedures = Set ('Procedure')
			lcProcedures = Strtran (lcProcedures, ';', ',')
			lnLines		 = Alines (laLines, lcProcedures, .T., ',')
			For lnI = 1 To lnLines
				If Not Empty (laLines[lnI])
					If Inlist(Upper(Justext(laLines[lnI])), 'PRG', 'FXP')
						lcFileName = Forceext(laLines[lnI], 'PRG')
						If File(lcFileName)
							This.GoToDefProcessPRG (lcFileName, tcName, toInclude)
							If Not Empty (toInclude.File)
								Exit
							Endif Not Empty (toInclude.File)
						Endif
					Endif
				Endif
			Next lnI
		Endif Not llFound
		
		* PRGs in the path.
		
		lcFile = tcName + '.PRG'
		If File (lcFile)
			toInclude.File = lcFile
			llFound		   = .T.
		Endif File (lcFile)
		
		
		Return
		
		
	ENDPROC

	PROCEDURE gotodefineclass
		Lparameters lcMethodName
		
		Local lcCLass, lcClassLib, lcCommand, lcFullName, lcQuote, lnEndPos, lnStartPos
		If Not Upper(m.lcMethodName) == 'DEFINE'
			Return .F.
		Endif
		
		lnStartPos = This.oEditorWin.GetLineStart (This.nLeftHighlightPos, 0)
		lnEndPos   = This.oEditorWin.GetLineStart (This.nLeftHighlightPos, 1)
		lcCommand  = This.oEditorWin.GetString (m.lnStartPos, m.lnEndPos - 1)
		lcCommand  = Chrtran(m.lcCommand, CRLF, '  ')
		
		lcCLass	   = Chrtran(Getwordnum(m.lcCommand, 5), ['"] + '[]', '')
		lcClassLib = ''
		If Upper(Getwordnum(m.lcCommand, 6)) == 'OF'
			lcClassLib = Getwordnum(m.lcCommand, 7)
			lcQuote	   = Left(m.lcClassLib, 1)
			If m.lcQuote $  ['"] + '['
				lcClassLib = Substr(m.lcCommand, Atc(m.lcClassLib, m.lcCommand))
				lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
			Endif
		
			lcFullName = Fullpath (m.lcClassLib)
			If File (m.lcFullName)
				This.EditSourceX (m.lcFullName, m.lcCLass)
				Return .T.
			Else
				Return .F.
			Endif
		Else
			Return This.GoToDefFindClass (m.lcCLass)
		Endif
		
	ENDPROC

	PROCEDURE gotodefinition
		Local laObjects[1], lcFullMethodName, lcMethod, lcMethodName, lcNewName, lcObjectName
		Local lcOriginalPath, lcPlugIn, lcText, lcTextAfter, lcTextBefore, lcWonTop, llAnySelectedObjects
		Local llDoDefault, llFormOrClass, llFound, llFullPath, llResult, llSearched, lnEndPos, lnNextDot
		Local lnStartPos, lnWindowType, loTopOfForm, lxResult
		
		lnWindowType = This.oEditorWin.FindWindow()
		If m.lnWindowType < 0
			This.QuickAddPEM(.T.)
			Return ''
		Endif
		llFormOrClass = m.lnWindowType = 10
		
		lcMethodName	 = This.GetCurrentHighlightedText (.T., .T.)
		lcFullMethodName = m.lcMethodName
		
		lcWonTop	= This.oEditorWin.GetTitle()
		loTopOfForm	= This.Outils.FindTopMostParent()
		
		*** JRN 2010-04-03 : get name of window on top; correcting as well for reference to top of form/class
		lcWonTop = Alltrim (Chrtran (Upper (m.lcWonTop), '*', ' '))
		Do Case
				* remove timestamp, if any
			Case '(' $ m.lcWonTop
				lcWonTop   = Left (m.lcWonTop, At ('(', m.lcWonTop) - 1)
				llFullPath = .T.
				* for inherited code
			Case Left (m.lcWonTop, 1) = '-' And '.Inherited.PRG' = Right(m.lcWonTop, 14)
				*	lcWonTop   = Left (lcWonTop, rAt ('._', lcWonTop) - 1)
				lcWonTop	  = Substr (m.lcWonTop, 2, Len(m.lcWonTop) - 15)
				llFullPath	  = .T.
				llFormOrClass = .T.
		Endcase
		
		If (Not Isnull (m.loTopOfForm)) And m.lcWonTop = Upper (m.loTopOfForm.Name) + '.'
			lcWonTop = Substr (m.lcWonTop, At ('.', m.lcWonTop))
		Endif
		lcWonTop = Alltrim ( Chrtran (m.lcWonTop, '-', ''))
		
		*** JRN 2010-04-03 : Handling for DoDefault
		If Upper (m.lcMethodName) = 'DODEFAULT'
			lcMethodName = m.lcWonTop
			llDoDefault	 = .T.
			If Not '(' $ m.lcMethodName
				lcMethodName = 'This.' + Justext(m.lcMethodName)
			Endif
		Else
			llDoDefault = .F.
		Endif
		
		*** JRN 2010-04-02 : Special processing for THISFORM, THIS, and loObject.
		If Upper (m.lcMethodName) == 'THIS'
			lcMethodName = 'THIS.'
		Endif
		
		Do Case
			Case Empty(m.lcMethodName)
		
			Case Left(m.lcMethodName, 1) $  ['"] + '['
				llFound	   = This.GoToDefFindFile (This.RemoveQuotes (m.lcMethodName))
				llSearched = .T.
		
			Case m.llFormOrClass And m.lcMethodName = '.' && this is OK
		
			Case m.llFormOrClass And Upper (m.lcMethodName) == 'THISFORM'
				llFound	   = This.GoToDef (m.loTopOfForm, '', '', m.loTopOfForm, m.llDoDefault)
				llSearched = .T.
		
			Case m.llFormOrClass And Upper (m.lcMethodName) = 'THISFORM.'
				lcMethodName = Substr (m.lcMethodName, 9)
		
			Case m.llFormOrClass And Upper (m.lcMethodName) = 'THIS.'
		
				If Upper (m.lcMethodName) == 'THIS.'
					lcMethod = ''
				Else
					lcMethod = Substr (m.lcMethodName, 5)
				Endif
		
				llAnySelectedObjects = 0 # Aselobj (laObjects) Or 0 # Aselobj (laObjects, 1)
		
				Do Case
					Case Isnull (m.loTopOfForm)
		
					Case m.llFullPath && we got the full path already (parens indicated timestamp)
						lcMethodName = Left (m.lcWonTop, Rat ('.', m.lcWonTop) - 1) + m.lcMethod
					Case m.lcWonTop = Upper (m.laObjects(1).Name + '.') && matches current object?
						lcMethodName = This.Outils.GetObjectPath (m.laObjects(1)) + m.lcMethod
					Otherwise
						lcMethodName = Left (m.lcWonTop, At ('.', m.lcWonTop) - 1) + m.lcMethod
				Endcase
				If Empty(m.lcMethodName)
					llFound	   = This.GoToDef (m.loTopOfForm, '', '', m.loTopOfForm, m.llDoDefault)
					llSearched = .T.
				Endif
		
			Case 1 = Occurs('.', m.lcMethodName) And Len(Justext(m.lcMethodName)) <= 3 And This.GoToDefFindFile (m.lcMethodName)
				llFound	   = .T.
				llSearched = .T.
		
			Case m.llFormOrClass And '.' $ m.lcMethodName && must be something like loObject.<Reference> ... remove loObject
				lnNextDot	 = At ('.', m.lcMethodName)
				lcMethodName = Substr (m.lcMethodName, m.lnNextDot)
		
				* This. in classes
			Case m.lnWindowType = 1 And Upper (m.lcMethodName) = 'THIS.'
				lxResult   = Execscript(_Screen.cThorDispatcher, 'Thor_Proc_PEME_GoToDefPRGXClasses', m.lcMethodName)
				llFound	   = (Not Isnull(m.lxResult)) And m.lxResult
				llSearched = .T.
		
			Case Upper (m.lcMethodName) == 'NEWOBJECT'
				llFound	   = This.GoToDefNewObject ()
				llSearched = .T.
		
			Case Upper (m.lcMethodName) == 'CREATEOBJECT'
				llFound	   = This.GoToDefCreateObject ()
				llSearched = .T.
		
			Case Upper (m.lcMethodName) == 'LOCAL'
				llFound	   = This.GoToDefLocal ()
				llSearched = .T.
		
			Case This.GoToDefCurlyBraces (m.lcMethodName)
				llFound	   = .T.
				llSearched = .T.
		
			Case This.GoToDefineClass (m.lcMethodName)
				llFound	   = .T.
				llSearched = .T.
		
			Otherwise
				lnStartPos = This.oEditorWin.GetLineStart (This.nLeftHighlightPos, 0)
				lcText	   = This.oEditorWin.GetString (m.lnStartPos, This.nLeftHighlightPos - 1)
				Do Case
					Case 2 = Getwordcount (m.lcText)							;
							And Upper (Getwordnum (m.lcText, 1)) == 'DO'		;
							And Upper (Getwordnum (m.lcText, 2)) == 'FORM'
						llFound	   = This.GoToDefFindFile (Forceext (m.lcMethodName, 'SCX'))
					Case 2 = Getwordcount (m.lcText)								;
							And Upper (Getwordnum (m.lcText, 1)) == 'REPORT'		;
							And Upper (Getwordnum (m.lcText, 2)) == 'FORM'
						llFound	   = This.GoToDefFindFile (Forceext (m.lcMethodName, 'FRX'))
					Otherwise
						llFound	   = This.GoToDefFindConstant (m.lcMethodName)
				Endcase
		
				llSearched = .T.
		
		Endcase
		
		
		Do Case
		
			Case m.llSearched Or Empty (m.lcMethodName) Or Not m.llFormOrClass
		
			Case Isnull (m.loTopOfForm)
				llFound = .F.
		
			Case '.' $ m.lcMethodName
				lcObjectName = Upper (Juststem (m.lcMethodName))
				If m.lcObjectName # '.' And Not Empty (m.lcObjectName)
					lcObjectName = '.' + m.lcObjectName
				Endif
				lcMethod = Justext (m.lcMethodName)
				llFound	 = This.GoToDef (m.loTopOfForm, m.lcObjectName, m.lcMethod, m.loTopOfForm, m.llDoDefault)
		
			Otherwise
				llFound = This.GoToDef (m.loTopOfForm, '', m.lcMethodName, m.loTopOfForm, m.llDoDefault)
		
		Endcase
		
		Do Case
			Case m.llFound
		
			Case m.llFormOrClass and Upper(m.lcFullMethodName) = 'THISFORM' and Upper(m.loTopOfForm.BaseClass) # 'FORM'
		
			Case m.llFormOrClass And 1 = Occurs('.', m.lcMethodName) and InList(Upper(JustStem(m.lcFullMethodName)) + '.', 'THIS.', 'THISFORM.')
		
				lcNewName = Justext (m.lcMethodName)
				Do Form AskAddPemNewGoToDef With m.lcNewName, .T. To m.llResult
				If Not m.llResult
					Return
				Endif
		
			Case 0 = Occurs('.', m.lcMethodName) And (Not Empty (m.lcMethodName)) And This.GoToDefFindClass(m.lcMethodName)
		
			Case This.GoToDefFindFile (Forceext (m.lcMethodName, 'SCX'))
		
			Case This.GoToDefFindFile (Forceext (m.lcMethodName, 'FRX'))
		
			Case not Empty(JustExt(lcFullMethodName)) and This.GoToDefFindFile (lcFullMethodName)
		
			Otherwise
		
				lcPlugIn = Execscript(_Screen.cThorDispatcher, 'Full Path=Thor_Proc_PEME_GoToDefinition')
				If Not Empty (m.lcPlugIn)
					lnStartPos	 = This.oEditorWin.GetLineStart (This.nLeftHighlightPos, 0)
					lcTextBefore = This.oEditorWin.GetString (m.lnStartPos, This.nLeftHighlightPos - 1)
		
					lnEndPos	= This.oEditorWin.GetLineStart (This.nRightHighlightPos, 1)
					lcTextAfter	= This.oEditorWin.GetString (This.nRightHighlightPos + 1, m.lnEndPos - 1)
					lcTextAfter	= Chrtran (m.lcTextAfter, CR + LF, '')
		
					lcOriginalPath = Set('Path')
					Set Path To (This.Outils.cPlugInPath) Additive
					llFound = This.oDynamicSnippet.GoToDefinition (m.lcPlugIn, m.lcMethodName, m.lcTextBefore, m.lcTextAfter)
					Set Path To (m.lcOriginalPath)
				Else
					llFound = .F.
				Endif
		
				If Not m.llFound
					llFound = This.GoToISXClassDefinition(lcFullMethodName)
				Endif
		
				If Not m.llFound
					Messagebox (Strtran (ccLOC_Cap_DefNotFound, '<insert>', m.lcFullMethodName), 16, ccLOC_Title_DefNotFound)
				Endif
		
		
		Endcase
		
	ENDPROC

	PROCEDURE gotodeflocal
		Local lcCLass, lcClassLib, lcCommand, lcFullName, lcQuote, lnEndPos, lnStartPos
		
		lnStartPos = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 0)
		lnEndPos   = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 1)
		lcCommand  = This.oEditorWin.GetString (m.lnStartPos, m.lnEndPos)
		
		lcCLass	   = Chrtran(Getwordnum(m.lcCommand, 4), ['"] + '[]', '')
		lcClassLib = ''
		
		If Upper(Getwordnum(m.lcCommand, 5)) == 'OF'
			lcClassLib = Getwordnum(m.lcCommand, 6)
			lcQuote	   = Left(m.lcClassLib, 1)
			If m.lcQuote $  ['"] + '['
				lcClassLib = Substr(m.lcCommand, Atc(m.lcClassLib, m.lcCommand))
				lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
			Endif
			lcFullName = Fullpath (m.lcClassLib)
			If File (m.lcFullName)
				This.EditSourceX (m.lcFullName, m.lcCLass)
				Return .T.
			Else
				Return .F.
			Endif
		
		Else
			Return This.GoToDefFindClass (m.lcCLass)
		Endif
		
	ENDPROC

	PROCEDURE gotodeflocateline
		Lparameters tcCode, tcName, tcPattern
		Local lnReturn, loMatches, loRegExp
		
		*** Doug Hennig 2010-11-18
		 
		* Create and set up a RegExp object.
		
		loRegExp = This.oUtils.GetRegExp()
		With loRegExp
			*** JRN 2010-12-17 : Following pattern guarantees start of line
			.Pattern	= '^\s*' + tcPattern + '\s+' + tcName + '\b'
		EndWith 	
		
		* Try to find matches. Returns position of match (origin 1; 0 means no match)
		
		loMatches = loRegExp.Execute (tcCode)
		If loMatches.Count = 0
			lnReturn = 0
		Else
			lnReturn = loMatches.Item(0).FirstIndex + loMatches.Item(0).Length + 1 - Len(tcName)
		Endif loMatches.Count = 0
		
		Return lnReturn
		
	ENDPROC

	PROCEDURE gotodefnewobject
		Local lcClass, lcClassLib, lcFullName, lcText, lnEndPos
		
		lnEndPos = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 1)
		lcText	 = This.oEditorWin.GetString (This.nRightHighlightPos + 1, lnEndPos)
		
		If '(' $ lcText
			lcText = Substr (lcText, 1 + At ('(', lcText))
		Endif
		
		If ')' $ lcText
			lcText = Left (lcText, At (')', lcText) - 1)
		Endif
		
		If Alines (laLines, lcText, .T., ',', ';') >= 2
			lcClass	   = This.RemoveQuotes (Alltrim (laLines(1)))
			lcClassLib = This.RemoveQuotes (Alltrim (laLines(2)))
		
			If Empty (Justext (lcClassLib))
				lcClassLib = Forceext (lcClassLib, '.VCX')
			Endif
		
			lcFullName = Fullpath (lcClassLib)
			If File (lcFullName)
				This.EditSourceX (lcFullName, lcClass)
				Return .T.
			Else
				Return .F.
			Endif
		Else
			Return .F.
		Endif
		
	ENDPROC

	PROCEDURE gotodefprocessinclude
		Lparameters tcIncludeFileName, tcIncludeText, tcName, toInclude
		
		*** Doug Hennig 2010-11-18
		Local lcIncludeFile, lnCharPosition, lnI, loIncludeFiles
		
		lnCharPosition = This.GoToDefLocateLine (tcIncludeText, tcName, '#DEFI(|N|NE)')
		
		If lnCharPosition > 0
			toInclude.File		   = tcIncludeFileName
			toInclude.CharPosition = lnCharPosition
		Else
			loIncludeFiles = This.oUtils.GetIncludeFiles (tcIncludeText)
			For Each lcIncludeFile In loIncludeFiles FoxObject
				If toInclude.CharPosition > 0
					Exit
				Endif toInclude.CharPosition > 0
		
				Do Case
					Case Empty(tcIncludeFileName)
						lcIncludeFile = Fullpath (lcIncludeFile)
					Case Upper(lcIncludeFile) = 'FOXPRO.H'
						lcIncludeFile = Addbs(Home()) + lcIncludeFile
					Otherwise
						lcIncludeFile = Fullpath (lcIncludeFile, tcIncludeFileName)
				Endcase
		
				If File (lcIncludeFile)
					This.GoToDefProcessInclude (lcIncludeFile, Filetostr (lcIncludeFile), tcName, toInclude)
				Endif
		
			Next lnI
		Endif
		
		Return
		
		
		
	ENDPROC

	PROCEDURE gotodefprocessprg
		Lparameters tcPRG, tcName, toInclude, tcCode
		
		*** Doug Hennig 2010-11-18
		
		Local lcCode, lcFile, lnCharPosition
		lcFile = tcName + '.PRG'
		
		Do Case
			Case Not File (tcPRG) and not Empty(tcPRG)
		
			Case Upper (Justfname (tcPRG)) = lcFile
				toInclude.File		   = tcPRG
				toInclude.CharPosition = 0
		
			Otherwise
				If 'C' = Vartype(tcCode)
					lcCode = tcCode
				Else
					lcCode = Upper (Filetostr (tcPRG))
				Endif
		
				lnCharPosition = This.GoToDefLocateLine (lcCode, tcName, 'PROC(|E|ED|EDU|EDUR|EDURE)')
				If lnCharPosition = 0
					lnCharPosition = This.GoToDefLocateLine (lcCode, tcName, 'FUNC(|T|TI|TIO|TION)')
				Endif lnCharPosition = 0
				If lnCharPosition > 0
					toInclude.File		   = tcPRG
					toInclude.CharPosition = lnCharPosition
				Endif lnCharPosition > 0
		
		Endcase
		
		Return
		
	ENDPROC

	PROCEDURE gotodefprocessprgforclass
		Lparameters tcPRG, tcName, toInclude, tcCode
		
		*** JRN 2010-12-17 : 
		
		Local lnCharPosition
		
		lnCharPosition = This.GoToDefLocateLine (tcCode, tcName, 'DEFI(|N|NE)\s+CLAS(|S)')
		If lnCharPosition > 0
			toInclude.File		   = tcPRG
			toInclude.CharPosition = lnCharPosition
		Endif lnCharPosition > 0
		
		Return
		
	ENDPROC

	PROCEDURE gotodefprocessvcxforclass
		Lparameters tcVCX, tcName, toInclude
		
		*** Doug Hennig 2010-11-18
		Local llOK, lnSelect
		lnSelect = Select()
		Select 0
		
		Try
			Use (tcVCX) Again Shared Alias This_VCX
			llOK = .T.
		Catch
			llOK = .F.
		Endtry
		
		If llOK
			Locate For (Lower (objname)) == Lower (tcName)		;
				And Lower(reserved1) = 'class' And Not Deleted()
			If Found()
				toInclude.File		   = tcVCX
			EndIf
			Use 
		Endif
		
		Select (lnSelect)
		Return
	ENDPROC

	PROCEDURE gotoisxclassdefinition
		Lparameters lcMethodName
		
		Local loCodeBlocks As Collection
		Local lcBlock, lcClass, lcClassLib, lcCode, lcDefineClass, lcExt, lcMethod, lcPRG, lcQuote, lnEnd
		Local lnI, lnStart, loBlock, loObject
		
		lcClass	   = ''
		lcClassLib = ''
		lcMethod   = ''
		
		If '.' $ m.lcMethodName
			loObject = Execscript(_Screen.cThorDispatcher, 'Thor_Proc_ISX', .F., .F., .F., .F., .F., .F., .T., Juststem(m.lcMethodName))
			If Vartype(m.loObject) = 'O'
				lcClass	   = m.loObject.Class
				lcClassLib = m.loObject.ClassLibrary
				lcMethod   = Justext(m.lcMethodName)
			Endif
		Endif
		
		If Empty(m.lcClass)
			loObject = Execscript(_Screen.cThorDispatcher, 'Thor_Proc_ISX', .F., .F., .F., .F., .F., .F., .T., m.lcMethodName)
			If Vartype(m.loObject) = 'O'
				lcClass	   = m.loObject.Class
				lcClassLib = m.loObject.ClassLibrary
			Endif
		Endif
		
		* These both are necessary else there is hanging reference preventing opening the file
		loObject			= Null
		_Screen.xThorResult	= Null
		
		lcExt	 = Upper(Justext(m.lcClassLib))
		
		Do Case
			Case Empty(m.lcClass)
				Return .F.
		
			Case m.lcExt == 'VCX'
				This.EditSourceX(m.lcClassLib, m.lcClass, m.lcMethod)
		
			Case m.lcExt == 'PRG' Or m.lcExt == 'FXP'
		
				Do While .T.
					lcPRG		 = Forceext(m.lcClassLib, 'PRG')
					If Not File(m.lcPRG)
						Return .F.
					Endif
		
					lcCode		  = Filetostr(m.lcPRG)
					loCodeBlocks  = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_GetProcedureStartPositions.prg', m.lcCode, .T.)
					lcDefineClass = ''
		
					For lnI = 1 To m.loCodeBlocks.Count
						loBlock	  = m.loCodeBlocks.Item[m.lnI]
						Do Case
							Case Upper(m.loBlock.Name) == Upper(m.lcClass)
								lcDefineClass = Substr (m.lcCode, m.loBlock.Start, m.loBlock.Length)
								lnStart		  = m.loBlock.Start + Atc(m.lcClass, m.lcDefineClass) - 1
								lnEnd		  = m.lnStart + Len(m.lcClass)
		
								If Empty(m.lcMethod)
									This.EditSourceX(m.lcPRG, , , m.lnStart, m.lnEnd)
									Execscript(_Screen.cThorDispatcher, 'Thor_Proc_SelectText')
									Return .T.
								Endif
		
							Case Upper(m.loBlock.Name) == Upper(m.lcClass + '.' + m.lcMethod)
								lcBlock	= Substr (m.lcCode, m.loBlock.Start, m.loBlock.Length)
								lnStart	= m.loBlock.Start + Atc(m.lcMethod, m.lcBlock) - 1
								lnEnd	= m.lnStart + Len(m.lcMethod)
		
								This.EditSourceX(m.lcPRG, , , m.lnStart, m.lnEnd)
								Execscript(_Screen.cThorDispatcher, 'Thor_Proc_SelectText')
		
								Return .T.
		
						Endcase
					Endfor
		
					* -------------------------------------------------------------------------------- 
					* OK, let's try the parent class
					If Empty(m.lcDefineClass)
						Return .F.
					Endif
		
					lcClass	   = Chrtran(Getwordnum(m.lcDefineClass, 5), ['"] + '[]', '')
					lcClass	   = Chrtran(m.lcClass, CRLF, '')
					lcClassLib = ''
					If Upper(Getwordnum(m.lcDefineClass, 6)) == 'OF'
						lcClassLib = Getwordnum(m.lcDefineClass, 7)
						lcClassLib = Chrtran(m.lcClassLib, CRLF, '')
						lcQuote	   = Left(m.lcClassLib, 1)
						If m.lcQuote $  ['"] + '['
							lcClassLib = Substr(m.lcDefineClass, Atc(m.lcClassLib, m.lcDefineClass))
							lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
						Endif
					Endif
		
					Try
						loObject = Newobject(m.lcClass, m.lcClassLib, 0)
					Catch
					Endtry
		
					If Isnull(m.loObject)
						Return .F.
					Endif
		
					lcClassLib = m.loObject.ClassLibrary
					loObject   = Null
		
				Enddo
		
				Return .F.
		
		Endcase
	ENDPROC

	PROCEDURE highlightcontrolstructure
		Local loControlStructures As Object
		Local loEditorWin As Object
		Local loItem As Object
		Local loMainItem As Object
		Local loTopItem As Object
		Local lcCodeSource, llStructureLine, lnEndByte, lnI, lnIndex, lnLevel, lnSelEnd, lnSelStart
		Local lnStartByte, lnStartIndex
		
		* Get the current window, code, and start and end of selected text
		loEditorWin = This.oEditorWin
		If 0 >= loEditorWin.FindWindow()
			Return
		Endif
		
		With loEditorWin
			lnSelStart	 = .GetSelStart()
			lnSelEnd	 = .GetSelEnd()
			lcCodeSource = .GetString (0, 1000000)
			lnLineNumber = .GetLineNumber(lnSelStart)
		Endwith
		
		* Get the collection of control structure positions
		loControlStructures = This.oUtils.GetControlStructurePositions (lcCodeSource)
		
		* and find which item therein immediately precedes start of selected text
		For lnIndex = loControlStructures.Count To 1 Step - 1
			loMainItem = loControlStructures.Item (lnIndex)
			If loMainItem.LineNumber <= lnLineNumber
				Exit
			Endif
		Endfor
		
		* Find the starting item for the current control structure
		Do Case
		
				* Procedure, Function, Define class
			Case loMainItem.ProcedureBoundary
				lnLevel = 0
		
				* If, Scan, Do Case, etc.  ... on same line
			Case loMainItem.StartStructure And loMainItem.LineNumber = lnLineNumber
				lnLevel = 0
				llStructureLine = .T.
				* following allows for repeated applications ... each time, finding next largest control structure
				If lnSelStart # lnSelEnd And lnSelStart = loEditorWin.GetByteOffset(loMainItem.LineNumber)
					lnLevel = -1
				Endif
		
				* Line following If, Scan, Do Case, etc.
			Case loMainItem.StartStructure
				lnLevel = 0
				llStructureLine = .F.
		
				* Endif, EndScan, EndCase, etc ... on same line
			Case loMainItem.EndStructure And loMainItem.LineNumber = lnLineNumber
				lnLevel = 1
				llStructureLine = .T.
		
				* Line following Endif, EndScan, EndCase, etc
			Case loMainItem.EndStructure
				lnLevel = 0
				llStructureLine = .F.
		
				* Else, Catch, Case, Otherwise ... on same line
			Case loMainItem.LineNumber = lnLineNumber
				lnLevel = 0
				llStructureLine = .T.
		
				* Line following Else, Catch, Case, Otherwise
			Otherwise
				lnLevel = 0
				llStructureLine = .F.
		
		Endcase
		
		For lnI = lnIndex To 1 Step - 1
			loItem = loControlStructures.Item (lnI)
			Do Case
				Case loItem.ProcedureBoundary
					lnStartIndex = lnI
					Exit
				Case loItem.StartStructure
					lnLevel = lnLevel + 1
					If lnLevel > 0
						lnStartIndex = lnI
						Exit
					Endif
				Case loItem.EndStructure
					lnLevel = lnLevel - 1
			Endcase
		Endfor
		
		* Find the ending item for the current control structure
		loTopItem	= loControlStructures.Item (lnStartIndex)
		lnStartByte	= loEditorWin.GetByteOffset(loTopItem.LineNumber)
		
		If loTopItem.ProcedureBoundary
			lnLevel		 = 1
			lnStartIndex = lnStartIndex + 1
		Else
			lnLevel = 0
		Endif
		
		lnEndByte	= Len (lcCodeSource)
		
		For lnI = lnStartIndex To loControlStructures.Count
			loItem = loControlStructures.Item (lnI)
			Do Case
				Case loItem.ProcedureBoundary
					lnEndByte = loEditorWin.GetByteOffset(loItem.LineNumber + 1)
					Exit
				Case loItem.StartStructure
					lnLevel = lnLevel + 1
				Case loItem.EndStructure
					lnLevel = lnLevel - 1
					If lnLevel <= 0
						lnEndByte = loEditorWin.GetByteOffset(loItem.LineNumber + 1)
						Exit
					Endif
			Endcase
		Endfor
		
		* finis!
		
		loEditorWin.Select (lnStartByte, lnEndByte)
		
	ENDPROC

	HIDDEN PROCEDURE Init
		Lparameters  loUtils, loPrefs, loEditorWin, lcSnippetPath
		
		With This
		
			.oUtils		= loUtils
			.cPluginPath = loUtils.cPluginPath 
			.oEditorWin	= loEditorWin
			.oPrefs		= loPrefs
			.oDynamicSnippet = Newobject ('DoubleHash', 		'Source\PEME_DoubleHash.PRG', 		''	;
				  , .oPrefs, lcSnippetPath)
			
			.aHandleHistory(1) = 0
		
			.CreateSystemMenu()
		
		Endwith
		
		
		
	ENDPROC

	PROCEDURE movewindow
		Local laDims[1], laEnv[25], lcTitle, lnCount, lnHandle, lnHeight, lnLeft, lnResult, lnTop, lnWidth
		Local loEditorWin
		
		* Get the whandle for the current window
		loEditorWin = This.oEditorWin
		lxResult = loEditorWin.FindWindow()
		
		If lxResult = -1
			Return
		EndIf
		
		If Not Inlist (loEditorWin.GetEnvironment(25), 1, 10)
			Return
		Endif
		
		lnCount = Alines (laDims, This.oPrefs.cWindowDimensions, .T., ',')
		
		If lnCount >= 1 And Not Empty (laDims(1))
			lnLeft = Val (laDims(1))
		Else
			lnLeft = loEditorWin.GetLeft()
		Endif
		
		If lnCount >= 2 And Not Empty (laDims(2))
			lnTop = Val (laDims(2))
		Else
			lnTop = loEditorWin.GetTop()
		Endif
		
		If lnCount >= 3 And Not Empty (laDims(3))
			lnWidth = Val (laDims(3))
		Else
			lnWidth = loEditorWin.GetWidth()
		Endif
		lnWidth = Max(100, Min(lnWidth, _Screen.Width - lnLeft)) 
		
		If lnCount >= 4 And Not Empty (laDims(4))
			lnHeight = Val (laDims(4))
		Else
			lnHeight = loEditorWin.GetHeight()
		Endif
		lnHeight = Max(100, Min(lnHeight, _Screen.Height - lnTop)) 
		
		loEditorWin.MoveWindow (lnLeft, lnTop)
		loEditorWin.ReSizeWindow (lnWidth, lnHeight)
		
	ENDPROC

	PROCEDURE navigatehandles
		Lparameters lcPlusMinus
		
		Local  ;
			loEditorWin As Object	,;
			loWindows As Object
		Local lnCount, lnHandle, lnI, lnWonTop, laEnv[25]
		
		*** JRN 2010-07-25 : Clean up handles list ... removes inactive ones, adds missing
		loEditorWin = This.oEditorWin
		loEditorWin.FindWindow()
		
		lnWonTop = loEditorWin.nHandle
		If This.lResetPrevNextHistory
			loWindows = loEditorWin.GetOpenWindows()
			lnCount	  = 0
			For lnI = 1 To loWindows.Count
				If loWindows (lnI).nWHandleType > 0
					lnHandle = loWindows (lnI).nWHandle
					Try
						If _EdGetEnv (lnHandle, @laEnv) # 0
							lnCount	 = lnCount + 1
							Dimension This.aHandleHistory (lnCount)
							This.aHandleHistory (lnCount) = lnHandle
						Endif
					Catch
					Endtry
				Endif
			Endfor
		
			If lnCount = 0
				Return
			Endif
		
			This.lResetPrevNextHistory = .F.
		Endif
		****************************************************************
		
		lnCount = Alen (This.aHandleHistory)
		Do Case
			Case This.aHandleHistory(1) # lnWonTop Or 1 = lnCount
				lnHandle = This.aHandleHistory(1)
			Case lcPlusMinus = '+'
				lnHandle = This.aHandleHistory (lnCount)
				Ains (This.aHandleHistory, 1)
				This.aHandleHistory(1) = lnHandle
			Case lcPlusMinus = '-'
				lnHandle = This.aHandleHistory(1)
				Adel (This.aHandleHistory, 1)
				This.aHandleHistory (lnCount) = lnHandle
				lnHandle = This.aHandleHistory(1)
		Endcase
		
		loEditorWin.SelectWindow(lnHandle)
		
	ENDPROC

	PROCEDURE pasteandpositioncursor
		Lparameters lcText
		
		Local lcChars, lcOldClipText, lnNewPos, lnSelStart
		
		With This.oEditorWin
		
			lcOldClipText = _Cliptext
			lnSelStart = .GetSelStart()
			_Cliptext  = lcText
			.Paste()
		
			If ide_LOC_PutCursorHere $ lcText
		
				* find beginning of marked text (beginning of PMD Marker)
				* get all text from here to end of method code
				lcChars	 = .GetString (lnSelStart, 1000000)
				* find the marker for where the cursor is to go
				lnNewPos = lnSelStart + At (ide_LOC_PutCursorHere, lcChars) - 1
				* select the marker, and cut it ... which leaves the cursor where desired
				.Select (lnNewPos, lnNewPos + Len (ide_LOC_PutCursorHere))
				.Cut()
		
			Endif
		
			_Cliptext = lcOldClipText
		
		Endwith
		
	ENDPROC

	PROCEDURE processopenmrumenuitems
		Lparameters lcChoice, lxParameters
		
		Local laMRU[1], lcClass, lcExt, lcFileName, lnFavorites, lnHandle, loException
		
		Do Case
		
			Case lcChoice = 'MRU'
				Alines (laMRU, lxParameters + ' ', .T., '|')
				lcFileName = laMRU(1)
				lcClass	   = Alltrim (laMRU(2))
		
				This.EditSourceX(lcFileName, lcClass)
				This.oUtils.SetRefreshTimer(500)
		
			Case lcChoice = 'Open Class'
				This.oUtils.DoFormModifyFile ('Class')
		
			Case lcChoice = 'Open Form'
				This.oUtils.DoFormModifyFile ('Form')
		
			Case lcChoice = 'Open Project'
				Modify Project ? Nowait
		
			Case lcChoice = 'Open Other'
				This.oUtils.DoFormModifyFile ('Other')
		
			Case lcChoice = 'Select'
				Set Library To (Home() + 'FoxTools.fll') Additive
				Try
					_WSelect (lxParameters)
				Catch
				Endtry
		
			Case lcChoice = 'Remove Favorite'
				This.oPrefs.cFavorites = Strtran(This.oPrefs.cFavorites, CR + lxParameters + CR, CR, 1, 1, 1)
		
			Case lcChoice = 'Add Favorite'
				This.oPrefs.cFavorites = This.oPrefs.cFavorites + lxParameters + CR
		
		Endcase
		
		
	ENDPROC

	PROCEDURE quickaddmethod
		Lparameters lcMethodName, lcMethodText
		
		Local laObjects[1]
		If 0 = Aselobj(laObjects) And 0 = Aselobj(laObjects, 1)
			Return
		Endif
		
		Do Form AskAddPEMNew With lcMethodName, .T., 'M', .F., lcMethodText
	ENDPROC

	PROCEDURE quickaddpem
		Lparameters llOnlyIfFormOrClass
		
		Local loForm As Object
		Local laObjects[1], lnI
		
		If llOnlyIfFormOrClass And 0 = Aselobj(laObjects) And 0 = Aselobj(laObjects, 1)
			Return
		Endif
		
		For lnI = 1 To _Screen.FormCount
			loForm = _Screen.Forms[lnI]
			If Pemstatus(loForm, 'lAskAddPEM', 5) And loForm.lAskAddPEM
				loForm.Show()
				loForm = .Null.
				Return
			Endif
		Endfor
		
		loForm = .Null.
		Do Form AskAddPEMNewStayOpen With, .T., , .T.  
	ENDPROC

	PROCEDURE release
		DoDefault()
		
		Try
			This.ClearTempFilesList()
		Catch
		
		EndTry
	ENDPROC

	PROCEDURE removequotes
		Lparameters lcText
		
		Local lcEnds
		
		lcEnds	 = Left (lcText, 1) + Right (lcText, 1)
		If Len (lcText) > 2 And Inlist (lcEnds, [''], [""], '[]')
			Return Substr (lcText, 2, Len (lcText) - 2)
		Else
			Return ''
		Endif
		
	ENDPROC

	PROCEDURE savehandlehistory
		Local lnHandle
		
		lnHandle = This.oEditorWin.GetWindowHandle()
		If This.aHandleHistory(1) # lnHandle
			This.lResetPrevNextHistory = .T.
			This.aHandleHistory(1) = lnHandle
		Endif
		
	ENDPROC

	PROCEDURE setonkeylabel
		Lparameters lcKey, lcMethod, lcDoThis
		Local lcCommand
		
		Try
			Do Case
				Case Not Empty (lcDoThis)
					On Key Label &lcKey 	&lcDoThis
				Case Not Empty (lcMethod)
					lcCommand = "_oPEMEditor." + lcMethod
					On Key Label &lcKey   	Evaluate(Iif("O" = Vartype(_oPEMEditor),  "&lcCommand", "0"))
				Otherwise
					On Key Label &lcKey
			Endcase
		Catch
		
		Endtry
		
	ENDPROC

	PROCEDURE setonkeylabels
		Local lcCommand, lcStart, lnBar
		
		With This
			If This.oPrefs.nToolsPlacement = 3
				.SetOnKeyLabel (.oPrefs.cOpenMenuKey,				"CreateOpenMRUMenu()")
			
				.SetOnKeyLabel (.oPrefs.cViewDefinitionKey, 		"GoToDefinition()")
				.SetOnKeyLabel (.oPrefs.cExtractToMethod,			"ExtractToMethod()")
		
				.SetOnKeyLabel (.oPrefs.cEnhancedCtrlC,				"oIDEx.EnhancedCutCopy('Copy')")
				.SetOnKeyLabel (.oPrefs.cEnhancedCtrlX,				"oIDEx.EnhancedCutCopy('Cut')")
		
				.SetOnKeyLabel (.oPrefs.cEnhancedCtrlCAdditive,		"oIDEx.EnhancedCutCopy('Copy', .T.)")
				.SetOnKeyLabel (.oPrefs.cEnhancedCtrlXAdditive,		"oIDEx.EnhancedCutCopy('Cut', .T.)")
		
				.SetOnKeyLabel (.oPrefs.cPrevMethodWindow,			"oIDEx.NavigateHandles('-')")
				.SetOnKeyLabel (.oPrefs.cNextMethodWindow,			"oIDEx.NavigateHandles('+')")
				.SetOnKeyLabel (.oPrefs.cCloseAllWindows,			"oIDEx.CloseAllHandles('+')")
		
				.SetOnKeyLabel (.oPrefs.cMoveWindow,				".MoveWindow()")
				.SetOnKeyLabel (.oPrefs.cBeautify,					"Beautify()")
				.SetOnKeyLabel (.oPrefs.cLocals,					"CreateLocals()")
				.SetOnKeyLabel (.oPrefs.cIDList,					"CreateIDList()")
				.SetOnKeyLabel (.oPrefs.cDoubleHash,				".DynamicSnippet()")
		
				lcStart = Addbs(This.cApplicationPath) + "Source\_StartPEMEditor.PRG"
				If File (lcStart)
					lcCommand = "Do '" + lcStart + "' with '" + This.cApplicationPath + "'"
					.SetOnKeyLabel (.oPrefs.cLaunchKey,		'', lcCommand)
				Endif
			Endif
		
		Endwith
		
		
	ENDPROC

ENDDEFINE
