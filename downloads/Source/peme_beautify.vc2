*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="peme_beautify.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basebeautify AS basecustom OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addwhitespace
		*m: countcharacterwidth
		*m: countparens
		*m: findbeforeas		&& Returns portion of the line that precedes AS
		*m: fixascolumn
		*m: fixsemicoloncolumn
		*m: getcontinuationchar
		*m: getindent
		*m: lastcharin
		*m: trimleadingwhitespace
		*m: trimtrailingwhitespace
	*</DefinedPropArrayMethod>

	*<PropValue>
		Name = "basebeautify"
	*</PropValue>
	
	PROCEDURE addwhitespace
		Lparameters lcLine, lnDestColumn
		
		Local laLines(1), llOneAdded, lnColumn, lnI, lnLineCount, lnWithTabs 
		
		lcLine = This.TrimTrailingWhiteSpace (lcLine)
		lnColumn = This.CountCharacterWidth (lcLine)
		
		Do While lnColumn < lnDestColumn - 1
			llOneAdded = .T.
			lnWithTabs = lnColumn + This.nTabWidth - lnColumn % This.nTabWidth
			If This.oPrefs.lUseTabs and lnWithTabs < lnDestColumn
				lcLine = lcLine + Tab
				lnColumn = lnWithTabs
			Else
				lcLine = lcLine + ' '
				lnColumn = lnColumn + 1
			Endif
		Enddo
		
		Return lcLine + IIF (llOneAdded, '', ' ')
		
		
	ENDPROC

	PROCEDURE countcharacterwidth
		Lparameters lcLine
		
		Local laLines(1), lnColumn, lnI, lnLineCount
		
		*** JRN 2010-06-08 : adding a single character at end so trailing tab is not ignored
		lnLineCount = Alines (laLines, lcLine + '?', .F., Tab)
		lnColumn = 0
		
		For lnI = 1 To lnLineCount
			lnColumn = lnColumn + Len (laLines (lnI))
			If lnI < lnLineCount
				lnColumn = lnColumn + This.nTabWidth - lnColumn % This.nTabWidth
			Endif
		Endfor
		
		Return lnColumn - 1
	ENDPROC

	PROCEDURE countparens
		Lparameters lcLine
		
		* Returns incremental count of parenthesis within this line ...
		*   add one for each left paren, subtract one for each right paren
		
		Local lcRestLineString, lcThisChar, lnCharPos, lnCharscount, lnClosingCharPosition, lnResult 
		
		lnResult = 0
		lnCharscount = Len (lcLine)
		For lnCharPos = 1 To lnCharscount
		
			lcThisChar = Substr (lcLine, lnCharPos, 1)
		
			Do Case
		
				Case lcThisChar = ['] Or lcThisChar = ["] Or						;
						(lcThisChar = '[' And Not This.IsNameChar (Right (This.TrimTrailingWhiteSpace (Left (lcLine, lnCharPos - 1)), 1)))
					* Grab entire character string
					lcRestLineString = Substr (lcLine, lnCharPos + 1)
					lnClosingCharPosition = At (IIf (lcThisChar = '[', ']', lcThisChar), lcRestLineString)
					lnCharPos = lnCharPos + lnClosingCharPosition
		
				Case Substr (lcLine, lnCharPos, 2) = INLINECOMMENTS
					Exit
		
				Case lcThisChar $ '(['
					lnResult = lnResult + 1
		
				Case lcThisChar $ '])'
					lnResult = lnResult - 1
		
			Endcase
		
		Endfor
		
		Return lnResult
		
		
	ENDPROC

	PROCEDURE findbeforeas		&& Returns portion of the line that precedes AS
		Lparameters lcLine
		Local lcLeft, lcRight, lnCounter, lnPos
		
		For lnCounter = 1 To 1000
			lnPos = Rat ('AS', Upper (lcLine), lnCounter)
			Do Case
				Case lnPos <= 1
					Return ''
				Case Substr (lcLine, lnPos - 1, 1) $ BLANKS + ')' And Substr (lcLine, lnPos + 2, 1) ISABLANK
					lcLeft = Left (lcLine, lnPos - 1)
					lcRight = Substr (lcLine, lnPos)
					If INLINECOMMENTS $ lcRight
						lcRight = Left (lcRight, At (INLINECOMMENTS, lcRight) - 1)
					Else
						lcRight = lcRight
					Endif
		
					If Not (')' $ lcRight Or '(' $ lcRight Or '.' $ lcRight)
						Return lcLeft
					Endif
			Endcase
		Endfor
		
	ENDPROC

	PROCEDURE fixascolumn
		Lparameters lcLine, lnDestColumn
		Local lcLeft, lcRight, lcRightNoComments
		
		lcLeft = This.FindBeforeAS (lcLine)
		If 0 = Len (lcLeft)
			Return lcLine
		Endif
		
		lcRight = Substr (lcLine, 1 + Len (lcLeft))
		If Not Right (lcLine,1) ISABLANK
			lcLine = lcLine + ' '
		Endif
		
		Return This.AddWhiteSpace (lcLeft, lnDestColumn) + lcRight
		
	ENDPROC

	PROCEDURE fixsemicoloncolumn
		Lparameters lcLine, lnDestColumn
		Local lcExecutable, lcRight, lnEOL 
		
		lnEOL = Evl (At (INLINECOMMENTS, lcLine), Len (lcLine) + 1)
		lcExecutable = This.TrimTrailingWhiteSpace (Left (lcLine, lnEOL - 1))
		If Right (lcExecutable, 1) # ';'
			Return lcLine
		Endif
		
		lcRight = Substr (lcLine, Len (lcExecutable))
		lcLine = Left (lcLine, Len (lcExecutable) - 1)
		lcLine = This.AddWhiteSpace (lcLine, lnDestColumn)
		Return lcLine + lcRight
		
	ENDPROC

	PROCEDURE getcontinuationchar
		Lparameters lcLine, llComment
		* Returns:
		* 	' ' for no continuation
		*	';' for continuation of a code line
		*	'*' for continuation of a comment line
		Local lnPos 
		
		Do Case
			Case Right (This.TrimTrailingWhiteSpace (lcLine), 1) = ';'
				If llComment Or Getwordnum (lcLine,1) = '*' Or ('&' + '&') $ lcLine
					Return '*'
				Else
					Return ';'
				Endif
			Case  ('&' + '&') $ lcLine
				lnPos = At (('&' + '&'), lcLine)
				lcLine = Left (lcLine, lnPos - 1)
				If Right (This.TrimTrailingWhiteSpace (lcLine), 1) = ';'
					Return ';'
				Else
					Return ' '
				Endif
			Otherwise
				Return ' '
		Endcase
		
	ENDPROC

	PROCEDURE getindent
		Lparameters lcline
		Local lcChar, lcIndent, lnI
		
		lcIndent = ''
		For lnI = 1 To Len (lcline)
			lcChar = Substr (lcline, lnI, 1)
			If lcChar ISABLANK
				lcIndent = lcIndent + lcChar
			Else
				Exit
			Endif
		Endfor
		
		Return lcIndent
		
	ENDPROC

	PROCEDURE isnamechar
		Lparameters lcChar
		
		Return Isalpha (lcChar) Or Isdigit (lcChar) Or lcChar = '_'
		
	ENDPROC

	PROCEDURE lastcharin
		Lparameters lcLine
		* returns last character, other then whitespace or semi-colon
		Local lcRight, lnPos
		If INLINECOMMENTS $ lcLine
			lnPos = At (INLINECOMMENTS, lcLine)
			lcLine = Left (lcLine, lnPos - 1)
		Endif
		
		lcLine = This.TrimTrailingWhiteSpace (lcLine)
		lcRight = Right (lcLine, 1)
		If lcRight = ';'
			lcRight = Right (This.TrimTrailingWhiteSpace (Left (lcLine, Len (lcLine) - 1)), 1)
		Endif
		
		Return lcRight
		
	ENDPROC

	PROCEDURE trimleadingwhitespace
		Lparameters lcText
		
		Do While Left (lcText, 1) ISABLANK
			lcText = Right (lcText, Len (lcText) -1)
		Enddo
		
		Return lcText
		
	ENDPROC

	PROCEDURE trimtrailingwhitespace
		Lparameters lcText
		
		Do While Right (lcText, 1) ISABLANK
			lcText = Left (lcText, Len (lcText) -1)
		Enddo
		
		Return lcText
		
	ENDPROC

ENDDEFINE

DEFINE CLASS beautify AS basebeautify OF "peme_beautify.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: addalignasblock
		*m: addasphase
		*m: addnewlocal
		*m: addobjectidlist
		*m: alignsemicolons
		*m: atnew
		*m: beautifycodeblock
		*m: beautifyinsertcode
		*m: beautifyreplacecode
		*m: beautifyselectcode
		*m: beautifyselectcreatebreakpoints
		*m: beautifyselectmain
		*m: beautifyselectmain_splitfields		&& The part of beautifyselectmain dealing to split fields to new lines due to single options. Not dealing with select items or fields to update.
		*m: beautifyselectstandard
		*m: beautifyselectx
		*m: beautifysingleline
		*m: beautifyword
		*m: calccolumn
		*m: calccolumnoffset		&& Given a starting column, offsets it; primarily for handling tabs
		*m: converttabsforindent
		*m: createidlist
		*m: createidlistcursors
		*m: createidlistsummary
		*m: createlocalsforcodeblock
		*m: createlocalstatements
		*m: createnewlocals
		*m: doformidlist
		*m: doidlisttext
		*m: dolocals
		*m: fetchparameterslist
		*m: findcurrentlocals
		*m: findlocalslinenumber
		*m: findprocstartline
		*m: fixwith
		*m: fixwithstatements
		*m: formatidlist
		*m: getassignmentcol
		*m: getconstants
		*m: geteditorwindowtext
		*m: getindentation
		*m: getparameterslist
		*m: getsourcecodeline
		*m: getvariableslist
		*m: getwindowhandle
		*m: getwordcountx		&& Do GetWordCount and check for CR in default search.
		*m: getwordnumx		&& Do GetWordNum and remove trailing semicolon. Check for CR in default search.
		*m: insertconstants
		*m: insertid
		*m: insertidothers
		*m: insertlocalids
		*m: iskeyword
		*m: movelocalstotop
		*m: nativebeautify
		*m: parsecodeline
		*m: parselineforidlist
		*m: parseprgcodeblocks
		*m: peme_beautify
		*m: peme_createidlist
		*m: peme_createlocals
		*m: peme_createobjectidlist
		*m: regexpsearch
		*m: removeparens
		*m: setbeautifyoptions
		*m: whereis
		*p: cbeautifyoptions
		*p: ccurrentlocals
		*p: ccurrentwithendwith
		*p: clocalsplugin
		*p: clocalstatement
		*p: cpluginbeautifyselect
		*p: cpluginisoperator
		*p: csystemmemoryvariables
		*p: laddmdots
		*p: laddtockl
		*p: lapplyckl
		*p: lautoaddtockl
		*p: lfieldreference
		*p: lnodotsinassignments
		*p: lreturns
		*p: ltestselect
		*p: nafterwithcolumn
		*p: nbeautifyselectiontype
		*p: ncharsafterset
		*p: nlocalslist
		*p: nmdotsusage
		*p: nnewlocalscount
		*p: nselend
		*p: nselstart
		*p: ntabwidth
		*p: nwithendwithlevel
		*p: oeditorwin
		*p: onativebeautify
		*p: oprefs
		*p: oregexp
		*p: outils
		*a: acodelines[1,0]
		*a: alocalslist[1,0]
		*a: anewlocals[1,0]
		*a: aprgcodeblocks[1,0]
		*a: awithendwith[1,0]
		*a: nbeautifyoptions[9,0]
	*</DefinedPropArrayMethod>

	HIDDEN Height,HelpContextID,Init
	*<PropValue>
		cbeautifyoptions = 
		ccurrentlocals = 
		ccurrentwithendwith = .F.
		clocalsplugin = 
		clocalstatement = 
		cpluginbeautifyselect = 
		cpluginisoperator = 
		csystemmemoryvariables = 
		laddmdots = .F.
		laddtockl = .F.
		lapplyckl = .F.
		lautoaddtockl = .F.
		lfieldreference = .F.
		lnodotsinassignments = .F.
		lreturns = .F.
		ltestselect = .F.
		nafterwithcolumn = 0
		Name = "beautify"
		nbeautifyselectiontype = 2
		ncharsafterset = .F.
		nlocalslist = 
		nmdotsusage = 0
		nnewlocalscount = 0
		nselend = 0
		nselstart = 0
		ntabwidth = 1
		nwithendwithlevel = 0
		oeditorwin = .NULL.
		onativebeautify = .NULL.
		oprefs = .NULL.
		oregexp = .F.
		outils = .NULL.
		_memberdata = <VFPData>
			<memberdata name="onativebeautify" display="oNativeBeautify"/>
			<memberdata name="oprefs" display="oPrefs"/>
			<memberdata name="oeditorwin" display="oEditorWin"/>
			<memberdata name="outils" display="oUtils"/>
			<memberdata name="geteditorwindowtext" display="GetEditorWindowText"/>
			<memberdata name="nselstart" display="nSelStart"/>
			<memberdata name="nselend" display="nSelEnd"/>
			<memberdata name="getparameterslist" display="GetParametersList"/>
			<memberdata name="getidlist" display="GetIDList"/>
			<memberdata name="idlistsetup" display="IDListSetup"/>
			<memberdata name="parselineforidlist" display="ParseLineForIDList"/>
			<memberdata name="insertidothers" display="InsertIDOthers"/>
			<memberdata name="createidlistsummary" display="CreateIDListSummary"/>
			<memberdata name="createidlistcursors" display="CreateIDListCursors"/>
			<memberdata name="insertid" display="InsertID"/>
			<memberdata name="peme_createidlist" display="PEME_CreateIDList"/>
			<memberdata name="createidlist" display="CreateIDList"/>
			<memberdata name="lfieldreference" display="lFieldReference"/>
			<memberdata name="insertconstants" display="InsertConstants"/>
			<memberdata name="getconstants" display="GetConstants"/>
			<memberdata name="peme_createobjectidlist" display="PEME_CreateObjectIDList"/>
			<memberdata name="doformidlist" display="DoFormIDList"/>
			<memberdata name="addobjectidlist" display="AddObjectIDList"/>
			<memberdata name="insertlocalids" display="InsertLocalIDs"/>
			<memberdata name="getprocedurestartpositions" display="GetProcedureStartPositions"/>
			<memberdata name="converttabsforindent" display="ConvertTabsForIndent"/>
			<memberdata name="doidlisttext" display="DoIDListText"/>
			<memberdata name="laddmdots" display="lAddMDots"/>
			<memberdata name="nmdotsusage" display="nMDotsUsage"/>
			<memberdata name="lreturns" display="lRETURNS"/>
			<memberdata name="beautifyword" display="BeautifyWord"/>
			<memberdata name="lapplyckl" display="lApplyCKL"/>
			<memberdata name="laddtockl" display="lAddtoCKL"/>
			<memberdata name="lautoaddtockl" display="lAutoAddtoCKL"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE addalignasblock
		Lparameters;
			taBlockArray,;
			tiIndex,;
			tiStart,;
			tiEnd,;
			tiPos
		
		External Array;
			taBlockArray
		
		tiIndex = tiIndex + 1
		
		Dimension;
			taBlockArray(tiIndex, 5)
		
		taBlockArray(tiIndex, 1) = tiStart
		taBlockArray(tiIndex, 2) = tiEnd
		taBlockArray(tiIndex, 3) = tiPos
		
	ENDPROC

	PROCEDURE addasphase
		Lparameters lcName, lcASPhrase, lcAS
		Local lcSuffix, lcVartype 
		*SF 2022/03/19
		*Beautify phrases
		lcVartype = Upper(Substr(lcName, 2, 1))
		lcAS = EVL(m.lcAS,This.BeautifyWord(" as "))
		
		Do Case
			Case Not Empty (lcASPhrase)
				Return lcName + m.lcAS + lcASPhrase
			Case lcName # 'l'
				Return lcName
			Case lcVartype = "N"
				lcSuffix = m.lcAS + This.BeautifyWord("Number")
			Case lcVartype = "I"
				lcSuffix = m.lcAS + This.BeautifyWord("Integer")
			Case lcVartype = "O"
				lcSuffix = m.lcAS + This.BeautifyWord("Object")
			Case lcVartype = "L"
				lcSuffix = m.lcAS + This.BeautifyWord("Boolean")
			Case lcVartype = "C"
				lcSuffix = m.lcAS + This.BeautifyWord("String")
			Case lcVartype = "U"
				lcSuffix = m.lcAS + This.BeautifyWord("Variant")
			Case lcVartype = "D"
				lcSuffix = m.lcAS + This.BeautifyWord("Date")
			Case lcVartype = "T"
				lcSuffix = m.lcAS + This.BeautifyWord("DateTime")
			Case lcVartype = "Y"
				lcSuffix = m.lcAS + This.BeautifyWord("Currency")
			Otherwise
				lcSuffix = ''
		EndCase
		
		Return lcName + lcSuffix
		
	ENDPROC

	PROCEDURE addnewlocal
		Lparameters lcNewLocalName, lcASphrase, llArray, llAlreadyLocal, lcArrayDims
		Local lcName, lnRow
		
		lcName = Alltrim (lcNewLocalName)
		* Remove array dimensions
		Do Case
			Case '&' $ lcName
				Return
			Case '(' $ lcName
				lcName = Left (lcName, At ('(', lcName) - 1)
				llArray = .T.
			Case '[' $ lcName
				lcName = Left (lcName, At ('[', lcName) - 1)
				llArray = .T.
			Case ['] $ lcName or ["] $ lcName
				lcName = Chrtran(lcName, ['"], '') 
		Endcase
		
		If Lower (Left (lcName, 2)) = 'm.'
			lcName = Substr (lcName,3)
		Endif
		
		If '.' $ lcName and This.lNoDotsInAssignments 
			Return
		Endif
		
		Do Case
		
			Case Empty (lcName)
		
			Case lcName = '_'  and  (Upper (lcName) + '_') $ This.cSystemMemoryVariables
		
			Case (',' + Lower (lcName) + ',') $ Lower (This.cCurrentLocals)
		
			Case This.nNewLocalsCount > 0  And Ascan (This.aNewLocals, lcName, -1, -1, 1, 15) # 0
				lnRow = Ascan (This.aNewLocals, lcName, -1, -1, 1, 15)
				This.aNewLocals (lnRow,8) = .T.
				If llArray And llAlreadyLocal
					This.aNewLocals (lnRow,3) = llArray
					This.aNewLocals (lnRow,7) = Evl (lcArrayDims, '1')
				Endif
		
			Otherwise
				lnRow = This.nNewLocalsCount + 1
				This.nNewLocalsCount = lnRow
				Dimension This.aNewLocals (lnRow, 10)
				This.aNewLocals (lnRow,1) = lcName
				This.aNewLocals (lnRow,2) = Evl (lcASphrase, ' ')
				This.aNewLocals (lnRow,3) = llArray
				This.aNewLocals (lnRow,4) = Not Empty (lcASphrase)
				This.aNewLocals (lnRow,5) = lcName = 'l'
				This.aNewLocals (lnRow,6) = llAlreadyLocal
				This.aNewLocals (lnRow,7) = Evl (lcArrayDims, '1')
		
		Endcase
		
	ENDPROC

	PROCEDURE addobjectidlist
		Lparameters loObject, llRecursive
		
		Local loControl AS Object
		Local laObjectMembers(1), lcCode, lcName, lcObjectName, lnControlCount, lnI, lNonDefault, lnRow
		
		lcObjectName = This.oUtils.GetObjectPath(loObject)
		
		Amembers(laObjectMembers, loObject, 1, 'PHG#')
		
		For lnRow = 1 To Alen(laObjectMembers, 1)
			If Inlist(laObjectMembers(lnRow,2), 'Method', 'Event')
				lNonDefault = 'C' $ laObjectMembers[lnRow, 3]
				If lNonDefault
					lcName = laObjectMembers(lnRow,1)
					lcCode = loObject.ReadMethod(lcName)
					If Not Empty(lcCode)
						This.GetConstants (lcCode)
						Insert Into crsr_IDs_Procs (ProcName, StartLine) Values (lcObjectName + '.' + lcName, 1)
						Alines (This.aCodeLines, lcCode)
						This.CreateIDList ('', 1, Alen (This.aCodeLines))
					Endif
				Endif
			Endif
		Endfor
		
		If llRecursive
			lnControlCount = This.oUtils.GetControlCount(loObject)
			If lnControlCount # 0 And "O" = Type("loObject.Objects(1)")
				For lnI = 1 To lnControlCount
					loControl = loObject.Objects(lnI)
					This.AddObjectIDList(loControl, .T.)
				Endfor
			Endif
		Endif
		
	ENDPROC

	PROCEDURE alignsemicolons
		Lparameters lcCodeBlock
		
		Local laLines[1], laPositions[1], lcLine, lnCount
		Local lcExecutable, lcResult, lcRight, lnEOL, lnI, lnMaxPosition, lnWidth
		
		lnCount = Alines (laLines, lcCodeBlock + ' ') && but we'll ignore the first line!
		Dimension laPositions (lnCount)
		lnMaxPosition = 0
		
		For lnI = 2 To lnCount
			lcLine = laLines(lnI)
			lnEOL = Evl (At (INLINECOMMENTS, lcLine), Len (lcLine) + 1)
			lcExecutable = This.TrimTrailingWhiteSpace (Left (lcLine, lnEOL - 1))
			If Right (lcExecutable, 1) # ';'
				laPositions(lnI) = -1
				Loop
			Endif
			lcLine = This.TrimTrailingWhiteSpace (Left (lcLine, Len (lcExecutable) - 1))
			lnWidth = This.CountCharacterWidth (lcLine)
			lnMaxPosition = Max(lnMaxPosition, lnWidth)
			laPositions(lnI) = Len (lcLine)
		Endfor
		
		lcResult = ''
		lnMaxPosition = Min (This.oPrefs.nSemiColoncolumn, This.CalcColumnOffset (lnMaxPosition + 1, This.oPrefs.nBeforeSemicolons))
		For lnI = 2 To lnCount
			lcLine = laLines(lnI)
			lnWidth = laPositions(lnI)
			If lnWidth >= 0
				lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, lnWidth + 1))
				lcLine = Left (lcLine, lnWidth)
				lcLine = This.AddWhiteSpace (lcLine, lnMaxPosition) + lcRight
			Endif
			lcResult = lcResult + LINEEND + This.TrimTrailingWhiteSpace (lcLine)
		Endfor
		
		Return lcResult
		
	ENDPROC

	PROCEDURE atnew
		Lparameters lcSearchfor, lcSearched, lnOccurrence
		
		Return Evl (At (lcSearchfor, lcSearched, Evl(lnOccurrence, 1)), 1 + Len (lcSearched))
		
	ENDPROC

	PROCEDURE beautifycodeblock
		Lparameters lcCodeSource
		Local laCodeSource[1], laLines2[1], laLines[1], laResultLines(1,3)
		Local lcCleanedLine, lcCode, lcContinuationBlock, lcContinuationChar, lcFirstWord, lcFW, lcIndent
		Local lcLine, lcNewCode, lcNewIndent, lcTextBlockCode, lcThisContinuationChar, lcThisIndent, lcType
		Local lnAssignmentLines, lnC, lnCol, lnCount, lnEndParenCount, lnI, lnIndent, lnIndentChange, lnJ
		Local lnLinesCount, lnOffset, lnPosition, lnResultLineCount, lnStart, lnW
		
		If This.oPrefs.lNativeBeautify
			lcCode = This.NativeBeautify (lcCodeSource)
		Else
			lcCode = lcCodeSource
		Endif
		
		If This.lAddMDots
			lcCode = ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_AddMDotsMultipleProcs.PRG', lcCode, This.nMDotsUsage = 3)
		Endif
		
		If This.lApplyCKL Or This.lAddToCKL
			Local loAddWordstoCKL
			loAddWordstoCKL = Execscript(_Screen.cThorDispatcher, 'Class= clsAddWordstoCKL from Thor_Proc_AddWordsToCKL.PRG')
		
			If This.lAddToCKL
				loAddWordstoCKL.ProcessText(lcCode, .F., .T.)
				loAddWordstoCKL.PostProcessing(.F., This.lAutoAddtoCKL)
			Endif
		
			If This.lApplyCKL
				loAddWordstoCKL.CreateAllKeywordsCursor()
				lcCode = loAddWordstoCKL.ApplyCKL(lcCode)
			Endif
		
		EndIf
		
		Dimension laLines(1)
		Alines (laLines, lcCode + ' ', .F.)
		Alines (laCodeSource, lcCodeSource + ' ', .F.)
		lnLinesCount = Min (Alen (laLines), Alen (laCodeSource))
		Dimension laResultLines(lnLinesCount,3)
		lnResultLineCount = 0
		
		lcContinuationChar = ' '
		lnAssignmentLines = 0
		
		For lnCount = 1 To lnLinesCount
			lcLine = laLines[lnCount]
			lcFirstWord = Upper (THIS.GetWordNumX (lcLine,1))
			lcThisContinuationChar = This.GetContinuationChar (lcLine)
		
			Do Case
		
				Case lcFirstWord == 'TEXT'
					* For Text/EndText, do nothing with initial line
					lcCleanedLine = This.BeautifySingleLine (lcLine)
					lnResultLineCount = lnResultLineCount + 1
					laResultLines (lnResultLineCount, 1) = lcCleanedLine
		
					lcTextBlockCode = ''
					Do Case
						Case '{PEME:IGNORE}' $ Upper (lcCleanedLine)
							lcType = 'Ignore'
						Case '{PEME:CODE}' $ Upper (lcCleanedLine)
							lcType = 'Code'
						Case '{PEME:SELECT}' $ Upper (lcCleanedLine)
							lcType = 'Select'
						Case This.oPrefs.lBeautifyTEXTasSelect
							For lnI = lnCount + 1 To lnLinesCount
								lcFW = Upper (THIS.GetWordNumX (laLines[lnI],1))
								Do Case
									Case Empty(lcFW)
		
									Case 'SELECT ' = lcFW
										lcType = 'Select'
										Exit
									Otherwise
										lcType = 'Ignore'
										Exit
								Endcase
							Endfor
						Otherwise
							lcType = 'Ignore'
					Endcase
		
					For lnCount = lnCount + 1 To lnLinesCount
						lcLine = laLines[lnCount]
						lcFirstWord = Upper (THIS.GetWordNumX (lcLine,1))
						If lcFirstWord == 'ENDTEXT'
							Exit
						Endif
						If lcType = 'Select'
							lcTextBlockCode = lcTextBlockCode + LINEEND + This.BeautifySingleLine (laLines[lnCount], This.oPrefs.cIgnoreTextOperators, .T.)
						Else
							lcTextBlockCode = lcTextBlockCode + LINEEND + laCodeSource[lnCount]
						Endif
					Endfor
		
					Do Case
						Case lcType = 'Select'
							lcTextBlockCode = LINEEND + This.BeautifySelectCode (Substr (lcTextBlockCode, 1 + Len (LINEEND)), .F., This.nTabWidth)
						Case lcType = 'Code'
							lcTextBlockCode = This.BeautifyCodeBlock (lcTextBlockCode)
						Otherwise
					Endcase
					lnResultLineCount = lnResultLineCount + 1
					laResultLines (lnResultLineCount, 1) = Substr (lcTextBlockCode, 1 + Len (LINEEND))
		
					lnResultLineCount = lnResultLineCount + 1
					laResultLines (lnResultLineCount, 1) = lcLine
					lcContinuationChar = This.GetContinuationChar (lcLine)
		
				Case lcThisContinuationChar = ' ' Or lnCount >= lnLinesCount
					* simple line, no continuation, nothing special to do.
					If Inlist (lcFirstWord, '*', INLINECOMMENTS)
						lcCleanedLine = This.GetIndent (lcLine) + This.TrimLeadingWhiteSpace (laCodeSource(lnCount))
					Else
						lcCleanedLine = This.BeautifySingleLine (lcLine)
					Endif
					lnResultLineCount = lnResultLineCount + 1
		
					laResultLines (lnResultLineCount, 1) = lcCleanedLine
					laResultLines (lnResultLineCount, 2) = This.GetAssignmentCol(lcCleanedLine)
		
				Otherwise
					****************************************************************
					* get the entire continuation block of lines
					lcIndent = This.GetIndent (lcLine)
					lnEndParenCount = 0
					lcContinuationBlock = ''
		
					Do While .T.
						If lcContinuationChar == '*' Or Inlist (lcFirstWord, '*', INLINECOMMENTS)
							* continuation lines for comments
							lcLine = This.GetIndent (lcLine) + This.TrimLeadingWhiteSpace (laCodeSource(lnCount))
							lcContinuationBlock = lcContinuationBlock + LINEEND + lcLine
							lcContinuationChar = This.GetContinuationChar (lcLine, .T.)
						Else
							* correction for continuation line after in-line comments
							If lcContinuationChar == ';'											;
									and (Not Substr (lcLine, 1 + Len (lcIndent), 1) ISABLANK)		;
									and lcLine = lcIndent											;
									and This.nBeautifyOptions (7) = 1
								lcLine = Stuff (lcLine, 1 + Len (lcIndent), 0, 						;
									IIF (This.nBeautifyOptions(4) = 1, Tab, Space (This.nBeautifyOptions(3))))
							Endif
		
							If lnEndParenCount # 0 And This.oPrefs.nParenIndent > 0
								lcThisIndent = This.GetIndent (lcLine)
								lcNewIndent = Space (lnEndParenCount * This.oPrefs.nParenIndent)
								lcNewIndent = This.ConvertTabsForIndent(lcNewIndent)
								lcLine = Stuff (lcLine, 1 + Len (lcThisIndent), 0, lcNewIndent)
							Endif
							lnEndParenCount = Max (0, lnEndParenCount + This.CountParens (lcLine))
		 
							lcCleanedLine = This.BeautifySingleLine (lcLine)
							lcContinuationBlock = lcContinuationBlock + LINEEND + lcCleanedLine
							lcContinuationChar = This.GetContinuationChar (lcLine)
						Endif
		
						If lcContinuationChar # ' ' And lnCount < lnLinesCount
							lnCount = lnCount + 1
							lcLine = laLines[lnCount]
						Else
							Exit
						Endif
					Enddo
		
					****************************************************************
					Do Case
						Case (lcFirstWord == 'SELECT' Or lcFirstWord == 'UPDATE' Or lcFirstWord == 'DELETE')	;
								and This.oPrefs.nSelectIndentation = 3
							* PEME Custom indentation for SELECTs
							lcContinuationBlock = This.BeautifySelectCode (lcContinuationBlock, .T., This.nTabWidth)
		
						Case lcFirstWord == 'INSERT' 								;
								and This.oPrefs.nSelectIndentation = 3
							* PEME Custom indentation for REPLACEs
							lcContinuationBlock = This.BeautifyInsertCode (lcContinuationBlock)
		
						Case lcFirstWord == 'REPLACE' 								;
								and This.oPrefs.nReplaceIndentation = 3
							* PEME Custom indentation for REPLACEs
							lcContinuationBlock = This.BeautifyReplaceCode (lcContinuationBlock)
		
						Case This.oPrefs.lNativeBeautify And (;
								(This.oPrefs.nSelectIndentation = 2 And (lcFirstWord == 'SELECT' Or lcFirstWord == 'UPDATE' Or lcFirstWord == 'DELETE'));
								Or (This.oPrefs.nReplaceIndentation = 2 And lcFirstWord == 'REPLACE');
								)
							* Ugh.  Keep original indentation;
							* ... need to backtrack thru lines to reinstate, ;
							* but adding back the correct indentation matching the first line
							* This appears indirect at first, but correctly handles inline comments, etc
							lnC = Alines (laLines2, Substr (lcContinuationBlock, 1 + Len (LINEEND)) + ' ')
							lnOffset = lnCount - lnC
							lnIndentChange = This.CountCharacterWidth (This.GetIndent (laLines(lnOffset + 1)));
								- This.CountCharacterWidth (This.GetIndent (laCodeSource(lnOffset + 1)))
							lcContinuationBlock = ''
							For lnI = 1 To lnC
								lnIndent = lnIndentChange + This.CountCharacterWidth (This.GetIndent (laCodeSource(lnI + lnOffset)))
								If lnIndent > 0
									lcIndent = Space (lnIndent)
									lcIndent = This.ConvertTabsForIndent(lcIndent)
								Else
									lcIndent = ''
								Endif
								lcContinuationBlock = lcContinuationBlock + LINEEND + lcIndent ;
									+ This.TrimLeadingWhiteSpace (laLines2 (lnI))
							Endfor
		
					Endcase
		
					lnResultLineCount = lnResultLineCount + 1
					Do case
						Case This.oPrefs.lAlignSemicolons
							laResultLines (lnResultLineCount, 1) = Substr (This.AlignSemiColons (lcContinuationBlock), 1 + Len (LINEEND)) 
						Case lcContinuationBlock = LINEEND
							laResultLines (lnResultLineCount, 1) = Substr (lcContinuationBlock, 1 + Len (LINEEND))
						Otherwise
							laResultLines (lnResultLineCount, 1) = Substr (lcContinuationBlock, 2)
					Endcase
			Endcase
		Endfor
		
		lnStart = 0
		lcNewCode = ''
		
		If This.oPrefs.lFixAssignments
			For lnI = 1 To lnResultLineCount
				lnW = laResultLines (lnI, 2)
				If 'N' = Vartype(lnW) And lnW > 0
					If lnStart = 0
						lnStart = lnI
						lnPosition = laResultLines (lnI, 2)
					Else
						lnPosition = Max (lnPosition, lnW)
						For lnJ = lnStart To lnI
							laResultLines (lnJ,3) = lnPosition
						Endfor
					Endif
				Else
					lnStart = 0
				Endif
			Endfor
		*SF 2022/03/1
		*splited Result line for within the if, and not within
		*odd results for not within
			For lnI = 1 To lnResultLineCount
				lcLine = laResultLines (lnI, 1)
				lnCol = At('=', lcLine) - 1
				lnW = laResultLines (lnI, 3)
				If 'N' = Vartype(lnW) And lnW > 0
					lcNewCode = lcNewCode + LINEEND ;
						+ This.AddWhiteSpace(This.TrimTrailingWhiteSpace(Left (lcLine, lnCol)), lnW + 2);
						+ This.TrimLeadingWhiteSpace(Substr (lcLine, lnCol + 1))
				Else
					lcNewCode = lcNewCode + LINEEND + lcLine
				Endif
			Endfor
		Else
			For lnI = 1 To lnResultLineCount
				lcNewCode = lcNewCode + LINEEND + laResultLines (lnI, 1)
			Endfor
		Endif
		
		
		Return Trim(Substr (lcNewCode, 1 + Len (LINEEND)), 1, ' ', Tab)
		
	ENDPROC

	PROCEDURE beautifyinsertcode
		Lparameters lcCode
		Local laLines[1], lcLine, lcResult, lnCount, lnLineCount
		
		lnLineCount = Alines (laLines, lcCode, .F.)
		lcResult = ''
		
		For lnCount = 1 To lnLineCount
			lcLine = laLines (lnCount)
		
			If Upper (THIS.GetWordNumX (lcLine, 1)) == 'SELECT'
				For lnCount = lnCount + 1 To lnLineCount
					lcLine = lcLine + LINEEND + laLines (lnCount)
				ENDFOR
				lcLine = This.BeautifySelectCode(lcLine, .T., This.nTabWidth)
			Endif
		
			lcResult = lcResult + LINEEND + lcLine
		
		Endfor
		
		Return Substr (lcResult, 1 + Len (LINEEND))
		
	ENDPROC

	PROCEDURE beautifyreplacecode
		Lparameters lcCode
		
		Local laLines(1), laResult(1)
		Local lcCurrentKeyWord, lcFirstWord, lcIndent, lcLine, lcNewLine, lcResult, llFixWITH, ln, lnAfterWITH
		Local lnBeforeWITH, lnCount, lnEndParenCount, lnHangingIndent, lnIndent, lnIndentAll, lnLineCount
		Local lnParenCount, lnTotalIndent, lnWITHCol
		
		lnLineCount = Alines (laLines, lcCode, .F.)
		Acopy (laLines, laResult)
		lnWITHCol = 0
		
		* find first non-blank line ... it better start with SELECT!
		For lnCount = 1 To lnLineCount
			lcLine = laLines (lnCount)
			Do Case
				Case Empty (lcLine)
		
				Case Inlist (Upper (THIS.GetWordNumX (lcLine, 1)) + ' ', 'REPLACE ')
					Exit
				Otherwise
					Return lcCode
			Endcase
		Endfor
		
		lnIndentAll= This.CountCharacterWidth (This.GetIndent (lcLine))
		lcCurrentKeyWord = Upper (THIS.GetWordNumX (lcLine, 1))
		* determine indent to be applied to all lines
		lcResult = ''
		
		For lnCount = lnCount To lnLineCount
			lcLine = This.TrimLeadingWhiteSpace (laLines (lnCount))
			lcFirstWord = Upper (THIS.GetWordNumX (lcLine, 1))
			llFixWITH	= .F.
		
			Do Case
				Case lcFirstWord == 'REPLACE'
					lnParenCount = 0
					lnEndParenCount = This.CountParens (lcLine)
					lnIndent = 0
					lnHangingIndent = This.oPrefs.nReplaceFieldIndent + This.oPrefs.nSingleREPLACEFieldIndent
					If Upper (THIS.GetWordNumX (lcLine, 3)) == 'WITH'
						llFixWITH = .T.
						lcLine = This.AddWhiteSpace (Left (lcLine,7), This.oPrefs.nReplaceFieldIndent + 1) + This.TrimLeadingWhiteSpace (Substr (lcLine,8))
					Endif
		
				Case (' ' + lcFirstWord + ' ') $ ' FOR IN WHILE ' And lnParenCount = 0
					lnParenCount = 0
					lnEndParenCount = This.CountParens (lcLine)
					lnIndent = This.oPrefs.nReplaceKeywords
					lnHangingIndent = lnIndent + This.oPrefs.nReplaceHangingIndent
		
				Case (Upper (THIS.GetWordNumX (lcLine, 2)) == 'WITH' Or Upper (THIS.GetWordNumX (lcLine, 3)) == 'WITH') And lnParenCount = 0
					ln = 0
					lnEndParenCount = This.CountParens (lcLine)
					lnIndent = This.oPrefs.nReplaceFieldIndent - IIf (Upper (THIS.GetWordNumX (lcLine, 1)) = ',', 2, 0)
					lnHangingIndent = This.oPrefs.nReplaceFieldIndent + This.oPrefs.nSingleREPLACEFieldIndent
					llFixWITH	= .T.
		
				Otherwise
					lnEndParenCount = Max (0, lnParenCount + This.CountParens (lcLine))
					lnIndent = lnHangingIndent
		
			Endcase
		
			lnTotalIndent = lnIndentAll + lnIndent + (This.oPrefs.nParenIndent * lnParenCount)
			lcIndent = Space (lnTotalIndent)
			lcNewIndent = This.ConvertTabsForIndent(lcIndent)
		
			lcNewLine = lcNewIndent + lcLine
			If llFixWITH And This.oPrefs.lAlignWith
				lnWITHCol = Max (lnWITHCol, This.CalcColumn (lcNewLine, 'WITH'))
			Endif
		
			laResult (lnCount) = lcNewLine
			lnParenCount = lnEndParenCount
		
		Endfor
		
		lcResult = ''
		lnBeforeWITH = This.CalcColumnOffset (lnWITHCol, This.oPrefs.nBeforeWith)
		lnAfterWITH = This.CalcColumnOffset (lnBeforeWITH + 3, This.oPrefs.nAfterWith)
		
		For lnCount = 1 To lnLineCount
			lcLine = laResult (lnCount)
		
			If lnWITHCol # 0
				lcNewLine = This.FixWITH (lcLine, 4, lnBeforeWITH, lnAfterWITH)
			Else
				lcNewLine = lcLine
			Endif
		
			lcResult = lcResult + LINEEND + lcNewLine
		
		Endfor
		
		Return Substr (lcResult, 1 + Len (LINEEND))
		
	ENDPROC

	PROCEDURE beautifyselectcode
		Lparameters tcCode, tlSemiColons, tnTabWidth
		Local lcCode, lcNewResult, lcResult, lnLastLen, lnTabs, lnTabWidth
		
		lnTabWidth = Evl(tnTabWidth, 1) 
		lcCode = Strtran(tcCode, Tab, Space(lnTabWidth)) 
		lcResult = This.Beautifyselectx(lcCode, tlSemiColons)
		
		*SF 2020/10/29 Run only if Beautify Option is set to tabs
		*        4 = tabs/spaces, 						1 - use tabs, 2 - use spaces, 3 = no change
		If This.nBeautifyOptions(4)=1 THEN
		* leading tabs, where approppriate
			If lnTabWidth > 1
				lnLastLen = 0
				lcNewResult = ccCR + lcResult
				lnTabs = 0
				Do While Len(lcNewResult) #lnLastLen
					lnLastLen = Len(lcNewResult)
					lcNewResult = Strtran(lcNewResult;
						, ccCR + Replicate(Tab, lnTabs) + Space(lnTabWidth);
						, ccCR + Replicate(Tab, lnTabs + 1))
					lnTabs = lnTabs + 1
				Enddo
				lcResult = Substr(lcNewResult, 2)
			Endif
		Endif &&This.nBeautifyOptions(4)=1 
		
		Return lcResult
		
	ENDPROC

	PROCEDURE beautifyselectcreatebreakpoints
		Lparameters tcText, lcAlias
		Local lcClosingChar, lcPattern, lcValue, lnFirstIndex, lnI, lnParens, loMatch, loMatches
		
		lcPattern = [('|"|] + '\[|\]|\(|\)|\&' + '\&)|\r|\,'
		loMatches = This.RegExpSearch (lcPattern, tcText)
		
		Create Cursor (lcAlias) (Start N(8), End N(8), Value c(1), nParens N(4), notcode L)
		*SF 2022/03/17
		*first index is 0, not 1
		Insert Into (lcAlias) (Start) Values (0)
		lnParens = 0
		For lnI = 1 To loMatches.Count
			loMatch		 = loMatches.Item (lnI - 1)
			lnFirstIndex = loMatch.FirstIndex
			lcValue		 = loMatch.Value
			Replace End With lnFirstIndex
			lcClosingChar = lcValue
			Do Case
				Case lcValue = '('
					lnParens = lnParens + 1
				Case lcValue = ')'
					lnParens = lnParens - 1
				Case lcValue = '['
					If This.IsNameChar (Right (Trim (Left (tcText, lnFirstIndex)), 1))
						Loop
					Endif
					lcClosingChar = ']'
				Case lcValue = ']'
					Loop
				Case lcValue = '&'
					lcClosingChar = CR
				Case lcValue = CR
					lcClosingChar = '?'
			Endcase
			Insert Into (lcAlias) (Start, Value, nParens) Values (lnFirstIndex + 1, lcValue, lnParens)
			If lcClosingChar $ ['"] + ']' + CR
				Replace notcode With .T.
				For lnI = lnI + 1 To loMatches.Count
					If loMatches.Item (lnI - 1).Value = lcClosingChar
						loMatch		 = loMatches.Item (lnI - 1)
						lnFirstIndex = loMatch.FirstIndex
						lcValue		 = loMatch.Value
						Replace End With lnFirstIndex
						Insert Into (lcAlias) (Start, Value, nParens) Values (lnFirstIndex + 1, lcValue, lnParens)
						Exit
					Endif
				Endfor
			Endif
		Endfor
		Replace End With Len (tcText)
		
	ENDPROC

	PROCEDURE beautifyselectmain
		Lparameters lcText, llSemiColons, llCommasBeginLine
		
		* A long procedure, but done this way because it recursive
		
		Local laEndParen[1], laMatch[1], laSELECTS[1], lcAlias, lcBreakWords
		Local lcEndThisLine, lcNewLine, lcReplaceText, lcResultText, lcSelectText, lcSubQ, lcSubQuery
		Local lcThisLine, llAnyFound, lnFirstIndex, lnLastIndex, lnI, lnIndent, lnOffset, lnPos
		Local lcFirstWord, lcSecondWord
		Local lnSubQueries, loMatch, loMatches
		Local lSelectExpandFields, llSelectExpandGroupBy, llSelectExpandOrderBy, llSelectExpandFrom, llSelectExpandSelectItem
		
		* our important breakpoints
		lcAlias = Sys(2015)
		This.BeautifySelectCreateBreakPoints (lcText, lcAlias)
		
		* Our 'SELECT' subquery substitutions, if any
		lnSubQueries = 0
		llAnyFound	 = .T.
		
		Do While llAnyFound
			llAnyFound = .F.
			loMatches  = This.RegExpSearch ('\bSelect\b', lcText)
			For lnI = 1 To loMatches.Count
				loMatch		 = loMatches.Item (lnI - 1)
				lnFirstIndex = loMatch.FirstIndex
				Select  nParens								  ;
					From (lcAlias)							  ;
					Where Between (lnFirstIndex, Start, End)  ;
					And nParens > 0						  ;
					And Not notcode						  ;
					Into Array laMatch
				If _Tally > 0
					Select  Start					  ;
						From (lcAlias)				  ;
						Where Start > lnFirstIndex	  ;
						And nParens < laMatch[1]  ;
						And Not notcode			  ;
						Into Array laEndParen
					lcSelectText  = Substr (lcText, lnFirstIndex + 1, laEndParen[1] - lnFirstIndex - 1)
					lcReplaceText = '<<' + Sys(2015) + '>>'
		
					lnSubQueries  = lnSubQueries + 1
					Dimension laSELECTS (lnSubQueries, 2)
					laSELECTS (lnSubQueries, 1) = lcSelectText
					laSELECTS (lnSubQueries, 2) = lcReplaceText
		
					lcText		= Stuff (lcText, lnFirstIndex + 1, Len (lcSelectText), lcReplaceText)
					This.BeautifySelectCreateBreakPoints (lcText, lcAlias)
					llAnyFound = .T.
					Exit
				Endif
			Endfor
		Enddo && while .t.
		
		* Major keyword substitutions, as well as commas for fields
		lcResultText = lcText
		
		*SF 2022/03/17
		*just break on delete / select too
		lcBreakWords = '\Wupdate\W|\Wdelete\W|\Wselect\W|\Wfrom\W|\Wwhere\W|\Wgroup by\W|\Worder by\W|\Whaving\W|\Wunion\W|\Winto\W'
		*lcBreakWords = '\Wselect\W|\Wfrom\W|\Wwhere\W|\Wgroup by\W|\Worder by\W|\Whaving\W|\Wunion\W|\Winto\W'
		
		*SF 2022/03/17
		* we parse out the commas on special method, new properties
		If This.oPrefs.lSelectExpandFields
		*	lcBreakWords = '\,|' + lcBreakWords
			lSelectExpandFields      = .T.
			llSelectExpandGroupBy    = This.oPrefs.lSelectExpandGroupBy
			llSelectExpandOrderBy    = This.oPrefs.lSelectExpandOrderBy
			llSelectExpandFrom       = This.oPrefs.lSelectExpandFrom
			llSelectExpandSelectItem = This.oPrefs.lSelectExpandSelectItem
		Endif
		*/SF 17.03.2022
		
		If This.oPrefs.lSelectExpandJoins
			lcBreakWords = lcBreakWords + '|\Wleft join\W|\Wleft outer join\W|\Wright join\W|\Wright outer join\W|\Wfull join\W' ;
				+ '|\Wfull outer join\W|\Winner join\W|\Wjoin\W'
		Endif
		
		If This.oPrefs.lSelectExpandOn
			lcBreakWords = lcBreakWords + '|\Won\W'
		Endif
		
		If This.oPrefs.lSelectExpandAndOr
		*SF 2022/03/16 I have the strange feeling that "." must be escaped, needs check. At least "\W. looks odd, since the dot is word boundary .
			lcBreakWords = lcBreakWords + '|\W.and.\W|\W.or.\W|\Wand\W|\Wor\W'
		*	lcBreakWords = lcBreakWords + '|\W\.and\.\W|\W\.or\.\W|\Wand\W|\Wor\W'
		*/SF 2022/03/16
		Endif
		
		loMatches	= This.RegExpSearch ('(' + lcBreakWords + ')', lcText)
		lnOffset	= 1 && because search includes leading blank character!
		lcNewLine	= Iif (llSemiColons, ';' + CR, ' ' + CR)
		lnLastIndex = Len (lcResultText) 
		
		* rewitten to split the items (the part before FROM)
		For lnI =  loMatches.Count To 1 STEP -1
			loMatch		 = loMatches.Item (lnI - 1)
			lnFirstIndex = loMatch.FirstIndex
			lcFirstWord	 = Upper (This.GetWordNumX (loMatch.Value, 1))
			lcSecondWord = Upper (This.GetWordNumX (loMatch.Value, 2))
		
			Select  nParens								  ;
				From (lcAlias)							  ;
				Where Between (lnFirstIndex, Start, End)  ;
				And Not notcode						  ;
				Into Array laMatch
			If _Tally > 0
				lnFirstIndex = lnFirstIndex + lnOffset
		*SF 2022/03/17
		*		If loMatch.Value = ','
					Do Case
						Case laMatch[1] # 0
							* lnFirstIndex points to the comma
		
						Case lcFirstWord=='GROUP' AND lcSecondWord=='BY'
		*if GROUP BY, and expand fields in GROUP BY
							lcResultText = This.BeautifySelectMain_SplitFields(lcResultText, lnFirstIndex, lnLastIndex, lcAlias, llSemiColons, llCommasBeginLine, llSelectExpandGroupBy   , .T.)
							
						Case lcFirstWord=='ORDER' AND lcSecondWord=='BY'
		*if ORDER BY, and expand fields in ORDER BY
							lcResultText = This.BeautifySelectMain_SplitFields(lcResultText, lnFirstIndex, lnLastIndex, lcAlias, llSemiColons, llCommasBeginLine, llSelectExpandOrderBy    , .T.)
		
						Case lcFirstWord=='FROM'
		*if FROM clause, and expand cursors in FROM clause
							lcResultText = This.BeautifySelectMain_SplitFields(lcResultText, lnFirstIndex, lnLastIndex, lcAlias, llSemiColons, llCommasBeginLine, llSelectExpandFrom       , .F.)
		
						Case Inlist(' '+lcFirstWord+' ',' SELECT ',' UPDATE ',' DELETE ')
		*if Select-item-list, and expand Select-item-list
							lcResultText = This.BeautifySelectMain_SplitFields(lcResultText, lnFirstIndex, lnLastIndex, lcAlias, llSemiColons, llCommasBeginLine, llSelectExpandSelectItem , .F.)
		
						CASE lSelectExpandFields
		*whatever else ist expandable
							lcResultText = This.BeautifySelectMain_SplitFields(lcResultText, lnFirstIndex, lnLastIndex, lcAlias, llSemiColons, llCommasBeginLine, .T.                      , .F.)
						
						OTHERWISE
		*nothing to expand
					lcThisLine = Left (lcResultText, lnFirstIndex)
					lcThisLine = Substr (lcThisLine, Rat (CR, lcThisLine) + 1)
					If Not Empty (lcThisLine)
						lcEndThisLine = Substr (lcResultText, lnFirstIndex + 1)
						lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
						lcEndThisLine = Strtran(lcEndThisLine, Getwordnum(lcEndThisLine, 1), '')
						If Not Empty (Chrtran(lcEndThisLine, ccCR + ccLF + ccTAB + ';', Space(4)))
		*					lcResultText = Stuff (lcResultText, lnFirstIndex + 1, 0, lcNewLine)
							lcResultText = TRIM(LEFT(lcResultText, lnFirstIndex),' ','	') + lcNewLine + RIGHT(lcResultText, LEN(lcResultText) - lnFirstIndex) 
		*					lnOffset	 = lnOffset + 2
						Endif
					Endif
		
				Endcase
		*/SF 17.03.2022
			Endif
			lnLastIndex  = lnFirstIndex-1
		
		Endfor
		
		* Expand our SELECT subqueries, stuff 'em back in,
		*   making sure to expand leading white space.
		*   (note the assumption that there are no tabs involved!
		lcResultText = Strtran(This.BeautifySelectStandard (lcResultText, llSemiColons), LF, '')
		
		For lnI = 1 To lnSubQueries
			lcSubQuery	  = This.BeautifySelectMain (laSELECTS (lnI, 1), llSemiColons, llCommasBeginLine)
			lcReplaceText = laSELECTS (lnI, 2)
			lnPos		  = At (lcReplaceText, lcResultText)
			lnIndent	  = lnPos - Rat (CR, Left (lcResultText, lnPos)) - 1
			lcSubQ		  = Strtran (Strtran(lcSubQuery, LF, ''), CR, CR + Space (lnIndent))
			lcResultText  = Stuff (lcResultText, lnPos, Len (lcReplaceText), lcSubQ)
		Endfor
		
		*SF 2022/03/17 Alias should be closed after
		Use In Select (lcAlias)
		
		Return lcResultText
	ENDPROC

	PROCEDURE beautifyselectmain_splitfields		&& The part of beautifyselectmain dealing to split fields to new lines due to single options. Not dealing with select items or fields to update.
		LPARAMETERS;
		 tcText,;
		 tnFirstIndex,;
		 tnLastIndex,;
		 tcAlias,;
		 tlSemiColons,;
		 tlCommasBeginLine,;
		 tlBreakOnComma,;
		 tlKeepIntegers
		
		*SF 2022/03/19
		*new method to split snippets into fields
		
		Local laMatch[1], lcBeforeThisLine
		Local lcEndThisLine, lcNewLine, lcStartLine, lcSnippet
		Local lcThisLine, lnEndChars, lnFirstIndex, lnI, lnOffset
		Local loMatch, loMatches, lnLeadingBlanks
		LOCAL llIntegersLine, lnNext_FirstIndex
		
		lcSnippet   = Substr (tcText, tnFirstIndex + 1, tnLastIndex - tnFirstIndex)
		
		lcStartLine = ''
		lcNewLine	= Iif (tlSemiColons, ';' + CR, ' ' + CR)
		
		lcThisLine = Left (tcText, tnFirstIndex)
		lcThisLine = Substr (lcThisLine, Rat (CR, lcThisLine) + 1)
		If Not Empty (lcThisLine)
			lcEndThisLine = Substr (tcText, tnFirstIndex + 1)
			lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
			lcEndThisLine = Strtran(lcEndThisLine, Getwordnum(lcEndThisLine, 1), '')
			If Not Empty (Chrtran(lcEndThisLine, ccCR + ccLF + ccTAB + ';', Space(4)))
				lcStartLine = lcNewLine
			Endif
		Endif
		
		
		loMatches	= This.RegExpSearch ('\,', lcSnippet)
		lnOffset	= 1 && because search includes leading blank character!
		
		IF loMatches.Count = 0 OR !m.tlBreakOnComma THEN
			If Not Empty (lcThisLine)
				If Not Empty (Chrtran(lcEndThisLine, ccCR + ccLF + ccTAB + ';', Space(4)))
					tcText      = TRIM(LEFT(tcText, tnFirstIndex),' ','	') + lcNewLine + RIGHT(tcText, LEN(tcText) - tnFirstIndex) 
				Endif
			Endif
		ELSE  &&loMatches.Count = 0 OR !m.tlBreakOnComma
		    lnNext_FirstIndex = 0
			For lnI =  loMatches.Count To 1 STEP -1
				loMatch		 = loMatches.Item (lnI - 1)
				lnFirstIndex = loMatch.FirstIndex
				Select  nParens	;
					From (tcAlias)	;
					Where Between (lnFirstIndex + tnFirstIndex, Start, End)  ; 
					And Not notcode	;
					Into Array laMatch
		
				If _Tally > 0
					lnFirstIndex = lnFirstIndex + lnOffset
						Do Case
		
							Case laMatch[1] # 0
							* lnFirstIndex points to the comma
		
							Case tlCommasBeginLine
								lcEndThisLine = Substr (lcSnippet, lnFirstIndex + 1)
								lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
		*SF 2023/05/27
		*will not work if a inline comment is set, and the comma is before ;:
		* group by abcd, ; && xyz
		*  cde
		*nobody seems to run into this for ages, so it's to much work to figure this out
								If Empty (lcEndThisLine) Or Left (Getwordnum (lcEndThisLine, 1), 1) $ ';*' Or Left (Getwordnum (lcEndThisLine, 1), 2) = '&' + '&'
									* at end of line
									* lcSnippet = Stuff (lcSnippet, lnFirstIndex + 1, 1 + Len (lcEndThisLine), Space(1 + Len (lcEndThisLine)))
									lcSnippet = Stuff (lcSnippet, lnFirstIndex, 2 + Len (lcEndThisLine), Space(1 + Len (lcEndThisLine)) + ',')
								Else
									lnLeadingBlanks = Len(lcEndThisLine) - Len(Ltrim(lcEndThisLine))
									If lnLeadingBlanks # 1
										lcSnippet = Stuff (lcSnippet, lnFirstIndex + 1, lnLeadingBlanks, ' ')
		*								lnOffset	 = lnOffset + 1 - lnLeadingBlanks
									Endif
								Endif
								lcBeforeThisLine = Left (lcSnippet, lnFirstIndex - 1)
								lcBeforeThisLine = Substr (lcBeforeThisLine, Rat (CR, lcBeforeThisLine) + 1)
								If Not Empty (lcBeforeThisLine)
									IF m.tlKeepIntegers THEN 
										IF ISDIGIT(LTRIM(lcEndThisLine)) THEN
											IF !m.llIntegersLine THEN
											* last Integer in Line
												m.llIntegersLine = .T.
											ENDIF &&!m.llIntegersLine 
									    	lnNext_FirstIndex = m.lnFirstIndex
								 
										ELSE  &&ISDIGIT(LTRIM(lcEndThisLine))
											IF m.llIntegersLine THEN
												* first Integer in Line
												lnNext_FirstIndex = AT(',', stuff(lcSnippet, 1, lnFirstIndex, '')) + lnFirstIndex
												lcSnippet = Stuff (lcSnippet, lnNext_FirstIndex, 0, lcNewLine)
												m.llIntegersLine = .F.
								 
											ENDIF &&m.llIntegersLine
											lcSnippet = Stuff (lcSnippet, lnFirstIndex, 0, lcNewLine)
										ENDIF &&ISDIGIT(LTRIM(lcEndThisLine))
									ELSE  &&m.tlKeepIntegers
										lcSnippet = Stuff (lcSnippet, lnFirstIndex, 0, lcNewLine)
									ENDIF &&m.tlKeepIntegers
		
		
		
		**********************
		*							lcSnippet = Stuff (lcSnippet, lnFirstIndex, 0, lcNewLine)
		*							lnOffset	 = lnOffset + 2
								Endif
		
							Otherwise
		*comma on end of line
								lcEndThisLine = Substr (lcSnippet, lnFirstIndex + 1)
								lcEndThisLine = Left (lcEndThisLine, This.AtNew (CR, lcEndThisLine) - 1)
		*SF 2023/05/27
		*will not work if a inline comment is set, and the comma is on the next line:
		* group by abcd ; && xyz
		* , cde
		*nobody seems to run into this for ages, so it's to much work to figure this out
								If Empty (lcEndThisLine) Or Left (Getwordnum (lcEndThisLine, 1), 1) $ ';*' Or Left (Getwordnum (lcEndThisLine, 1), 2) = '&' + '&'
									* already at end of line
								Else
									IF m.tlKeepIntegers THEN 
										IF ISDIGIT(LTRIM(lcEndThisLine)) THEN
											IF !m.llIntegersLine THEN
											* last Integer in Line
												m.llIntegersLine = .T.
											ENDIF &&!m.llIntegersLine 
									    	lnNext_FirstIndex = m.lnFirstIndex
								 
										ELSE  &&ISDIGIT(LTRIM(lcEndThisLine))
											IF m.llIntegersLine THEN
												* first Integer in Line
												lcSnippet = Stuff (lcSnippet, m.lnNext_FirstIndex + 1, 0, lcNewLine)
												m.llIntegersLine = .F.
								 
											ENDIF &&m.llIntegersLine
											lcSnippet = Stuff (lcSnippet, lnFirstIndex + 1, 0, lcNewLine)
										ENDIF &&ISDIGIT(LTRIM(lcEndThisLine))
		
									ELSE  &&m.tlKeepIntegers
											lcSnippet = Stuff (lcSnippet, lnFirstIndex + 1, 0, lcNewLine)
									ENDIF &&m.tlKeepIntegers
		
		*							lnOffset	 = lnOffset + 2
								Endif
		
								lcBeforeThisLine = Left (lcSnippet, lnFirstIndex - 1)
								lcBeforeThisLine = Substr (lcBeforeThisLine, Rat (CR, lcBeforeThisLine) + 1)
								If Empty (lcBeforeThisLine)
									lnEndChars = Iif(tlSemiColons, 2, 1)
									lcSnippet  = TRIM(LEFT(lcSnippet, lnFirstIndex - Len (lcBeforeThisLine) - lnEndChars - 1),' ','	') + RIGHT(lcSnippet, LEN(lcSnippet) - lnFirstIndex + 1) 
								Endif
						Endcase
		
				Endif
			Endfor
		
			tcText = STUFF(tcText, tnFirstIndex + 1, tnLastIndex - tnFirstIndex, lcStartLine + lcSnippet)
		*	tcText = STUFF(tcText, tnFirstIndex + 1, tnLastIndex - tnFirstIndex, lcSnippet)
		
		ENDIF &&loMatches.Count = 0 OR !m.tlBreakOnComma
		
		RETURN tcText
	ENDPROC

	PROCEDURE beautifyselectstandard
		Lparameters lcCode, llSemiColons
		Local laLines[1], laResult[1], lcCurrentKeyWord, lcFirstWord, lcIndent, lcLine, lcNewLine, lcResult
		Local llFieldNextLineIndent, llFieldThisLineIndent, lnASCol, lnAfterAS, lnBeforeAS, lnCount, lnCount1
		Local lnEndParenCount, lnHangingIndent, lnIndent, lnIndentAll, lnLineCount, lnParenCount
		Local lnParentCount, lnPos, lnTotalIndent, lnAsColumn
		Local lnLen, lcLastPart, llUnionIndentAlter, llUnionFound, lnUnionCount, lnUnionIndentAlter, lnUnionIndentFirst
		Local lcIndentJoin, llIndentOn
		Local llAlignASFieldBlocks, lnAlignASBlockMax, lnAlignASBlock, laAlignASBlocks(1, 5), lnASCol2
		
		
		llUnionIndentAlter		= NVL(This.oPrefs.lUnionIndentAlter,.F.)
		lnUnionIndentAlter		= 0
		
		llIndentOn = NVL(This.oPrefs.lIndentON,.F.)
		If llIndentOn Then
			lcIndentJoin = ' INNER OUTER JOIN LEFT RIGHT FULL ON '
		Else  &&llIndentOn
			lcIndentJoin = ' INNER OUTER JOIN LEFT RIGHT FULL '
		Endif &&llIndentOn
		
		llAlignASFieldBlocks	= NVL(This.oPrefs.lAlignASFieldBlocks,.F.)
		lnAlignASBlockMax   	= 0
		laAlignASBlocks         = 0
		lnAsColumn              = EVL(This.oPrefs.nAsColumn,1000)
		
		lnLineCount = Alines (laLines, lcCode + ' ', .F.)
		Acopy (laLines, laResult)
		
		* find first non-blank line ... it better start with SELECT or UPDATE!
		For lnCount = 1 To lnLineCount
			lcLine = laLines (lnCount)
			Do Case
				Case Empty (lcLine)
		
				Case Inlist (Upper (This.GetWordNumX (lcLine, 1)) + ' ', 'SELECT ', 'UPDATE ', 'DELETE ')
					Exit
				Otherwise
					Return lcCode
			Endcase
		Endfor
		
		lnHangingIndent	= This.oPrefs.nFieldIndent
		
		lnIndentAll		 = IIF(m.llSemiColons,This.CountCharacterWidth (This.GetIndent (lcLine)),0)
		lcCurrentKeyWord = Upper (This.GetWordNumX (lcLine, 1))
		lnPos			 = At (lcCurrentKeyWord, Upper (lcLine))
		*direct trailing ;? then one or no space according to This.oPrefs.lSpaceBeforeCommas
		*lcLine			 = Left (lcLine, lnPos + 5) + Space (Max (1, This.oPrefs.nCharsAfterSelect)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 6))
		lnLen			 = Len (lcCurrentKeyWord)
		lcLine           = This.TrimLeadingWhiteSpace (lcLine)
		lcLastPart       = This.TrimLeadingWhiteSpace (Substr (lcLine, lnLen + 1))
		
		lnUnionIndentFirst = lnCount
		lnASCol = 0
		
		If lcLastPart = ';' Then
			lcLine			= SPACE(lnIndentAll) + Left (lcLine, lnLen) + lcLastPart
			lnParenCount	= 0
			llFieldNextLineIndent = .F.
		
			This.AddAlignAsBlock(@laAlignASBlocks, @lnAlignASBlockMax, lnCount + 1, lnLineCount, 0 )
		
		Else  &&lcLastPart = ';'
			lcLine			= SPACE(lnIndentAll) + Left (lcLine, lnLen) + Space (Max (1, This.oPrefs.nCharsAfterSelect)) + lcLastPart
			lnParenCount	= This.CountParens (lcLine)
			IF m.lcCurrentKeyWord=='UPDATE' THEN
		*SF 2022/03/15
		* first line after UPDATE should not be autoindent. it's
		* -a SET is in UPDATE line, so next line is expected as field
		* -b SET is on next line, this will suit itself below
		* this will fail on table and SET on second line, but we ignore this for now. like:
		* UPDATE;
		*  xxx SET ...
		* it must be parsed out in the loop below, but seems to be to much work for this  exotic case
				llFieldNextLineIndent = lnParenCount # 0
		*SF 2022/03/15
		* just check if SET is on this line, so we set as lcCurrentKeyWord (or some indent will not work)
		        FOR lnCount1 = 1 To THIS.GetWordCountX (lcLine)  
		        	If Upper (This.GetWordNumX (lcLine, lnCount1)) == 'SET' Then 
		        		lcCurrentKeyWord = 'SET'
		        		exit
		        	Endif &&Upper (This.GetWordNumX (lcLine, lnCount1)) == 'SET'
		        Endfor &&lnCount1
		
			Else  &&m.lcCurrentKeyWord=='UPDATE'
				llFieldNextLineIndent = lnParenCount # 0 Or (		;
					This.LastCharIn (lcLine) # ','					;
					And THIS.GetWordCountX (lcLine) > 1					;
					And Not Inlist (Upper (This.GetWordNumX (lcLine, THIS.GetWordCountX (lcLine) - 1)), 'SELECT', 'DISTINCT'))
			
			Endif &&m.lcCurrentKeyWord=='UPDATE' 
		*/SF 15.3.2022
		
		
			If This.oPrefs.lAlignAS
				lnASCol = This.CountCharacterWidth (This.TrimTrailingWhiteSpace (This.FindBeforeAS (lcLine)))
				This.AddAlignAsBlock(@laAlignASBlocks, @lnAlignASBlockMax, lnCount, lnLineCount, lnASCol )
			Endif
		
		Endif &&lcLastPart = ';'
		*/direct trailing ;?
		laResult (lnCount) = lcLine
		*
		lnHangingIndent	= This.oPrefs.nFieldIndent
		
		For lnCount = lnCount + 1 To lnLineCount
			lcLine			= This.TrimLeadingWhiteSpace (laLines (lnCount))
			lcFirstWord		= Upper (This.GetWordNumX (lcLine, 1))
			lnEndParenCount	= Max (0, lnParenCount + This.CountParens (lcLine))
		
			Do Case
				Case (' ' + lcFirstWord + ' ') $ ' FROM ' And lnParenCount = 0
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
		*			lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nKeyWordIndent
					lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = .F.
		
					lnLen		= Len (lcCurrentKeyWord)
					lcLastPart	= This.TrimLeadingWhiteSpace (Substr (lcLine, lnLen + 1))
					if lnAlignASBlockMax > 0
						laAlignASBlocks(lnAlignASBlockMax, 2) = lnCount-1
					endif lnAlignASBlockMax > 0
		
					If lcLastPart = ';' Then
						lnEndParenCount	= 0
						This.AddAlignAsBlock(@laAlignASBlocks, @lnAlignASBlockMax, lnCount+1, lnLineCount, 0 )
					Else  &&lcLastPart = ';'
						lnEndParenCount	= This.CountParens (lcLine)
						This.AddAlignAsBlock(@laAlignASBlocks, @lnAlignASBlockMax, lnCount, lnLineCount,;
							IIF(This.oPrefs.lAlignAS, This.CountCharacterWidth (This.TrimTrailingWhiteSpace (This.FindBeforeAS (lcLine))), 0) )
					Endif &&lcLastPart = ';'
		
				Case (' ' + lcFirstWord + ' ') $ ' WHERE HAVING INTO TO ' And lnParenCount = 0
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nKeyWordIndent
					lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = .F.
		
					if lnAlignASBlockMax > 0 and laAlignASBlocks(lnAlignASBlockMax, 2) > lnCount Then
						laAlignASBlocks(lnAlignASBlockMax, 2) = lnCount-1
					Endif
		
				Case Inlist (lcFirstWord, 'GROUP', 'ORDER') And Upper (This.GetWordNumX (lcLine, 2)) == 'BY' And lnParenCount = 0
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nKeyWordIndent
		*			lnHangingIndent		  = This.oPrefs.nFieldIndent
					lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
					llFieldThisLineIndent = .F.
		*			llFieldNextLineIndent = lnParenCount # 0 Or This.LastCharIn (lcLine) # ','
					llFieldNextLineIndent = .F.
		
					if lnAlignASBlockMax > 0 and laAlignASBlocks(lnAlignASBlockMax, 2) > lnCount Then
						laAlignASBlocks(lnAlignASBlockMax, 2) = lnCount-1
					Endif
		
				Case (' ' + lcFirstWord + ' ') $ lcIndentJoin And lnParenCount = 0	&&' INNER OUTER JOIN LEFT RIGHT FULL ON '
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nJOINIndent
					lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = .F.
		
				Case (' ' + lcFirstWord + ' ') $ ' UNION ' And lnParenCount = 0
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
		*			lnIndent			  = Iif(llUnionIndentAlter, This.oPrefs.nUNIONIndent, -This.oPrefs.nSELECTIndent)
					lnIndent			  = Iif(llUnionIndentAlter, -This.oPrefs.nSELECTIndent, This.oPrefs.nUNIONIndent)
					lnHangingIndent		  = lnIndent + This.oPrefs.nHangingIndent
					llFieldThisLineIndent = .F.
					llFieldNextLineIndent = .F.
		
					if lnAlignASBlockMax > 0 and laAlignASBlocks(lnAlignASBlockMax, 2) > lnCount Then
						laAlignASBlocks(lnAlignASBlockMax, 2) = lnCount-1
					Endif
					If Not llUnionFound Then
						llUnionFound  = .T.
						If llUnionIndentAlter Then
		*					lnUnionIndentAlter = This.oPrefs.nUNIONIndent
							lnUnionIndentAlter = This.oPrefs.nSELECTIndent
							lnASCol = Iif(lnASCol = 0, 0 , lnASCol + This.oPrefs.nSELECTIndent)
							For lnAlignASBlock = 1 To lnAlignASBlockMax
								laAlignASBlocks(lnAlignASBlock, 3) = Iif(laAlignASBlocks(lnAlignASBlock, 3) = 0, 0, laAlignASBlocks(lnAlignASBlock, 3) + This.oPrefs.nSELECTIndent)
							Endfor
							For lnUnionCount = lnUnionIndentFirst To lnCount-1
								laResult (lnUnionCount) = Space(lnUnionIndentAlter) + laResult (lnUnionCount)
							Endfor
						ELSE  &&llUnionIndentAlter
							lnUnionIndentAlter = 0
						Endif &&llUnionIndentAlter
					Endif &&NOT llUnionFound
		
				Case (' ' + lcFirstWord + ' ') $ ' SELECT ' And lnParenCount = 0
					lnPos  				= At ('SELECT', Upper (lcLine))
					lcCurrentKeyWord	= lcFirstWord
					lnLen				= Len (lcCurrentKeyWord)
					lcLastPart			= This.TrimLeadingWhiteSpace (Substr (lcLine, lnLen + 1))
		
					lnParentCount		  = 0
					If lcLastPart = ';' Then
						lcLine = Substr (lcLine, lnPos, 6) + lcLastPart
						lnEndParenCount		  = 0
						llFieldNextLineIndent = .F.
						This.AddAlignAsBlock(@laAlignASBlocks, @lnAlignASBlockMax, lnCount+1, lnLineCount, 0 )
					Else  &&lcLastPart = ';'
						lcLine = Substr (lcLine, lnPos, 6) + Space (Max (1, This.oPrefs.nCharsAfterSelect)) + lcLastPart
						lnEndParenCount		  = This.CountParens (lcLine)
						llFieldNextLineIndent = lnParenCount # 0 Or (This.LastCharIn (lcLine) # ',' And THIS.GetWordCountX (lcLine)>1)
						This.AddAlignAsBlock(@laAlignASBlocks, @lnAlignASBlockMax, lnCount, lnLineCount,;
							IIF(This.oPrefs.lAlignAS, This.CountCharacterWidth (This.TrimTrailingWhiteSpace (This.FindBeforeAS (lcLine))), 0) )
		
					Endif &&lcLastPart = ';'
		*			lcLine = Substr (lcLine, lnPos, 6) + Space (Max (1, This.oPrefs.nCharsAfterSelect)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 6))
		
		* comes after UNION. In UNION the overall Indent after UNION will be set in lnUnionIndentAlter,
		* This is the total indentation of the SELECT Statement, so lnIndent is 0
					lnIndent			  = Iif(llUnionIndentAlter,0 ,This.oPrefs.nSELECTIndent)
		*			lnIndent			  = 0
					lnHangingIndent		  = This.oPrefs.nFieldIndent
					llFieldThisLineIndent = .F.
		
				Case (' ' + lcFirstWord + ' ') $ ' SET ' And lnParenCount = 0
					lnPos  = At ('SET', Upper (lcLine))
					lcLine = Substr (lcLine, lnPos, 3) + Space (Max (1, This.oPrefs.nCharsAfterSET)) + This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + 3))
		
					lcCurrentKeyWord	  = lcFirstWord
					lnParentCount		  = 0
					lnEndParenCount		  = This.CountParens (lcLine)
					lnIndent			  = This.oPrefs.nSETIndent
					lnHangingIndent		  = This.oPrefs.nSETFieldIndent
					llFieldThisLineIndent = .F.
		*SF 2022/03/15
		* fails if SET is alone on line, then there is no field break
		* needs to parse out;  ugly 
		* Hint: This.GetContinuationChar (lcLine) gets ;
		
					llFieldNextLineIndent = lnParenCount # 0 Or This.LastCharIn (lcLine) # ','
		
				Otherwise
					lnIndent = lnHangingIndent
		* additional indentation for fields defs that span multiple lines
					llFieldThisLineIndent = llFieldNextLineIndent
					llFieldNextLineIndent = Inlist (lcCurrentKeyWord + ' ', 'SELECT ', 'GROUP ', 'ORDER ', 'SET ') ;
						And (lnEndParenCount # 0;
						Or (Not EMPTY(lcFirstWord);
						And This.LastCharIn (lcLine) # ','))
		*** JRN 2010-05-27 : Correction for lines where leading comma means a new field
					If Inlist (lcCurrentKeyWord + ' ', 'SELECT ', 'GROUP ', 'ORDER ') And lnParenCount = 0 And lcFirstWord = ','
						llFieldThisLineIndent = .F.
						lnIndent			  = MAX(0, lnIndent - 2)
					Endif
		        FOR lnCount1 = 1 To THIS.GetWordCountX (lcLine)  
		        	If Upper (This.GetWordNumX (lcLine, lnCount1)) == 'SET' Then 
		        		lcCurrentKeyWord = 'SET'
		        		exit
		        	Endif &&Upper (This.GetWordNumX (lcLine, lnCount1)) == 'SET'
		        Endfor &&lnCount1
		
			Endcase
		
			lnTotalIndent = lnIndentAll + lnIndent + lnUnionIndentAlter									;
				+ (This.oPrefs.nParenIndent * lnParenCount)												;
				+ Iif (llFieldThisLineIndent And lcFirstWord # '&',										;
				IIf (lcCurrentKeyWord = 'SET', This.oPrefs.nSingleSETFieldIndent, This.oPrefs.nSingleFieldIndent) ;
				, 0)
			lcIndent = Space (lnTotalIndent)
		*	lcNewIndent = This.ConvertTabsForIndent(lcIndent)
			lcNewIndent = lcIndent
		
			lcNewLine = lcNewIndent + lcLine
		
			If This.oPrefs.lAlignAS
				lnASCol2 = This.CountCharacterWidth (This.TrimTrailingWhiteSpace (This.FindBeforeAS (lcNewLine)))
				lnASCol	 = Max (lnASCol  				    , lnASCol2)
				if lnAlignASBlockMax > 0 and laAlignASBlocks(lnAlignASBlockMax, 2) > lnCount Then
					laAlignASBlocks(lnAlignASBlockMax, 3) = Max (laAlignASBlocks(lnAlignASBlockMax, 3), lnASCol2)
				Endif
			Endif
		
			laResult (lnCount) = lcNewLine
			lnParenCount = lnEndParenCount
		
		Endfor
		
		lcResult   = ''
		If llAlignASFieldBlocks Then
			For lnAlignASBlock = 1 To lnAlignASBlockMax
				laAlignASBlocks(lnAlignASBlock, 4) = This.CalcColumnOffset (laAlignASBlocks(lnAlignASBlock, 3), This.oPrefs.nBeforeAS)
				laAlignASBlocks(lnAlignASBlock, 4) = Min (laAlignASBlocks(lnAlignASBlock, 4), lnAsColumn)
				laAlignASBlocks(lnAlignASBlock, 5) = This.CalcColumnOffset (laAlignASBlocks(lnAlignASBlock, 4) + 1, This.oPrefs.nAfterAS)
			Endfor
		
			lnAlignASBlock = 1
			For lnCount = 1 To lnLineCount
				lcLine = laResult (lnCount)
		
				If Between(lnCount,laAlignASBlocks(lnAlignASBlock, 1),laAlignASBlocks(lnAlignASBlock, 2)) And laAlignASBlocks(lnAlignASBlock, 3) # 0
					lcNewLine = This.FixASColumn (lcLine, 2, laAlignASBlocks(lnAlignASBlock, 4), laAlignASBlocks(lnAlignASBlock, 4))
				Else
					lcNewLine = lcLine
				Endif
				lcResult = lcResult + LINEEND + This.TrimTrailingWhiteSpace (lcNewLine)
		
				If lnCount = laAlignASBlocks(lnAlignASBlock, 2) And lnAlignASBlock<lnAlignASBlockMax Then
					lnAlignASBlock = lnAlignASBlock+1
				Endif &&lnCount = laAlignASBlocks(lnAlignASBlock, 2) AND lnAlignASBlock<lnAlignASBlockMax
		
			Endfor
		Else  &&llAlignASFieldBlocks
			lnBeforeAS = This.CalcColumnOffset (lnASCol, This.oPrefs.nBeforeAS)
			lnBeforeAS = Min (lnBeforeAS, lnAsColumn)
			lnAfterAS  = This.CalcColumnOffset (lnBeforeAS + 1, This.oPrefs.nAfterAS)
		
			For lnCount = 1 To lnLineCount
				lcLine = laResult (lnCount)
		
				If lnASCol # 0
					lcNewLine = This.FixASColumn (lcLine, 2, lnBeforeAS, lnAfterAS)
				Else
					lcNewLine = lcLine
				Endif
		
				lcResult = lcResult + LINEEND + This.TrimTrailingWhiteSpace (lcNewLine)
		
			Endfor
		Endif &&llAlignASFieldBlocks
		
		Return Substr (lcResult, 1 + Len (LINEEND))
		
		
	ENDPROC

	PROCEDURE beautifyselectx
		Lparameters tcCode, tlSemiColons
		
		This.oRegExp = Createobject ('VBScript.RegExp')
		With This.oRegExp
			.IgnoreCase	= .T.
			.Global		= .T.
			.MultiLine	= .T.
		Endwith
		
		* we lie about tabs throughout this
		lnTabWidth = This.ntabwidth
		This.ntabwidth = 1000
		
		lcCode = Strtran (tcCode, LF, '')
		lcResult = This.BeautifySelectMain (lcCode, tlSemiColons, This.oPrefs.lSelectCommasBeginLine)
		
		This.ntabwidth = lnTabWidth
		
		Return lcResult
		
	ENDPROC

	PROCEDURE beautifysingleline
		Lparameters tcCode, tcIgnoreTextOperators, tlTextMerge
		
		Local lcCharsToAdd, lcCode, lcCommaOperators, lcNextChar, lcNot, lcOperators, lcPrevChar
		Local lcRestLineString, lcResult, lcStringConstant, lcThisChar, lnCharPos, lnCharscount
		Local lnClosingCharPosition, lnOption, llIsOperator
		
		#Define OPERATORS 	'+-*/=$#%<>'
		lcOperators = Chrtran (OPERATORS, Evl (tcIgnoreTextOperators, ''), '')
		*!*	Changed by: SF 1.4.2022
		*!*	<pdm>
		*!*	<change date="{^2022-04-01,11:40:00}">Changed by: SF<br />
		*!*	deflate single line SQL
		*!*	</change>
		*!*	</pdm>
		If Inlist (Upper (This.GetWordNumX (tcCode, 1)) + ' ', 'SELECT ', 'UPDATE ', 'DELETE ')
			lcThisContinuationChar = This.GetContinuationChar (tcCode)
			If This.oPrefs.lExpandSingleLineSQL And lcThisContinuationChar = ' '
				lcResult = This.BeautifySelectCode (tcCode, .T., This.nTabWidth)
			Endif
		Endif
		
		If Empty (lcResult)
		*!*	/Changed by: SF 1.4.2022
		
		*** JRN 2010-07-06 : Some commands allow wildcards not within string constants
			If (' ' + Upper (This.GetWordNumX (tcCode, 1)) + ' ') $ ' APPEND COPY SORT COPY SCATTER GATHER PRIVATE RELEASE SAVE SET ERASE DELETE COMPILE '
				lcOperators = Chrtran (OPERATORS, '*?-', '')
			Endif
			lcOperators		 = Iif (This.oPrefs.lSpacesAroundOperators, lcOperators, '')
			lcCommaOperators = Iif (This.oPrefs.lSpaceBeforeCommas, ',', '') + lcOperators
		
			lcCode = This.TrimTrailingWhiteSpace (tcCode)
			If Empty (lcCode) ;
					Or Inlist (This.GetWordNumX (tcCode, 1), '*', '#', INLINECOMMENTS, '\') ;
					or Upper(This.GetWordNumX (tcCode, 1)) == 'RUN'
				Return lcCode
			Endif
		
			lcResult = ''
		
			lnCharscount = Len (lcCode)
			lcPrevChar	 = ''
			For lnCharPos = 1 To lnCharscount
		
				lcThisChar	 = Substr (lcCode, lnCharPos, 1)
				lcNextChar	 = Substr (lcCode, lnCharPos + 1, 1)
				lcCharsToAdd = lcThisChar
				llIsOperator = .T.
		
				Do Case
		
		* database!tablename
					Case lcThisChar = '!'					  ;
							And This.isnamechar (lcPrevChar)  ;
							And This.isnamechar (lcNextChar)
						lcCharsToAdd = lcThisChar + lcNextChar
						lnCharPos	 = lnCharPos + 1
		
		* !/
					Case lcThisChar = '!'  ;
							And This.TrimLeadingWhiteSpace (Substr (lcCode, lnCharPos + 1)) = '/'
						For lnCharPos = lnCharPos + 1 To lnCharscount
							lcThisChar	 = Substr (lcCode, lnCharPos, 1)
							lcCharsToAdd = lcCharsToAdd + lcThisChar
							If Not (lcThisChar ISABLANK Or lcThisChar = '/')
								Exit
							Endif
						Endfor
		
		* substitutions for 'NOT' and !
					Case This.oPrefs.nDefinitionForNOT  = 2  ;
							And lcThisChar = '!'	  ;
							And lcNextChar # '='
						lnOption = This.nBeautifyOptions (2)
						lcNot	 = Iif (lnOption = 1, 'NOT', Iif (lnOption = 2, 'not', 'Not'))
						lcCharsToAdd = Iif (lcPrevChar ISABLANK Or lcPrevChar $ '(', '', ' ')  ;
							+ lcNot + Iif (lcNextChar ISABLANK, '', ' ')
		
					Case This.oPrefs.nDefinitionForNOT  = 3							;
							And Not This.isnamechar (lcPrevChar)				;
							And Upper (Substr (lcCode, lnCharPos, 3)) == 'NOT'	;
							And Not This.isnamechar (Substr (lcCode, lnCharPos + 3, 1))
						lcCharsToAdd = Iif (lcPrevChar $ lcCommaOperators, ' ', '') + '!'
						lnCharPos	 = lnCharPos + 2
		
					Case This.isnamechar (lcThisChar)
		* Add a space after operators or commas
						If lcPrevChar $ lcCommaOperators
		* But not if this is negative constant
							If Not (lcPrevChar == "-"															;
									And Isdigit (lcThisChar)													;
									And Right (This.TrimTrailingWhiteSpace (Left (lcCode, lnCharPos - 2)), 1) $ '([,' + lcOperators ;
									)
								lcCharsToAdd = " " + lcCharsToAdd
							Endif
						Endif
		
		* substitutions for  # and != and <>
					Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 2 And Inlist (lcThisChar + lcNextChar, '!=', '<>')
						lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '#'
						lnCharPos	 = lnCharPos + 1
		
					Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 3 And lcThisChar = '#'
						lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '!='
		
					Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 3 And lcThisChar + lcNextChar = '<>'
						lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '!='
						lnCharPos	 = lnCharPos + 1
		
					Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 4 And lcThisChar = '#'
						lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '<>'
		
					Case (Not tlTextMerge) And This.oPrefs.nDefinitionForNOTEQUAL = 4 And lcThisChar + lcNextChar = '!='
						lcCharsToAdd = Iif (This.oPrefs.lSpacesAroundOperators And Not lcPrevChar ISABLANK, ' ', '') + '<>'
						lnCharPos	 = lnCharPos + 1
		
					Case lcThisChar $ ['"{] Or	;
							(lcThisChar = '[' And Not This.isnamechar (Right (This.TrimTrailingWhiteSpace (lcResult), 1)))
		* Grab entire character string (or date string .. {^2010,10,01}
						lcRestLineString	  = Substr (lcCode, lnCharPos + 1)
						lnClosingCharPosition = At (Iif (lcThisChar = "[", "]", Iif (lcThisChar = "{", "}", lcThisChar)), lcRestLineString)
						lcStringConstant	  = lcThisChar + Left (lcRestLineString, lnClosingCharPosition )
		*** JRN 2010-05-03 : select 'normal' string delimiters
						Do Case
							Case This.oPrefs.nStringDelimiters = 2	 ;
									And lcThisChar = ["]	 ;
									And Not ['] $ lcStringConstant
								lcStringConstant = ['] + Left (lcRestLineString, lnClosingCharPosition - 1) + [']
							Case This.oPrefs.nStringDelimiters = 3	 ;
									And lcThisChar = [']	 ;
									And Not ["] $ lcStringConstant
								lcStringConstant = ["] + Left (lcRestLineString, lnClosingCharPosition - 1) + ["]
							Case This.oPrefs.nStringDelimiters = 4	 ;
									And lcThisChar $ ['"]	 ;
									And Not ('[' $ lcStringConstant Or ']' $ lcStringConstant)
								lcStringConstant = '[' + Left (lcRestLineString, lnClosingCharPosition - 1) + ']'
						Endcase
		
						lcCharsToAdd = lcStringConstant
						lcThisChar	 = Right (lcStringConstant, 1)
						lnCharPos	 = lnCharPos + lnClosingCharPosition
		* Add a space after operators or commas
						If lcPrevChar $ lcCommaOperators
							lcCharsToAdd = " " + lcCharsToAdd
						Endif
		
					Case lcPrevChar == "&" And lcThisChar == "&"
		* double && -- trailing comment
						lcResult = lcResult + Substr (lcCode, lnCharPos)
						Exit
		
					Case lcPrevChar == "(" Or lcThisChar == ")"
		* no spaces after ( or before )
		
		* Case lcThisChar $ lcOperators And lcPrevChar $ lcOperators
		
					Case tlTextMerge And lcPrevChar + lcThisChar = '<<'
		* no added space after << within text merging
						lcCharsToAdd = lcThisChar + lcNextChar
						lnCharPos	 = lnCharPos + 1
		
					Case tlTextMerge And lcThisChar + lcNextChar = '>>'
		* no added space before >> within text merging
		
					Case lcThisChar + lcNextChar = '->'
		* no added space before >> within text merging
						lcCharsToAdd = lcThisChar + lcNextChar + Substr (lcCode, lnCharPos + 2, 1)
						lnCharPos	 = lnCharPos + 2
		
					Case Inlist (lcPrevChar + lcThisChar, "<=", ">=", "<>", "==", "!=", "**", ".*", "<<", ">>", "{/", "//", "/:", "/}", "--", "/*", "*/", "=<", "=>")
		* Special cases for  <=   >=   <>   ==   !=  **   .*
		
					Case lcThisChar == "+" And							;
							(											;
							Upper (Right (lcResult, 3)) == "ALT" Or	;
							Upper (Right (lcResult, 4)) == "CTRL" Or	;
							Upper (Right (lcResult, 5)) == "SHIFT"	;
							)
		* no space for hotkey definitions (CTRL+X, etc)
						lcCharsToAdd = lcThisChar + lcNextChar
						lnCharPos	 = lnCharPos + 1
		
					Case lcThisChar $ lcOperators And Not (lcPrevChar ISABLANK)
		* space before operators (finally!)
						If lnCharPos > 1
		
		***********************************************
							If Not Empty (This.cpluginisoperator)
		* 2011.11.22 MarioPeschke
		*            allowed to add spaces, only for specific structures
								Try
										llIsOperator = Execscript (This.cpluginisoperator, lcCode,lnCharPos)
									Catch To loException
										This.ShowErrorMsg (loException, 'IsOperator Failure')
								Endtry
							Endif
							If llIsOperator
								lcCharsToAdd = " " + lcThisChar
							Endif
						Endif
		
					Case This.oPrefs.nBeforeLeftParens = 3	 ;
							And lcThisChar = '('			 ;
							And (Not (lcPrevChar ISABLANK))	 ;
							And (Not (Isdigit (lcNextChar) Or lcNextChar = ')'))
		* (conditionally) add space before left parenthesis
						lcCharsToAdd = " " + lcThisChar
		
					Case (lcThisChar == "," And This.oPrefs.lSpaceBeforeCommas) Or (lcThisChar = '(' And This.oPrefs.nBeforeLeftParens = 2)
		* remove spaces or tabs before comma and left parentheses
						If Not Empty (lcResult)
							lcResult = This.TrimTrailingWhiteSpace (lcResult)
						Endif
		* but leave spaces between multiples commas   (a, b, , ,)
						If Right (lcResult, 1) = ','
							lcCharsToAdd = ' ' + lcThisChar
						Endif
		
		* Add a space after operators or commas
					Case This.oPrefs.lSpaceAfterCommas And lcPrevChar $ lcCommaOperators And Not lcThisChar ISABLANK
						lcCharsToAdd = " " + lcCharsToAdd
		
				Endcase
		
				lcResult   = lcResult + lcCharsToAdd
				If llIsOperator
					lcPrevChar = Right (lcCharsToAdd, 1)
				Else
					lcPrevChar = 'X'
				Endif
		
			Endfor
		
		*!*	Changed by: SF 1.4.2022
		*!*	<pdm>
		*!*	<change date="{^2022-04-01,11:40:00}">Changed by: SF<br />
		*!*	defalte single line SQL
		*!*	</change>
		*!*	</pdm>
		Endif &&Empty (lcResult)
		*!*	/Changed by: SF 1.4.2022
		
		Return lcResult
		
		
	ENDPROC

	PROCEDURE beautifyword
		Lparameters tcWord
		
		Local lcWord
		Do Case
			Case This.nBeautifyOptions(2) = 1
				lcWord = Upper(tcWord)
			Case This.nBeautifyOptions(2) = 2
				lcWord = Lower(tcWord)
			Otherwise
				lcWord = Proper(tcWord)
		Endcase
		
		Return lcWord
	ENDPROC

	PROCEDURE calccolumn
		Lparameters lcLine, lcText
		Local lcLeft, lnPos 
		
		lnPos = 1 + At (' ' + lcText + ' ', Strtran (Upper (lcLine), Tab, ' ', 1, 999))
		If lnPos <= 1
			Return lcLine
		Endif
		
		lcLeft = Left (lcLine, lnPos - 1)
		Return This.CountCharacterWidth (This.TrimTrailingWhiteSpace (lcLeft))
		
		
		
		
	ENDPROC

	PROCEDURE calccolumnoffset		&& Given a starting column, offsets it; primarily for handling tabs
		Lparameters lnCol, lnOffset
		
		If lnOffset <= 4
			Return lnCol + 1 + lnOffset
		Else
			Return (lnCol - lnCol % This.nTabWidth) + This.nTabWidth + 1 + IIf (lnOffset = 5, 0, This.nTabWidth)
		Endif
		
	ENDPROC

	PROCEDURE converttabsforindent
		Lparameters lcNewIndent
		
		If This.oPrefs.lUseTabs
			Return Strtran (lcNewIndent, Space (This.nTabWidth), Tab)
		Else
			Return lcNewIndent
		Endif
		
	ENDPROC

	PROCEDURE createidlist
		Lparameters lcProcName, lnStartLine, lnEndLine
		
		Local loRegExp As 'VBScript.RegExp'
		Local laLocals[1], laParens[1], lcName, lcNewCode, lcNotNameChars, lcRestLineString, lcSourceLine
		Local lcThisChar, lcUpperWord, lcWord, lcWord1, lcWord2, lcWordNew, llAssign, llLongEnough
		Local lnCharPos, lnClosingCharPosition, lnI, lnJ, lnLineCount, lnLoop, lnLoopStartValue
		Local lnParenCount, lnParenLevel, lnPos, lnType
		
		With This
			.FixWithStatements() && this is for setup only
			.nNewLocalsCount	  = 0
			.cCurrentLocals		  = This.FindCurrentLocals (lnStartLine, lnEndLine)
			.lNoDotsInAssignments = .F.
			.CreateNewLocals (lnStartLine, lnEndLine, .T.)
		Endwith
		
		lcNotNameChars = Chrtran (NOTNAMECHARS, '&\(^),', '') + Tab + CR + LF
		
		loRegExp = This.oUtils.GetRegExp()
		
		****************************************************************
		For lnLoop = lnStartLine To lnEndLine
			lnLoopStartValue = lnLoop
			lcSourceLine	 = ' ' + This.GetSourceCodeLine (@lnLoop, .T.)
		
			If Empty (lcSourceLine)
				Loop
			Endif
		
			With loRegExp
				* replace all white space and sem-colons with simple white space
				.Pattern	 = '(\s+|;)'
				lcSourceLine = .Replace (lcSourceLine, ' ')
			Endwith
		
			lcWord1		 = Upper (THIS.GetWordNumX (lcSourceLine, 1))
			lcWord2		 = THIS.GetWordNumX (lcSourceLine, 2)
			llLongEnough = Len (lcWord1) >= 4
		
			*** JRN 2010-08-16 : pseudo line allowed to identify tables in use
		
			If Inlist (lcWord1, '*', '#', INLINECOMMENTS)
				Loop
			Endif
		
			If llLongEnough And 'EXTERNAL' = lcWord1
				Loop
			Endif
		
			Insert Into crsr_IDs_Lines				;
				(ProcID, SourceLine, Lineno)		;
				Values								;
				(crsr_IDs_Procs.Id, lcSourceLine, lnLoopStartValue)
		
			This.lFieldReference = llLongEnough And (											;
				'SELECT' = lcWord1															;
				Or 'UPDATE' = lcWord1															;
				Or 'REPLACE' = lcWord1														;
				Or 'INSERT' = lcWord1															;
				Or ('CREATE' = lcWord1 And Inlist (Upper (lcWord2), 'TABLE', 'CURSOR'))		;
				)
		
			If lcWord1 == 'DECLARE'
				If 'IN' == Upper (THIS.GetWordNumX (lcSourceLine, 3))
					This.InsertID (THIS.GetWordNumX (lcSourceLine, 2), TYPE_Declared)
				Else
					This.InsertID (THIS.GetWordNumX (lcSourceLine, 3), TYPE_Declared)
				Endif
				Loop
			Endif
		
			lcNewCode	 = This.ParseLineForIDList (lcSourceLine, lcNotNameChars)
			lnParenLevel = 0
		
			With loRegExp
				.Pattern  = '(Alt|Shift|Ctrl)\s+\+\s'
				lcNewCode = .Replace (lcNewCode, '$1+')
			Endwith
		
			If Upper (lcNewCode) = ' *{PEME:TABLES}'
				lcSourceLine = 'From ' + Substr (lcNewCode, 16)
			Endif
		
			If llLongEnough
				If 'LOCAL' = lcWord1 Or 'PRIVATE' = lcWord1
					This.InsertLocalIDs (lcNewCode, TYPE_Locals, 2)
					Loop
				Endif
		
				If 'LPARAMETERS' = lcWord1 Or 'PARAMETERS' = lcWord1
					This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 2)
					Loop
				Endif
		
				If 'PROCEDURE' = lcWord1 Or 'FUNCTION' = lcWord1
					This.InsertID (lcProcName, Iif('.' $ lcProcName, TYPE_Methods, TYPE_Procedures))
					This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 3)
					Loop
				Endif
		
				If 'HIDDEN' = lcWord1 Or 'PROTECTED' = lcWord1
					This.InsertID (lcProcName, Iif('.' $ lcProcName, TYPE_Methods, TYPE_Procedures))
					This.InsertLocalIDs (lcNewCode, TYPE_Parameters, 4)
					Loop
				Endif
		
			Endif
		
			For lnI = 1 To THIS.GetWordCountX (lcNewCode)
				lcWord		= THIS.GetWordNumX (lcNewCode, lnI)
				lcUpperWord	= Upper (lcWord)
		
				Do Case
		
					Case Left (lcUpperWord, 1) $ '^+'
		
					Case lcUpperWord = '('
						lnParenLevel = lnParenLevel + 1
		
					Case lcUpperWord = ')'
						lnParenLevel = lnParenLevel - 1
		
					Case lcUpperWord == 'DO'
						Do Case
							Case Upper (lcWord2) == 'CASE'
							Case Upper (lcWord2) == 'WHILE'
							Case Upper (lcWord2) == 'FORM'
								lnType = TYPE_Forms
								lcWord = THIS.GetWordNumX (lcNewCode, lnI + 2)
								This.InsertID (lcWord, lnType)
							Otherwise
								lnType = TYPE_Procedures
								lcWord = THIS.GetWordNumX (lcNewCode, lnI + 1)
								This.InsertID (lcWord, lnType)
						Endcase
		
						* Tables
					Case lcUpperWord == 'USE'
						lnType = TYPE_Tables
						lcWord = THIS.GetWordNumX (lcNewCode, lnI + 1)
						This.InsertID (lcWord, lnType)
		
					Case lcUpperWord == 'JOIN'
						lnType = TYPE_Tables
						lcWord = THIS.GetWordNumX (lcNewCode, lnI + 1)
						This.InsertID (lcWord, lnType)
						Do Case
							Case Upper (THIS.GetWordNumX (lcNewCode, lnI + 2)) == 'AS'
								lcWord = THIS.GetWordNumX (lcNewCode, lnI + 3)
								This.InsertID (lcWord, lnType)
							Case Not Upper (THIS.GetWordNumX (lcNewCode, lnI + 2)) == 'ON'
								lcWord = THIS.GetWordNumX (lcNewCode, lnI + 2)
								This.InsertID (lcWord, lnType)
						Endcase
		
					Case lcUpperWord == 'FROM'
						lnType = TYPE_Tables
						For lnJ = lnI + 1 To THIS.GetWordCountX (lcNewCode)
							lcWord = THIS.GetWordNumX (lcNewCode, lnJ)
							This.InsertID (lcWord, lnType)
							lcWordNew = THIS.GetWordNumX (lcNewCode, lnJ + 1)
							Do Case
								Case Empty (lcWord)
									Exit
								Case Upper (lcWordNew) == 'AS'
									lnJ = lnJ + 1
								Case lcWordNew = ','
									lnJ = lnJ + 1
								Case This.Iskeyword (lcWordNew)
									Exit
							Endcase
						Endfor
		
					Case lcUpperWord == 'IN' And lcWord1 # 'FOR'
						lnType = TYPE_Tables
						lcWord = THIS.GetWordNumX (lcNewCode, lnI + 1)
						If Not Inlist (Upper (lcWord) + ' ', 'SCREEN ', 'WIN32API ', 'KERNEL32 ')
							This.InsertID (lcWord, lnType)
						Endif
		
					Case lcUpperWord == 'SELECT'
						lnType = TYPE_Tables
						lcWord = THIS.GetWordNumX (lcNewCode, lnI + 1)
						If Empty (THIS.GetWordNumX (lcNewCode, lnI + 2))
							This.InsertID (lcWord, lnType)
						Endif
		
					Case lcUpperWord == 'CREATE' And Inlist (' ' + Upper (THIS.GetWordNumX (lcNewCode, lnI + 1)), ' TABLE', ' CURSOR')
						lnType = TYPE_Tables
						lcWord = THIS.GetWordNumX (lcNewCode, lnI + 2)
						This.InsertID (lcWord, lnType)
		
					Case lcUpperWord == 'INSERT' And Upper (THIS.GetWordNumX (lcNewCode, lnI + 1)) =  'INTO'
						lnI	   = lnI + 2
						lcWord = THIS.GetWordNumX (lcNewCode, lnI)
		
						Do Case
							Case lcWord = '('
								Do While .T.
									lnI		= lnI + 1
									lcWord2	= THIS.GetWordNumX (lcNewCode, lnI)
									If Empty (lcWord2) Or lcWord2 = ')'
										Exit
									Else
										This.InsertIDOthers (lcWord2, THIS.GetWordNumX (lcNewCode, lnI + 1))
									Endif
								Enddo
								lcWord = '?Table'
								lnType = TYPE_Tables
								This.InsertID (lcWord, lnType)
		
							Case lcWord = '^'
								lcWord = '?Table'
								lnType = TYPE_Tables
								This.InsertID (lcWord, lnType)
		
							Otherwise
								lnType = TYPE_Tables
								This.InsertID (lcWord, lnType)
						Endcase
		
						lnI		= lnI + 1
						lcWord2	= THIS.GetWordNumX (lcNewCode, lnI)
						If lcWord2 = '('
							Do While .T.
								lnI		= lnI + 1
								lcWord2	= THIS.GetWordNumX (lcNewCode, lnI)
								If Empty (lcWord2) Or lcWord2 = ')'
									Exit
								Else
									This.InsertID (lcWord + '.' + lcWord2, TYPE_Objects)
								Endif
							Enddo
						Endif
		
					Case lcUpperWord == 'INTO' And Inlist (' ' + Upper (THIS.GetWordNumX (lcNewCode, lnI + 1)), ' TABLE', ' CURSOR')
						lnType = TYPE_Tables
						lcWord = THIS.GetWordNumX (lcNewCode, lnI + 2)
						This.InsertID (lcWord, lnType)
		
					Case Inlist (lcUpperWord, 'UPDATE', 'ALIAS')
						lnType = TYPE_Tables
						lcWord = THIS.GetWordNumX (lcNewCode, lnI + 1)
						This.InsertID (lcWord, lnType)
		
					Case 1 = Len (lcWord) And lcUpperWord $ ASDATATYPE_CHARS
						* do nothing for single character names that can be used in Cast( AS ...) or Create Cursor or Create Table
		
					Otherwise
						This.InsertIDOthers (lcWord, THIS.GetWordNumX (lcNewCode, lnI + 1))
		
				Endcase
			Endfor
		
		Endfor
		
		Return
		
	ENDPROC

	PROCEDURE createidlistcursors
		Create Cursor crsr_IDs_Procs (			;
			  Id     		I AutoIncr,			;
			  ProcName   	C(250),				;
			  StartLine	    N(6)				;
			  )
		
		Create Cursor crsr_IDs_Lines (			;
			  Id     		I AutoIncr,			;
			  ProcID        I,					;
			  SourceLine	M,					;
			  Lineno		N(4),				;
			  AnyFound		L					;
			  )
		
		Create Cursor crsr_IDs_Refs (		;
			  ProcID        I,				;
			  LineID		I,				;
			  Name		 	C(100),			;
			  Type      	N(2)			;
			  )
		
		Create Cursor crsr_IDs_Constants  (			;
			  Constant      C(100)				;
			  )
	ENDPROC

	PROCEDURE createidlistsummary
		Lparameters lcProcName
		Local laLocals[1], lcName, lnI, lnLineCount
		
		Select  Distinct									;
				Upper (Name)		 As	 UpperName,			;
				TYPE_Tables			 As	 nNewType,			;
				Len (Trim (Name))	 As	 nLength			;
			From crsr_IDs									;
			Where nType = TYPE_Tables						;
			Into Cursor crsr_Tables Readwrite
		
		Select  Upper (Name)				   As  UpperName,											;
				Min (Name)					   As  Name,												;
				Min (Nvl (nNewType, nType))	   As  nType												;
			From crsr_IDs																				;
				Left Join crsr_Tables																	;
					On Left (crsr_Tables.UpperName, nLength) = Upper (Left (crsr_IDs.Name, nLength))	;
					And Substr (crsr_IDs.Name, nLength + 1, 1) $ ' .'									;
			Where Upper (Name) # Upper (Evl (lcProcName, '??'))											;
			Group By 1																					;
			Order By 3, 1																				;
			Into Cursor crsr_Summary
		
		
	ENDPROC

	PROCEDURE createlocalsforcodeblock
		Lparameters lcCodeSource, lnWindowType, lnCurrentLine, llLocalsAllProcs
		Local lcCode, lcName, lcNewCode, lcType, lnEnd, lnI, lnJ, lnStart 
		
		This.SetBeautifyOptions()
		Alines (This.aCodeLines, lcCodeSource + ' ')
		
		Do Case
			Case lnWindowType = 10 && Method Code
				lcNewCode = This.DoLocals (1, Alen (This.aCodeLines))
			Case lnWindowType = 1 && PRG
				This.ParsePRGCodeBlocks ()
				lcNewCode = ''
				For lnI = 1 To Alen (This.aPRGCodeBlocks, 1)
					lcName	= This.aPRGCodeBlocks (lnI, 1)
					lcType	= This.aPRGCodeBlocks (lnI, 2)
					lnStart	= This.aPRGCodeBlocks (lnI, 3)
					lnEnd	= This.aPRGCodeBlocks (lnI, 4)
					If lcType $ 'PF' And (		;
							  llLocalsAllProcs Or Between (lnCurrentLine + 1, lnStart, lnEnd))
						lcCode	  = This.DoLocals (lnStart, lnEnd)
						lcNewCode = IIf (Empty (lcNewCode), '', lcNewCode + LINEEND) + lcCode
					Else
						For lnJ = lnStart To lnEnd
							lcNewCode = IIf (Empty (lcNewCode), '', lcNewCode + LINEEND) + This.aCodeLines (lnJ)
						Endfor
					Endif
				Endfor
			Otherwise
				Return
		Endcase
		
		Return lcNewCode
		
	ENDPROC

	PROCEDURE createlocalstatements
		Local laLocals[1]
		Local lcArrayDims, lcASPhrase, lcCode, lcLine, lcLocalName, lcLocalPhrase, lcLocalsPlugIn, lcName
		Local lcResult, lcVar, llAlreadyLocal, llArray, llCommasBeforeLocals, llContinuation, llHasASPhrase
		Local llStartsWithL, llUseAsPhrase, llUseTabs, lnMaxWidth, lnRow, lnSelectionType, lnType
		Local llAssigned, llRemoveOrphanLocals, llSortCreatedLocals
		Local llLocalsPureLocal, llSpaceBeforeCommas, llLocalsAlignAS
		Local llLocalArray, llArrayRoundBracket, lcLocalArrayName, lcLocalKeyWrd, lcResultArray, lcArrayBracket_Start, lcArrayBracket_End
		Local lcComma, lnLines, lnLine, lnPos, lnPosMax, Lcas
		
		If This.nNewLocalsCount = 0
			Return ''
		Endif
		
		lcLocalsPlugIn = This.oUtils.GetPlugInPath ("CreateLocalsStatements")
		If Not Empty (lcLocalsPlugIn)
			Acopy (This.aNewLocals, laLocals)
			lcCode = Execscript (Filetostr (lcLocalsPlugIn), @laLocals)
			Return lcCode
		Endif
		
		****************************************************************
		
		This.SetBeautifyOptions()
		lcLocalKeyWrd = This.BeautifyWord('Local')
		Lcas = This.BeautifyWord(' as ')
		llUseTabs = This.nBeautifyOptions(4) = 1
		
		lcLocalArrayName = lcLocalKeyWrd + ' ' + This.BeautifyWord('Array')
		
		With This.oPrefs
			llContinuation		 = Not .lLocalsMultPerLine
			llLocalsPureLocal	 = Nvl(.lLocalsPureLocal, .F.)
			llSpaceBeforeCommas	 = .lSpaceBeforeCommas
			lnSelectionType		 = .nLocalsSelectionType
			lnMaxWidth			 = .nLocalsLineWidth
			llUseAsPhrase		 = .lLocalsUseAS
			llCommasBeforeLocals = .lCommasBeforeLocals
			llRemoveOrphanLocals = .lRemoveOrphanLocals
		*!*	<pdm>
		*!*	<change date="{^2023-10-25,12:57:00}">Changed by: alemrcc<br />
		*!*	In some installations the value of llSortCreatedLocals is initialised to 1.00 or 0.00
		*!*	</change>
		*!*	</pdm>
			llSortCreatedLocals  = IIF(VARTYPE(.lSortCreatedLocals) = 'N', CAST(.lSortCreatedLocals as Logical), .lSortCreatedLocals)
		*!*	/Changed by: alemrcc 25.10.2023
			llLocalsAlignAS		 = Nvl(.lLocalsAlignAS, .F.)
		*!*	<pdm>
		*!*	<change date="{^2022-03-31,18:17:00}">Changed by: SF<br />
		*!*	Dealing with Arrays like LOCAL ARRAY
		*!*	Option to use round bracktes for array declaration
		*!*	</change>
		*!*	</pdm>
			llLocalArray		 = .lLocalArray
			llArrayRoundBracket	 = .lArrayRoundBracket
		*!*	/Changed by: SF 31.3.2022
		Endwith
		
		If m.llSpaceBeforeCommas Then
			lcComma     = ', '
		Else  &&m.llSpaceBeforeCommas
			lcComma     = ','
		Endif &&m.llSpaceBeforeCommas
		
		If llArrayRoundBracket
			lcArrayBracket_Start = '('
			lcArrayBracket_End	 = ')'
		Else
			lcArrayBracket_Start = '['
			lcArrayBracket_End	 = ']'
		Endif
		
		****************************************************************
		With This
		
			If llSortCreatedLocals
				Asort (.aNewLocals, 1, -1, 0, 0)
			Endif
		
			lcResult = ''
			lcResultArray = ''
		*!*	<pdm>
		*!*	<change date="{^2022-03-31,18:17:00}">Changed by: SF<br />
		*!*	Dealing with Arrays like LOCAL ARRAY
		*!*	</change>
		*!*	</pdm>
		
		*	For lnType = 0 To 4
			For lnType = Iif(llLocalArray, -1, 1) To 4
		
				If lnType > 0
					lcLocalName = lcLocalKeyWrd
				Else
					lcLocalName = lcLocalArrayName
				Endif
		
				If lnType = 1 And llLocalArray
		*buffer local array
					lcResultArray =  lcResult
					lcResult = ''
		
				Endif
		
		*!*	/Changed by: SF 31.3.2022
				lcLine = ''
				For lnRow = 1 To Alen (.aNewLocals, 1)
		
					Do Case
						Case Empty (m.lcLine) And m.llContinuation And m.llLocalsPureLocal And m.llSpaceBeforeCommas
							lcLocalPhrase = ' ;' + LINEEND + Iif (llUseTabs, Tab, ' ')
						Case Empty (m.lcLine) And m.llContinuation And m.llLocalsPureLocal
							lcLocalPhrase = ';' + LINEEND + Iif (llUseTabs, Tab, ' ')
						Otherwise
							lcLocalPhrase = ' '
					Endcase
		
					lcName		   = .aNewLocals (lnRow, 1)
					lcASPhrase	   = .aNewLocals (lnRow, 2)
					llArray		   = .aNewLocals (lnRow, 3)
					llHasASPhrase  = .aNewLocals (lnRow, 4)
					llStartsWithL  = .aNewLocals (lnRow, 5)
					llAlreadyLocal = .aNewLocals (lnRow, 6)
					lcArrayDims	   = .aNewLocals (lnRow, 7)
					llAssigned     = .aNewLocals (lnRow, 8)
		
					lcName = lcName + Iif (llArray, lcArrayBracket_Start + lcArrayDims + lcArrayBracket_End, '')
		
					Do Case
		
		****************************************************************
						Case lnType < 1  And (Not llArray)
		* lnType,-1,0 only array
							Loop
		
						Case lnType > 0  And llLocalArray And llArray
		* And llStartsWithL
		* local array on llLocalArray only on lnType < 1
							Loop
		
						Case llRemoveOrphanLocals And llAlreadyLocal And (Not llAssigned) And (Not llArray)
							Loop
		
						Case llUseAsPhrase And llStartsWithL
							If Inlist (lnType, -1, 1)
								lcVar		  = This.AddASPhase (lcName, lcASPhrase, m.lcAS)
								lcLocalPhrase = lcLocalName + m.lcLocalPhrase
							Else
								Loop
							Endif
		
						Case llUseAsPhrase And Inlist (lnType, -1, 1) And lnSelectionType = 4
							lcVar		  = This.AddASPhase (lcName, lcASPhrase, m.lcAS)
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
		
						Case llUseAsPhrase And Inlist (lnType,  0, 2) And lnSelectionType = 3
							lcVar		  = This.AddASPhase (lcName, lcASPhrase, m.lcAS)
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
		
						Case llUseAsPhrase And lnType = 3 And lnSelectionType = 2
							lcVar		  = This.AddASPhase (lcName, lcASPhrase, m.lcAS)
							lcLocalPhrase = '*:Global' + m.lcLocalPhrase
		
						Case lnType = 0 And lnSelectionType = 2 AND Not llStartsWithL
							lcVar		  = lcName
							lcLocalPhrase = '*:Global Array' + m.lcLocalPhrase
		
						Case llUseAsPhrase
							Loop
		
		****************************************************************
						Case lnSelectionType = 1 And Not llStartsWithL
							Loop
		
						Case lnType = -1 And lnSelectionType = 4 
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
		
						Case lnType = 0 And lnSelectionType = 4 
							loop
		
						Case llHasASPhrase And lnType = 1
							lcVar		  = lcName + m.lcAS + lcASPhrase
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
						Case Not llHasASPhrase And lnType = -1 And llStartsWithL
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
						Case Not llHasASPhrase And lnType =  0 And Not llStartsWithL
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
						Case llHasASPhrase
							Loop
		
						Case llStartsWithL And lnType = 2
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
						Case llStartsWithL
							Loop
		
						Case lnSelectionType = 4 And lnType = 2
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
		
						Case lnSelectionType = 2 And lnType = 3 And llAlreadyLocal
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
		
						Case lnSelectionType = 2 And lnType = 4
							lcVar		  = lcName
							lcLocalPhrase = '*:Global' + m.lcLocalPhrase
		
						Case lnSelectionType = 3 And lnType = 4
							lcVar		  = lcName
							lcLocalPhrase = lcLocalName + m.lcLocalPhrase
		
						Otherwise
							Loop
					Endcase
		
					Do Case
						Case Empty (lcLine)
							lcLine = lcLocalPhrase  + lcVar
						Case llContinuation Or llUseAsPhrase
							If llCommasBeforeLocals
								lcLine = lcLine + ';' + LINEEND + Iif (llUseTabs, Tab, ' ') + m.lcComma + lcVar
							Else
								lcLine = lcLine + m.lcComma+';' + LINEEND + Iif (llUseTabs, Tab, ' ') + lcVar
							Endif
						Case Not Inlist(lnType, -1, 1) And (Len (lcLine) + 2 + Len (lcVar)) <= lnMaxWidth
							lcLine = lcLine + m.lcComma + lcVar
						Otherwise
							lcResult = lcResult + lcLine + LINEEND
							lcLine	 = lcLocalPhrase  + lcVar
					Endcase
				Endfor
		
				If Not Empty (lcLine)
					lcResult = lcResult + lcLine + LINEEND
				Endif
			Endfor
		
		Endwith
		
		If m.llContinuation  And m.llUseAsPhrase And m.llLocalsAlignAS Then
			lnLines = Alines(laLocals,m.lcResult)
			lcResult = ''
			lcVar    = This.BeautifyWord(' as ')
			lnPosMax = 0
			For lnLine = 1 To m.lnLines
				lnPosMax = Max(m.lnPosMax,At(m.lcAS,laLocals(m.lnLine)))
			Endfor &&lnLine
			For lnLine = 1 To m.lnLines
				lnPos = At(m.lcAS,laLocals(m.lnLine))
				If m.lnPos = 0 Then
					lcResult = m.lcResult + laLocals(m.lnLine) + LINEEND
				Else  &&m.lnPos = 0
		*            lcResult = m.lcResult + STUFF(laLocals(m.lnLine),m.lnPos,1,SPACE(m.lnPosMax-m.lnPos+1)) + LINEEND
					lcResult = m.lcResult + ;
						+ This.AddWhiteSpace(This.TrimTrailingWhiteSpace(Left (laLocals(m.lnLine), lnPos)), lnPosMax + 1);
						+ This.TrimLeadingWhiteSpace(Substr (laLocals(m.lnLine), lnPos + 1)) + ;
						LINEEND
				Endif &&m.lnPos = 0
			Endfor &&lnLine
		
		Endif &&m.llContinuation AND m.llUseAsPhrase AND m.llLocalsAlignAS
		
		
		*!*	<pdm>
		*!*	<change date="{^2022-03-31,18:17:00}">Changed by: SF<br />
		*!*	Dealing with Arrays like LOCAL ARRAY
		*!*	Option to use round bracktes for array declaration
		*!*	</change>
		*!*	</pdm>
		If Not Empty (lcResultArray) Then
			If Empty (lcResult) Then
				lcResult = lcResultArray
			Else  &&EMPTY(lcResult)
				lcResult = lcResult + LINEEND + lcResultArray
			Endif &&EMPTY(lcResult)
		Endif &&m.llContinuation AND m.llUseAsPhrase AND m.llLocalsAlignAS
		*!*	/Changed by: SF 31.3.2022
		
		Return lcResult
		
		
	ENDPROC

	PROCEDURE createnewlocals
		Lparameters lnStartLoop, lnEndLoop, llFixWITHs
		* This.aNewLocals:
		*    Col 1 = Local Name
		*    Col 2 = AS blabla
		*    Col 3 = Array?
		*    Col 4 = Col 2 non-empty
		*    Col 5 = Begins with lowercase 'l'
		*    Col 6 = Already found in LOCALs
		*    Col 7 = Array parameters
		*    Col 8 = Actual assignment?
		*    Col 9 = <Unused>
		*    Col 10 = <Unused>
		
		Local laLocals[1], laWithEndWith[1]
		Local lcArrayFunc, lcArrayFunctions, lcArrayLine, lcASPhrase, lcChar
		Local lcCurrentWithEndWith, lcDims, lcExpression, lcName, lcObjClassLib, lcObjType, lcParams, lcParse
		Local lcSourceLine, lcTmp, lcVar, lcWord, lcWord1, lcWord2, llCreateObject, llFirstTimeThru, llNameOK
		Local lnI, lnLoop, lnPos, lnWithEndWithLevel, lnWord
		Local lcIncludeFile, lcValue, lnI, loIncludeFiles, loRegExp, loResults
		
		llFirstTimeThru = .T.
		This.FixWithStatements()
		
		*!*	Changed by: SF 31.3.2022
		*!*	<pdm>
		*!*	<change date="{^2022-03-31,18:17:00}">Changed by: SF<br />
		*!*	Problems searching array names in array-funtions
		*!*	Problems to locating array-funtions in constructs like <expr>FOR ALINES(</expr>
		*!*	</change>
		*!*	</pdm>
		
		loRegExp = This.oUtils.GetRegExp()
		loRegExp.Pattern  = '[\s\;]*\('
		*!*	/Changed by: SF 31.3.2022
		
		
		For lnLoop = lnStartLoop To lnEndLoop
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
			lcWord1 = Lower (THIS.GetWordNumX (lcSourceLine, 1))
			lcWord2 = Lower (THIS.GetWordNumX (lcSourceLine, 2))
		
			If llFixWITHs
				lcSourceLine = This.FixWithStatements(lcSourceLine)
			Endif
		
			lcParse = ''
			If Empty (lcSourceLine) Or lcWord1 = '*'
				Loop
			Endif
		
			Do Case
		
				Case 'procedure ' = lcWord1 Or 'function ' = lcWord1
					If Not llFirstTimeThru
						Exit
					Endif
		
				Case ('protected ' = lcWord1 Or 'hidden ' = lcWord1)		;
						And ('procedure ' = lcWord2 Or 'function ' = lcWord2)
					If Not llFirstTimeThru
						Exit
					Endif
		
				Case ' to array ' $ Lower (lcSourceLine) And (		;
						'copy ' = lcWord1							;
						Or 'scatter ' = lcWord1					;
						Or 'sum ' = lcWord1						;
						Or 'calculate ' = lcWord1					;
						Or 'average ' = lcWord1					;
						)
					lcParse = Substr (lcSourceLine, Rat ([ to ], Lower (lcSourceLine)) + 10)
					For lnWord = 1 To 1000
						lcWord = Alltrim (Getwordnum (lcParse, lnWord, ','))
						If Empty (lcWord)
							Exit
						Else
							This.AddNewLocal (THIS.GetWordNumX (lcWord, 1), , .T.)
						Endif
					Endfor
		
				Case ' to ' $ Lower (lcSourceLine) And (		;
						'store ' = lcWord1					;
						Or 'calculate ' = lcWord1				;
						Or 'average ' = lcWord1				;
						Or 'sum ' = lcWord1					;
						Or 'count ' = lcWord1					;
						Or 'wait ' = lcWord1					;
						Or 'catch ' = lcWord1					;
						)
					lcParse = lcSourceLine			
					lcParse = This.RemoveParens(lcParse)
					If ' to ' $ Lower (lcParse)
						lcParse = Substr (lcParse, Rat ([ to ], Lower (lcParse)) + 4)
						lcParse = Strtran(lcParse, ';', ' ')
						For lnWord = 1 To 1000
							lcWord = Alltrim (Getwordnum (lcParse, lnWord, ','))
							If Empty (lcWord) 
								Exit
							Else
								This.AddNewLocal (THIS.GetWordNumX (lcWord, 1))
								If 1 # THIS.GetWordCountX(lcWord)
									Exit
								EndIf 
							Endif
						EndFor
					EndIf 
		
				Case 'dimension ' = lcWord1
					lcSourceLine = Alltrim (lcSourceLine)
					lcParse = Substr (lcSourceLine, At (' ', lcSourceLine) + 1)
					If Not Empty (lcParse)
						Dimension laLocals(1)
						This.ParseCodeLine (lcParse, @laLocals, .T.)
		
						For lnI = 1 To Alen (laLocals, 1)
							lcName = laLocals (lnI, 1)
							lcDims = laLocals (lnI, 2)
							lcASPhrase = laLocals (lnI, 3)
							This.AddNewLocal (lcName, , .T.)
						Endfor
					Endif
		
				Case 'catch ' = lcWord1 And 'to ' = lcWord2
					This.AddNewLocal (THIS.GetWordNumX (lcSourceLine, 3))
				Case 'select ' = lcWord1 And ' into array ' $ Lower (lcSourceLine)
					lcParse = THIS.GetWordNumX (Substr (lcSourceLine, Rat (' into array ', Lower (lcSourceLine)) + 12), 1)
					This.AddNewLocal (lcParse + '(1)')
				Case 'scatter ' = lcWord1 And ' name ' $ Lower (lcSourceLine)
					lcParse = Strextract (lcSourceLine, ' name ', ' ', 1, 1 + 2)
					This.AddNewLocal (THIS.GetWordNumX (lcParse, 1))
				Case Lower (Left (lcSourceLine, 9)) = 'for each '
					lcParse = Strextract (lcSourceLine, 'for each ', ' ', 1, 3)
					If ' as ' $ Lower (lcSourceLine)
						lcASPhrase = Strextract (lcSourceLine, ' as ', ' ', 1, 3)
						This.AddNewLocal (THIS.GetWordNumX (lcParse, 1), THIS.GetWordNumX (lcASPhrase, 1))
					Else
						This.AddNewLocal (THIS.GetWordNumX (lcParse, 1))
					Endif
				Case 'for ' = lcWord1
					lcParse = Strextract (lcSourceLine, 'for ', '=', 1, 3)
					This.AddNewLocal (lcParse)
				Case Left (Lower (lcSourceLine), 8) = 'text to '
					lcParse = THIS.GetWordNumX (lcSourceLine, 3)
					This.AddNewLocal (lcParse)
				Case '=' $ lcSourceLine
					lnPos = At ('=', lcSourceLine)
					lcVar = Alltrim (Left (lcSourceLine, lnPos - 1))
					lcExpression = Alltrim (Substr (lcSourceLine, lnPos + 1))
					llNameOK = .T.
					For lnI = 1 To Len (lcVar)
						lcChar = Substr (lcVar, lnI, 1)
						llNameOK = llNameOK And (This.IsNameChar (lcChar) Or lcChar $ '.()[]')
					Endfor
					If llNameOK
						lcASPhrase = ''
						If Inlist (Lower (Left (lcExpression, 9)), 'newobject', 'createobj')
							llCreateObject = (Lower (Left (lcExpression, 9)) == 'createobj')
							lcExpression = Alltrim (Strextract (lcExpression, [(]))
							If Right (lcExpression, 1) = [)]
								lcExpression = Left (lcExpression, Len (lcExpression) - 1)
							Endif
							lcObjType = Alltrim (Getwordnum (lcExpression, 1, [,]))
							lcObjClassLib = Alltrim (Getwordnum (lcExpression, 2, [,]))
							If Empty (lcObjClassLib) Or llCreateObject
								If Left (lcObjType, 1) $ (['"] + '[')
									lcASPhrase = lcObjType
								Endif
							Else
								If Left (lcObjType, 1) $ (['"] + '[') And Left (lcObjClassLib, 1) $ (['"] + '[')
									lcASPhrase = lcObjType + [ OF ] + lcObjClassLib
								Endif
							Endif
						Endif
						This.AddNewLocal (lcVar, lcASPhrase)
					Endif
			Endcase
		
			*-- THM 08/31/2006 - Support for inline array functions.
			*Support for array functions - lines may contain more than one of these....
			*-- RCE 01/23/2009 - respect Current Locals
			*** JRN 2023-06-29 : value following = indicates which parameter contains the name of the variable
			lcArrayFunctions = 'aclass,acopy=2,adatabases,adbobjects,adir,adlls,adockstate,aerror,aevents,afields,' ;
				+ 'afont,agetclass,agetfileversion,ainstance,alanguage,alines,amembers,amouseobj,anetresources,aprinters,' ;
				+ 'aprocinfo,aselobj,asessions,asqlhandles,astackinfo,ataginfo,aused,avcxclasses' && ,sqlexec=4'
		
		*!*	Changed by: SF 31.3.2022
		*!*	<pdm>
		*!*	<change date="{^2022-03-31,18:17:00}">Changed by: SF<br />
		*!*	Problems searching array names in array-funtions
		*!*	Problems to locating array-funtions in constructs like <expr>FOR ALINES(</expr>
		*!*	</change>
		*!*	</pdm>
		
			lcArrayLine = loRegExp.Replace (lcSourceLine,'(')
		
		*!*	/Changed by: SF 31.3.2022
		
			Local lcText, lnParamNo
			For lnI = 1 To GetWordCount (lcArrayFunctions, ',')
				lcText = Getwordnum (lcArrayFunctions, lnI, ',')
				lcArrayFunc = Getwordnum (lcText, 1, '=')
				lnParamNo = Evl(Val(Getwordnum (lcText, 2, '=')), 1)
				*** JRN 2010-04-21 : check character before reference to make sure it is not part of a name ... laMouseObj, e.g.,
				If lcArrayFunc + '(' $ Lower (lcArrayLine)
					lnPos = At (lcArrayFunc + '(', Lower (lcArrayLine))
					If lnPos = 1 or Not This.IsNameChar (Substr (lcArrayLine, lnPos - 1, 1))
						lcParams = Strextract (Substr (lcArrayLine, lnPos), '(', ')')
						This.AddNewLocal (Getwordnum (lcParams, lnParamNo, ','), , .T.)
					Endif
				Endif
			Endfor
		
			*-- THM 08/31/06 - Support for 'DO FORM'
			*-- RCE 01/23/09 - Support for WITH clause; respect Current Locals
			If Left (Lower (lcSourceLine), 8) = 'do form '
				If ' to ' $ Lower (lcSourceLine)
					lcTmp = THIS.GetWordNumX (Substr (lcSourceLine, Rat ([ to ], Lower (lcSourceLine)) + 4), 1)
					This.AddNewLocal (lcTmp)
				Endif
		
				If ' name ' $ Lower (lcSourceLine)
					lcTmp = THIS.GetWordNumX (Substr (lcSourceLine, Rat ([ name ], Lower (lcSourceLine)) + 6), 1)
					This.AddNewLocal (lcTmp, 'Form')
				Endif
		
			Endif
			llFirstTimeThru = .F.
		Endfor
		
	ENDPROC

	PROCEDURE doformidlist
		Lparameters lnHandle, lcSourceFileName, lcClassName
		
		Local loFormIDList As 'FrmIDList' Of 'Source\EditProperty.VCX'
		Select  *						;
			From crsr_IDs_Lines			;
			Where AnyFound				;
			Into Cursor crsr_IDS_Lines2
		
		loFormIDList 	 = Newobject ('FrmIDList', 'Source\EditProperty.VCX', ''		;
			  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Procs')						;
			  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Lines2')						;
			  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Refs')						;
			  , This.oUtils.ConvertCursortoXML ('crsr_IDs_Constants')					;
			  , This.oUtils.cApplicationPath											;
			  , This.oUtils																;
			  , lnHandle, lcSourceFileName, lcClassName									;
			  )
		
		loFormIDList.Show()
		
		* following allows this to be kept around after this method ends
		* and also to be cleaned up when _oPEMEditor closes
		This.oUtils.AddProperty ('o' + Sys(2015), loFormIDList)
		
	ENDPROC

	PROCEDURE doidlisttext
		Lparameters lcSourceLine, lnLoop, lnLinesCount
		
		Local lcFirstWord, lcLine, lcType, lnI
		Do Case
			Case '{PEME:IGNORE}' $ Upper (lcSourceLine)
				lcType = 'Ignore'
			Case '{PEME:CODE}' $ Upper (lcSourceLine)
				lcType = 'Code'
			Case '{PEME:SELECT}' $ Upper (lcSourceLine)
				lcType = 'Select'
			Case This.oPrefs.lBeautifyTEXTasSelect
				For lnI = lnLoop + 1 To lnLinesCount
					lcLine		= This.aCodeLines[lnI]
					lcFirstWord	= Upper (THIS.GetWordNumX (lcLine, 1))
					Do Case
						Case Empty (lcFirstWord)
		
						Case 'SELECT ' = lcFirstWord
							lcType = 'Select'
							Exit
						Otherwise
							lcType = 'Ignore'
							Exit
					Endcase
				Endfor lnI = lnLoop + 1 To lnLinesCount
			Otherwise
				lcType = 'Ignore'
		Endcase
		
		If lcType = 'Ignore'
			For lnI = lnLoop + 1 To lnLinesCount
				lcLine		= This.aCodeLines[lnI]
				lcFirstWord	= Upper (THIS.GetWordNumX (lcLine, 1))
				If lcFirstWord == 'ENDTEXT'
					Return lnI
				Endif
			Endfor lnI = lnLoop + 1 To lnLinesCount
		Endif lcType = 'Ignore'
		
		Return lnLoop
	ENDPROC

	PROCEDURE dolocals
		LPARAMETERS lnStartLine, lnEndLine
		LOCAL lcLocalStatements, lcNewCode, lcSourceLine, lcWord1, llAddTheseLines, llInsertLocalsLater
		LOCAL llLocalRun
		LOCAL lnFirstLocalPos
		
		THIS.nNewLocalsCount = 0
		DIMENSION THIS.aNewlocals(1,10)
		* This.aNewLocals:
		*    Col 1 = Local Name
		*    Col 2 = AS blabla
		*    Col 3 = Array?
		*    Col 4 = Col 2 non-empty
		*    Col 5 = Begins with lowercase 'l'
		*    Col 6 = Already found in LOCALs
		*    Col 7 = Array parameters
		*    Col 8 = Actual assignments
		*    Col 9 = <Unused>
		*    Col 10 = <Unused>
		
		*SF 2023/05/26
		*changed the insertion of LOCALS below [L]PARA, wherever it is located, while keeping old behaviour if no parameters
		*issue #104
		THIS.cCurrentLocals = THIS.FindCurrentLocals (lnStartLine, lnEndLine, THIS.oPrefs.lMovelocals)
		THIS.lNoDotsInAssignments = .T.
		THIS.CreateNewLocals (lnStartLine, lnEndLine)
		lcLocalStatements = THIS.CreateLocalStatements()
		lnFirstLocalPos = 0
		
		lcNewCode = ''
		FOR lnLoop = lnStartLine TO lnEndLine
		 lnLoopValueBefore = lnLoop
		 lcSourceLine = THIS.GetSourceCodeLine (@lnLoop, , .T.)	&&lnloop is now increasd by lines continued
		 lcWord1 = LOWER (THIS.GetWordNumX (lcSourceLine,1))
		 llAddTheseLines = .T.
		*	llInsertNewLocals = .F.
		
		 DO CASE
		  CASE LEN (lcWord1) >= 4 AND 'local ' = (lcWord1 + ' ')
		   IF THIS.oPrefs.lMovelocals
		    llAddTheseLines = .F.
		*				llInsertNewLocals = .T.
		    llLocalRun = .T.
		    lnFirstLocalPos = IIF(EMPTY(m.lnFirstLocalPos), LEN(m.lcNewCode) + 1, m.lnFirstLocalPos)
		   ELSE
		    llInsertLocalsLater = .T.
		   ENDIF
		
		  CASE llInsertLocalsLater
		   lnFirstLocalPos = IIF(EMPTY(m.lnFirstLocalPos), LEN(m.lcNewCode) + 1, m.lnFirstLocalPos)
		   llInsertLocalsLater = .F.
		
		  CASE EMPTY (lcSourceLine)
		
		  CASE lcWord1 = '#if'
		   IF '{PEME:LOCALSAFTER}' $ UPPER (lcSourceLine) THEN
		    lnFirstLocalPos = 0
		   ELSE &&'{PEME:LOCALAFTER}' $ Upper (lcSourceLine)
		    llInsertNewLocals = .T.
		    lnFirstLocalPos = IIF(EMPTY(m.lnFirstLocalPos), LEN(m.lcNewCode) + 1, m.lnFirstLocalPos)
		   ENDIF &&'{PEME:LOCALAFTER}' $ Upper (lcSourceLine)
		
		  CASE INLIST (lcWord1, '*', INLINECOMMENTS) OR (LEN (lcWord1) >= 4 AND 'note ' = lcWord1)
		   IF '{PEME:LOCALSAFTER}' $ UPPER (lcSourceLine) THEN
		    lnFirstLocalPos = 0
		   ENDIF &&'{PEME:LOCALAFTER}' $ Upper (lcSourceLine)
		   llLocalRun = .F.
		
		  CASE INLIST (lcWord1, '#')
		   llLocalRun = .F.
		
		  CASE LEN (lcWord1) >= 4 AND 			;
		    ('procedure ' 		= lcWord1 	;
		    OR 'function ' 		= lcWord1 	;
		    OR 'hidden ' 		= lcWord1 	;
		    OR 'protected ' 	= lcWord1 	;
		    OR 'public ' 		= lcWord1 	;
		    OR 'private ' 		= lcWord1 	;
		    OR '*:global ' 		= lcWord1 	;
		    )
		   llLocalRun = .F.
		
		  CASE LEN (lcWord1) >= 4 AND 			;
		    ('lparameters ' 	= lcWord1 	;
		    OR 'parameters ' 	= lcWord1 	;
		    )
		   llLocalRun = .F.
		   lnFirstLocalPos = 0
		
		  OTHERWISE
		   llLocalRun = .F.
		   lnFirstLocalPos = IIF(EMPTY(m.lnFirstLocalPos), LEN(m.lcNewCode) + 1, m.lnFirstLocalPos)
		
		 ENDCASE
		
		*!*		If llInsertNewLocals And Not Empty (lcLocalStatements)
		*!*			lcNewCode = Iif (Empty (lcNewCode), '', lcNewCode + LINEEND) + lcLocalStatements
		*!*			lcLocalStatements = ''
		*!*		Endif
		
		 IF llAddTheseLines AND NOT llLocalRun
		  FOR lnI = lnLoopValueBefore TO lnLoop
		*			lcNewCode = Iif (Empty (lcNewCode), '', lcNewCode + Replicate (LINEEND, lnLocalRun + 1)) + This.aCodeLines (lnI)
		   lcNewCode = IIF (EMPTY (lcNewCode), '', lcNewCode + LINEEND ) + THIS.aCodeLines (lnI)
		  ENDFOR
		 ENDIF
		ENDFOR
		
		IF !EMPTY(m.lnFirstLocalPos) AND !EMPTY (lcLocalStatements) THEN
		 IF m.lnFirstLocalPos<=1 THEN 
		  lcNewCode = STUFF(m.lcNewCode, m.lnFirstLocalPos, 0, m.lcLocalStatements + LINEEND)
		 ELSE  &&m.lnFirstLocalPos<=1
		  lcNewCode = STUFF(m.lcNewCode, m.lnFirstLocalPos, 0, LINEEND + m.lcLocalStatements)
		 ENDIF &&EMPTY(m.lnFirstLocalPos)
		ENDIF &&m.lnFirstLocalPos<=1
		
		RETURN lcNewCode
		
	ENDPROC

	PROCEDURE fetchparameterslist
		Local lcCodeSource
		
		lcCodeSource = This.GetEditorWindowText (.T.)
		
		If Empty (lcCodeSource)
			Return .F.
		Endif
		
		Return This.GetParametersList (lcCodeSource)
		
		
	ENDPROC

	PROCEDURE findcurrentlocals
		Lparameters lnStartLoop, lnEndLoop, llMoveLocals
		Local laLocals[1], lcASPhrase, lcCurrentLocals, lcDims, lcName, lcSourceLine, lcType, lcWord1
		Local llFirstTimeThru, lnI, lnLoop
		
		lcCurrentLocals	= ','
		llFirstTimeThru	= .T.
		This.nLocalsList	= 0
		
		* Find the existing local declarations
		For lnLoop = lnStartLoop To lnEndLoop
			* Add SourceLine to previous if continuation line
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
		
			lcSourceLine = IIf (Lower (Left (lcSourceLine, 7)) == 'hidden ', Alltrim (Substr (lcSourceLine, 8)), lcSourceLine)
			lcSourceLine = IIf (Lower (Left (lcSourceLine, 10)) == 'protected ', Alltrim (Substr (lcSourceLine, 11)), lcSourceLine)
		
			*--------------------------------------------------
			*  GLR 8-29-2006 : add Private, Public, and Dimension to the list of possible declaration statements
			*--------------------------------------------------
			*-- GLR 8/31/2006 : added 'Define' to list
			*-- THM 8/31/2006 : removed 'dimens' from list.
			lcWord1 = Lower (THIS.GetWordNumX (lcSourceLine, 1))
			If Inlist (lcWord1, 'local', 'privat', 'public', 'parame', 'lparam', '*:glob',		;
					  'proced', 'functi', 'endpro', 'endfun', 'define')
				lcType = 'other'
				Do Case
						*--------------------------------------------------
						*  standard declarations
						*--------------------------------------------------
					Case 'local ' = lcWord1						;
							Or 'private ' = lcWord1				;
							Or 'public ' = lcWord1				;
							Or 'parameters ' = lcWord1			;
							Or 'lparameters ' = lcWord1			;
							Or '*:global ' = lcWord1
						lcType		 = lcWord1
						lcSourceLine = Substr (lcSourceLine, 1 + Len (lcWord1))
		
						If Lower (THIS.GetWordNumX (lcSourceLine, 1)) == 'array'
							lcSourceLine = Alltrim (lcSourceLine)
							lcSourceLine = Substr (lcSourceLine, 7)
						Endif
						*--------------------------------------------------
						*  if start procedure, get arguments
						*--------------------------------------------------
					Case 'procedure ' = lcWord1 Or 'function ' = lcWord1
						lcSourceLine = Strtran(lcSourceLine, '()', '')
						Do Case
							Case Not llFirstTimeThru
								Exit
							Case '(' $ lcSourceLine
								lcType		 = 'lparameters'
								lcSourceLine = Strtran (Substr (lcSourceLine, At ('(', lcSourceLine) + 1), ')', '')
							Otherwise
								Loop
						Endcase
		
					Otherwise
						Loop
				Endcase
		
				*--------------------------------------------------
				*  Parse declarations
				*--------------------------------------------------
		
				If Not Empty (lcSourceLine)
					Dimension laLocals(1)
					This.ParseCodeLine (lcSourceLine, @laLocals, .F.)
		
					For lnI = 1 To IIf (Alen (laLocals) # 1, Alen (laLocals, 1), 0)
						lcName	   = Alltrim (laLocals (lnI, 1))
						lcDims	   = laLocals (lnI, 2)
						lcASPhrase = laLocals (lnI, 3)
		
						Do Case
							Case 'local ' = (lcWord1 + ' ') And llMoveLocals
								This.AddNewLocal (lcName, lcASPhrase, Not Empty (lcDims), .T., lcDims)
							Case Not Lower (',' + lcName + ',') $ Lower (lcCurrentLocals)
								lcCurrentLocals = lcCurrentLocals + lcName + ','
						Endcase
		
						This.nLocalsList = This.nLocalsList + 1
						Dimension This.aLocalsList (This.nLocalsList, 2)
						This.aLocalsList (This.nLocalsList, 1) = lcName
						This.aLocalsList (This.nLocalsList, 2) = lcType
		
					Endfor
				Endif
			Endif
			llFirstTimeThru = .F.
		Endfor
		
		Return lcCurrentLocals
		
	ENDPROC

	PROCEDURE findlocalslinenumber
		Lparameters lnStartLoop, llFirst
		Local lcSourceLine, lcWord1, lnLineNumber, lnLocalLineNumber, lnLoopValueBefore, lnLoop
		
		lnLineNumber = lnStartLoop
		lnLocalLineNumber = 100000
		
		For lnLoop = lnStartLoop To Alen (This.aCodeLines)
			lnLoopValueBefore = lnLoop
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
			lcWord1 = Lower (THIS.GetWordNumX (lcSourceLine,1))
		
			Do Case
				Case Empty (lcSourceLine)
					lnLineNumber = lnLoop
		
				Case Inlist (lcWord1, '*', '#', INLINECOMMENTS)
					lnLineNumber = lnLoop + 1
		
				Case Len (lcWord1) >= 4 And 'local ' = lcWord1
					Do Case
						Case llFirst
							Return lnLoopValueBefore 
						Case lnLineNumber <= lnLocalLineNumber
							lnLineNumber = lnLoop + 1
							lnLocalLineNumber = lnLineNumber
					Endcase
		
				Case Len (lcWord1) >= 4 And 			;
						('procedure ' = lcWord1 		;
						or 'function ' = lcWord1 		;
						or 'hidden ' = lcWord1 			;
						or 'protected ' = lcWord1 		;
						or 'lparameters ' = lcWord1 	;
						or 'parameters ' = lcWord1 		;
						or 'public ' = lcWord1 			;
						or 'private ' = lcWord1 		;
						or '*:global ' = lcWord1 		;
						)
					lnLineNumber = lnLoop + 1
		
				Otherwise
					Return Min (lnLineNumber, lnLocalLineNumber)
		
			Endcase
		Endfor
		
		Return lnLineNumber
		
	ENDPROC

	PROCEDURE findprocstartline
		Lparameters lnCurrentLine
		Local lcSourceLine, lcWord1, lcWord2, lnCounter, lnCounterNow, lnProcStart 
		
		lnProcStart = 1
		For lnCounter = 1 To lnCurrentLine
			lnCounterNow = lnCounter
			lcSourceLine = This.GetSourceCodeLine (@lnCounter)
			lcWord1 = Lower (THIS.GetWordNumX (lcSourceLine,1))
			lcWord2 = Lower (THIS.GetWordNumX (lcSourceLine,2))
		
			If Len (lcWord1) >= 4											;
					and ('procedure ' = lcWord1 or 'function ' = lcWord1)
				lnProcStart = lnCounterNow
			Endif
		
			If Len (lcWord1) >= 4											;
					and ('protected ' = lcWord1 or 'hidden ' = lcWord1)	;
					and Len (lcWord2) >= 4 									;
					and ('procedure ' = lcWord2 or 'function ' = lcWord2)
				lnProcStart = lnCounterNow
			Endif
		Endfor
		
		Return lnProcStart 
	ENDPROC

	PROCEDURE fixascolumn
		Lparameters lcLine, lnWordWidth, lnWITHColumn, lnAfterWITHColumn
		Local lcLeft, lcNewLeft, lcNewLine, lcRight, lnPos
		
		lcLeft = This.FindBeforeAS (lcLine)
		If 0 = Len (lcLeft)
			Return lcLine
		Endif
		
		lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, 1 + Len (lcLeft) + lnWordWidth))
		If Not Right (lcLine,1) ISABLANK
			lcLine = lcLine + ' '
		Endif
		
		lcNewLeft = This.AddWhiteSpace (lcLeft, lnWITHColumn) + Substr (lcLine, 1 + Len (lcLeft), lnWordWidth)
		lcNewLine = This.AddWhiteSpace (lcNewLeft, lnAfterWITHColumn) + lcRight
		
		Return lcNewLine
		
	ENDPROC

	PROCEDURE fixwith
		Lparameters lcLine, lnWordWidth, lnWITHColumn, lnAfterWITHColumn
		Local lcLeft, lcNewLeft, lcNewLine, lcRight, lnPos
		
		lnPos = 1 + At (' WITH ', Strtran (Upper (lcLine), Tab, ' ', 1, 999))
		
		If lnPos <= 1
			Return lcLine
		Endif
		
		lcLeft = Left (lcLine, lnPos - 1)
		lcRight = This.TrimLeadingWhiteSpace (Substr (lcLine, lnPos + lnWordWidth)) 
		
		lcNewLeft = This.AddWhiteSpace (lcLeft, lnWITHColumn) + Substr (lcLine, lnPos, lnWordWidth)
		lcNewLine = This.AddWhiteSpace (lcNewLeft, lnAfterWITHColumn) + lcRight
		
		Return lcNewLine
		
		
		
	ENDPROC

	PROCEDURE fixwithstatements
		Lparameters lcSourceLine
		
		Local lcWord1, lcWord2, lnJ, lnPos
		
		If Pcount() = 0
			With This
				.nWithEndWithLevel = 0
				.aWithEndWith = ' '
				.cCurrentWithEndWith = ''
			Endwith
			Return
		Endif
		
		lcWord1 = Upper (THIS.GetWordNumX (lcSourceLine,1))
		
		Do Case
			Case lcWord1 == 'WITH'
				lcWord2 = Alltrim (Substr (Alltrim (lcSourceLine), 5))
				If lcWord2 = '.'
					lcWord2 = This.cCurrentWithEndWith + lcWord2
					lcSourceLine = 'With ' + lcWord2
				Endif
				This.nWithEndWithLevel = This.nWithEndWithLevel + 1
				Dimension This.aWithEndWith(This.nWithEndWithLevel)
				This.aWithEndWith(This.nWithEndWithLevel) = lcWord2
				This.cCurrentWithEndWith = lcWord2
		
			Case lcWord1 == 'ENDWITH'
				If This.nWithEndWithLevel > 1
					This.nWithEndWithLevel = This.nWithEndWithLevel - 1
					This.cCurrentWithEndWith = This.aWithEndWith(This.nWithEndWithLevel)
				Else
					This.nWithEndWithLevel = 0
					This.cCurrentWithEndWith = ''
				Endif
		
			Case Not Empty (This.cCurrentWithEndWith)
				lcSourceLine = ' ' + lcSourceLine
				For lnJ = 1 To 999
					lnPos = At (' .', lcSourceLine, lnJ)
					Do Case
						Case lnPos = 0
							Exit
						Case Isdigit (Substr (lcSourceLine, lnPos + 2, 1))
						Case Inlist (Upper (Substr (lcSourceLine, lnPos + 1)), '.T.', '.F.', '.NULL.')
						Otherwise
							lcSourceLine = Left (lcSourceLine, lnPos) + This.cCurrentWithEndWith + Substr (lcSourceLine, lnPos + 1)
							If This.cCurrentWithEndWith # '.'
								lnJ = lnJ - 1
							Endif
					Endcase
				Endfor
		Endcase
		
		Return lcSourceLine
		
	ENDPROC

	PROCEDURE formatidlist
	ENDPROC

	PROCEDURE getassignmentcol
		Lparameters lcLine
		Local lcLeft, lcLeftBracket, lcRightBracket, lcText, lnPos 
		
		lnPos = At ('=', lcLine)
		If lnPos = 0 Or Not This.oPrefs.lFixAssignments
			Return 0
		Endif
		
		lcLeft = This.TrimTrailingWhiteSpace (Left (lcLine, lnPos - 1))
		lcText = This.TrimLeadingWhiteSpace (lcLeft)
		
		* 02/22/2012 -- added to handle assignments of arrays
		If Right(lcText,1) $ '])'
			lcRightBracket = Right(lcText,1)
			lcLeftBracket = IIF(lcRightBracket = ']', '[', '(') 
			If Occurs(lcLeftBracket, lcText) = Occurs(lcRightBracket, lcText)
				lcText = This.TrimTrailingWhiteSpace (Left(lcText, At(lcLeftBracket, lcText) - 1)) 
			Endif
		Endif && Right(lcText,1) $ '])'
			
		If Len (lcText) # Len (Chrtran (lcText, Chrtran(NOTNAMECHARS, '&', '') + CR + LF, '')) or Empty (lcText)
			Return 0
		Endif
		
		Return This.CountCharacterWidth (lcLeft)
		
	ENDPROC

	PROCEDURE getconstants
		Lparameters lcSourceText, tcIncludeFileName
		
		Local lcIncludeFile, lcValue, lnI, loIncludeFiles, loRegExp, loResults
		
		*   #Defines
		loRegExp = This.oUtils.GetRegExp()
		With loRegExp
			.Pattern  = '^\s*#Defi(|n|ne)\s+\w+'
			loResults = .Execute (lcSourceText)
		Endwith
		
		For lnI = 0 To loResults.Count - 1
			lcValue  = Chrtran (loResults.Item (lnI).Value, Chr(13) + Chr(10), '')
			Insert Into crsr_IDs_Constants Values (Upper (THIS.GetWordNumX (lcValue, 2)))
		Endfor
		
		*   #Includes
		loIncludeFiles = This.oUtils.GetIncludeFiles (lcSourceText)
		For Each lcIncludeFile In loIncludeFiles FoxObject
			If Empty (tcIncludeFileName)
				lcIncludeFile = Fullpath (lcIncludeFile)
			Else
				lcIncludeFile = Fullpath (lcIncludeFile, tcIncludeFileName)
			Endif
		
			If File (lcIncludeFile)
				This.GetConstants (Filetostr (lcIncludeFile), lcIncludeFile)
			Endif
		
		EndFor 
		
		
	ENDPROC

	PROCEDURE geteditorwindowtext
		Lparameters llAllText
		
		Local lcCodeSource, lnSelEnd, lnSelStart
		
		If 0 >= This.oEditorWin.FindWindow()
			Return ''
		Endif
		
		With This.oEditorWin
			lnSelStart = .GetSelStart()
			lnSelEnd   = .GetSelEnd()
			If llAllText Or lnSelStart = lnSelEnd
				lnSelStart = 0
				lnSelEnd   = .GetEnvironment(2)
			Endif
			lcCodeSource   = .GetString (lnSelStart, lnSelEnd - 1)
		Endwith
		
		This.nSelStart = lnSelStart
		This.nSelEnd   = lnSelEnd
		
		Return lcCodeSource
	ENDPROC

	PROCEDURE getindentation
		Lparameters lcText
		
		Return Left(lcText, Len(lcText) - Len(Ltrim(lcText, 1, ' ', Chr(9)))) 
		
	ENDPROC

	PROCEDURE getparameterslist
		Lparameters lcCodeSource
		
		Local lcName, lcResult, lcType, lnI
		
		Alines (This.aCodeLines, lcCodeSource + ' ')
		This.FindCurrentLocals(1, Alen (This.aCodeLines))
		
		lcResult = ''
		For lnI = 1 To This.nLocalslist
			lcName = This.aLocalslist (lnI, 1)
			lcType = This.aLocalslist (lnI, 2)
			If lcType = 'para' Or lcType = 'lpara'
				lcResult = lcResult + IIf (Empty (lcResult), '', ', ') + lcName
			Endif
		Endfor
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getsourcecodeline
		Lparameters lnCounter, llIgnoreTextMerge, llIgnoreHashIF
		Local lcLine, lcSourceLine, llHashIFBlock, llTextBlock
		
		lcSourceLine  = ''
		llTextBlock	  = .F.
		llHashIFBlock = .F.
		Do While lnCounter <= Alen (This.aCodeLines)
			lcLine		 = This.aCodeLines (lnCounter)
			lcSourceLine = Evl (lcSourceLine + ' ', '') + Alltrim (Chrtran (lcLine, Tab + CR + LF, '   '))
			lnCounter	 = lnCounter + 1
		
			Do Case
				Case llTextBlock And Upper (This.GetWordNumX (lcLine, 1)) == 'ENDTEXT'
		*SF changed 2022/06/10 (see below)
		*SF changed 2022/05/27 we need to force this
		*			llTextBlock = .F.
					Exit
				Case llTextBlock
					Loop
				Case Upper (This.GetWordNumX (lcLine, 1)) == 'TEXT'
					If llIgnoreTextMerge
						lnCounter = This.DoIDListText(lcSourceLine, lnCounter, Alen (This.aCodeLines))
						Exit
					Else
						llTextBlock = .T.
					Endif
					Loop
		
				Case llHashIFBlock And Upper (This.GetWordNumX (lcLine, 1)) == '#ENDIF'
		*SF changed 2022/06/10 (see below)
		*SF changed 2022/05/27 we need to force this
		*			llHashIFBlock = .F.
					Exit
				Case llHashIFBlock
					Loop
				Case llIgnoreHashIF And Upper (This.GetWordNumX (lcLine, 1)) == '#IF'
					llHashIFBlock = .T.
					Loop
		
		*2023/05/27 moved before ";" because a line can end like "&& ;"
				Case INLINECOMMENTS $ lcSourceLine
					lcSourceLine = Alltrim (Left (lcSourceLine, At (INLINECOMMENTS, lcSourceLine) - 1))
					If ';' = Right (lcSourceLine, 1)
						Loop
					Endif
		
				Case ';' == Right (lcSourceLine, 1)
					Loop
			Endcase
		
			lnCounter = lnCounter - 1
			Exit
		
		Enddo
		
		*SF changed 2022/06/10, 
		*https://github.com/VFPX/PEMEditor/issues/28
		*Problem when ENDTEXT / #ENDIF is missing, lnCounter will be one to large
		If llTextBlock Or llHashIFBlock Then
			lnCounter = lnCounter - 1
		Endif &&llTextBlock Or llHashIFBlock
		*/SF 2022/06/10
		
		Return lcSourceLine
		
	ENDPROC

	PROCEDURE getvariableslist
		Lparameters tcCodeSource, tcType
		
		Local laResult[1], lcKey, lcName, lcType, lcVarType, lnCount, lnI, lnRow, loResult
		
		Alines (This.aCodeLines, tcCodeSource + ' ')
		
		This.nNewLocalsCount = 0
		Dimension This.aNewlocals(1, 10)
		* This.aNewLocals:
		*    Col 1 = Local Name
		*    Col 2 = AS blabla
		*    Col 3 = Array?
		*    Col 4 = Col 2 non-empty
		*    Col 5 = Begins with lowercase 'l'
		*    Col 6 = Already found in LOCALs
		*    Col 7 = Array parameters
		*    Col 8 = Actual assignments
		*    Col 9 = <Unused>
		*    Col 10 = <Unused>
		
		This.FindCurrentLocals(1, Alen (This.aCodeLines))
		This.lNoDotsInAssignments = .T.
		This.CreateNewLocals (1, Alen (This.aCodeLines))
		
		lcType = Evl(tcType, 'PL!')
		
		Do Case
			Case '#' $ lcType
				loResult = Createobject('Empty')
				AddProperty(loResult, 'aList[1]')
				Acopy(This.aLocalsList, loResult.aList)
				Return loResult
			Case '*' $ lcType
				lnCount = Alen(This.aLocalsList, 1)
				Dimension laResult(lnCount, 3)
				For lnI = 1 To lnCount
					If not Empty(This.aLocalsList[lnI, 1])
						laResult[lnI, 1] = This.aLocalsList[lnI, 1]
						laResult[lnI, 2] = This.aLocalsList[lnI, 2]
					EndIf 
				Endfor
		
				lnCount = Alen(This.aNewlocals, 1)
				For lnI = 1 To lnCount
					lcName = This.aNewlocals[lnI, 1]
					If Empty(lcName)
						Loop
					EndIf 
					If (This.aNewlocals[lnI, 6] = .F.) Or (This.aNewlocals[lnI, 8] = .T.)
		
						lnRow = Ascan(laResult, lcName, 1, -1, 1, 15)
						If lnRow # 0
							laResult[lnRow, 3] = .T.
						Else
							lnRow = Alen(laResult, 1) + 1
							Dimension laResult[lnRow, 3]
							laResult[lnRow, 1] = lcName
							laResult[lnRow, 2] = '?'
							laResult[lnRow, 3] = .T.
						Endif && lnRow # 0
					Endif && This.aNewlocals[lnI,6]  or This.aNewlocals[lnI,8]
				Endfor
				loResult = Createobject('Empty')
				AddProperty(loResult, 'aList[1]')
				Acopy(laResult, loResult.aList)
				Return loResult
		Endcase
		
		loResult		 = Createobject('Collection')
		loResult.KeySort = 2
		For lnI = 1 To This.nLocalsList
			lcName	  = This.aLocalsList(lnI, 1)
			lcKey	  = Upper(lcName)
			lcVarType = This.aLocalsList(lnI, 2)
			If ('P' $ lcType And 'para' $ lcVarType)		;
					Or ('L' $ lcType And Inlist(lcVarType, 'local', 'private', 'public'))
				If 0 = loResult.GetKey(lcKey)
					loResult.Add(lcName, lcKey)
				Endif
			Endif
		Endfor
		
		If '!' $ lcType
			For lnI = 1 To This.nNewLocalsCount
				lcName = This.aNewlocals(lnI, 1)
				If Ascan(This.aLocalsList, lcName, 1, -1, 1, 15) # 0
					Loop
				Endif
				lcKey  = Upper(lcName)
				If 0 = loResult.GetKey(lcKey)
					loResult.Add(lcName, lcKey)
				Endif
			Endfor
		Endif
		
		If '=' $ lcType
			For lnI = 1 To This.nNewLocalsCount
				lcName = This.aNewlocals(lnI, 1)
				lcKey  = Upper(lcName)
				If 0 = loResult.GetKey(lcKey) And This.aNewlocals(lnI, 8)
					loResult.Add(lcName, lcKey)
				Endif
			Endfor
		Endif
		
		Return loResult
		
	ENDPROC

	PROCEDURE getwindowhandle
		Set Library To (Home() + "FoxTools.fll") Additive
		Return _WonTop ()
		
	ENDPROC

	PROCEDURE getwordcountx		&& Do GetWordCount and check for CR in default search.
		LPARAMETERS;
		 tcString,;
		 tcDelimiters
		
		LOCAL;
		 lnReturn AS integer
		
		IF PCOUNT()=1 THEN
		*SF 2022/03/17
		*see https://github.com/VFPX/HelpFile/issues/17
		*This is Space+Tab+CR+LF
		 lnReturn = GETWORDCOUNT(m.tcString,0h20090D0A)
		ELSE  &&PCOUNT()=2
		 lnReturn = GETWORDCOUNT(m.tcString,m.tcDelimiters)
		ENDIF &&PCOUNT()=2
		
		
		RETURN m.lnReturn
		
	ENDPROC

	PROCEDURE getwordnumx		&& Do GetWordNum and remove trailing semicolon. Check for CR in default search.
		LPARAMETERS;
		 tcString,;
		 tnIndex,;
		 tcDelimiters
		
		LOCAL;
		 lcReturn AS CHARACTER
		
		IF PCOUNT()=2 THEN
		*SF 2022/03/17
		*see https://github.com/VFPX/HelpFile/issues/17
		* lcReturn = GETWORDNUM(m.tcString,m.tnIndex)
		*This is Space+Tab+CR+LF
		 lcReturn = GETWORDNUM(m.tcString,m.tnIndex,0h20090D0A)
		ELSE  &&PCOUNT()=2
		 lcReturn = GETWORDNUM(m.tcString,m.tnIndex,m.tcDelimiters)
		ENDIF &&PCOUNT()=2
		
		IF ';' $ m.lcReturn THEN
		 m.lcReturn = LEFT(m.lcReturn,AT(';',m.lcReturn,1)-1)
		ENDIF &&';' $ m.lcReturn 
		
		IF '&'+'&' $ m.lcReturn THEN
		 m.lcReturn = LEFT(m.lcReturn,AT('&'+'&',m.lcReturn,1)-1)
		ENDIF &&RIGHT(m.lcReturn,1)==';'
		
		RETURN m.lcReturn
		
	ENDPROC

	HIDDEN PROCEDURE Init
		Lparameters loUtils, loPrefs, loEditorWin, lcSystemMemoryVariables
		 
		Local lcDBF, lcPlugIn, loThor
		
		With This
			.oUtils					= loUtils
			.oPrefs					= loPrefs
			.oEditorWin				= loEditorWin
			.cSystemMemoryVariables	= lcSystemMemoryVariables
		Endwith
		
		If 'C' = Vartype (_Screen.cThorDispatcher)
			*!* * Removed 12/28/2012 / JRN
			*!* loThor			 = Execscript (_Screen.cThorDispatcher, 'Thor Engine=')
			*!* This.lAddMDots	 = Nvl(loThor.GetOption ('MDots in BeautifyX', 'MDots'), .F.)
			*!* This.nMDotsUsage = Nvl(loThor.GetOption ('MDots Usage', 'MDots'), 1)
			This.lAddMDots	 = This.GetThorOption('MDots in BeautifyX', 'MDots', .F.)
			This.nMDotsUsage = This.GetThorOption('MDots Usage', 'MDots', 1)
			This.lRETURNS    = This.GetThorOption('BeautifyX', 'RETURNs between WITH/ENDWITH', 1)
			This.lAddMDots	 = Not Empty(This.lAddMDots)
			This.lApplyCKL   = This.GetThorOption('ApplyCKL in BeautifyX', 'Apply Custom Keyword List to code window' , .F.)
			This.lAddtoCKL   = This.GetThorOption('AddtoCKL in BeautifyX', 'Add all words in code window' , .F.)
			This.lAutoAddtoCKL   = This.GetThorOption('AutoAddNewtoCKL in BeautifyX', 'Add all words in code window' , .F.)
		Endif
		
		If Not Used ('fdkeywrd')
			m.lcDBF = This.whereis ('FDKEYWRD.DBF')
			If Not File (m.lcDBF)
				Return .F.
			Endif
			Use (m.lcDBF) Order token Alias fdkeywrd In 0
		Endif
		
		lcPlugIn = This.oUtils.GetPlugInPath ('IsOperator')
		If Not Empty (lcPlugIn)
			This.cpluginisoperator = Filetostr (lcPlugIn)
		Endif
	ENDPROC

	PROCEDURE insertconstants
		Lparameters loConstants
		
		For each lcConstant in loConstants FoxObject
			This.InsertID(lcConstant, TYPE_Constants)
		EndFor 
		
	ENDPROC

	PROCEDURE insertid
		Lparameters lcWord, lnType
		
		Do Case
			Case Empty (lcWord)
		
			Case Left (lcWord, 1) $ ['^+(,0123456789)]
		
			Case lcWord = '&' And Not '.' $ lcWord
		
			Case lcWord = '.' And Isdigit (Substr (lcWord, 2, 1))
		
			Case Inlist (Upper (lcWord) + ' '		;
					  , '.T. ', '.F. ', '.OR. ', '.NOT. ', '.AND. ', '.NULL. ', '( ', '^ ')
		
				*Case This.IsKeyWord (Substr (lcWord, 1 + Rat ('.', lcWord)))
			Case This.IsKeyWord (lcWord)
		
			Otherwise
				Insert Into crsr_IDs_Refs Values (crsr_IDs_Procs.Id, crsr_IDs_Lines.Id, lcWord, lnType)
				Replace AnyFound With .T. In crsr_IDs_Lines
		
		Endcase
		
	ENDPROC

	PROCEDURE insertidothers
		Lparameters lcWord, lcNextWord
		
		Local llAssign, lnType
		
		llAssign = 0 # Ascan (This.aNewlocals, lcWord, 1, -1, 1, 15)
		Do Case
		
			Case lcNextWord = '('
				If '.' $ lcWord
					lnType = TYPE_Methods
				Else
					lnType = TYPE_Procedures
				Endif
		
			Case llAssign And Not '.' $ lcWord
				lnType = TYPE_Assignments
			Case llAssign
				lnType = TYPE_PropAssign
			Case '.' $ lcWord
				lnType = TYPE_Objects
			Case This.lFieldReference 
				lnType = TYPE_Fields
			Otherwise
				lnType = TYPE_Others
		Endcase
		
		If Upper (lcWord) = 'M.'
			lcWord = Substr (lcWord, 3)
			lnType = TYPE_Others
		Endif
		
		This.InsertID (lcWord, lnType)
		
	ENDPROC

	PROCEDURE insertlocalids
		Lparameters lcNewCode, lnType, lnStartWord
		
		Local lcWord2, lnI
		For lnI = lnStartWord To THIS.GetWordCountX (lcNewCode)
			lcWord2		= THIS.GetWordNumX (lcNewCode, lnI)
			If Upper (lcWord2) == 'AS' Or Upper (lcWord2) == 'OF'
				lnI = lnI + 1
			Endif
			This.InsertID (lcWord2, lnType)
		Endfor
		
	ENDPROC

	PROCEDURE iskeyword
		Lparameters lcWord
		
		Return Indexseek (Upper (lcWord) + ' ', .F., 'FDKEYWRD')
	ENDPROC

	PROCEDURE movelocalstotop
		Lparameters lnHandle, lnProcStart
		
		Local laLocals(1), laOthers(1)
		Local lcLine, lcNewCode, lcOldClipText, lcSourceLine, lcWord1, lnDestIndex, lnEndPosPos, lnI
		Local lnInsertLineNumber, lnLocalsCount, lnLoop, lnLoopNow, lnOthersCount, lnStartPos
		
		lnLocalsCount = 0
		lnOthersCount = 0
		
		lnInsertLineNumber = This.FindLocalsLineNumber (lnProcStart, .T.)
		
		* Find the existing local declarations
		For lnLoop = lnInsertLineNumber To Alen (This.aCodeLines)
			lnLoopNow = lnLoop
			lcSourceLine = This.GetSourceCodeLine (@lnLoop, , .T.)
		
			lcSourceLine = IIf (Lower (Left (lcSourceLine, 7)) == 'hidden ', Alltrim (Substr (lcSourceLine, 8)), lcSourceLine)
			lcSourceLine = IIf (Lower (Left (lcSourceLine, 10)) == 'protected ', Alltrim (Substr (lcSourceLine, 11)), lcSourceLine)
		
			lcWord1 = Lower (THIS.GetWordNumX (lcSourceLine,1))
		
			Do Case
				Case Len (lcWord1) >= 4 And 'local ' = lcWord1
					For lnI = lnLoopNow To lnLoop
						lnLocalsCount = lnLocalsCount + 1
						Dimension laLocals (lnLocalsCount)
						laLocals (lnLocalsCount) = This.aCodeLines (lnI)
					Endfor
		
				Case Len (lcWord1) >= 4 And (				;
						'procedure ' = lcWord1  			;
						or 'function ' = lcWord1  			;
						or 'endproc ' = lcWord1 			;
						Or 'endfunc ' = lcWord1)
					Exit
		
				Case Left (Lower (lcSourceLine), 13) == 'define class '
					Exit
		
				Otherwise
					For lnI = lnLoopNow To Min (lnLoop, Alen (This.aCodeLines)) 
						lnOthersCount = lnOthersCount + 1
						Dimension laOthers (lnOthersCount)
						laOthers (lnOthersCount) = This.aCodeLines (lnI)
					Endfor
		
			Endcase
		
		Endfor
		
		If lnLocalsCount = 0
			Return lnInsertLineNumber
		Endif
		
		lnDestIndex = lnInsertLineNumber
		lcNewCode = ''
		*!*	For lnI = 1 To lnLocalsCount
		*!*		lcLine = laLocals (lnI)
		*!*		This.aCodeLines (lnDestIndex) = lcLine
		*!*		lnDestIndex = lnDestIndex + 1
		*!*		lcNewCode = lcNewCode + lcLine + LINEEND
		*!*	Endfor
		
		For lnI = 1 To lnOthersCount
			lcLine = laOthers (lnI)
			This.aCodeLines (lnDestIndex) = lcLine
			lnDestIndex = lnDestIndex + 1
			lcNewCode = lcNewCode + lcLine + LINEEND
		Endfor
		
		lnStartPos = _EdGetLPos(lnHandle, lnInsertLineNumber - 1)
		lnEndPosPos = _EdGetLPos(lnHandle, lnLocalsCount + lnDestIndex - 1)
		_EdSelect (lnHandle, lnStartPos, lnEndPosPos)
		
		lcOldClipText = _Cliptext
		_Cliptext = lcNewCode
		_EdPaste (lnHandle)
		_Cliptext = lcOldClipText
		
		_EdSelect (lnHandle, lnStartPos, lnStartPos)
		_EdSetPos (lnHandle, lnStartPos)
		_EdStoPos (lnHandle, lnStartPos, .T.)
		
		Return lnInsertLineNumber
	ENDPROC

	PROCEDURE nativebeautify
		Lparameters lcSourceCode, llSkipIndentation
		
		This.SetBeautifyOptions()
		lcOptions = This.cBeautifyOptions 
		
		*** JRN 2010-05-09 : conditionally turn off indentation (for SELECT statements)
		If llSkipIndentation
			lcOptions = Stuff (lcOptions, 13, 1, Chr(0)) 
		EndIf 
		
		If "O" # Vartype (This.oBeautify)
			This.oNativeBeautify = peme_newsessionobject("cbeautify", "peme_beautifycode.vcx")
		EndIf 
		
		lcNewCode = lcSourceCode
		This.oNativeBeautify.Execute (@lcNewCode, lcOptions, 3, '')
		
		Return lcNewCode
		
	ENDPROC

	PROCEDURE parsecodeline
		* Parses a single code line into an array:
		*    Col 1 = Name
		*    Col 2 = Array Dimensions, if any
		*    Col 3 = AS phrase
		
		* All this tomfoolery because of confusion with commas:  they are separators between names
		* and also between dimensions of a name.
		* For example:
		* 	Dimension laResult[ALEN (laResult, 1) + 1], laTemp(3)
		
		Lparameters tcCodeLine, laResult, llAssignment
		
		#Define FILLER Chr(31)
		Local laExtras(1), lcArrayDims, lcChar, lcCode, lcMatchChar, lcName, lnDepth, lnExtraCounter, lnExtras, lnI
		Local lnMatchPos, lnPos
		
		lcCode = Chrtran (tcCodeLine, ';', ' ')
		lnExtras = 0
		
		Do While '(' $ lcCode Or '[' $ lcCode
			lnPos = Min (This.ATNew('(', lcCode), This.ATNew('[', lcCode))
			lcChar = Substr(lcCode, lnPos, 1)
			lcMatchChar = Iif (lcChar ='(', ')', ']')
			lnDepth = 1
			Do While .T.
				lnMatchPos = At (lcMatchChar, lcCode, lnDepth)
				lnMatchPos = Evl (lnMatchPos, 1 + Len (lcCode))
				If 0 = At (lcChar, Left (lcCode, lnMatchPos), lnDepth + 1)
					lnExtras = lnExtras + 1
					Dimension laExtras (lnExtras, 2)
					laExtras (lnExtras, 1) = Alltrim (Substr (Left (lcCode, lnMatchPos - 1), lnPos + 1))
					laExtras (lnExtras, 2) = Alltrim (Substr (Left (lcCode, lnMatchPos), lnPos))
					lcCode = Stuff (lcCode, lnPos, 1 + lnMatchPos - lnPos, FILLER)
					Exit
				Else
					lnDepth = lnDepth + 1
				Endif
			Enddo
		Enddo
		
		lnExtraCounter = 0
		For lnI = 1 To 1000
			lcName = Getwordnum (lcCode, lnI, ',')
			If Empty (lcName)
				Exit
			Endif
		
			Dimension laResult (lnI, 3)
		
			If ' as ' $ Lower (lcName)
				lnPos = At (' as ' , Lower (lcName))
				lcAsPhrase = Alltrim (Substr (lcName, lnPos + 4))
				lcName = Alltrim (Left (lcName, lnPos))
			Else
				lcAsPhrase = ''
			Endif
		
			If FILLER $ lcName
				lnExtraCounter = lnExtraCounter + 1
				lcArrayDims = laExtras [lnExtraCounter, 1]
				laResult (lnI, 1) = Strtran (lcName, FILLER, '')
				laResult (lnI, 2) = lcArrayDims
			Else
				laResult (lnI, 1) = lcName
				laResult (lnI, 2) = ''
			Endif
		
			If FILLER $ lcAsPhrase
				lnExtraCounter = lnExtraCounter + 1
				lcAsPhrase = laExtras [lnExtraCounter, 2]
			Endif
			laResult (lnI, 3) = lcAsPhrase
		Endfor
		
	ENDPROC

	PROCEDURE parselineforidlist
		* Parse a single line of code (that is, a line including continuation lines, with ; removed
		*      (1) WITH/ENDWITH ... replace names beginning with dot with the WITH that precedes them
		*      (2) Character constants are replaced with '^' (for historical reasons .. s.b. ')
		*      (3) All other none-name characters with '+'
		
		Lparameters lcSourceLine, lcNotNameChars
		
		Local lcNewCode, lcRestLineString, lcThisChar, lnCharPos, lnClosingCharPosition
		
		lcSourceLine = This.FixWithStatements (lcSourceLine)
		lcSourceLine = Strtran (lcSourceLine, '.*', ' ')
		
		lcNewCode = ''
		For lnCharPos = 1 To Len (lcSourceLine)
			lcThisChar = Substr (lcSourceLine, lnCharPos, 1)
			Do Case
				Case lcThisChar $ ' ' + TAB
					lcThisChar = ' '
				Case lcThisChar $ ['"{] Or		;
						(lcThisChar = '[' And Not This.IsNameChar (Right (This.TrimTrailingWhiteSpace (lcNewCode), 1)))
					lcRestLineString	  = Substr (lcSourceLine, lnCharPos + 1)
					lnClosingCharPosition = At (IIf (lcThisChar = '[', ']', IIf (lcThisChar = '{', '}', lcThisChar)), lcRestLineString)
					lnCharPos			  = lnCharPos + lnClosingCharPosition
					lcThisChar			  = [ ^ ]
				Case lcThisChar = ';'
					lcThisChar = ' '
				Case lcThisChar $ lcNotNameChars + '^'
					lcThisChar = ' + '
				Case lcThisChar $ '(),+'
					lcThisChar = ' ' + lcThisChar + ' '
			Endcase
			lcNewCode = lcNewCode + lcThisChar
		Endfor
		
		Return lcNewCode
	ENDPROC

	PROCEDURE parseprgcodeblocks
		Local lcClassName, lcName, lcSourceLine, lcWord1, lcWord2, lcWord3, lnCount, lnCounterNow, lnCurrentRow
		Local lnLineCount
		
		lnCurrentRow = 1
		Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
		This.aPRGCodeBlocks (lnCurrentRow, 1) = ''
		This.aPRGCodeBlocks (lnCurrentRow, 2) = 'P'
		This.aPRGCodeBlocks (lnCurrentRow, 3) = 1
		This.aPRGCodeBlocks (lnCurrentRow, 4) = 1
		
		lnLineCount	= Alen (This.aCodeLines)
		lcClassName	= ''
		
		For lnCount = 1 To lnLineCount
			lnCounterNow = lnCount
			lcSourceLine = This.GetSourceCodeLine (@lnCount)
			lcWord1 = Lower (THIS.GetWordNumX (lcSourceLine,1))
			lcWord2 = Lower (THIS.GetWordNumX (lcSourceLine,2))
			lcWord3 = Lower (THIS.GetWordNumX (lcSourceLine,3))
		
			Do Case
				Case Empty (lcSourceLine)
		
				Case Len (lcWord1) >= 4											;
						and ('procedure ' = lcWord1 Or 'function ' = lcWord1)
					If lnCounterNow > 1
						This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
						lnCurrentRow = lnCurrentRow + 1
						Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
					Endif
					lcName = THIS.GetWordNumX (lcSourceLine,2)
					If '(' $ lcName
						lcName = Left (lcName, At('(', lcName) - 1)
					Endif
					This.aPRGCodeBlocks (lnCurrentRow, 1) = lcClassName + lcName
					This.aPRGCodeBlocks (lnCurrentRow, 2) = Upper (Left (lcWord1,1))
					This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
					This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow
		
				Case Len (lcWord1) >= 4											;
						and ('protected ' = lcWord1 Or 'hidden ' = lcWord1)	;
						and Len (lcWord2) >= 4 									;
						and ('procedure ' = lcWord2 Or 'function ' = lcWord2)
					If lnCounterNow > 1
						This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
						lnCurrentRow = lnCurrentRow + 1
						Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
					Endif
					lcName = THIS.GetWordNumX (lcSourceLine,3)
					If '(' $ lcName
						lcName = Left (lcName, At('(', lcName) - 1)
					Endif
					This.aPRGCodeBlocks (lnCurrentRow, 1) = lcClassName + lcName
					This.aPRGCodeBlocks (lnCurrentRow, 2) = Upper (Left (lcWord2,1))
					This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
					This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow
		
				Case Len (lcWord1) >= 4											;
						and ('define ' = lcWord1)	;
						and Len (lcWord2) >= 4 									;
						and ('class ' = lcWord2)
					If lnCounterNow > 1
						This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow - 1
						lnCurrentRow = lnCurrentRow + 1
						Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
					Endif
					This.aPRGCodeBlocks (lnCurrentRow, 1) = THIS.GetWordNumX (lcSourceLine,3)
					This.aPRGCodeBlocks (lnCurrentRow, 2) = 'C'
					This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow
					This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow
					lcClassName	= This.aPRGCodeBlocks (lnCurrentRow, 1) + '.'
		
				Case Len (lcWord1) >= 4											;
						and ('enddefine ' = lcWord1   ;
						or 'endproc ' = lcWord1   ;
						or 'endfunc ' = lcWord1   ;
						)
					If lnCounterNow > 1
						This.aPRGCodeBlocks(lnCurrentRow, 4) = lnCounterNow
						lnCurrentRow = lnCurrentRow + 1
						Dimension This.aPRGCodeBlocks (lnCurrentRow, 4)
					Endif
					This.aPRGCodeBlocks (lnCurrentRow, 1) = ''
					This.aPRGCodeBlocks (lnCurrentRow, 2) = ' '
					This.aPRGCodeBlocks (lnCurrentRow, 3) = lnCounterNow + 1
					This.aPRGCodeBlocks (lnCurrentRow, 4) = lnCounterNow + 1
					If 'enddefine ' = lcWord1
						lcClassName	= ''
					EndIf 
		
			Endcase
		Endfor
		
		This.aPRGCodeBlocks (lnCurrentRow, 4) = lnLineCount
		
	ENDPROC

	PROCEDURE peme_beautify
		Local laEnv[25]
		Local lcCodeSource, lcIndent, lcNewCode, lcOldClipText, lcPrompt, llAnyOptions, llLocalsAllProcs
		Local llSelectedText, lnCurrentLine, lnHandle, lnOriginalCursor, lnResult, lnSelEnd, lnSelStart
		Local lnThisLine
		
		With This.oPrefs
			llAnyOptions = .lSettingsChanged	;
				or .lNativeBeautify 			;
				or .lBeautifyLocals 			;
				or .lFixAssignments				;
				or .lAlignSemicolons			;
				or .nSelectIndentation = 3 		;
				or .nParenIndent       # 2 		;
				or .nBeforeLeftParens  # 1		;
				or .nStringDelimiters  # 1		;
				or .nDefinitionForNOT  # 1		;
				or .nDefinitionForNOTEQUAL # 1
		Endwith
		
		If Not llAnyOptions
			Text to lcPrompt NoShow
		BeautifyX has not been activated yet. By default, none of its settings are activated.
		
		Do you want to be taken to the settings form?
			EndText
			If MESSAGEBOX(lcPrompt, 68, "BeautifyX not activated.", 0) = 6
				ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_OpenOptionsPage', 'BeautifyX')
			EndIf
			Return
		Endif
		
		* Get the whandle for the current window
		lnHandle = This.GetWindowHandle()
		lnResult = _EdGetEnv (lnHandle, @laEnv )
		If (lnResult = 0 Or laEnv[25] = 0)
			Return ''
		Endif
		
		* Get the current cursor position
		lcOldClipText = _Cliptext
		
		This.SetBeautifyOptions()
		
		lnSelStart		 = laEnv[17]
		lnSelEnd		 = laEnv[18]
		lnOriginalCursor = laEnv[17]
		lnCurrentLine	 = _EdGetLNum (lnHandle, lnSelStart)
		This.nTabWidth	 = laEnv[21]
		If lnSelStart = lnSelEnd && if nothing highlighted, select all
			_EdSelect (lnHandle, 0, 1000000)
			lnResult   = _EdGetEnv (lnHandle, @laEnv )
			lnSelStart = laEnv[17]
			lnSelEnd   = laEnv[18]
			llLocalsAllProcs = This.oPrefs.lLocalsAllProcs
			llSelectedText = .F.
		Else
			llLocalsAllProcs = .T.
			llSelectedText = .T.
		Endif
		
		lcCodeSource = _EdGetStr (lnHandle, lnSelStart, lnSelEnd - 1)
		lcIndent = This.GetIndentation(lcCodeSource)
		
		****************************************************************
		****************************************************************
		
		*!*	<pdm>
		*!*	<change date="{^2023-10-25,13:40:00}">Changed by: alemrcc<br />
		*!*	In some installations the value of This.oPrefs.lBeautifyLocals is initialised to 1.00 or 0.00
		*!*	</change>
		*!*	</pdm>
		lBeautifyLocals = IIF(VARTYPE(This.oPrefs.lBeautifyLocals)='N', CAST(This.oPrefs.lBeautifyLocals AS Logical), This.oPrefs.lBeautifyLocals)
		If lBeautifyLocals
		*!*	/Changed by: alemrcc 25.10.2023
			lcCodeSource = This.CreateLocalsForCodeBlock(lcCodeSource, laEnv[25], lnCurrentLine, llLocalsAllProcs)
		Endif
		
		lcNewCode = This.BeautifyCodeBlock (lcCodeSource)
		
		If llSelectedText
			If Len(lcIndent) # 0
				lcNewCode = Iif(lcNewCode # lcIndent, lcIndent, ' ') + Strtran(lcNewCode, LINEEND, LINEEND + lcIndent, 1, 1000, 3)
			Endif
		Endif
		
		*SF 2020/10/29 RIGHT(..,1) will never be LINEEND, because LINEEND is CRLF ...
		If Right (lcCodeSource, 2) $ LINEEND
			lcNewCode = lcNewCode + LINEEND
		Endif
		 
		****************************************************************
		****************************************************************
		
		_Cliptext = lcNewCode
		_EdPaste (lnHandle)
		
		If this.lRETURNS 
			_WSelect(lnHandle)
			If ExecScript(_screen.Cthordispatcher, 'Thor_Proc_CheckWindowForReturns', 2) && prompt if any found
				_Cliptext = lcOldClipText
				Return
			EndIf 
		EndIf 
		
		* Try to go back to where we started
		lnThisLine = _EdGetLPos (lnHandle, lnCurrentLine)
		_EdSelect (lnHandle, lnThisLine, lnThisLine)
		_EdSetPos (lnHandle, lnThisLine)
		_EdStoPos (lnHandle, lnThisLine, .T.)
		
		_Cliptext = lcOldClipText
		
		
	ENDPROC

	PROCEDURE peme_createidlist
		Lparameters llAllText
		
		Local loFormIDList As 'FrmIDList' Of  'Source\EditProperty.VCX'
		Local lcCodeSource, lcInclude, lcName, lcPRGTitle, lcType, lnBlocks, lnEnd, lnEndByte, lnI, lnLines
		Local lnStart, lnStartByte, lnStartLine, loProcs
		
		lcCodeSource = This.GetEditorWindowText(llAllText)
		
		If Empty (lcCodeSource)
			Return .F.
		Endif
		
		This.CreateIDListCursors()
		This.GetConstants (lcCodeSource)
		
		* for a single method
		If This.oEditorWin.GetEnvironment(25) = 10
		
			Alines (This.aCodeLines, lcCodeSource)
			Insert Into crsr_IDs_Procs (StartLine) Values (1)
			This.CreateIDList ('', 1, Alen (This.aCodeLines))
			lcInclude	 = This.oUtils.GetCurrentIncludeFile()
			If File (lcInclude)
				This.GetConstants (Filetostr (lcInclude), lcInclude)
			Endif
		
		Else
		
			* or a PRG with no embedded PROCs or FUNCs
			loProcs	   = This.oUtils.GetProcedureStartPositions (lcCodeSource)
		
			If 0 = loProcs.Count
		
				Alines (This.aCodeLines, lcCodeSource)
				Insert Into crsr_IDs_Procs (StartLine) Values (1)
				This.CreateIDList ('', 1, Alen (This.aCodeLines))
		
			Else
		
				lnStartLine = 1
				* for a PRG with PROCs and FUNCs
				For lnI = 0 To loProcs.Count
					Do Case
						Case lnI = 0
							lnStartByte	= 0
							lnEndByte	= loProcs(1).StartByte
							If lnEndByte = 0
								Loop
							Endif
							lcName = This.oEditorWin.GetTitle()
							lcType = 'Procedure'
						Case lnI < loProcs.Count
							lcName		= loProcs (lnI).Name
							lnStartByte	= loProcs (lnI).StartByte
							lnEndByte	= loProcs (lnI + 1).StartByte
							lcType		= loProcs (lnI).Type
						Otherwise
							lcName		= loProcs (lnI).Name
							lnStartByte	= loProcs (lnI).StartByte
							lnEndByte	= This.oEditorWin.GetEnvironment(2)
							lcType		= loProcs (lnI).Type
					Endcase
		
					lnLines = Alines (This.aCodeLines, Substr (lcCodeSource, lnStartByte + 1, lnEndByte - lnStartByte)) 
					If Inlist (lcType, 'Procedure', 'Method')
						Insert Into crsr_IDs_Procs (ProcName, StartLine) Values (lcName, lnStartLine)
						This.CreateIDList (lcName, 1, lnLines)
					Endif
					lnStartLine = lnStartLine + lnLines
				Endfor
		
			Endif
		
		Endif
		
		This.DoFormIDList (This.oEditorWin.nHandle)
		
	ENDPROC

	PROCEDURE peme_createlocals
		Local laEnv[25]
		Local lcCodeSource, lcIndent, lcNewCode, lcOldClipText, llLocalsAllProcs, llSelectedText, lnCurrentLine
		Local lnHandle, lnOriginalCursor, lnResult, lnSelEnd, lnSelStart, lnThisLine
		
		* Get the whandle for the current window
		lnHandle = This.GetWindowHandle()
		lnResult = _EdGetEnv (lnHandle, @laEnv )
		If (lnResult = 0 Or laEnv[25] = 0)
			Return ''
		Endif
		
		* Get the current cursor position
		lcOldClipText = _Cliptext
		
		This.SetBeautifyOptions()
		
		lnSelStart		 = laEnv[17]
		lnSelEnd		 = laEnv[18]
		lnOriginalCursor = laEnv[17]
		lnCurrentLine	 = _EdGetLNum (lnHandle, lnSelStart)
		This.nTabWidth	 = laEnv[21]
		If lnSelStart = lnSelEnd && if nothing highlighted, select all
			_EdSelect (lnHandle, 0, 1000000)
			lnResult   = _EdGetEnv (lnHandle, @laEnv )
			lnSelStart = laEnv[17]
			lnSelEnd   = laEnv[18]
			llLocalsAllProcs = This.oPrefs.lLocalsAllProcs
			llSelectedText = .F.
		Else
			llLocalsAllProcs = .T.
			llSelectedText = .T.
		Endif
		
		lcCodeSource = _EdGetStr (lnHandle, lnSelStart, lnSelEnd - 1)
		
		****************************************************************
		****************************************************************
		
		lcNewCode = This.CreateLocalsForCodeBlock(lcCodeSource, laEnv[25], lnCurrentLine, llLocalsAllProcs)
		
		If llSelectedText
			lcIndent = This.GetIndentation(lcCodeSource)
			If Len(lcIndent) # 0
				lcNewCode = Iif(lcNewCode # lcIndent, lcIndent, ' ') + Strtran(lcNewCode, LINEEND + 'L', LINEEND + lcIndent + 'L', 1, 1000, 3)
			Endif
		Endif
		
		****************************************************************
		****************************************************************
		
		_Cliptext = lcNewCode
		_EdPaste (lnHandle)
		
		* Try to go back to where we started
		lnThisLine = _EdGetLPos (lnHandle, lnCurrentLine)
		_EdSelect (lnHandle, lnThisLine, lnThisLine)
		_EdSetPos (lnHandle, lnThisLine)
		_EdStoPos (lnHandle, lnThisLine, .T.)
		
		_Cliptext = lcOldClipText
		
	ENDPROC

	PROCEDURE peme_createobjectidlist
		Lparameters loObject, llRecursive, lcSourceFileName, lcClassName
		Local lcIncludeFile
		
		With This
			.CreateIDListCursors()
		
			lcIncludeFile = This.oUtils.GetCurrentIncludeFile()
			If Not Empty (lcIncludeFile)
				.GetConstants (Filetostr (lcIncludeFile), lcIncludeFile)
			Endif
		
			.AddObjectIDList (loObject, llRecursive)
		
		Endwith
		
		If Lower (loObject.BaseClass) == 'form'
			Select  Distinct Id							;
				From crsr_IDs_Procs						;
				Where 1 = Occurs ('.', ProcName)		;
				Into Cursor crsr_ThisForm_IDs
			Index on ID tag ID 
		
			Select crsr_IDs_Refs
			Set Relation To ProcID Into crsr_ThisForm_IDs
		
			Replace	Name  With	'Thisform.' + Substr (Name, 6)		;
				For Found ('crsr_ThisForm_IDs')						;
					And Upper (Left (Name, 5)) == 'THIS.'
		
		Endif
		
		This.DoFormIDList(0, lcSourceFileName, lcClassName)
		
	ENDPROC

	PROCEDURE regexpsearch
		Lparameters tcPattern, tcText
		This.oRegExp.Pattern = tcPattern
		Return This.oRegExp.Execute (tcText)
		
		
	ENDPROC

	PROCEDURE removeparens
		Lparameters lcText
		
		Local lcThisChar, lnEndPos, lnStartPos 
		lcText = Chrtran(lcText, '()', '[]')
		Do While .T.
			lnStartPos = Min (This.AtNew(['], lcText), This.AtNew(["], lcText), This.AtNew(']', lcText))
			If lnStartPos > Len(lcText)
				Return lcText
			Endif
		
			lcThisChar = Substr (lcText, lnStartPos, 1)
			If lcThisChar $ ['"]
				lnEndPos = This.AtNew(lcThisChar, lcText, 2)
				lcText	 = Left (lcText, lnStartPos - 1) + ' ' + Substr (lcText, lnEndPos + 1)
			Else
				lnEndPos   = lnStartPos
				lnStartPos = Rat('[', Left(lcText, lnEndPos))
				lcText	   = Left (lcText, lnStartPos - 1) + '( ' + Substr (lcText, lnEndPos + 1)
			Endif
		Enddo && While .T.
	ENDPROC

	PROCEDURE setbeautifyoptions
		*    Options:
		*        1 = Variable case - 4 = no change, 3 = use 1st
		*        2 = command Case - 3 = mixed, 2 = lower, 1 = upper
		*        3 = number of spaces if option 4 (below) is 2
		*        4 = tabs/spaces, 						1 - use tabs, 2 - use spaces, 3 = no change
		*        5 =  ??
		*        6 = comments - 						1 = include comments, 0 = no
		*        7 = Line continuation 					1 = include, 0 = no
		*        8 = Extra indent beneath procedures 	1 = yes, 0 = no
		*        9 = Extra indent beneath Do Case 		1 = yes, 0 = no
		
		Local lcOptions, lnI, lnSelect
		
		lnSelect = Select()
		Select 0
		
		lcOptions =								 ;
			Chr(3) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(3) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(4) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(1) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(1) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(0) + Chr(0) + Chr(0) + Chr(0) +	 ;
			Chr(0) + Chr(0) + Chr(0) + Chr(0)
		
		If Set ('Resource') = 'ON'
			Use (Set ('Resource', 1)) Again Shared Alias Resource
			Locate For Id = 'BEAUTIFY'
			If Found()
				lcOptions = Right (Data, 36)
			Endif
			Use
		Endif
		
		For lnI = 1 To 9
			This.nBeautifyOptions (lnI) = Asc (Substr (lcOptions, (4 * lnI) - 3, 1))
		Endfor
		
		Select (lnSelect)
		
		This.cBeautifyOptions = lcOptions
		
	ENDPROC

	PROCEDURE whereis
		Lparameters mfile
		Local mtemp
		
		If File (m.mfile)
			Return m.mfile
		Endif
		
		mtemp = 'fd3fll\' + m.mfile
		If File (m.mtemp)
			Return m.mtemp
		Endif
		
		mtemp = Sys(2004) + m.mfile
		If File (m.mtemp)
			Return m.mtemp
		Endif
		
		mtemp = Sys(2004) + 'wizards\' + m.mfile
		If File (m.mtemp)
			Return m.mtemp
		Endif
		
		Return ''
		
	ENDPROC

ENDDEFINE
