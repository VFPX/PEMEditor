*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="peme_utils.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pemeditor_utils AS basecustom OF "peme_basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "editpropertydialog.h"
	*<DefinedPropArrayMethod>
		*m: aboutpemeditor
		*m: addcontrol
		*m: addtockl
		*m: addtomemberdata
		*m: autorename
		*m: autorenamecontrol
		*m: autorenamecontrols
		*m: avoidbufferoverrun
		*m: changeparentclass
		*m: cleartempfileslist
		*m: clickoncontainer
		*m: clickoncontrol
		*m: closeforms
		*m: closesearchresults
		*m: compareclass
		*m: compareproperties
		*m: containerclick
		*m: convertcursortoxml
		*m: copyproperties
		*m: copypropertiestoarray
		*m: creatememberscursor
		*m: createnewpem
		*m: createobjectidlist
		*m: createpemlist
		*m: createsortedobjectarray
		*m: createtempfileslist
		*m: createthortools
		*m: dochangeparentclass
		*m: dofindobjects
		*m: doformmodifyfile
		*m: dontdisablepemeditor
		*m: dopasteproperties
		*m: editlocalmethodcode
		*m: editparentclasses
		*m: editpreferences
		*m: exportchildmethodcode
		*m: exportmethodcode
		*m: extractpropertyvalue
		*m: find
		*m: findobjects
		*m: findtopmostparent
		*m: focusoncontrol
		*m: fullobjectnametoclipboard
		*m: getaccessmethodcode
		*m: getallcode
		*m: getallinheritedcode
		*m: getclass
		*m: getclassfilename
		*m: getclassfolders
		*m: getclassfromprg
		*m: getclassfromvcx
		*m: getclasslist
		*m: getcodeorvalue
		*m: getcontrolstructurepattern
		*m: getcontrolstructurepositions
		*m: getcurrentincludefile
		*m: getcurrentobject
		*m: getdefaultvalue
		*m: getincludefiles		&& Returns list of include files
		*m: getinheritedcode
		*m: getinheritedvalue
		*m: getmywindowname
		*m: getnewmethodheader
		*m: getobjectparentclasses
		*m: getobjectpath
		*m: getoneselectedobject
		*m: getparentobjects
		*m: getpemvalue
		*m: getprocedurestartpositions
		*m: getregexp
		*m: getresourcefile
		*m: getstructurepositionobject
		*m: getthis
		*m: gogetparentobjectclasses
		*m: gotodefthis
		*m: idetoolshelp
		*m: isnumber
		*m: isreadonly
		*m: justpem
		*m: movecontrolsincontainer
		*m: opensearchresults
		*m: opentables		&& Programmatically opens the tables and views associated with the data environment.
		*m: open_vfp_keywords
		*m: parsesearchfor
		*m: pasteobject
		*m: pasteproperties
		*m: peme_findtopmostparent
		*m: refreshform
		*m: refreshforms
		*m: registerwiththor
		*m: restorecontrolsincontainer
		*m: restoremywindowname
		*m: selectcompareclass
		*m: selectpastedproperties
		*m: setcurrentselectedobject
		*m: setfocustocontrol
		*m: setonkeylabel
		*m: setrefreshtimer
		*m: setupforparentobjectclasses
		*m: setwindowtitle
		*m: showform
		*m: simplesetfocus
		*m: str2val
		*m: thiscontroldeletable
		*m: timestamptodate
		*m: viewhtmltempfile
		*m: viewparentcode
		*m: viewtempfile
		*m: viewtempfiletext
		*m: writememberdata
		*p: capplication
		*p: capplicationpath
		*p: coriginalcaption
		*p: cpluginpath
		*p: csearchfor
		*p: csnippetpath
		*p: csourcefilename
		*p: csourcepath
		*p: lclass
		*p: lresetprevnexthistory
		*p: nfoundobjects
		*p: nindex
		*p: obeautifyx
		*p: odoctreeview
		*p: odynamicsnippet
		*p: oeditorwin
		*p: oformat
		*p: oformatmenu
		*p: ofoxref
		*p: oidex
		*p: opemeditor
		*p: oprefs
		*p: osearchresults
		*p: oserver
		*p: oundo
		*a: ahandlehistory[1,0]
		*a: aproclines[1,0]
	*</DefinedPropArrayMethod>

	HIDDEN Height,HelpContextID,Init
	*<PropValue>
		capplication = .F.
		capplicationpath = 
		coriginalcaption = .F.
		cpluginpath = .F.
		csearchfor = .F.
		csnippetpath = 
		csourcefilename = 
		csourcepath = 
		lclass = .F.
		lreleaseondestroy = .T.
		lresetprevnexthistory = .T.
		Name = "pemeditor_utils"
		nfoundobjects = .F.
		nindex = 0
		obeautifyx = .NULL.
		odoctreeview = .NULL.
		odynamicsnippet = .NULL.
		oeditorwin = .NULL.
		oformat = .F.
		oformatmenu = .NULL.
		ofoxref = .NULL.
		oidex = .NULL.
		opemeditor = .NULL.
		oprefs = .NULL.
		osearchresults = .NULL.
		oserver = .NULL.
		oundo = .NULL.
		_memberdata = <VFPData>
			<memberdata name="capplicationpath" display="cApplicationPath"/>
			<memberdata name="csourcepath" display="cSourcePath"/>
			<memberdata name="csnippetpath" display="cSnippetPath"/>
			<memberdata name="opemeditor" display="oPEMEditor"/>
			<memberdata name="odoctreeview" display="oDocTreeview"/>
			<memberdata name="oidex" display="oIDEx"/>
			<memberdata name="odynamicsnippet" display="oDynamicSnippet"/>
			<memberdata name="oeditorwin" display="oEditorWin"/>
			<memberdata name="oserver" display="oServer"/>
			<memberdata name="obeautifyx" display="oBeautifyX"/>
			<memberdata name="showform" display="ShowForm"/>
			<memberdata name="aboutpemeditor" display="AboutPEMEditor"/>
			<memberdata name="addmrufile" display="AddMRUFile"/>
			<memberdata name="editpreferences" display="EditPreferences"/>
			<memberdata name="showhelp" display="ShowHelp"/>
			<memberdata name="oprefs" display="oPrefs"/>
			<memberdata name="cpluginpath" display="cPluginPath"/>
			<memberdata name="capplication" display="cApplication"/>
			<memberdata name="getmrulist" display="GetMRUList"/>
			<memberdata name="diskfilename" display="DiskFileName"/>
			<memberdata name="getrelativepath" display="GetRelativePath"/>
			<memberdata name="showerrormsg" display="ShowErrorMsg"/>
			<memberdata name="setrefreshtimer" display="SetRefreshTimer"/>
			<memberdata name="doformmodifyfile" display="DoFormModifyFile"/>
			<memberdata name="findtopmostparent" display="FindTopMostParent"/>
			<memberdata name="csourcefilename" display="cSourceFileName"/>
			<memberdata name="lclass" display="lClass"/>
			<memberdata name="striptabs" display="StripTabs"/>
			<memberdata name="aproclines" display="aProcLines"/>
			<memberdata name="isnamechar" display="IsNameChar"/>
			<memberdata name="getcontrolcount" display="GetControlCount"/>
			<memberdata name="getnewmethodheader" display="GetNewMethodHeader"/>
			<memberdata name="getpemstatus" display="GetPEMStatus"/>
			<memberdata name="createnewpem" display="CreateNewPEM"/>
			<memberdata name="refreshform" display="RefreshForm"/>
			<memberdata name="editlocalmethodcode" display="EditLocalMethodCode"/>
			<memberdata name="getdefaultvalue" display="GetDefaultValue"/>
			<memberdata name="cleartempfileslist" display="ClearTempFilesList"/>
			<memberdata name="createtempfileslist" display="CreateTempFilesList"/>
			<memberdata name="viewtempfile" display="ViewTempFile"/>
			<memberdata name="viewtempfiletext" display="ViewTempFileText"/>
			<memberdata name="openurl" display="OpenURL"/>
			<memberdata name="viewhtmltempfile" display="ViewHTMLTempFile"/>
			<memberdata name="setwindowtitle" display="SetWindowTitle"/>
			<memberdata name="ahandlehistory" display="aHandleHistory"/>
			<memberdata name="lresetprevnexthistory" display="lResetPrevNextHistory"/>
			<memberdata name="setonkeylabel" display="SetOnKeyLabel"/>
			<memberdata name="getpluginpath" display="GetPlugInPath"/>
			<memberdata name="getobjectpath" display="GetObjectPath"/>
			<memberdata name="peme_findtopmostparent" display="PEME_FindTopmostParent"/>
			<memberdata name="convertcursortoxml" display="ConvertCursorToXML"/>
			<memberdata name="getregexp" display="GetRegExp"/>
			<memberdata name="getincludefiles" display="GetIncludeFiles"/>
			<memberdata name="getcurrentincludefile" display="GetCurrentIncludeFile"/>
			<memberdata name="ofoxref" display="oFoxRef"/>
			<memberdata name="oformatmenu" display="oFormatMenu"/>
			<memberdata name="closeforms" display="CloseForms"/>
			<memberdata name="dofindobjects" display="DoFindObjects"/>
			<memberdata name="findobjects" display="FindObjects"/>
			<memberdata name="createsortedobjectarray" display="CreateSortedObjectArray"/>
			<memberdata name="oundo" display="oUndo"/>
			<memberdata name="extractpropertyvalue" display="ExtractPropertyValue"/>
			<memberdata name="getcodeorvalue" display="GetCodeOrValue"/>
			<memberdata name="getclassfilename" display="GetClassFileName"/>
			<memberdata name="setupforparentobjectclasses" display="SetupForParentObjectClasses"/>
			<memberdata name="getobjectparentclasses" display="GetObjectParentClasses"/>
			<memberdata name="isreadonly" display="IsReadOnly"/>
			<memberdata name="opensearchresults" display="OpenSearchResults"/>
			<memberdata name="parsesearchfor" display="ParseSearchFor"/>
			<memberdata name="closesearchresults" display="CloseSearchResults"/>
			<memberdata name="find" display="Find"/>
			<memberdata name="createobjectidlist" display="CreateObjectIDList"/>
			<memberdata name="createpemlist" display="CreatePEMList"/>
			<memberdata name="avoidbufferoverrun" display="AvoidBufferOverrun"/>
			<memberdata name="creatememberscursor" display="CreateMembersCursor"/>
			<memberdata name="getoneselectedobject" display="GetOneSelectedObject"/>
			<memberdata name="copyproperties" display="CopyProperties"/>
			<memberdata name="isnumber" display="IsNumber"/>
			<memberdata name="open_vfp_keywords" display="Open_VFP_Keywords"/>
			<memberdata name="fullobjectnametoclipboard" display="FullObjectNameToClipBoard"/>
			<memberdata name="compareproperties" display="CompareProperties"/>
			<memberdata name="dontdisablepemeditor" display="DontDisablePEMEditor"/>
			<memberdata name="getpemvalue" display="GetPEMValue"/>
			<memberdata name="selectpastedproperties" display="SelectPastedProperties"/>
			<memberdata name="pasteproperties" display="PasteProperties"/>
			<memberdata name="justpem" display="JustPEM"/>
			<memberdata name="getinheritedcode" display="GetInheritedCode"/>
			<memberdata name="getinheritedvalue" display="GetInheritedValue"/>
			<memberdata name="opentables" display="OpenTables"/>
			<memberdata name="nindex" display="nIndex"/>
			<memberdata name="addcontrol" display="AddControl"/>
			<memberdata name="writememberdata" display="WriteMemberData"/>
			<memberdata name="changeparentclass" display="ChangeParentClass"/>
			<memberdata name="clickoncontainer" display="ClickOnContainer"/>
			<memberdata name="clickoncontrol" display="ClickOnControl"/>
			<memberdata name="compareclass" display="CompareClass"/>
			<memberdata name="copypropertiestoarray" display="CopyPropertiesToArray"/>
			<memberdata name="dochangeparentclass" display="DoChangeParentClass"/>
			<memberdata name="dopasteproperties" display="DoPasteProperties"/>
			<memberdata name="editparentclasses" display="EditParentClasses"/>
			<memberdata name="focusoncontrol" display="FocusOnControl"/>
			<memberdata name="getparentobjects" display="GetParentObjects"/>
			<memberdata name="setcurrentselectedobject" display="SetCurrentSelectedObject"/>
			<memberdata name="selectcompareclass" display="SelectCompareClass"/>
			<memberdata name="restoremywindowname" display="RestoreMyWindowName"/>
			<memberdata name="pasteobject" display="PasteObject"/>
			<memberdata name="getresourcefile" display="GetResourceFile"/>
			<memberdata name="getmywindowname" display="GetMyWindowName"/>
			<memberdata name="thiscontroldeletable" display="ThisControlDeletable"/>
			<memberdata name="autorename" display="AutoRename"/>
			<memberdata name="getthis" display="GetThis"/>
			<memberdata name="gotodefthis" display="GoToDefThis"/>
			<memberdata name="getcurrentobject" display="GetCurrentObject"/>
			<memberdata name="idetoolshelp" display="IDEToolsHelp"/>
			<memberdata name="simplesetfocus" display="SimpleSetFocus"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE aboutpemeditor
		Do Form 'About_PEM_Editor' With This.oPrefs.cVersion
		
	ENDPROC

	PROCEDURE addcontrol
		Local loClassInfo AS Object
		Local loDestObject AS Object
		Local loException AS Object
		Local loSourceObject AS Object
		Local lbCancel, lbFailed, lcClass, lcClassLib, lcName, lcTempName1
		
		loSourceObject = This.GetOneSelectedObject()
		If 'O' # Vartype (loSourceObject)
			MessageBox(ccLOC_SingleObject)
			Return
		Endif
		
		If Not Inlist (Lower (loSourceObject.BaseClass) + ' ', 'form', 'container', 'page ', 'column')
			MessageBox('Unable to add objects to this object')
			Return
		Endif
		
		With This
			.DontDisablePEMEditor (.T.)
		
			loClassInfo = This.GetClass()
			If 'O' = Vartype(loClassInfo)
				lbCancel   = .F.
				lcClassLib = loClassInfo.ClassLib
				lcClass	   = loClassInfo.Class
			Else
				lbCancel = .T.
			Endif
		
			.DontDisablePEMEditor (.F.)
		Endwith
		
		If lbCancel
			Return
		Endif
		
		lcName 		= Lower(lcClass)
		lcTempName1	= lcName + '_New' + Sys(2015)
		lbFailed	= .F.
		
		*** JRN 10/16/2010 : at SW Fox
		Try
			loSourceObject.Newobject (lcTempName1, lcClass, lcClassLib)
			loDestObject = loSourceObject.&lcTempName1
		Catch To loException
			This.ShowErrorMsg (loException)
			lbFailed = .T.
		Endtry
		
		If Not lbFailed
			This.FocusOnControl (loDestObject)
			This.SetCurrentSelectedObject (loDestObject)
		Endif
	ENDPROC

	PROCEDURE addtockl
		Lparameters lcName
		
		Local loAddWordstoCKL
		
		If This.oPrefs.lAddNewPEMStoCKL and lcName # Lower(lcName) 
			loAddWordstoCKL = Execscript(_Screen.cThorDispatcher, 'Class= clsAddWordstoCKL from Thor_Proc_AddWordsToCKL.PRG')
		
			m.loAddWordstoCKL.ProcessText(m.lcName, .F., .T.)
			m.loAddWordstoCKL.PostProcessing(.F., .T.)
		Endif
		
		
	ENDPROC

	PROCEDURE addtomemberdata
		Lparameters toTopOfForm, lcMixedName
		
		Local  ;
			loDestNode AS Object	,;
			loDestXML AS ccXML_DOM_CLASS	,;
			loRoot AS Objectbject
		Local lcLowerName
		
		lcLowerName = Lower(lcMixedName)
		If lcLowerName == lcMixedName
			Return
		Endif
		
		loDestXML		= Createobject (ccXML_DOM_CLASS)
		loDestXML.Async	= .F.
		
		loTopOfForm = This.FindTopMostParent()
		If This.GetPEMStatus (loTopOfForm, '_MemberData', 5)				;
				And This.GetPEMStatus (loTopOfForm, '_MemberData', 0)		;
				And Not Empty (loTopOfForm._MemberData)
			loDestXML.LoadXML (loTopOfForm._MemberData)
		Else
			loDestXML.LoadXML ('')
		Endif
		
		loDestNode = loDestXML.selectSingleNode ('//memberdata[@name = "' + lcLowerName + '"]')
		
		If Vartype (loDestNode) # 'O'
			loDestNode = loDestXML.createElement (ccMEMBER_DATA_XML_ELEMENT)
			loDestNode.setAttribute ('name', lcLowerName)
			* Get the root node of the MemberData XML. If it doesn't exist, create it.
			loRoot = loDestXML.selectSingleNode ('/' + ccXML_ROOT_NODE)
			If Vartype (loRoot) # 'O'
				loRoot = loDestXML.createElement (ccXML_ROOT_NODE)
				loDestXML.appendChild (loRoot)
			Endif Vartype (loRoot) # 'O'
			* Add the new node to the root.
			loRoot.appendChild (loDestNode)
		Endif Vartype (loDestNode) # 'O'
		loDestNode.setAttribute ('display', lcMixedName )
		
		This.WriteMemberData (loDestXML)
		
		
	ENDPROC

	PROCEDURE autorename
		Lparameters tlChangeChildren
		
		* Auto rename objects, and possibly their children
		
		Local laObjects[1], lnI, lnInput, lnNotChanged, loObject
		
		If 0 = Aselobj (laObjects) And 0 = ASelObj (laObjects, 1)
			Return
		EndIf
		
		If 1 = Alen (laObjects)
			loObject = This.GetOneSelectedObject()
			If 'O' # Vartype (loObject)
				Messagebox (ccLOC_SingleObject)
				Return
			Endif
			Dimension laObjects(1)
			laObjects(1) = loObject
		Endif
		
		lnNotChanged = 0
		For lnI = 1 To Alen (laObjects)
			lnNotChanged = lnNotChanged + This.AutoRenameControls (laObjects (lnI), tlChangeChildren)
		Endfor
		
		Do case
			case lnNotChanged = 1						;
				And 1 = Alen (laObjects)		;
				And Not tlChangeChildren
			lnInput = Messagebox ('Change name even though it is not default?', 3 + 32, 'Name change?')
			If lnInput = 6
				This.AutoRenameControls (laObjects (1), .F., .T.)
			EndIf
			Case lnNotChanged > 0
			lnInput = Messagebox (Transform(lnNotChanged) + ' not changed; names are not default', 64) 
		Endcase
		
		This.RefreshForms()
		
	ENDPROC

	PROCEDURE autorenamecontrol
		Lparameters loControl, lcNewPrefix
		Local lcBaseClass, lcNewName, lcCaption, lnThirdSpace, lcChars, lcControlSource, lcRecordSource
		Local lcCustomPRG, lnCounter, lcName, loException, lbHide1
		
		*** JRN 03/05/2009 : Default behavior
		lcBaseClass = Lower(loControl.BaseClass)
		
		Do Case
		
			Case Not Empty (lcNewPrefix)
				lcNewName = lcNewPrefix
		
			Case lcBaseClass= 'checkbox'
				lcNewName = 'chk'
		
			Case lcBaseClass= 'collection'
				lcNewName = 'col'
		
			Case lcBaseClass= 'combobox'
				lcNewName = 'cbo'
		
			Case lcBaseClass= 'commandbutton'
				lcNewName = 'cmd'
		
			Case lcBaseClass= 'commandgroup'
				lcNewName = 'cmg'
		
			Case lcBaseClass= 'container'
				lcNewName = 'cnt'
		
			Case lcBaseClass= 'control'
				lcNewName = 'ctl'
		
			Case lcBaseClass= 'editbox'
				lcNewName = 'edt'
		
			Case lcBaseClass= 'form'
				lcNewName = 'frm'
		
			Case lcBaseClass= 'grid'
				lcNewName = 'grd'
		
			Case lcBaseClass= 'column'
				lcNewName = 'grc#'
		
			Case lcBaseClass= 'header'
				lcNewName = 'grh'
		
			Case lcBaseClass= 'hyperlink'
				lcNewName = 'hpl'
		
			Case lcBaseClass= 'image'
				lcNewName = 'img'
		
			Case lcBaseClass= 'label'
				lcNewName = 'lbl'
		
			Case lcBaseClass= 'line'
				lcNewName = 'lin'
		
			Case lcBaseClass= 'listbox'
				lcNewName = 'lst'
		
			Case lcBaseClass= 'oleboundcontrol'
				lcNewName = 'olb'
		
			Case lcBaseClass= 'ole'
				lcNewName = 'ole'
		
			Case lcBaseClass= 'optionbutton'
				lcNewName = 'opt#'
		
			Case lcBaseClass= 'optiongroup'
				lcNewName = 'opg'
		
			Case lcBaseClass= 'pageframe'
				lcNewName = 'pgf'
		
			Case lcBaseClass= 'page'
				lcNewName = 'pag#'
		
			Case lcBaseClass= 'separator'
				lcNewName = 'sep'
		
			Case lcBaseClass= 'shape'
				lcNewName = 'shp'
		
			Case lcBaseClass= 'spinner'
				lcNewName = 'spn'
		
			Case lcBaseClass= 'textbox'
				lcNewName = 'txt'
		
			Case lcBaseClass= 'timer'
				lcNewName = 'tmr'
		
			Case lcBaseClass= 'toolbar'
				lcNewName = 'tbr'
		
		Endcase
		
		Do Case
		
			Case Empty (lcNewName)
		
			Case This.GetPEMStatus (loControl, 'ControlSource', 5) And Not Empty (loControl.ControlSource)
				lcControlSource = loControl.ControlSource
				If "." $ lcControlSource
					lcControlSource = Substr (lcControlSource, 1 + RAt(".", lcControlSource ))
				Endif
				lcChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"
				lcControlSource = Chrtran(lcControlSource, Chrtran(lcControlSource, lcChars, ""), "")
				lcNewName = lcNewName + lcControlSource
		
			Case This.GetPEMStatus (loControl, 'RecordSource', 5) And Not Empty (loControl.RecordSource)
				lcRecordSource = loControl.RecordSource
				lcNewName = lcNewName + lcRecordSource
		
			Case This.GetPEMStatus (loControl, 'Caption', 5) And This.GetPEMStatus (loControl, 'Caption', 0)
				lcCaption = loControl.Caption
				lnThirdSpace = At(" ", lcCaption, 3)
				If lnThirdSpace # 0
					lcCaption = Left (lcCaption, lnThirdSpace)
				Endif
				lcChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
				lcNewName = lcNewName + Chrtran(lcCaption , Chrtran(lcCaption , lcChars, ""), "")
		
		Endcase
		
		*** JRN 03/05/2009 : Custom PRG to handle this?
		*	lcCustomPRG =  This.cApplicationPath + "AutoRenameControl.PRG"
		lcCustomPRG =  This.GetPlugInPath ("AutoRenameControl")
		If not Empty (lcCustomPRG)
			Try
				lcNewName = Execscript(Filetostr(lcCustomPRG), loControl, lcNewName)
			Catch To loException
				This.ShowErrorMsg(loException, 'Automatic Control Rename Failure', lcCustomPRG)
			Endtry
		
		Else
		
		Endif
		
		*** JRN 03/05/2009 : add on the number suffix, if needed, to avoid conflicts
		lnCounter = 1
		If '#' $ lcNewName
			lcNewName = Strtran(lcNewName, '#', '')
			lbHide1 = .F.
		Else
			lbHide1 = .T.
		Endif
		
		Do While Not Empty (lcNewName) And (Not This.GetPEMStatus (loControl, "Name", 1))
			lcName = lcNewName + Iif (lbHide1 And lnCounter = 1, '', Transform (lnCounter))
			If This.GetPEMStatus (loControl.Parent, lcName, 5)
				lnCounter = lnCounter + 1
			Else
				lcNewName = lcName
				Exit
			Endif
		Enddo
		
		Return lcNewName
		
	ENDPROC

	PROCEDURE autorenamecontrols
		Lparameters loControl, lbChangeChildren, lbForceChange
		
		* automatically renames the current control (and its sub-controls) if it has the default VFP name
		Local loChildControl As Object
		Local lbChangeChildren, lbChangeMyName, lbNameChangeable, lcClass, lcNamePrefix, lcNewName, lnIndex
		
		lcClass = Lower(loControl.Class)
		lcNamePrefix = ''
		If Empty (loControl.ClassLibrary)
			Local laClasses(1), laStdNames(1), laPrefixes(1)
			Alines(laClasses, "TextBox,EditBox,CommandButton,OptionButton,CheckBox,ComboBox,ListBox", .T.,',')
			Alines(laStdNames, "text,edit,command,option,check,combo,list", .T.,',')
			Alines(laPrefixes, "txt,edt,cmd,opt,chk,cbo,lst", .T.,',')
		
			lnIndex = Ascan (laClasses, loControl.Class, 1, -1, 1, 1)
			If lnIndex # 0
				lcClass = laStdNames(lnIndex)
				lcNamePrefix = laPrefixes(lnIndex)
			Endif
		Endif
		
		lnNotChanged =  0
		If Not This.GetPEMStatus (loControl, "Name", 1)
		
			If lbForceChange Or (;
					Lower (loControl.Name) = lcClass 								;
					and 0 # Val (Substr (loControl.Name, 1 + Len (lcClass))))
		
				lcNewName = This.AutoRenameControl (loControl, lcNamePrefix)
		
				Try && not sure if this Try/EndTry is necessary
					loControl.Name = lcNewName
				Catch
					lnNotChanged = 1
				Endtry
		
			Else
				lnNotChanged = 1
			Endif
		
		Endif
		
		If lbChangeChildren
			If This.GetPEMStatus(loControl, 'Objects', 5)
				For Each loChildControl In loControl.Objects FoxObject
					lnNotChanged = lnNotChanged + This.AutoRenameControls(loChildControl, lbChangeChildren)
				Next loControl
			Endif 
		Endif
		
		Return lnNotChanged
		
	ENDPROC

	PROCEDURE avoidbufferoverrun
		Lparameters toObject, tlTopOfForm, tlClass
		
		If Not Used ('BufferOverrunList')
			Return .F.
		Endif
		
		Do Case
			Case tlTopOfForm And tlClass
				Select  * From BufferOverrunList														 ;
					Where Lower (classname) = Lower (toObject.Class)									 ;
						And Lower (Justfname (classloc)) = Lower (Justfname (This.cSourcefilename))	 ;
						Noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
				Select  * From BufferOverrunList													  ;
					Where Lower (classname) = Lower (toObject.ParentClass)							  ;
						And Lower (Justfname (classloc)) = Lower (Justfname (toObject.ClassLibrary))  ;
						Noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
			Case tlTopOfForm And Not tlClass
		
				Select  * From BufferOverrunList													   ;
					Where Lower (Justfname (classloc)) = Lower (Justfname (This.cSourcefilename))  ;
						Noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
				Select  * From BufferOverrunList													  ;
					Where Lower (classname) = Lower (toObject.Class)								  ;
						And Lower (Justfname (classloc)) = Lower (Justfname (toObject.ClassLibrary))  ;
						Noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
			Otherwise
		
				Select  * From BufferOverrunList													  ;
					Where Lower (classname) = Lower (toObject.Class)								  ;
						And Lower (Justfname (classloc)) = Lower (Justfname (toObject.ClassLibrary))  ;
						Noconsole To Screen
				If _Tally # 0
					Return .T.
				Endif
		
		Endcase
		
		Return .F.
		
		
	ENDPROC

	PROCEDURE changeparentclass
		Local loClassInfo As Object
		Local loDestObject As Object
		Local loException As Object
		Local loSourceObject As Object
		Local lbCancel, lbFailed, lcClass, lcClassLib, lcName, lcTempName1, lnResultCode
		
		loSourceObject = This.GetOneSelectedObject()
		If 'O' # Vartype (loSourceObject)
			Messagebox(ccLOC_SingleObject)
			Return
		Endif
		
		Do Case
			Case Not This.ThisControlDeletable (loSourceObject)
				Messagebox('Can not change parent class (member of a parent class).')
				Return
			Case 0 # This.GetControlCount (loSourceObject)
				Messagebox('Can not change parent class if there are any child objects')
				Return
			Case Upper (loSourceObject.BaseClass) = 'OLE'
				Return
		Endcase
		
		If This.oPrefs.lUseAGetClass
			If Agetclass (laClassInfo)
				lcClassLib = laClassInfo(1)
				lcClass = laClassInfo(2)
			Else
				lbCancel = .T.
			Endif
		
		Else
			With This
				.DontDisablePEMEditor (.T.)
		
				loClassInfo = This.GetClass()
				If 'O' = Vartype(loClassInfo)
					lbCancel   = .F.
					lcClassLib = loClassInfo.Classlib
					lcClass	   = loClassInfo.Class
				Else
					lbCancel = .T.
				Endif
		
				.DontDisablePEMEditor (.F.)
			Endwith
		Endif
		
		If lbCancel
			Return
		Endif
		
		lcName = loSourceObject.Name
		
		lcTempName1 = lcName + "_New" + Sys(2015)
		lbFailed = .F.
		
		*** Step 1: Copy properties
		This.CopyProperties("aCopiedProperties")
		
		*** Step 2: Create new object
		Try
			loSourceObject.Parent.Newobject(lcTempName1, lcClass, lcClassLib)
			loDestObject = loSourceObject.Parent.&lcTempName1
		Catch To loException
			This.ShowErrorMsg(loException)
			lbFailed = .T.
		Endtry
		If lbFailed
			Return
		Endif
		
		lnResultCode = This.DoChangeParentClass (loSourceObject, loDestObject)
		
		Do Case
			Case lnResultCode = 0 && success
				With This
					.SetCurrentSelectedObject (loDestObject)
				Endwith
		
			Case lnResultCode = 1 && aborted; remove destination object
				loDestObject.Parent.RemoveObject(loDestObject.Name)
		
			Case lnResultCode = 2 && failure (for reasons unknown); remove destination, rename
				loDestObject.Parent.RemoveObject(loDestObject.Name)
				loSourceObject.Name = lcName
		
		Endcase
		
		
		
	ENDPROC

	PROCEDURE cleartempfileslist
		*** JRN 12/18/2008 : clean up crew
		Local lnSelect, lcName, lcWindowName
		
		lnSelect = Select()
		Select crsr_TempFiles
		
		Scan
			lcName = Trim(FileName)
			lcWindowName = Trim(WindowName)
			If Wexist(lcWindowName)
				Release Windows (lcWindowName)
			Endif
			Erase (lcName)
		Endscan
		
		This.CreateTempFilesList()
		
		Select(lnSelect)
		
	ENDPROC

	PROCEDURE clickoncontainer
		Lparameters loControl, lcWindowName, loTopOfForm
		
		#Define NumberOfSteps 3
		
		Local laMouseObj[1], laPercents[NumberOfSteps], lnCol, lnHorzPos, lnI, lnRow, lnVertPos
		
		lnTop	 = Objtoclient(loControl, 1)
		lnLeft	 = Objtoclient(loControl, 2)
		lnWidth	 = Objtoclient(loControl, 3)
		lnHeight = Objtoclient(loControl, 4)
		
		For lnI = 1 To NumberOfSteps
			laPercents(lnI) =(lnI - 1) /(NumberOfSteps - 1)
		Endfor
		
		* first pass ... see if we can do it without moving anything
		For lnRow = 1 To NumberOfSteps
			lnVertPos = Max(1, Min(lnTop + Round((lnHeight - 1) * laPercents(lnRow), 0), loTopOfForm.Height - 1))
		
			For lnCol = 1 To NumberOfSteps
				lnHorzPos = Max(1, Min(lnLeft + Round((lnWidth - 1) * laPercents(lnCol), 0), loTopOfForm.Width - 1))
				Mouse At  lnVertPos, lnHorzPos  Pixels Window(lcWindowName)
				DoEvents
				If 0 # Amouseobj(laMouseObj) And 'O' = Vartype(laMouseObj(1))
					If laMouseObj(1) = loControl
						This.ContainerClick(loControl, lnVertPos, lnHorzPos, lcWindowName)
						DoEvents
						Return .T.
					Endif
				Endif
			Endfor && lnCol = 1 To NumberOfSteps
		Endfor && lnRow = 1 To NumberOfSteps
		
		* if that fails ... see if we can get to an object within the container class
		* if so, we can move it out of the way, do our stuff, and then move it back
		For lnRow = 1 To NumberOfSteps
			lnVertPos = Max(1, Min(lnTop + Round((lnHeight - 1) * laPercents(lnRow), 0), loTopOfForm.Height - 1))
		
			For lnCol = 1 To NumberOfSteps
				lnHorzPos = Max(1, Min(lnLeft + Round((lnWidth - 1) * laPercents(lnCol), 0), loTopOfForm.Width - 1))
				Mouse At  lnVertPos, lnHorzPos  Pixels Window(lcWindowName)
				DoEvents
				If 0 # Amouseobj(laMouseObj) And 'O' = Vartype(laMouseObj(1))
					loMouseObject = laMouseObj(1)
		
					Do While 'O' = Type('loMouseObject.Parent')
						If loControl = loMouseObject.Parent
							loMovedControls = This.MoveControlsInContainer(loControl)
							This.ContainerClick(loControl, lnVertPos, lnHorzPos, lcWindowName)
							This.RestoreControlsInContainer(loMovedControls)
							Return .T.
						Else
							loMouseObject = loMouseObject.Parent
						Endif
					Enddo && While 'O' = Type('loMouseObject.Parent')
				Endif
			Endfor && lnCol = 1 To NumberOfSteps
		Endfor && lnRow = 1 To NumberOfSteps
		
		Return .F.
		
	ENDPROC

	PROCEDURE clickoncontrol
		Lparameters loControl, lcWindowName, lcShiftKeys, llStartInMiddle, loTopOfForm
		
		#Define NumberOfSteps 3
		
		Local laMouseObj[1], laPercents[NumberOfSteps], lnCol, lnHorzPos, lnI, lnRow, lnVertPos
		
		lnTop	 = Objtoclient(loControl, 1)
		lnLeft	 = Objtoclient(loControl, 2)
		lnWidth	 = Objtoclient(loControl, 3)
		lnHeight = Objtoclient(loControl, 4)
		
		For lnI = 1 To NumberOfSteps
			If llStartInMiddle
				laPercents(lnI) =(lnI % NumberOfSteps) /(NumberOfSteps - 1)
			Else
				laPercents(lnI) =(lnI - 1) /(NumberOfSteps - 1)
			Endif
		Endfor
		
		For lnRow = 1 To NumberOfSteps
			lnVertPos = Max(1, Min(lnTop + Round((lnHeight - 1) * laPercents(lnRow), 0), loTopOfForm.Height - 1))
		
			For lnCol = 1 To NumberOfSteps
				lnHorzPos = Max(1, Min(lnLeft + Round((lnWidth - 1) * laPercents(lnCol), 0), loTopOfForm.Width - 1))
				Mouse At  lnVertPos, lnHorzPos  Pixels Window(lcWindowName)
				DoEvents
				If 0 # Amouseobj(laMouseObj)
					If 'O' = Vartype(laMouseObj(1))	And laMouseObj(1) = loControl
						Mouse Click At lnVertPos, lnHorzPos  Pixels Window(lcWindowName) &lcShiftKeys
						DoEvents
						Return .T.
					Endif
				Endif
			Endfor && lnCol = 1 To NumberOfSteps
		Endfor && lnRow = 1 To NumberOfSteps
		Return .F.
		
	ENDPROC

	PROCEDURE closeforms
		With This
		
			If 'O' = Vartype (.oPEMEditor) Or 'O' = Vartype (.oDocTreeview) or 'O' = Vartype (.oFormatMenu)
		
				If 'O' = Vartype (.oPEMEditor)
					.oPEMEditor.Release()
					.oPEMEditor = .Null.
				Endif
		
				If 'O' = Vartype (.oDocTreeview)
					.oDocTreeview.Release()
					.oDocTreeview = .Null.
				Endif
		
				If 'O' = Vartype (.oFormatMenu)
					.oFormatMenu.Release()
					.oFormatMenu = .Null.
				Endif
		
			Else
		
				.ShowForm ()
		
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE closesearchresults
		If 'O' = Vartype (This.oSearchResults)
			This.oSearchResults.Release
			This.oSearchResults = .null.
		EndIf 
		
	ENDPROC

	PROCEDURE compareclass
		Local lcInheritValue, lcPEM, lcType, lcValue, loObject, lxInheritValue
		
		loObject = This.GetOneSelectedObject()
		If 'O' # Vartype (loObject)
			Messagebox (ccLOC_SingleObject)
			Return .F.
		Endif
		
		loProgress = Newobject ('FrmProgress', 'Source\EditProperty.vcx', '')
		loProgress.Show()
		loProgress.SetDescription ('Copying all properties and methods')
		
		With This
			.Open_VFP_Keywords()
			.CreatePEMList (loObject)
		Endwith
		
		*** JRN 2009-10-01 : Setup ... get list of non-defaults, and comparisons with their inherited values
		Select  *										;
			  , cType		  As  cTypeCol				;
			  , .F.			  As  lSelect				;
			  , .F.			  As  lIdentical			;
			  , Space(100)	  As  cValueCol				;
			  , Space(100)	  As  cInheritValueCol		;
			From csrMembers								;
			Where lNonDefault And lInherited			;
				And Upper (cName) # '_MEMBERDATA '		;
			Into Cursor csrCompareClass Readwrite
		
		If _Tally = 0
			Return
		Endif
		
		Scan
			lcPEM  = Alltrim (cName)
			lcType = cType
		
			With This.oServer
				Do Case
					Case '[' $ lcPEM Or '{' $ lcPEM && array?
						Replace lReadonly With .T.
		
					Case lcType = 'P'
						lcValue = Getpem (loObject, lcPEM)
						Replace cValueCol With Transform (lcValue)
		
						lxInheritValue = This.GetInheritedValue (lcPEM, loObject)
						Replace cInheritValueCol With Transform (lxInheritValue)
		
						Do Case
							Case Vartype (lcValue) # Vartype (lxInheritValue)
							Case not lcValue == lxInheritValue
							Otherwise
								Replace lIdentical With .T.
						Endcase
		
					Otherwise
						lcValue = loObject.ReadMethod (lcPEM)
						Replace cValueCol With IIf (Empty (lcValue), '', '[User Procedure]')
		
						lcInheritValue = This.GetInheritedCode (lcPEM, loObject)
						Replace cInheritValueCol With IIf (Empty (lcInheritValue), '', '[User Procedure]')
		
						Replace lIdentical With Transform (lcValue) == lcInheritValue
		
				Endcase
			Endwith
		Endscan
		
		Replace All lSelect With lIdentical
		loProgress.Release
		loProgress = .Null.
		
		*** JRN 2009-10-01 : put up selection form
		
		If This.SelectCompareClass (loObject)
		
			Scan For lSelect And Not lReadonly
				loObject.ResetToDefault (Trim (cName))
			Endscan
		
			This.SetCurrentSelectedObject (loObject)
		
		Endif
		
		
		
		
	ENDPROC

	PROCEDURE compareproperties
		Local loCompare As 'frmCompareProperties' Of 'Source\EditProperty.vcx'
		Local lbContinue, lcAppPath, loObject
		
		If Alen (This.oServer.aCopiedProperties, 2) <= 1
			MessageBox('You must copy (for comparing and pasting) first')
			Return
		EndIf 
		
		loObject = This.GetOneSelectedObject()
		If 'O' # Vartype (loObject)
			MessageBox(ccLOC_SingleObject)
			Return .F.
		Endif
		
		With This
			.DontDisablePEMEditor(.T.)
			
			.CopyProperties ('aCompareProperties')
		
			loCompare = Newobject ('frmCompareProperties', 'Source\EditProperty.vcx', ''	;
				  , loObject = .FindTopMostParent()											;
				  , .lClass)
			loCompare.Show()
		
			If 'O' = Vartype (loPaste)
				lbContinue = loPaste.lPasteIt
				loPaste.Release
			Else
				lbContinue = .F.
			Endif
		
			.DontDisablePEMEditor(.F.)
		
		Endwith
		
		Return lbContinue
		
	ENDPROC

	PROCEDURE containerclick
		Lparameters loControl, lnVertPos, lnHorzPos, lcWindowName
		Local laObjects[1]
		
		Mouse Click At lnVertPos, lnHorzPos  Pixels Window(lcWindowName)
		DoEvents
		If Aselobj(laObjects) = 1 Or Aselobj(laObjects, 1) = 1
			If laObjects[1] = loControl
				Return
			Endif
		Endif
		
		*** DH 2018-01-31: only do up to 10 times so don't get an infinite loop
		*Do While .T.
		local lnCounter
		lnCounter = 1
		do while lnCounter < 11
			lnCounter = lnCounter + 1
		*** DH 2018-01-31: end of new code
			Mouse Control Click At lnVertPos, lnHorzPos  Pixels Window(lcWindowName)
			DoEvents
			If Aselobj(laObjects) = 1 Or Aselobj(laObjects, 1) = 1
				If laObjects[1] = loControl
					Return
				Endif
			Endif
		Enddo && While .T.
		
	ENDPROC

	PROCEDURE convertcursortoxml
		Lparameters lcCursor
		
		Local lcXML
		Cursortoxml (lcCursor, 'lcXml', 1, 0, 0, '1')
		Return lcXML
		
	ENDPROC

	PROCEDURE copyproperties
		Lparameters tcDestArrayName, tcFilter
		
		Local llMemberParentClass, loObject
		
		loObject = This.GetOneSelectedObject()
		If 'O' # Vartype (loObject)
			Messagebox (ccLOC_SingleObject)
			Return .F.
		Endif
		
		With This.oServer
			.cCopyClassBaseClass = loObject.BaseClass
			.cCopyClass			 = loObject.Class
			If This.lClass And loObject = This.FindTopMostParent()
				.cCopyClassLibrary 	= This.cSourceFileName
			Else
				.cCopyClassLibrary 	= loObject.ClassLibrary
			Endif
		Endwith
		
		llMemberParentClass = This.GetPemStatus (loObject, 'Name', 1) And Not loObject = This.FindTopMostParent()
		This.CopyPropertiesToArray (loObject, tcDestArrayName, llMemberParentClass, tcFilter)
		
	ENDPROC

	PROCEDURE copypropertiestoarray
		Lparameters loObject, tcDestArrayName, llMemberParentClass, tcFilter
		
		Local loParents As Object
		Local loProgress As 'FrmProgress' Of  'Source\EditProperty.vcx'
		Local laCopiedProperties(1), lcDestArrayName, lcExpression, lcPEM, lcType, lcWhere, lnI
		Local lnRow, lxValue
		
		loProgress = Newobject ('FrmProgress', 'Source\EditProperty.vcx', '')
		loProgress.Show()
		loProgress.SetDescription ('Copying all properties and methods')
		
		With This
			.Open_VFP_Keywords()
			.CreatePEMList (loObject)
		Endwith
		
		If Empty(tcFilter)
			lcWhere = ''
		Else
			lcWhere = 'Where ' + tcFilter
		Endif
		
		Select  *							;
			, .F.		 As	 xValueCol		;
			, cType	 As	 cTypeCol		;
			, .T.		 As	 lSelect		;
			, .F.		 As	 lNewCol		;
			From csrMembers					;
			&lcWhere						;
			Order By cName					;
			Into Array laCopiedProperties
		
		lcDestArrayName = Evl (tcDestArrayName, 'aCopiedProperties')
		
		If _Tally = 0
			Dimension This.oServer.&lcDestArrayName.(1, 1)
			Return
		Endif
		
		*  (,1) = Name
		*  (,2) = Type ... (M)ethod, (V)alue, or e(X)pression
		*  (,ValueCol) = Value
		*  (,SelectCol) = Select?
		
		For lnRow = 1 To _Tally
			lcPEM  = Alltrim (laCopiedProperties (lnRow, 1) )
			lcType = laCopiedProperties (lnRow, ccPasteTypeCol)
		
			laCopiedProperties (lnRow, 1) = lcPEM
			Do Case
				Case '[' $ lcPEM Or '{' $ lcPEM && array?
					laCopiedProperties (lnRow, ccPasteTypeCol) = 'V'
					laCopiedProperties (lnRow, ccPasteValueCol) = .F.
				Case lcType = 'P'
					lcExpression = loObject.ReadExpression (lcPEM)
					If Empty ( lcExpression)
						laCopiedProperties (lnRow, ccPasteTypeCol) = 'V'
						Try
							lxValue = Getpem (loObject, lcPEM)
						Catch
							lxValue = ''
							laCopiedProperties (lnRow, ccNonDefaultCol) = .F.
						Endtry
						laCopiedProperties (lnRow, ccPasteValueCol) = Nvl (IIf ('O' # Vartype (lxValue), lxValue, ''), '.null.')
					Else
						laCopiedProperties (lnRow, ccPasteTypeCol) = 'X'
						laCopiedProperties (lnRow, ccPasteValueCol) = lcExpression
					Endif
		
					* correction if this object is actually a member added to a parent class
					* ASSUMEs that values from GetParentCode look like
					If llMemberParentClass And Not laCopiedProperties (lnRow, ccNonDefaultCol)
						loParents = This.GetObjectParentClasses (lcPEM, 'Value', loObject)
						For lnI = 1 To loParents.Count
							Do Case
								Case Not '.' $ loParents (lnI).Name
									Exit
								Case loParents (lnI).NonDefault
									laCopiedProperties (lnRow, ccNonDefaultCol) = .T.
									Exit
							Endcase
						Endfor
					Endif
		
				Otherwise
					laCopiedProperties (lnRow, ccPasteTypeCol) = 'M'
					laCopiedProperties (lnRow, ccPasteValueCol) = loObject.ReadMethod (lcPEM)
		
					* correction if this object is actually a member added to a parent class
					* ASSUMEs that values from GetParentCode look like
					If llMemberParentClass And Not laCopiedProperties (lnRow, ccNonDefaultCol)
						loParents = This.GetObjectParentClasses (lcPEM, 'Code', loObject)
						For lnI = 1 To loParents.Count
							Do Case
								Case Not '.' $ loParents (lnI).Name
									Exit
								Case loParents (lnI).NonDefault
									laCopiedProperties (lnRow, ccPasteValueCol) = loParents (lnI).Code
									laCopiedProperties (lnRow, ccNonDefaultCol) = .T.
									Exit
							Endcase
						Endfor
					Endif
		
			Endcase
		Endfor
		
		Dimension This.oServer.&lcDestArrayName.(1)
		Acopy (laCopiedProperties, This.oServer.&lcDestArrayName.)
		
		loProgress.Release
		loProgress = .Null.
		
	ENDPROC

	PROCEDURE creatememberscursor
		Lparameters tlPasteMode, tcCursorName
		
		Local lcCursorName
		lcCursorName = Evl (tcCursorName, 'csrMembers')
		
		If tlPasteMode
			* note that leading fields here must match normal case, but can't have a Memo field
			Create Cursor (lcCursorName) (	;
				cName 		C (128)		, 	;  && ccNameCol
				cType 		C (1)		, 	;  && ccTypeCol
				lAccess 	L			, 	;  && ccAccessCol
				lAssign 	L			, 	;  && ccAssignCol
				nVisibility N(2)		, 	;  && ccVisibilityCol
				lNative 	L			, 	;  && ccNativeCol
				lInherited 	L			, 	;  && ccInheritedCol
				lNonDefault L			, 	;  && ccNonDefaultCol
				lHasCode	L			, 	;  && ccHasCodeCol
				nFavorites 	N (1)		, 	;  && ccFavoritesCol
				lReadOnlyX 	L			, 	;  && ccReadOnlyXCol
				cDescript 	C (254)		, 	;  && ccDescriptCol
				nObjNumber	N (4)		,  	;  && ccObjNumberCol
				cValue		C (100)		,   ;  && ccPastecValueCol
				cScript     C (254)		,   ;  && ccHasScript
				;
				xValue		C (1) Null	,   ;  && ccPasteValueCol
				cTypeCol	C (1)		,	;  && ccPasteTypeCol
				lSelect		L			,	;  && ccPasteSelectCol
				lNew		L			,	;  && ccPastelNewCol
				;
				lReadOnly	L			,	;
				cCurValue	C (100)		,	;
				NRecNo      N (4)		    ;
				)
		
		Else
		
			Create Cursor (lcCursorName) (	;
				cName 		C (128)		, 	;
				cType 		C (1)		, 	;
				lAccess 	L			, 	;
				lAssign 	L			, 	;
				nVisibility N(2)		, 	;
				lNative 	L			, 	;
				lInherited 	L			, 	;
				lNonDefault L			, 	;
				lHasCode	L			, 	;
				nFavorites 	N (1)		, 	;
				lReadOnly 	L			, 	;
				cDescript 	M			, 	;
				nObjNumber	N (4)		,	;
				cValue		C (100)		,   ;
				cScript     M			    ;
				)
		
		Endif
		
	ENDPROC

	PROCEDURE createnewpem
		Lparameters lcType, lcNewMethodName, lxValue, loTopOfForm, tcDescription, llNoRefresh
		
		Local llFailed, loException, loPEMEditor
		
		If 'O' # Vartype (loTopOfForm)
			loTopOfForm = This.FindTopMostParent()
			If Isnull (loTopOfForm)
				Return .F.
			Endif
		Endif
		
		If Pemstatus(loTopOfForm, lcNewMethodName, 5)
			Messagebox(lcNewMethodName + ' already exists', 16, 'Failure')
			Return .F.
		Endif
		
		* create new method
		Try
			If lcType = 'M'
				lcMethodHeader = This.GetNewMethodHeader(lcNewMethodName, Evl(tcDescription, ''), This.oPrefs.nStartVisibility)
				If Not Empty(lcMethodHeader)
					lxValue = lcMethodHeader + CRLF + lxValue
				Endif
				loTopOfForm.WriteMethod (lcNewMethodName, lxValue, .T., This.oPrefs.nStartVisibility, Evl(tcDescription, ''))
			Else
				loTopOfForm.AddProperty (lcNewMethodName, lxValue, This.oPrefs.nStartVisibility, Evl(tcDescription, ''))
			Endif
			llFailed = .F.
		Catch To loException
			This.ShowErrorMsg (loException)
			llFailed = .T.
		Endtry
		
		If llFailed
			Return .F.
		Endif
		
		* memberdata
		If (lcNewMethodName # Lower(lcNewMethodName))
			This.AddtoCKL(lcNewMethodName)
			If (This.oPrefs.lUseMemberData Or Pemstatus(loTopOfForm, '_MemberData', 5));
					and Not This.oPrefs.lLowerCaseOnly
				loPEMEditor = This.oPEMEditor
				If Not Isnull (loPEMEditor)
					With loPEMEditor
						.CheckMemberData (lcNewMethodName)
						If Not llNoRefresh
							.DoRefresh()
						Endif
					Endwith
				Else
					This.AddToMemberdata (loTopOfForm, lcNewMethodName)
				Endif
			Endif
		Endif
		
		
	ENDPROC

	PROCEDURE createobjectidlist
		Lparameters llThisForm, llRecursive
		Local loTopofForm As Object
		Local laObjects[1]
		Local llFiller
		
		loTopofForm = This.FindTopMostParent()
		If 'O' # Vartype(loTopofForm)
			Return
		EndIf
		
		If llThisForm
			This.oBeautifyX.PEME_CreateObjectIDList(loTopofForm, llRecursive;
				, This.cSourceFileName, Iif(This.lClass, loTopofForm.Name, ''))
		Else
			llFiller = 0 = Aselobj(laObjects) And 0 = Aselobj(laObjects,1)
			This.oBeautifyX.PEME_CreateObjectIDList(laObjects(1), llRecursive;
				, This.cSourceFileName, Iif(This.lClass, loTopofForm.Name, ''))
		Endif
		
	ENDPROC

	PROCEDURE createpemlist
		Lparameters loObject, tcAlias
		
		* Populate the grid and select the appropriate property or method.
		
		Local loMemberDataEngine As [MemberDataEngine]
		Local llAvoidBufferOverrun, llClass, llTopOfForm, loTopOfForm, lcAlias
		
		loTopOfForm			 = This.FindTopMostParent()
		llTopOfForm			 = loTopOfForm = loObject
		llClass				 = This.lClass
		llAvoidBufferOverrun = This.AvoidBufferOverrun (loObject, llTopOfForm, This.lClass)
		
		lcAlias = Evl(tcAlias, 'csrMembers')
		loMemberDataEngine = Newobject ([MemberDataEngine], [PEME_MemberDataEngine.PRG])
		This.CreateMembersCursor(, lcAlias)
		
		With loMemberDataEngine
			.lClassDesigner	= llClass
			.oObject		= loObject
			.SetupEngine()
			.CreateMemberDataCollection (lcAlias, llTopOfForm And llClass	;
				  , llAvoidBufferOverrun, .F., This.oPrefs.lNoErrorMsgOnMissingVCX)
		Endwith
		
		
	ENDPROC

	PROCEDURE createsortedobjectarray
		Lparameters loParent, laControls
		
		Local loControl AS Object
		Local laControls, lnControlCount, lnCount, lnI, lnValue
		
		lnControlCount = This.GetControlCount(loParent)
		If lnControlCount # 0 And "O" = Type("loParent.Objects(1)")
		
			Dimension laControls (lnControlCount, 2)
			lnCount = 0
			For lnI = 1 To lnControlCount
				loControl = loParent.Objects(lnI)
				Do Case
					Case This.oPrefs.nTreeSort = 1
						lnValue = 0
					Case This.oPrefs.lTreeMemberSort And This.GetPEMStatus (loControl, 'PageOrder', 5)
						lnValue = loControl.PageOrder
					Case This.oPrefs.lTreeMemberSort And This.GetPEMStatus (loControl, 'ColumnOrder', 5)
						lnValue = loControl.ColumnOrder
					Case This.oPrefs.nTreeSort = 2
						lnValue = loControl.Name
					Case This.oPrefs.nTreeSort = 6
						lnValue = Upper(loControl.Name)
					Case This.oPrefs.nTreeSort = 3 						;
							and This.GetPEMStatus (loControl, 'tabindex', 5)
						lnValue = loControl.TabIndex
					Case This.oPrefs.nTreeSort = 4 						;
							and This.GetPEMStatus (loControl, 'top', 5) 		;
							And This.GetPEMStatus (loControl, 'left', 5)
						lnValue = 1E4 * loControl.Top + loControl.Left
					Case This.oPrefs.nTreeSort = 5 						;
							and This.GetPEMStatus (loControl, 'top', 5) 		;
							And This.GetPEMStatus (loControl, 'left', 5)
						lnValue = 1E4 * loControl.Left + loControl.Top
					Otherwise
						lnValue = 1E9
				Endcase
		
				lnCount = lnCount + 1
				laControls(lnCount,1) = lnCount
				laControls(lnCount,2) = lnValue
			Endfor
		
			If lnCount > 0
				Asort (laControls,2,-1)
			EndIf
		
		Else
		
			lnControlCount = 0
		
		Endif
		
		Return lnControlCount 
	ENDPROC

	PROCEDURE createtempfileslist
		Create Cursor crsr_TempFiles (FileName C(250), WindowName C(200))
		
	ENDPROC

	PROCEDURE createthortools
		Lparameters llQuiet
		Local lcFolder
		
		Select 0
		
		Try
			lcFolder = Execscript(_Screen.cThorDispatcher, 'Tool Folder= ')
		Catch
			lcFolder = ''
		Endtry
		
		If Not Empty(lcFolder)
			Use (This.cApplicationPath + 'Tables\Thor Source') Again in 0 Shared Alias ThorSource
			Use (This.cApplicationPath + 'Tables\Thor Menus') Again in 0 Shared Alias ThorMenus
		
			PEME_CreateThorTools (lcFolder, This.cApplicationPath, This.oPrefs.cVersion)
			PEME_CreateThorMenus ()
			
			If This.oPrefs.nToolsPlacement # 4	
				PEME_AssignThorHotKeys (This.oPrefs)
			EndIf 
			
			Use in ThorSource
			Use in ThorMenus
			
			If llQuiet
				Return
			EndIf 
		
			Messagebox('PEM Editor now registered with Thor', 64, 'Registered with Thor', 3000)
		Endif
		
		
	ENDPROC

	PROCEDURE dochangeparentclass
		Lparameters loSourceObject, loDestObject
		
		* Return values:
		*	0 = success
		* 	1 = dest object must be removed
		* 	2 = ditto, and source object must be renamed back
		
		Local lbFailed, lcName, lcPrompt, lcTempName2, llVisible, lnMsgBox, lnResultCode, lnTop
		lcName = loSourceObject.Name
		lnResultCode = 1
		
		*** Step 2.1 Make the object invisible, is possible
		*  first guess would be to use 'Visible' -- but that doesn't have any effect in Design Mode.
		If This.GetPEMStatus(loDestObject, 'Top', 5) and not This.GetPEMStatus (loDestObject, 'Top', 1)
			With loDestObject
				lnTop = .Top
				.Top = -2000
			EndWith
		Else
			lnTop = 0
		Endif
		
		*** Step 3: Verify if changing base class
		If Not Lower(loSourceObject.BaseClass) == Lower(loDestObject.BaseClass)
			lcPrompt = Strtran (ccLOC_CMG_ChangeBaseClass, '<old>', loSourceObject.BaseClass)
			lcPrompt = Strtran (lcPrompt, '<new>', loDestObject.BaseClass)
			lnMsgBox = Messagebox (lcPrompt , 4+32)
			If lnMsgBox # 6
				Return lnResultCode
			Endif
		Endif
		
		*** Step 4: Verify properties to be pasted
		If Not This.SelectPastedProperties(loDestObject)
			Return lnResultCode
		Endif
		
		*** Step 5: Rename original object
		lcTempName2 = lcName + "_Old" + Sys(2015)
		Try
			loSourceObject.Name = lcTempName2
		Catch To loException
			This.ShowErrorMsg(loException)
			lbFailed = .T.
		Endtry
		If lbFailed
			Return lnResultCode
		Endif
		
		If lnTop < 0
			loDestObject.ResetToDefault("Top")
		Endif
		
		lnResultCode = 2
		*** Step 6: Paste properties into new object (which will not include the name!)
		This.DoPasteProperties(loDestObject)
		
		*** Step 7: Rename new object
		Try
			loDestObject.Name = lcName
		Catch To loException
			This.ShowErrorMsg(loException)
			lbFailed = .T.
		Endtry
		If lbFailed
			Return lnResultCode
		Endif
		
		*** Step 8: Remove original object
		loSourceObject = .Null.
		Try
			loDestObject.Parent.RemoveObject(lcTempName2)
		Catch To loException
			This.ShowErrorMsg(loException)
			lbFailed = .T.
		Endtry
		If lbFailed
			Return lnResultCode
		Endif
		
		Return 0
		
	ENDPROC

	PROCEDURE dofindobjects
		Lparameters loObject, lcSearchText, lcName, loCollection
		
		Local loChild As Object
		Local loNextItem As 'Empty'
		Local laControls[1], lnCount, lnI
		
		With This
			If PEME_Find (This, loObject, lcSearchText, lcName)
				loNextItem = Createobject ('Empty')
				AddProperty (loNextItem, 'object', loObject)
				AddProperty (loNextItem, 'fullobjectname', This.GetObjectPath (loObject))
				loCollection.Add (loNextItem)
			Endif
		
			****************************************************************
		
			lnCount = This.CreateSortedObjectArray (loObject, @laControls)
			For lnI = 1 To lnCount
				loChild = loObject.Objects (laControls (lnI, 1))
				.DoFindObjects (loChild, lcSearchText, lcName + '.' + loChild.Name, loCollection)
			Endfor
		
		Endwith
		
		
	ENDPROC

	PROCEDURE doformmodifyfile
		Lparameters lcType
		* lcType = 'Form', 'Class', or 'Other'
		
		If lcType = 'Project'
			Modify Project ? Nowait
			Return
		EndIf 
		
		If Vartype(This.oFoxRef) # 'O'
			This.oFoxRef = PEME_NewSessionObject ('FoxRef', 'PEME_FoxRefEngine.VCX', This.oPrefs.cxResourceFile)
		Endif
		
		lcForm = 'PEME_Open' + lcType
		Do Form (lcForm) With This, This.oFoxRef, lcType name xxxx
		
		****************************************************************
		
		
		External form PEME_OpenClass
		External form PEME_OpenForm
		External form PEME_OpenOther
		
		
	ENDPROC

	PROCEDURE dontdisablepemeditor
		Lparameters llDontDisable
		
		If 'O' = Vartype (This.oPEMEditor)
			This.oPEMEditor.lDontDisableMe = llDontDisable
		Endif
		
	ENDPROC

	PROCEDURE dopasteproperties
		Lparameters toObject, llAll
		* llAll = .F. means only non-Default
		
		Local loDestNode As Object
		Local loDestXML As ccXML_DOM_CLASS
		Local loObject As Object
		Local loRoot As Object
		Local loSourceNode As Object
		Local loSourceXML As ccXML_DOM_CLASS
		Local loException AS Object
		Local lbNew, lbSelect, lcAttrName, lcAttrValue, lcDescript, lcErrors, lcMixedName, lcName, lcPem
		Local lcType, lFixMemberData, lnI, lnRow, lnVisibility, lxValue
		
		loObject = toObject
		
		****************************************************************
		*** JRN 09/29/2009 : Setup to handle _MemberData, if its being posted
		lFixMemberData = .F.
		For lnRow = 1 To Alen (This.oServer.aCopiedProperties, 1)
		
			If Not (This.oServer.aCopiedProperties (lnRow, ccNonDefaultCol) Or llAll)
				Loop
			Endif
		
			lcPem	 = This.oServer.aCopiedProperties (lnRow, 1)
			lxValue	 = This.oServer.aCopiedProperties (lnRow, ccPasteValueCol)
			lbSelect = This.oServer.aCopiedProperties (lnRow, ccPasteSelectCol)
		
			If lbSelect And Upper (lcPem) == '_MEMBERDATA'
				lFixMemberData	  = .T.
				loSourceXML		  = Createobject (ccXML_DOM_CLASS)
				loSourceXML.Async = .F.
				loSourceXML.LoadXML (lxValue)
			Endif
		Endfor
		
		loDestXML		= Createobject (ccXML_DOM_CLASS)
		loDestXML.Async	= .F.
		
		loTopOfForm = This.FindTopMostParent()
		If This.GetPEMStatus (loTopOfForm, '_MemberData', 5)				;
				And This.GetPEMStatus (loTopOfForm, '_MemberData', 0)		;
				And Not Empty (loTopOfForm._MemberData)
			loDestXML.LoadXML (loTopOfForm._MemberData)
		Else
			loDestXML.LoadXML ('')
		Endif
		
		****************************************************************
		
		lcErrors = ''
		For lnRow = 1 To Alen (This.oServer.aCopiedProperties, 1)
			lcPem = This.oServer.aCopiedProperties (lnRow, 1)
		
			lcDescript = Rtrim (This.oServer.aCopiedProperties (lnRow, ccPasteDescriptCol))
			lcType	   = This.oServer.aCopiedProperties (lnRow, ccPasteTypeCol)
			lxValue	   = This.oServer.aCopiedProperties (lnRow, ccPasteValueCol)
			lbNew	   = This.oServer.aCopiedProperties (lnRow, ccPastelNewCol)
			lbSelect   = This.oServer.aCopiedProperties (lnRow, ccPasteSelectCol)
			lnVisibility   = This.oServer.aCopiedProperties (lnRow, ccVisibilityCol)
		
			Try
				Do Case
					Case Not (llAll ;
						or This.oServer.aCopiedProperties [lnRow, ccNonDefaultCol] ;
						Or Not (This.oServer.aCopiedProperties [lnRow, ccNativeCol] or This.oServer.aCopiedProperties [lnRow, ccInheritedCol]))
		
					Case Not lbSelect
		
					Case Upper (lcPem) == '_MEMBERDATA'
		
					Case lcType = 'M'
						If lbNew
							loObject.WriteMethod (lcPem, lxValue, .T., lnVisibility, lcDescript)
						Else
							loObject.WriteMethod (lcPem, lxValue) && , lnVisibility, lcDescript)
						Endif
		
					Case lcType = 'X'
						If lbNew
							loObject.AddProperty (lcPem, lxValue, lnVisibility, lcDescript)
						Endif
						loObject.WriteExpression (lcPem, lxValue, lnVisibility, lcDescript)
		
					Case lcType = 'V'
						If lbNew
							loObject.AddProperty (lcPem, lxValue, lnVisibility, lcDescript)
						Else
							loObject.WriteExpression (lcPem, '')
							loObject.AddProperty (lcPem, lxValue, lnVisibility, lcDescript)
						Endif
		
				Endcase
		
				****************************************************************
				*** JRN 09/29/2009 : post to _MemberData, if appropriate
				If lbNew And lbSelect
					lcName = Lower (This.JustPem (lcPem))
					If lFixMemberData
						loSourceNode = loSourceXML.selectSingleNode ('//memberdata[@name = "' + lcName + '"]')
						If Vartype (loSourceNode) = 'O'
							loDestNode = loDestXML.selectSingleNode ('//memberdata[@name = "' + lcName + '"]')
		
							If Vartype (loDestNode) # 'O'
								loDestNode = loDestXML.createElement (ccMEMBER_DATA_XML_ELEMENT)
								loDestNode.setAttribute ('name', lcName)
								* Get the root node of the MemberData XML. If it doesn't exist, create it.
								loRoot = loDestXML.selectSingleNode ('/' + ccXML_ROOT_NODE)
								If Vartype (loRoot) # 'O'
									loRoot = loDestXML.createElement (ccXML_ROOT_NODE)
									loDestXML.appendChild (loRoot)
								Endif Vartype (loRoot) # 'O'
								* Add the new node to the root.
								loRoot.appendChild (loDestNode)
							Endif Vartype (loDestNode) # 'O'
		
							* attributes(0) is the name
							For lnI = 1 To loSourceNode.Attributes.Length - 1
								lcAttrName	= loSourceNode.Attributes (lnI).nodename
								lcAttrValue	= loSourceNode.getAttribute (lcAttrName)
								loDestNode.setAttribute (lcAttrName, lcAttrValue )
							Next lnI
		
							This.WriteMemberData (loDestXML)
		
						Endif Vartype (loSourceNode) = 'O'
					Else
						lcMixedName = This.JustPem (lcPem)
						If Not lcName == lcMixedName
							loDestNode = loDestXML.selectSingleNode ('//memberdata[@name = "' + lcName + '"]')
		
							If Vartype (loDestNode) # 'O'
								loDestNode = loDestXML.createElement (ccMEMBER_DATA_XML_ELEMENT)
								loDestNode.setAttribute ('name', lcName)
								* Get the root node of the MemberData XML. If it doesn't exist, create it.
								loRoot = loDestXML.selectSingleNode ('/' + ccXML_ROOT_NODE)
								If Vartype (loRoot) # 'O'
									loRoot = loDestXML.createElement (ccXML_ROOT_NODE)
									loDestXML.appendChild (loRoot)
								Endif Vartype (loRoot) # 'O'
								* Add the new node to the root.
								loRoot.appendChild (loDestNode)
							Endif Vartype (loDestNode) # 'O'
							loDestNode.setAttribute ('display', lcMixedName )
		
							This.WriteMemberData (loDestXML)
		
						Endif
					Endif lFixMemberData
				Endif lbNew And lbSelect
				****************************************************************
		
			Catch To loException
				lcErrors = lcErrors + lcPem + ": " + loException.Message + " (" + Transform(loException.ErrorNo) + ")" + CR
			Endtry
		Endfor
		
		If Not Empty (lcErrors)
			Messagebox ('Unable to paste all properties' + CR + CR + lcErrors, MB_OK + MB_ICONEXCLAMATION, 'Unable to paste all properties')
		Endif
		
	ENDPROC

	PROCEDURE editlocalmethodcode
		Lparameters lcFileName, loTopOfForm, toObject, lcMethod, llClass, llDataEnvironment
		
		Local loContainerObj As Object
		Local loObject As Object
		Local laObject[1], lcClassName, lcExpression, lcObjectName, lcParams, lcPem, lnStartRange
		
		If 'O' # Vartype (loTopOfForm)
			loTopOfForm = This.FindTopMostParent()
			If Isnull (loTopOfForm)
				Return .F.
			Endif
		Endif
		
		loObject = toObject
		
		Do Case
			Case Not llDataEnvironment
				If llClass
					lcClassName	= loTopOfForm.Name
					lcPem		= ''
				Else
					lcClassName	= ''
					lcPem		= loObject.Name + '.'
				Endif
		
				*** JRN 02/28/2009 : up through the parent to the top form/class
				Aselobj (laObject, 3)
				loContainerObj = laObject[ 1 ]
		
				Do While loContainerObj # loTopOfForm
					loContainerObj = loContainerObj.Parent
					If 'grid' # Lower (loContainerObj.BaseClass)
						lcPem = lcPem + 'Parent.'
					Endif
				Enddo
		
				*** JRN 02/28/2009 : and now drill down to the object
		
				loTopOfForm	 = loTopOfForm
				lcObjectName = ''
				Do While loObject # loTopOfForm
					lcObjectName = loObject.Name + '.' + lcObjectName
					loObject	 = loObject.Parent
				Enddo
				lcPem = lcPem + lcObjectName + lcMethod
		
			Case Lower (loObject.BaseClass) = Lower ('DataEnvironment')
				lcClassName	= ''
				lcPem		= loTopOfForm.Name + '.' + loObject.Name + '.' + lcMethod
		
			Otherwise
				lcClassName	= ''
				lcPem		= loTopOfForm.Name + '.' + loObject.Parent.Name + '.' + loObject.Name + '.' + lcMethod
		
		Endcase
		
		*	Editsource (lcFileName, lnStartRange, lcClassName, lcPem)
		lnStartRange = 0
		lcParams = 'lcFileName, lnStartRange, lcClassName, lcPem'
		lcExpression = 'lParameters ' + lcParams + ccCR + 'Editsource(' + lcParams + ')'
		Execscript(lcExpression, &lcParams)
		
		DoEvents
		
		If This.oPrefs.lAutoMoveWindow
			This.oIDEx.MoveWindow()
		Endif
		
		If 'O' = Vartype (This.oPEMEditor)
			This.oPEMEditor.RenameMethodWindow (toObject, lcMethod)
		Endif
		
		
	ENDPROC

	PROCEDURE editparentclasses
		Local loClasses AS Object
		Local loGetClass AS 'frmEditParentClass' OF  'Source\EditProperty.vcx'
		Local loObject AS Object
		Local loTopOfForm AS Object
		Local laObjects(1), lcClass, lcFileName
		
		
		loObject = This.GetOneSelectedObject()
		If 'O' # Vartype (loObject)
			Messagebox (ccLOC_SingleObject)
			Return .F.
		Endif
		
		This.AddMRUFile ('\-', '', 'MRU44')
		
		loClasses = This.GetObjectParentClasses (, , loObject)
		If loClasses.Count = 0
			Messagebox ('No parent class found')
		Endif
		
		*!*	For lnI = loClasses.Count To 1 Step - 1
		*!*		lcClass	   = loClasses (lnI).Class
		*!*		lcClassLib = loClasses (lnI).VCX
		
		*!*		If Not Empty (lcClass)
		*!*			This.AddMRUFile (Lower (lcClassLib + '|' + lcClass), '', 'MRU44')
		*!*		Endif
		*!*	Endfor
		
		With This
		
			ASelObj(laObjects, 3)
			lcFileName = laObjects[2]
			If 'VCX' = Upper(JustExt(lcFileName))
				loTopOfForm = This.FindTopMostParent()
				lcClass = loTopOfForm.Class
			Else
				lcClass = ''
			EndIf 
		
			loGetClass = Newobject ('frmEditParentClass', 'Source\EditProperty.vcx', ''			;
				  , This;
				  , loClasses;
				  , This.cApplicationPath;
				  , lcFileName;
				  , lcClass;
				  )
			loGetClass.Show()
			.AddProperty(Sys(2015), loGetClass)
		
		Endwith
		
		
	ENDPROC

	PROCEDURE editpreferences
		Lparameters lnPage
		
		Local lGridAboveOld, lUseAbbreviationsOld, llSaved, lnColumn, lnWidth
		
		lGridAboveOld		 = This.oPrefs.lGridAbove
		lUseAbbreviationsOld = This.oPrefs.lUseAbbreviations
		
		This.oPrefs.CopySettings() && so we can restore them, if cancelled.
		
		Do case 
			Case Evl(lnPage,1) = 1
				This.oPrefs.nStartVisibility = This.oPrefs.nStartVisibility 
				This.oPrefs.nAssignVisibility = This.oPrefs.nAssignVisibility 
				This.oPrefs.nFontSize = This.oPrefs.nFontSize
				
				Do Form PEME_EditPreferences    With This.oPrefs, 1 To llSaved
			Case Evl(lnPage,1) = 2
				Do Form PEME_EditPreferencesIDE With This.oPrefs, 1 To llSaved
		EndCase
		
		If llSaved
			If 'O' = Vartype (This.oPEMEditor)
				With This.oPEMEditor
		
					* Change to orientation
					If lGridAboveOld # This.oPrefs.lGridAbove
						.SetFormAlignment()
						.Height = .Height + 1
					Endif
		
					* Change to using abbreviations in columns
					If lUseAbbreviationsOld # This.oPrefs.lUseAbbreviations
						lnWidth = 25 * .nFontSize / 8
						With .oGrid
							.SetColumnHeadings()
							For lnColumn = 1 To .ColumnCount
								If Not Inlist (lnColumn, 1, 9, 10)
									.Columns (lnColumn).Width = IIf (This.oPrefs.lUseAbbreviations, lnWidth, .Columns[lnColumn].nWidth)
								Endif
							Next lnColumn
						Endwith
					Endif
		
					* and set grid highlighting
					.InitGridHighlighting()
					.SetGridHighlighting()
		
					.Refresh()
				Endwith
			Endif
		
			If Evl(lnPage,1) = 2 
				This.oPrefs.lSettingsChanged = .T.
			EndIf 
			
			This.oPrefs.SaveValues()
			This.oIDEx.CreateSystemMenu()
		
		Else
			This.oPrefs.RestoreCopiedSettings()
		Endif
		
	ENDPROC

	PROCEDURE exportchildmethodcode
		Lparameters loParent, lcFileName, lcNamePrefix, tbParentage, tbRecursive, llIsTopOfForm
		
		Local  ;
			loControl As Object	,;
			loResult As Object
		Local laControls(1), lcCode, lcInheritedCode, lcName, lcText, lnCount, lnI
		
		loResult = This.oServer.GetMethodList (loParent, This.lClass, llIsTopOfForm And This.lClass)
		Create Cursor cMyMembers (cName C(128), cType C(1), SortKey C(128))
		Append From Array loResult.MethodList
		
		Select cMyMembers
		Scan
			lcName = Trim (cName)
			lcText = This.GetAllCode(loParent, lcName, lcNamePrefix, tbParentage)
			If Not Empty(lcText)
				lcHeaderText = ccTopDividerLine + ccTopDividerLine		;
					+ Iif (tbParentage, '*' + Space(5) + lcName + ccCRLF, '')
				Strtofile (lcHeaderText, lcFileName, 1)
				Strtofile (lcText + ccCRLF + ccCRLF, lcFileName, 1)
			Endif
		Endscan
		
		****************************************************************
		If tbRecursive
			lnCount = This.CreateSortedObjectArray (loParent, @laControls)
		
			For lnI = 1 To lnCount
				loControl = loParent.Objects (laControls (lnI, 1))
				This.ExportChildMethodCode (loControl, lcFileName, lcNamePrefix  + '.' + loControl.Name, tbParentage, tbRecursive)
			Next lnI
		Endif
		
	ENDPROC

	PROCEDURE exportmethodcode
		Lparameters tbParentage, tbRecursive
		
		*** JRN 12/01/2008 : export list of pems
		Local loObject AS Object
		Local loTopOfForm AS Object
		Local lcFileName, lcObjectName, lcText, lcWindowName
		
		loObject = This.GetOneSelectedObject()
		If 'O' # Vartype (loObject)
			Messagebox (ccLOC_SingleObject)
			Return .F.
		Endif
		
		loTopOfForm	= This.FindTopMostParent ()
		lcObjectName = This.GetObjectPath(loObject)
		
		lcText = ''
		lcWindowName = loTopofForm.Name + lcObjectName + '.' + Sys(2015) + ".Procedures.PRG"
		lcFileName = Sys(2023) + "\" + lcWindowName
		
		loTopOfForm	= This.FindTopMostParent ()
		Strtofile('* Procedures for ' + loTopofForm.Name + lcObjectName + ccCRLF + '*' + ccCRLF, lcFileName, 0)
		
		This.ExportChildMethodCode (loObject, lcFileName, loObject.Name, tbParentage, tbRecursive, loTopOfForm = loObject)
		
		****************************************************************
		
		This.ViewTempFile(lcFileName)
		
	ENDPROC

	PROCEDURE extractpropertyvalue
		Lparameters lcName, lcProperties
		Local lcResult, lcUpperValue, lcValue, lnLen, lnPos
		
		lnPos = 1
		
		* We have to handle properties with more than 255 characters in the value
		* differently.
		
		If Substr (lcProperties, lnPos, 1) = ccPROPERTIES_PADDING_CHAR
			lnLen        = Val (Alltrim (Substr (lcProperties,		;
				lnPos + cnPROPERTIES_PADDING_SIZE,			;
				cnPROPERTIES_LEN_SIZE)))
			lcResult = Left (lcProperties, lnPos - 1) + Substr (lcProperties, lnPos +		;
				cnPROPERTIES_PADDING_SIZE + cnPROPERTIES_LEN_SIZE,						;
				lnLen)
		Else
			lcResult = Strextract (lcProperties, '', Chr(13))
		Endif Substr (lcProperties, lnPos, 1) = ccPROPERTIES_PADDING_CHAR
		
		lcValue		 = Ltrim (Substr (lcResult, 1 + At ('=', lcResult)))
		lcUpperValue = Upper (Alltrim (lcValue))
		
		Do Case
			Case Empty (lcValue)
				Return ''
			Case This.IsNumber (lcValue)
				Return Evaluate (lcValue)
			Case '.F.' == lcUpperValue
				Return .F.
			Case '.T.' == lcUpperValue
				Return .T.
			Case '.NULL.' == lcUpperValue
				Return .Null.
			Case Left (lcValue, 1) $ ['"] + '['
				lcValue = Alltrim (lcValue)
				Return Substr (lcValue, 2, Len (lcValue) - 2)
			Case Getwordcount(lcValue, ',') = 3
				Try
					lcValue = Evaluate('RGB(' + lcValue + ')')
				Catch
				Endtry
				Return lcValue
		
			Otherwise
				Return lcValue
		Endcase
		
		
	ENDPROC

	PROCEDURE find
		Local loFind As 'FrmFindObjects' Of  'Source\EditProperty.vcx'
		Local loProgress As 'FrmFindObjects' Of  'Source\EditProperty.vcx'
		Local lcAppPath, lcPath, llFindIt
		
		loTopofForm = This.FindTopMostParent()
		If 'O' # Vartype(loTopofForm)	
			Return
		Endif
		
		lcPath	  = This.cApplicationPath
		lcAppPath = Forcepath ('PEMEditor.app', lcPath)
		
		loFind = Newobject ('FrmFindObjects', 'Source\EditProperty.vcx', lcAppPath, 8)
		loFind.Show()
		If 'O' # Vartype (loFind)
			Return
		Endif
		
		This.cSearchFor	= Transform (loFind.cSearchFor)
		llFindIt		= loFind.lResult
		loFind.Release
		loFind = .Null.
		
		If llFindIt
		
			With This
				loFound = .FindObjects(This.cSearchFor)
				.nFoundObjects = loFound.Count
				loPEMEditor = This.oPEMEditor
		
				Do Case
					Case .nFoundObjects = 0
						Messagebox ('No objects found', 16, 'None Found')
					Case .nFoundObjects = 1 And 'O' = Vartype(loPEMEditor)
						.SetCurrentSelectedObject (loFound(1).Object)
					Otherwise
		
						If 'O' = Vartype(loPEMEditor)
							Dimension loPEMEditor.aSelectedObjects(.nFoundObjects)
							For lnI = 1 To .nFoundObjects
								loPEMEditor.aSelectedObjects(lnI) = loFound(lnI).Object
							Endfor
		
							loPEMEditor.ActivateForm (.T.)
						Endif
		
						.OpenSearchResults (This.ParseSearchFor(This.cSearchFor), , 'Search Results:    ' + This.cSearchFor, loFound)
				Endcase
			Endwith
		Endif
		
	ENDPROC

	PROCEDURE findobjects
		Lparameters tcSearchFor
		
		Local loCollection As 'Collection'
		Local loTopOfForm
		loCollection = Createobject ('Collection')
		
		loTopOfForm = This.FindTopMostParent()
		If Not Isnull (loTopOfForm)
			This.DoFindObjects (loTopOfForm, tcSearchFor, '', loCollection)
		Endif
		
		Return loCollection
		
	ENDPROC

	PROCEDURE findtopmostparent
		Local laObject[1], loTopOfForm
		
		If 0 # Aselobj (laObject, 3)
			This.cSourceFileName = Lower (laObject[2])
			This.lClass			 = Justext (This.cSourceFileName) == 'vcx'
			loTopOfForm			 = This.PEME_FindTopmostParent (laObject[1], This.lClass)
		
			Return loTopOfForm
		
		Else
		
			Return .Null.
		
		Endif
		
	ENDPROC

	PROCEDURE focusoncontrol
		* concept from ControlRenamer by Tamar
		Lparameters loControl, tlWindowAlreadyActive
		
		Local loTopOfForm As Object
		Local laStartMouseObj[1], lcBaseClass, lcWindow, lcWindowName, llFound, llNoWindow
		
		*** JRN 7/10/2012 : Setup; capture current mouse position and window name
		
		If Lower (loControl.BaseClass) = 'formset'
			Return
		Endif
		
		Amouseobj (laStartMouseObj, 1)
		
		Try
			lcWindowName = This.GetMyWindowName(tlWindowAlreadyActive)
			Activate Window (lcWindowName)
			llNoWindow = .F.
		Catch
			llNoWindow = .T.
		Endtry
		
		If llNoWindow
			Return
		Endif
		
		llFound		= .F.
		loTopOfForm	= This.FindTopMostParent()
		
		********************************************************************************
		
		lcBaseClass = Lower(loControl.BaseClass)
		
		Do Case
			Case This.SetFocusToControl(loControl)
		
			Case lcBaseClass = 'pageframe'
				This.ClickOnControl(loControl, lcWindowName, '', .F., loTopOfForm)
		
			Case Inlist(lcBaseClass, 'form', 'page', 'container', 'optiongroup')
				This.ClickOnContainer(loControl, lcWindowName, loTopOfForm)
		
			Otherwise
				This.ClickOnControl(loControl, lcWindowName, 'Shift Control', .T., loTopOfForm)
		Endcase
		
		
		********************************************************************************
		*** JRN 2010-03-06 : Restore mouse to original position
		If Alen (laStartMouseObj) >= 4 And 'O' = Vartype (laStartMouseObj(2))
			Try
				lcWindow = laStartMouseObj(2).Name
				Activate Window (lcWindow)
				Mouse At  laStartMouseObj(4), laStartMouseObj(3)  Pixels Window (lcWindow)
			Catch
		
			Endtry
		Endif
		
		This.RestoreMyWindowName()
		
		Return
		
		
		
	ENDPROC

	PROCEDURE fullobjectnametoclipboard
		Local loObject
		loObject = This.GetOneSelectedObject()
		If 'O' # Vartype (loObject)
			MessageBox(ccLOC_SingleObject)
			Return .F.
		Endif
		
		_Cliptext = This.GetObjectPath (loObject)
		
	ENDPROC

	PROCEDURE getaccessmethodcode
		Lparameters tcName, tcType
		
		Local lcCode
		Do Case
		
				*** JRN 03/02/2009 : following structure used instead of NVL
				* as the #defined variables are multiple lines with ';' for continuation
		
			Case tcType = 'ACCESS' And ('(' $ tcName Or '[' $ tcName)
				lcCode = This.oPrefs.cArrayAccessCode
		
			Case tcType = 'ACCESS'
				lcCode = This.oPrefs.cAccessCode
		
			Case tcType = 'ASSIGN' And ('(' $ tcName Or '[' $ tcName)
				lcCode = This.oPrefs.cArrayAssignCode
		
			Case tcType = 'ASSIGN'
				lcCode = This.oPrefs.cAssignCode
		
		Endcase
		
		Return Strtran(lcCode, 'PEM_Name_Place_Holder', This.JustPEM(tcName)) + ccCR
		
	ENDPROC

	PROCEDURE getallcode
		Lparameters loObject, lcMethodName, lcNamePrefix, tbParentage, tlDefaultOnly
		
		Local lcCode, lcHeaderText, lcInheritedCode, lcResult, lcText 
		
		lcResult = ''
		
		If This.GetPEMStatus (loObject, lcMethodName, 0)
		
			lcCode = loObject.ReadMethod (lcMethodName)
			If tbParentage
				lcInheritedCode = This.GetAllInheritedCode(lcMethodName, loObject, lcNamePrefix)
			Else
				lcInheritedCode = ''
			Endif
		
			If Not (Empty(lcCode) And Empty(lcInheritedCode))
				If (Not Empty (lcCode)) and not tlDefaultOnly
					lcText = 'Procedure ' + Evl(lcNamePrefix, '') + '.' + lcMethodName + ccCRLF		;
						+ lcCode + ccCRLF										;
						+ 'EndProc' + ccCRLF
					lcResult = lcResult + lcText
				Endif
		
				If Not Empty(lcInheritedCode)
					lcResult = lcResult + Iif(Empty(lcCode), '', ccCRLF) + lcInheritedCode
				Endif
			Endif
		Endif
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getallinheritedcode
		Lparameters lcName, loParent, lcNamePrefix
		
		Local  ;
			loParentInfo As Object	,;
			loParentMethods As Object
		Local lcResult, lcText, llQuote, lnI
		
		lcResult = ''
		loParentMethods = This.GetObjectParentClasses (lcName, 'Code', loParent)
		For lnI = 1 To loParentMethods.Count
			loParentInfo = loParentMethods.Item (lnI)
			If loParentInfo.NonDefault
				llQuote = Iif (' ' $ loParentInfo.VCX, ['], '')
				lcText = ccTopDividerLine 						;
					+ '* Class  ' + loParentInfo.Class + ' of ' + llQuote + loParentInfo.VCX + llQuote + ccCRLF ;
					+ Iif (Empty (loParentInfo.Class # loParentInfo.Name), '', '* Object ' + loParentInfo.Name + ccCRLF) ;
					+ 'Procedure ' + lcNamePrefix + '::' + loParentInfo.Name + '.' + Trim (lcName) + ccCRLF + loParentInfo.Code + ccCRLF ;
					+ 'EndProc' + ccCRLF
				lcResult = lcResult + lcText
			Endif
		Endfor
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getclass
		Local loGetClass As 'frmOpenClass' Of  'Source\EditProperty.vcx'
		Local loResult As 'Empty'
		
		If Vartype (This.oFoxRef) # 'O'
			This.oFoxRef = PEME_NewSessionObject ('FoxRef', 'PEME_FoxRefEngine.VCX', This.GetResourceFile())
		Endif
		
		loGetClass = Newobject ('frmOpenClass', 'Source\EditProperty.vcx', '',		;
			This,															;
			This.oFoxRef,															;
			'Class',																;
			.T.)
		loGetClass.Show(1)
		
		If 'O' = Vartype (loGetClass)
			loResult = Createobject('Empty')
			AddProperty(loResult, 'ClassLib', loGetClass.cClassLib)
			AddProperty(loResult, 'Class', loGetClass.cClassName)
			loGetClass.Release
			Return loResult
		Endif
		
		
	ENDPROC

	PROCEDURE getclassfilename
		Lparameters tcClassLoc, tcPath
		
		*** JRN 02/24/2009 : per Doug ... handles cases of absolute paths and relative to current directory
		
		Do Case
			Case ':' $ tcClassLoc
				Return tcClassLoc
		
			Case File ( Fullpath ( m.tcClassLoc, m.tcPath ) )
				Return Fullpath (tcClassLoc, tcPath)
		
			Otherwise
				Return Fullpath ( m.tcClassLoc )
		Endcase
		
	ENDPROC

	PROCEDURE getclassfolders
		Lparameters tcClass, tcFile, tcExt, tcFolder, tlSubFolders
		Local laFileList[1], lcExt, lcFile, lcFolder, lnCount, lnI 
		
		lcFolder = Addbs(tcFolder)
		lnCount = Adir(laFileList, lcFolder + '*.*', 'D')
		
		For lnI = 1 To lnCount
			lcFile = lcFolder + laFileList[lnI,1]
			lcExt = Upper(Justext(lcFile))
			Do Case
				Case tlSubFolders and laFileList[lnI,1] # '.' and 'D' $ laFileList[lnI,5]
					This.getclassfolders(tcClass, tcFile, tcExt, lcFile, tlSubFolders)
				Case Inlist(lcExt, 'VCX', '*')
					This.getclassfromVCX(lcFile)
				Case Inlist(lcExt, 'PRG', '*')
					This.getclassfromPRG(lcFile)
			Endcase
		Endfor
		
		
	ENDPROC

	PROCEDURE getclassfromprg
		Lparameters tcFile
		
		Local  ;
			loMatches As Object	,;
			loRegExp As Object
		Local lcMatch, lnI
		
		If not File(tcFile)
			Return
		EndIf 
		
		loRegExp = This.GetRegExp()
		With loRegExp
			.Pattern	= '^\s*DEFI(|N|NE)\s+CLAS(|S)\s\w+'
		Endwith
		
		* Try to find matches. Returns position of match (origin 1; 0 means no match)
		
		loMatches = loRegExp.Execute (Filetostr(tcFile))
		For lnI = 1 To loMatches.Count
			lcMatch = Chrtran(loMatches.Item(lnI-1).Value, CR + LF + TAB, '   ')
			Insert Into MRU_ProjectClasses (Class, FileName) Values (Getwordnum(lcMatch, 3), Lower(tcFile)) 
		Endfor
		
		
	ENDPROC

	PROCEDURE getclassfromvcx
		Lparameters tcFile
		Local lcExpression, lcObjName, lnClasses, lnI 
		Local laClasses[1]
		
		If Not File(tcFile)
			Return
		Endif
		
		lcExpression = 'Lparam laClasses, tcFile' + Chr(13) + 'AVcxClasses(laClasses, tcFile)'
		Execscript(lcExpression, @laClasses, tcFile)
		
		If Alen(laClasses) > 1
			lnClasses = Alen(laClasses, 1)
			For lnI = 1 To lnClasses
				Insert Into MRU_ProjectClasses (Class, FileName);
					Values (laClasses[lnI, 1], Lower(tcFile))
			Endfor
		Endif
		
		Return
		
		
		
		*!*	lnClasses = AVcxClasses(laClasses, tcFile)
		*!*	For lnI = 1 To lnClasses
		*!*		Insert Into MRU_ProjectClasses (Class, FileName);
		*!*			Values (laClasses[lnI, 1], Lower(tcFile))
		*!*	Endfor
		
		*!*	Return
		
		*!*	Select 0
		*!*	Use (tcFile) Again Alias GF_VCX
		*!*	Insert Into MRU_ProjectClasses;
		*!*		Select objname, Lower(tcFile), Timestamp ;
		*!*		From GF_VCX ;
		*!*		where Reserved1 == 'Class';
		*!*		And Not Deleted()
		*!*	Use
		
	ENDPROC

	PROCEDURE getclasslist
		Lparameters tcClass, tcFile, tlClassLibs, tlProcedures, tlProjectVCXs, tlProjectPRGs, tcFolder, tlSubFolders
		
		Local  ;
			loFile As Object	,;
			loResult As 'Empty'
		Local laLines[1], lcClass, lcExt, lcFile, lcPRG, lcProcedures, lcVCX, lnI, lnLines, lnSelect
		
		lnSelect = Select()
		
		Use In (Select ('MRU_ProjectClasses')) && Close MRU_ProjectClasses
		Create Cursor MRU_ProjectClasses (Class C(240), FileName C(240), Timestamp N(10))
		
		lcClass = Evl(tcClass, '')
		lcFile = Upper(Justfname(Evl(tcFile, '')))
		lcExt = Upper(Justext(Evl(lcFile, '*.*')))
		
		If tlClassLibs And Inlist(lcExt, 'VCX', '*')
			* Check all open class libraries.
			lcProcedures = Upper(Set ('ClassLib'))
			lcProcedures = Strtran (lcProcedures, ';', ',')
			lnLines		 = Alines (laLines, lcProcedures, .T., ',')
			For lnI = 1 To lnLines
				If Not Empty (laLines[lnI])
					lcVCX = Alltrim (laLines[lnI])
					Do Case
						Case '"' $ lcVCX
							lcVCX = Substr (lcVCX, 2, At ('"', lcVCX, 2) - 2)
						Case ' ALIAS ' $ Upper (lcVCX)
							lcVCX = Left (lcVCX, At (' ALIAS ', lcVCX) - 1)
					Endcase
		
					If Justext(lcVCX) == 'VCX';
							and (Empty(lcFile) Or lcFile == Justfname(lcVCX))
						This.getclassfromvcx(lcVCX)
					Endif
				Endif
			Next lnI
		Endif
		
		If tlProcedures And Inlist(lcExt, 'PRG', '*')
			* Check all open procedure files.
			lcProcedures = Upper(Set ('Procedure'))
			lcProcedures = Strtran (lcProcedures, ';', ',')
			lnLines		 = Alines (laLines, lcProcedures, .T., ',')
			For lnI = 1 To lnLines
				If Not Empty (laLines[lnI])
					If Inlist (Justext (laLines[lnI]), 'PRG', 'FXP')
						lcPRG = Forceext (laLines[lnI], 'PRG')
						If Empty(lcFile) Or lcFile == Justfname(lcPRG)
							This.getclassfromprg(lcPRG)
						Endif
					Endif
				Endif
			Next lnI
		Endif
		
		If tlProjectVCXs And _vfp.Projects.Count # 0 And Inlist(lcExt, 'VCX', '*')
			For Each loFile In _vfp.ActiveProject.Files FoxObject
				lcVCX = Upper(loFile.Name)
				If Justext (lcVCX) = 'VCX';
						and (Empty(lcFile) Or lcFile == Justfname(lcVCX))
					This.getclassfromvcx(lcVCX)
				Endif
			Endfor
		Endif
		
		If tlProjectPRGs And _vfp.Projects.Count # 0 And Inlist(lcExt, 'PRG', '*')
			For Each loFile In _vfp.ActiveProject.Files FoxObject
				lcPRG = Upper(loFile.Name)
				If Justext (lcPRG) = 'PRG';
						and (Empty(lcFile) Or lcFile == Justfname(lcPRG))
					This.getclassfromprg(lcPRG)
				Endif
			Endfor
		Endif
		
		If (not Empty(tcFolder)) and Directory(tcFolder)
			This.getclassfolders(lcClass, lcFile, lcExt, tcFolder, tlSubFolders)
		EndIf
		
		Select (lnSelect)
		loResult = Createobject ('Empty')
		AddProperty (loResult, 'List(1)')
		Select  distinct * ;
			From MRU_ProjectClasses  ;
			where Empty(lcClass) Or Upper(Class) == Upper(lcClass);
			Order By Class				   ;
			Into Array loResult.List
		
		If _tally > 0
			Return loResult
		Else
			Return ''
		EndIf 
		
	ENDPROC

	PROCEDURE getcodeorvalue
		Lparameters lcStyle, lcSearchName, loClassDef
		
		Local lcMethodCode, lcPropertyValue, lnPos
		Do Case
		
			Case Empty (lcStyle)
		
			Case lcStyle = 'Code'
				lcMethodCode = Strextract (ccLF + Methods, ccLF + 'procedure ' + lcSearchName + ccCRLF, ccCRLF + 'endproc', 1, 1)
				If Empty (lcMethodCode)
					AddProperty (loClassDef, 'NonDefault', .F.)
				Else
					AddProperty (loClassDef, 'Code', lcMethodCode )
					AddProperty (loClassDef, 'NonDefault', .T.)
				Endif
		
			Case lcStyle = 'Value'
				lnPos = Atc (ccLF + lcSearchName + ' = ', ccLF + properties)
				If lnPos > 0
					lcPropertyValue	 = Substr (properties, lnPos ) && + Len(lcSearchName) + 3)
					AddProperty (loClassDef, 'Value', This.ExtractPropertyValue (lcSearchName, lcPropertyValue))
					AddProperty (loClassDef, 'NonDefault', .T.)
				Else
					AddProperty (loClassDef, 'NonDefault', .F.)
				Endif
		
		Endcase
		
		Return
		
	ENDPROC

	PROCEDURE getcontrolstructurepattern
		#Define 	AnyEnding 				''
		#Define 	WhiteSpacePlusEnding 	'(|\s.*|\;.*|\&\&.*)$'
		
		Local lcPattern
		
		lcPattern = 'PROC(|E|ED|EDU|EDUR|EDURE)\s+(\w|\.)+' + AnyEnding
		lcPattern = lcPattern + '|' + 'FUNC(|T|TI|TIO|TION)\s+(\w|\.)+' + AnyEnding
		lcPattern = lcPattern + '|' + 'DEFINE\s+CLASS\s+\w+' + AnyEnding
		lcPattern = lcPattern + '|' + 'DEFI\s+CLAS\s+\w+' + AnyEnding
		lcPattern = lcPattern + '|' + 'ENDP(|R|RO|ROC)' + AnyEnding
		lcPattern = lcPattern + '|' + 'ENDFU(|N|NC)' + AnyEnding
		lcPattern = lcPattern + '|' + 'ENDD(E|EF|EFI|EFIN|EFINE)' + AnyEnding
		lcPattern = lcPattern + '|' + 'PROT(|E|EC|ECT|ECTE|ECTED)\s+\w+\s+\w+' + AnyEnding
		lcPattern = lcPattern + '|' + 'HIDD(|E|EN)\s+\w+\s+\w+' + AnyEnding
		
		lcPattern = lcPattern + '|' + 'TEXT' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ENDT(|E|EX|EXT)' + WhiteSpacePlusEnding
		
		lcPattern = lcPattern + '|' + 'DO\s+CASE' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'CASE' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'OTHE(|R|RW|RWI|RWISE)' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ENDC(|A|AS|ASE)' + WhiteSpacePlusEnding
		
		lcPattern = lcPattern + '|' + 'DO\s+WHIL(|E)' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ENDD(|O)' + WhiteSpacePlusEnding
		
		lcPattern = lcPattern + '|' + 'IF' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ELSE' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ENDI(|F)' + WhiteSpacePlusEnding
		
		lcPattern = lcPattern + '|' + 'FOR' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ENDF(|O|OR)' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'NEXT' + WhiteSpacePlusEnding
		
		lcPattern = lcPattern + '|' + 'SCAN' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ENDS(|C|CA|CAN)' + WhiteSpacePlusEnding
		
		lcPattern = lcPattern + '|' + 'TRY' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'CATC(|H)' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ENDT(|R|RY)' + WhiteSpacePlusEnding
		
		lcPattern = lcPattern + '|' + 'WITH' + WhiteSpacePlusEnding
		lcPattern = lcPattern + '|' + 'ENDW(|I|IT|ITH)' + WhiteSpacePlusEnding
		
		Return lcPattern
		
	ENDPROC

	PROCEDURE getcontrolstructurepositions
		Lparameters tcCode
		
		Local loRegExp As 'VBScript.RegExp'
		Local loResult As 'Collection'
		Local lcClassName, lcKeyWord, lcMatch, lcMatchEndWords, lcMatchOtherWords, lcMatchStartWords, lcName
		Local lcOrigMatch, lcPattern, lcType, lcWord1, llClassDef, llEndStructure, llProcedureBoundary, llStartStructure
		Local llTextEndText, lnEndByte, lnI, lnLineNumber, lnPosition, loException, loMatches, loObject
		
		* Returns a collection indicating the beginning of each procedure / class / etc
		* Each member in the collection has these properties:
		*   .Type == 'Procedure' (Procedures and Functions)
		*         == 'Class'     (Class Definition)
		*         == 'End Class' (End of Class Definition)
		*         == 'Method'    (Procedures and Functions within a class)
		*         == or any of the following:
		*					DO CASE, ENDCASE, DO WHILE, ENDDO, IF, ELSE, ENDIF, FOR, ENDFOR, SCAN, ENDSCAN, TRY, CATCH, ENDTRY, WITH, ENDWITH
		*   .LineNumber == starts at zero
		*   .Name
		*   .ClassName
		*   .Text      == text of the line
		*   .ProcedureBoundary == .T. for Procedures, Function, Classes, etc.
		*   .StartStructure    == .T. for beginning of control structures (IF, DO CASE, WITH, etc.)
		*   .EndStructure      == .T. for ending of control structures (ENDIF, ENDCASE, ENDWITH, etc.)
		
		****************************************************************
		
		loResult = Createobject ('Collection')
		****************************************************************
		
		loObject = This.GetStructurePositionObject()
		With loObject
			.LineNumber		   = -1
			.Type			   = 'Procedure'
			.ProcedureBoundary = .T.
		Endwith
		lcName = 'Top Of Code'
		loResult.Add (loObject, lcName)
		****************************************************************
		
		loRegExp = Createobject ('VBScript.RegExp')
		With loRegExp
			.IgnoreCase	= .T.
			.Global		= .T.
			.MultiLine	= .T.
		Endwith
		
		****************************************************************
		
		lcCodeWithLFs = tcCode
		Do While .T.
			loRegExp.Pattern = '\x0D[^\x0A]' && CRs not followed by LFs
			loMatches = loRegExp.Execute(lcCodeWithLFs)
		
			If loMatches.Count = 0
				Exit
			Else
				For lnI = loMatches.Count To 1 Step -1
					lnStartByte = loMatches.Item(lnI - 1).FirstIndex
					lcCodeWithLFs = Stuff(lcCodeWithLFs, lnStartByte + 1, 1, Chr(13) + Chr(10))
				Endfor
			Endif
		Enddo
		****************************************************************
		lcPattern = This.GetControlStructurePattern()
		
		With loRegExp
			.Pattern	= '^\s*(' + lcPattern + ')'
		Endwith
		
		loMatches = loRegExp.Execute (lcCodeWithLFs)
		****************************************************************
		
		llClassDef	  = .F. && currently within a class?
		llTextEndText = .F. && currently within a Text/EndText block?
		lcClassName	  = ''
		
		lcMatchStartWords = ' TEXT DOCASE DOWHILE IF FOR SCAN TRY WITH'
		lcMatchEndWords	  = ' ENDTEXT ENDCASE ENDDO ENDIF ENDFOR NEXT ENDSCAN ENDTRY ENDWITH ENDPROC ENDFUNC ENDDEFINE'
		lcMatchOtherWords = ' ELSE CATCH CASE OTHERWISE'
		
		For lnI = 1 To loMatches.Count
		
			* .Value
			* .FirstIndex
			* .Length
			With loMatches.Item (lnI - 1)
		
				* ignore leading CRLF's
				lcLeading 	   = Left( .Value, At(Getwordnum( Chrtran(.Value, CR + LF + Tab, '   '), 1), .Value) - 1) && text before first word
				lnLeadingCRLFs = Max (Rat (CR, lcLeading), Rat (LF, lcLeading))
		
				lnPosition   	= .FirstIndex
				lnLineNumber	= Getwordcount(Left(lcCodeWithLFs, lnPosition + lnLeadingCRLFs), LF)
				lcOrigMatch = Substr(.Value, lnLeadingCRLFs + 1)
				lcMatch		= Chrtran (lcOrigMatch, CR + LF + Tab, '   ')
				lcName		= Getwordnum (lcMatch, Getwordcount (lcMatch))
				lcWord1		= Upper (Getwordnum (lcMatch, Max(1, Getwordcount (lcMatch) - 1)))
		
				lcKeyWord = Upper (Getwordnum (lcMatch, 1))
				lcKeyWord = lcKeyWord + IIf (lcKeyWord = 'DO', Upper (Getwordnum (lcMatch, 2)), '')
			Endwith
		
			llProcedureBoundary	= .F.
			llStartStructure	= .F.
			llEndStructure		= .F.
			llClosingExtraText  = .F.
		
			Do Case
				Case llTextEndText
					If 'ENDTEXT' = lcKeyWord
						lcName		   = ''
						lcType		   = 'ENDTEXT'
						llEndStructure = .T.
						llTextEndText  = .F.
					Else
						Loop
					Endif
		
				Case 'TEXT' = lcKeyWord
					lcName			 = ''
					lcType			 = 'TEXT'
					llStartStructure = .T.
					llTextEndText	 = .T.
					llClosingExtraText  = .T.
		
				Case 'ENDDEFINE' = lcWord1
						llClassDef	= .F.
						lcType		= 'End Class'
						lcName		= lcClassName + '.-EndDefine'
						lcClassName	= ''
					llEndStructure = .T.
					llProcedureBoundary	= .T.
		
				Case 'CLASS' = lcWord1
					llClassDef			= .T.
					lcType				= 'Class'
					lcClassName			= lcName
					llProcedureBoundary	= .T.
					llStartStructure = .T.
		
				*!* * Removed 06/23/2011 
				*!* Case llClassDef
				*!* 	If 'ENDDEFINE' = lcWord1
				*!* 		llClassDef	= .F.
				*!* 		lcType		= 'End Class'
				*!* 		lcName		= lcClassName + '.-EndDefine'
				*!* 		lcClassName	= ''
				*!* 	Else
				*!* 		lcType = 'Method'
				*!* 		lcName = lcClassName + '.' + lcName
				*!* 	Endif
				*!* 	llProcedureBoundary	= .T.
		
				*!* Case 'CLASS' = lcWord1
				*!* 	llClassDef			= .T.
				*!* 	lcType				= 'Class'
				*!* 	lcClassName			= lcName
				*!* 	llProcedureBoundary	= .T.
		
				Case (' ' + lcKeyWord) $ lcMatchStartWords
					lcName			 = ''
					lcType			 = Getwordnum (Substr (lcMatchStartWords, At (' ' + lcKeyWord, lcMatchStartWords) + 1), 1)
					llStartStructure = .T.
					llClosingExtraText  = Inlist(lcType, 'DO', 'IF', 'FOR', 'SCAN', 'TRY', 'WITH')
		
				Case (' ' + lcKeyWord) $ lcMatchEndWords
					lcName		   = ''
					lcType		   = Getwordnum (Substr (lcMatchEndWords, At (' ' + lcKeyWord, lcMatchEndWords) + 1), 1)
					llEndStructure = .T.
		
				Case (' ' + lcKeyWord) $ lcMatchOtherWords
					lcName = ''
					lcType = Getwordnum (Substr (lcMatchOtherWords, At (' ' + lcKeyWord, lcMatchOtherWords) + 1), 1)
		
				Case Upper(lcWord1) = 'PROC'
					lcType				= 'Procedure'
					llProcedureBoundary	= .T.
					llEndStructure = .T.
		
				Otherwise
					lcType				= 'Function'
					llProcedureBoundary	= .T.
					llEndStructure = .T.
		
			Endcase
		
			loObject = This.GetStructurePositionObject()
		
			With loObject
				.LineNumber		   = lnLineNumber
				.Type			   = lcType
				.Name			   = lcName
				.ClassName		   = lcClassName
				.Text			   = lcOrigMatch
				.ProcedureBoundary = llProcedureBoundary
				.StartStructure	   = llStartStructure
				.EndStructure	   = llEndStructure
				.ClosingExtraText  = llClosingExtraText
			Endwith
		
			If Empty (lcName)
				lcName = 'Line ' + Transform (lnLineNumber)
			Endif
		
			Try
				loResult.Add (loObject, lcName)
			Catch To loException When loException.ErrorNo = 2062
				loResult.Add (loObject, lcName + ' ' + Transform (lnLineNumber))
			Catch To loException
				This.ShowErrorMsg (loException)
			Endtry
		
		Endfor
		
		Return loResult
		
	ENDPROC

	PROCEDURE getcurrentincludefile
		*** JRN 2010-12-28 : Returns name of the Include file for the current open form / class
		
		Local lcInclude, lcObjectFile
		If Aselobj (laObjects, 3) # 0
			lcObjectFile = laObjects[2]
			lcInclude	 = laObjects[3]
			If File (lcInclude)
				Return lcInclude
			Endif
		Endif
		
		Return ''
	ENDPROC

	PROCEDURE getcurrentobject
		Lparameters tlTopOfForm
		
		* Parameters:
		*     tlTopOfForm: .T.     == Current form or class
		*               (empty) == Current object
		
		Local loObject
		loObject = This.GetOneSelectedObject()
		
		Do Case
			Case 'O' # Vartype (loObject)
				Return .Null.
			Case Empty (tlTopOfForm)
				Return loObject
			Otherwise
				Return This.FindTopMostParent()
		Endcase
		
		
	ENDPROC

	PROCEDURE getdefaultvalue
		Lparameters lcName
		Local lcFirst, lcDefault, loException, lcCustomPRG
		
		lcFirst  = Left(lcName, 1)
		Do Case
			Case Not Islower(lcFirst)
				*** TODO: set property of oMember instead of setting edtDefault.Value and calling SetXValue
			Case lcFirst = 'c'
				lcDefault = []
			Case lcFirst = 'l'
				lcDefault = .F.
			Case Inlist(lcFirst, 'n', 'i', 'b', 'y')
				lcDefault = 0
			Case lcFirst = 'd'
				lcDefault = {}
			Case lcFirst = 't'
				lcDefault = {/:}
			Case lcFirst = 'o' Or lcFirst = 'u'
				lcDefault = .Null.
			Otherwise
				lcDefault = .F.	
		Endcase
		
		*	lcCustomPRG =  Thisform.cApplicationPath + "GetDefaultValue.PRG"
		lcCustomPRG =  This.GetPlugInPath ("GetDefaultValue")
		If Not Empty(lcCustomPRG)
			Try
				lcDefault = Execscript(Filetostr(lcCustomPRG), lcName)
			Catch To loException
				This.ShowErrorMsg(loException, 'Default Value Failure', lcCustomPRG)
			Endtry
		Endif
		
		Return lcDefault
		
	ENDPROC

	PROCEDURE getincludefiles		&& Returns list of include files
		Lparameters lcSourceText
		
		Local loResult As 'Collection'
		Local lcInclude, lcValue, lnI, loMatches, loRegexp
		
		loRegexp = This.GetRegExp()
		With loRegexp
			.Pattern  = '^\s*#Incl(|u|ud|ude).*$'
			loMatches = .Execute (Strtran(Strtran(lcSourceText, CR + LF, CR), CR, CR + LF))
		Endwith
		
		loResult = Createobject ('Collection')
		For lnI = 0 To loMatches.Count - 1
			lcValue	  = Chrtran (loMatches.Item (lnI).Value, Chr(13) + Chr(10), '')
			lcInclude = Getwordnum (lcValue, 1)
			loResult.Add (Alltrim (Substr (lcValue, At (lcInclude, lcValue) + Len (lcInclude))))
		Endfor
		
		Return loResult
		
	ENDPROC

	PROCEDURE getinheritedcode
		Lparameters lcPem, loObject, llAllLevels
		
		Local lnI, loParents
		loParents = This.GetObjectParentClasses (lcPem, 'Code', loObject)
		
		For lnI = 1 To Min(loParents.Count, IIf (llAllLevels, 1000, 1))
			If loParents (lnI).NonDefault
				Return loParents (lnI).Code
			Endif
		Endfor
		
		Return ''
		
		
		
		
	ENDPROC

	PROCEDURE getinheritedvalue
		Lparameters lcPem, loObject, llAllLevels
		
		Local laProps[1], lcResult, lcType, lnI, loParents
		loParents = This.GetObjectParentClasses (lcPem, 'Value', loObject)
		
		For lnI = 1 To Min(loParents.Count, IIf (llAllLevels, 1000, 1))
			If loParents (lnI).NonDefault
				Return loParents (lnI).Value
			Endif
		Endfor
		
		* note the ordering:  if there is a match to a specific baseclass,
		* it comes first; and the match to the name in general is always last
		Select  Type, cValue, cWidth, lValue, nValue				;
			From DefaultNativeProperties							;
			Where cPropName = Upper (lcPem)							;
				And (Empty (cBaseClass)								;
				  Or cBaseClass = Upper (loObject.BaseClass))		;
			Order By cBaseClass Desc								;
			Into Array laProps
		
		lcType = laProps(1)
		Do Case
			Case _Tally = 0
				Return ''
			Case lcType = 'C'
				Return Left (laProps(2), laProps(3))
			Case lcType = 'L'
				Return laProps(4)
			Case lcType = 'N'
				Return laProps(5)
		Endcase
		
		Return ''
		
		
		
		
	ENDPROC

	PROCEDURE getmywindowname
		Lparameters tlWindowAlreadyActive
		
		Local loTopOfForm AS Object
		Local lcWindowName
		
		With This
			loTopOfForm = This.FindTopMostParent()
			If 'form' = Lower (loTopOfForm.BaseClass)
				lcWindowName = loTopOfForm.Caption
				If 'L' = VarType(.cOriginalCaption) and (Empty(m.lcWindowName) or ! tlWindowAlreadyActive)
					.cOriginalCaption = lcWindowName
					lcWindowName = lcWindowName + Sys(2015)
					loTopOfForm.Caption = lcWindowName
				Endif
			Else
				lcWindowName = (loTopOfForm.Name)
			Endif
		
		Endwith
		
		Return lcWindowName
		
	ENDPROC

	PROCEDURE getnewmethodheader
		Lparameters lcName, lcDescription, lnVisibility
		
		Local lcCode, lcCustomPRG, loException
		
		lcCode = ''
		lcCustomPRG =  This.GetPlugInPath ('GetNewMethodHeader')
		If Not Empty (lcCustomPRG)
			Try
				lcCode = Execscript (Filetostr (lcCustomPRG), lcName, Evl (lcDescription, ''), Evl (lnVisibility, 1))
			Catch To loException
				This.ShowErrorMsg (loException, 'New Method Header Failure', lcCustomPRG)
			Endtry
		Endif
		
		Return lcCode
	ENDPROC

	PROCEDURE getobjectparentclasses
		Lparameters tcPem, tcStyle, toObject
		
		* Returns a collection of all the parent classes for an object
		
		* Each element in the collection is an object with these properties:
		*     Class -- the name of the class
		*     VCX   -- the name of the class library
		*     Name  -- the name of the object relative to the class
		*                empty except for those objects that are member objects in the class
		*                such as a label or textbox within a contain class
		*
		
		* Parameters (all are optional)
		* tcPem:          the name of a pem (case-insensitive) for which non-default
		*                 code or properties are requested.  If non-empty. a property
		*                 named 'NonDefault' is included in the result
		* lcStyle:
		*     	'Code'    includes another property named 'Code' with any non-default code
		*		'Value'   includes another property named 'Property' with any non-default values
		*
		* toObject:  the object for which this is requested.  If not supplied,
		*            the currently selected object is used
		
		Local loClassCollection As 'Collection'
		Local laObjects[1], lcClass, lcClassLib, lcFileName, lcParent, lcPem, lcResult, lcStyle, lnSelect
		Local loDetailInfo, loObject, loSetupInfo, loTopofForm
		
		loClassCollection = Createobject ('Collection')
		
		lcPem	= Evl (tcPem, '')
		lcStyle	= Evl (tcStyle, 'None')
		
		Do Case
			Case 'O' = Vartype (toObject)
				loObject = toObject
			Case 0 # Aselobj (laObjects) Or 0 # Aselobj (laObjects, 1)
				loObject = laObjects(1)
			Otherwise
				Return loClassCollection
		Endcase
		
		lnSelect = Select()
		Select 0
		
		If Empty (lcPem) Or			;
				(This.GetPEMStatus (loObject, lcPem, 5) And This.GetPEMStatus (loObject, lcPem, 6))
		
			loTopofForm = This.FindTopMostParent()
			If This.lClass And loTopofForm = loObject
		
				Use (This.cSourceFileName) Again Shared Alias VCX
				Locate For Lower (OBJNAME) == Lower (loObject.Class) And Lower (RESERVED1) = 'class'
		
				If Found()
					lcClass     = VCX.Class
					lcBaseClass = VCX.BaseClass
					If Not Empty (VCX.ClassLoc)
						lcClassLib = This.GetClassFileName (VCX.ClassLoc, Addbs (JustPath(This.cSourceFileName))) 
					Else
						lcClassLib = ''
					Endif
				Else
					lcClass	    = ''
					lcClassLib  = ''
					lcBaseClass = ''
				Endif
				lcParent = ''
				Use
		
			Else
				lcFileName	= loObject.ClassLibrary
				loSetupInfo	= This.SetupForParentObjectClasses (Lower (loObject.Class), lcFileName, loObject, loTopofForm)
		
				With loSetupInfo
					lcClass	    = .Class
					lcClassLib  = .Classlib
					lcParent    = .Parent
					lcBaseClass = .BaseClass
				Endwith
			Endif
		
			loDetailInfo = This.GoGetParentObjectClasses (loClassCollection, lcClass, lcClassLib, lcParent, loObject.Name, lcStyle, lcPem, lcBaseClass)
			With loDetailInfo
				lcClass	    = .Class
				lcClassLib  = .Classlib
				lcParent    = .Parent
				lcBaseClass = .BaseClass
			Endwith
		
			*** JRN 12/26/2008 : Handling of members (pages, optionbuttons, etc)
			Do Case
				Case loTopofForm = loObject && nothing to do
		
				Case Lower (lcClass) == Lower (loObject.BaseClass) && nothing here either
		
				Case This.GetPEMStatus (loObject.Parent, 'MemberClass', 5)
					loDetailInfo = This.GoGetParentObjectClasses (loClassCollection, loObject.Parent.MemberClass, loObject.Parent.MemberClassLibrary, '', loObject.Name, lcStyle, lcPem, lcBaseClass)
					With loDetailInfo
						lcClass	    = .Class
						lcClassLib  = .Classlib
						lcParent    = .Parent
						lcBaseClass = .BaseClass
					Endwith
		
				Case This.GetPEMStatus (loObject.Parent, 'HeaderClass', 5)
					loDetailInfo = This.GoGetParentObjectClasses (loClassCollection, loObject.Parent.HeaderClass, loObject.Parent.HeaderClassLibrary, '', loObject.Name, lcStyle, lcPem, lcBaseClass)
					With loDetailInfo
						lcClass	    = .Class
						lcClassLib  = .Classlib
						lcParent    = .Parent
						lcBaseClass = .BaseClass
					Endwith
		
			Endcase
		
		Endif
		
		Select (lnSelect)
		Return loClassCollection
		
		
		
	ENDPROC

	PROCEDURE getobjectpath
		Lparameters loObject
		
		Local loTopOfForm As Object
		Local lcCaption
		
		loTopOfForm	= This.FindTopMostParent ()
		
		lcCaption	= ''
		Do While loObject # loTopOfForm
			If Upper(loObject.BaseClass) # "DATAENVIRONMENT"
				lcCaption = '.' + loObject.Name + lcCaption
				If 'O' = Type ('loObject.Parent')
					loObject = loObject.Parent
				Else
					Exit
				Endif
			Else
				lcCaption = loObject.Name + lcCaption
				Exit
			Endif
		Enddo
		
		Return lcCaption
		
	ENDPROC

	PROCEDURE getoneselectedobject
		Local laObjects[1], lnObjects
		
		Do Case
		
			Case 'O' # Vartype (This.oPEMEditor) or not This.oPEMEditor.lUseCSO
		
				lnObjects = Aselobj (laObjects)
		
				Do Case
					Case lnObjects = 1
						Return laObjects(1)
					Case lnObjects > 1
						Return .Null.
					Case 1 = Aselobj (laObjects, 1)
						Return laObjects(1)
					Otherwise
						Return .Null.
				Endcase
		
			Case 1 = This.oPEMEditor.nSelectedObjects
				Return This.oPEMEditor.oObject
		
			Otherwise
				Return .Null.
		
		Endcase
	ENDPROC

	PROCEDURE getparentobjects
		Lparameters loObject, laParents
		Local loTopOfForm AS Object
		
		loTopOfForm = This.FindTopMostParent()
		laParents(1) = loObject
		Do While loObject # loTopOfForm And This.GetPEMStatus(loObject, 'Parent', 5) And "O" = Type ("loObject.Parent")
			loObject = loObject.Parent
			Dimension laParents( 1 + Alen (laParents))
			Ains (laParents,1)
			laParents (1) = loObject
		Enddo
		
	ENDPROC

	PROCEDURE getpemvalue
		Lparameters loObject, lcPem, lxDefaultValue
		
		If This.GetPEMStatus(loObject, lcPem, 5)
			Return Getpem (loObject, lcPem)
		Else
			Return lxDefaultValue
		Endif
		
	ENDPROC

	PROCEDURE getprocedurestartpositions
		Lparameters tcCode, tcName
		
		Local loObject As 'Empty'
		Local loRegExp As 'VBScript.RegExp'
		Local loResult As 'Collection'
		Local lcClassName, lcMatch, lcName, lcPattern, lcType, lcWord1, llClassDef, llTextEndText, lnI
		Local lnStartByte, loException, loMatches
		
		* Returns a collection indicating the beginning of each procedure / class / etc
		* Each member in the collection has these properties:
		*   .Type == 'Procedure' (Procedures and Functions)
		*         == 'Class'     (Class Definition)
		*         == 'End Class' (End of Class Definition)
		*         == 'Method'    (Procedures and Functions within a class)
		*   .StartByte == starts at zero; thus, # of chars preceding start position
		*   .Name
		*   .ClassName
		
		****************************************************************
		loRegExp = Createobject ('VBScript.RegExp')
		With loRegExp
			.IgnoreCase	= .T.
			.Global		= .T.
			.MultiLine	= .T.
		Endwith
		
		lcPattern = 'PROC(|E|ED|EDU|EDUR|EDURE)\s+(\w|\.)+'
		lcPattern = lcPattern + '|' + 'FUNC(|T|TI|TIO|TION)\s+(\w|\.)+'
		lcPattern = lcPattern + '|' + 'DEFINE\s+CLASS\s+\w+'
		lcPattern = lcPattern + '|' + 'DEFI\s+CLAS\s+\w+'
		lcPattern = lcPattern + '|' + 'ENDD(E|EF|EFI|EFIN|EFINE)\s+'
		*!* * Removed 8/29/2012 / JRN
		*!* lcPattern = lcPattern + '|' + 'PROT(|E|EC|ECT|ECTE|ECTED)\s+\w+\s+\w+'
		*!* lcPattern = lcPattern + '|' + 'HIDD(|E|EN)\s+\w+\s+\w+'
		
		With loRegExp
			.Pattern	= '^\s*(' + lcPattern + ')'
		Endwith
		
		loMatches = loRegExp.Execute (tcCode)
		****************************************************************
		
		loResult = Createobject ('Collection')
		
		llClassDef	  = .F. && currently within a class?
		illTextEndText = .F. && currently within a Text/EndText block?
		lcClassName	  = ''
		
		For lnI = 1 To loMatches.Count
		
			* .Value
			* .FirstIndex
			* .Length
			With loMatches.Item (lnI - 1)
				lnStartByte	= .FirstIndex
				lcMatch		= Chrtran (.Value, CR + LF, '  ')
				lcName		= Getwordnum (lcMatch, Getwordcount (lcMatch))
				lcWord1		= Upper (Getwordnum (lcMatch, Max(1, Getwordcount (lcMatch) - 1)))
			Endwith
		
			Do Case
				Case llTextEndText
					If 'ENDTEXT' = lcWord1
						llTextEndText = .F.
					Endif
					Loop
		
				Case llClassDef
					Do Case
						Case 'ENDDEFINE' = lcWord1
							llClassDef	= .F.
							lcType		= 'End Class'
							lcName		= lcClassName + '.-EndDefine'
							lcClassName	= ''
						*!* * Removed 8/29/2012 / JRN
						*!* Case ('HIDDEN' = Upper(lcName) or 'PROTECTED' = Upper(lcName)) and 2 = Getwordcount (lcMatch) 
						*!* 	Loop 
						Otherwise 
							lcType = 'Method'
							lcName = lcClassName + '.' + lcName
					Endcase
		
				Case 'CLASS' = lcWord1
					llClassDef	= .T.
					lcType		= 'Class'
					lcClassName	= lcName
					
				Otherwise
					lcType = 'Procedure'
		
			Endcase
		
			* ignore leading CRLF's
			Do While Substr (tcCode, lnStartByte + 1, 1) $ CR + LF
				lnStartByte = lnStartByte + 1
			Enddo
		
			loObject = Createobject ('Empty')
			AddProperty (loObject, 'Type')
			AddProperty (loObject, 'StartByte')
			AddProperty (loObject, 'Name')
			AddProperty (loObject, 'ClassName')
		
			With loObject
				.StartByte = lnStartByte
				.Type	   = lcType
				.Name	   = lcName
				.ClassName = lcClassName
			Endwith
		
			Try
				loResult.Add (loObject, lcName)
			Catch To loException When loException.ErrorNo = 2062
				loResult.Add (loObject, lcName + ' ' + Transform (lnStartByte))
			Catch To loException
				This.ShowErrorMsg(loException)
			Endtry
		
		
		Endfor
		
		Return loResult
		
	ENDPROC

	PROCEDURE getregexp
		Local loRegExp As 'VBScript.RegExp'
		
		loRegExp = Createobject ('VBScript.RegExp')
		With loRegExp
			.IgnoreCase	= .T.
			.Global		= .T.
			.MultiLine	= .T.
		Endwith
		
		Return loRegExp
		
	ENDPROC

	PROCEDURE getresourcefile
		*** JRN 02/10/2009 : Use own resource file, rather than FoxUser
		Local lcMyFile, lcResourceFile
		
		lcResourceFile =  (Home(7) + 'PEMEditor_Preferences.DBF')
		lcMyFile	   = 'PEMEditor_Preferences'
		If File (lcMyFile + '.DBF')
			Try
				Use (lcMyFile) Shared Again In 0 Alias My_Resources
				lcResourceFile = Dbf ('My_Resources')
				Use In My_Resources
			Catch
			Endtry
		Endif
		
		Return lcResourceFile
	ENDPROC

	PROCEDURE getstructurepositionobject
		Local loObject As 'Empty'
		
		loObject = Createobject ('Empty')
		AddProperty (loObject, 'Type')
		AddProperty (loObject, 'LineNumber')
		AddProperty (loObject, 'Name')
		AddProperty (loObject, 'ClassName')
		AddProperty (loObject, 'Text')
		AddProperty (loObject, 'ProcedureBoundary')
		AddProperty (loObject, 'StartStructure')
		AddProperty (loObject, 'EndStructure')
		AddProperty (loObject, 'ClosingExtraText')
		
		Return loObject
		
	ENDPROC

	PROCEDURE getthis
		Local lcMethodName, lcObjectName, lcWonTop, llFullPath, loEditorWin, loObject, loThis, loTools
		Local loTopOfForm
		
		loEditorWin = This.oEditorWin
		If loEditorWin.FindWindow() # 10
			Return
		Endif
		
		loTopOfForm	= This.GetCurrentObject (.T.)
		loThis		= This.GetCurrentObject (.F.)
		
		*** JRN 2010-04-03 : get name of window on top; correcting as well for reference to top of form/class
		lcWonTop = loEditorWin.GetTitle()
		lcWonTop = Alltrim (Chrtran (Upper (lcWonTop), '*', ' '))
		Do Case
			Case '(' $ lcWonTop
				lcWonTop   = Juststem(Left (lcWonTop, At ('(', lcWonTop) - 1))
				llFullPath = .T.
			Case '.PROCEDURES.PRG' = Right (lcWonTop, 15) And '._' $ lcWonTop
				*	lcWonTop   = Left (lcWonTop, rAt ('._', lcWonTop) - 1)
				lcWonTop   = Left (lcWonTop, Len (lcWonTop) - 15)
				llFullPath = .T.
			Otherwise
				llFullPath = .F.
		Endcase
		
		If lcWonTop = Upper (loTopOfForm.Name) + '.'
			lcWonTop = Substr (lcWonTop, At ('.', lcWonTop))
		Endif
		lcWonTop = Alltrim ( Chrtran (lcWonTop, '-', ''))
		
		Do Case
			Case llFullPath && we got the full path already (parens indicated timestamp)
				If 'O' = Type ('loTopOfForm' + lcWonTop)
					Return Evaluate ('loTopOfForm' + lcWonTop)
				Endif
				lcMethodName = Left (lcWonTop, Rat ('.', lcWonTop) - 1)
			Case lcWonTop = Upper (loTopOfForm.Name + '.') && matches current object?
				Return loThis
			Otherwise
				lcMethodName = Left (lcWonTop, At ('.', lcWonTop) - 1)
		Endcase
		
		If Empty(lcMethodName)
			loObject	 = loTopOfForm
		Else
			lcObjectName = '.' + lcMethodName
			loObject	 = This.GoToDefThis (loTopOfForm, lcObjectName)
		Endif
		Return loObject
		
		
	ENDPROC

	PROCEDURE gogetparentobjectclasses
		Lparameters loCollection, lcClass, lcClassLib, lcParent, lcObjectName, lcStyle, lcPEM, lcBaseClass
		
		Local loClassDef AS 'Empty'
		Local loException AS Object
		Local loResult AS 'Empty'
		Local lbFileOpened, lcCurrentParent, lcMethodCode, lcObjectPathName, lcParent2, lcResult, lcSearchName
		Local lcTempObject, lcUseTable, lnRecno 
		
		lcResult = ''
		Select 0
		
		* This apparently awkward construction chosen to avoid conflicts where the name
		* of the VCX is the same as the name of a VCX used by PEM Editor
		
		Text to lcUseTable NoShow
		Lparameters lcTable
		Use (lcTable)Again Shared Alias VCX
		EndText 
		
		Do While Not Empty (lcClassLib)
		
			loClassDef = Createobject ('Empty')
			AddProperty (loClassDef, 'Class', lcClass)
			AddProperty (loClassDef, 'BaseClass', lcBaseClass)
			AddProperty (loClassDef, 'VCX', lcClassLib)
			AddProperty (loClassDef, 'ErrorMsg', '')
			AddProperty (loClassDef, 'Name', lcClass)
			AddProperty (loClassDef, 'NonDefault', .F.)
		
			Try
				ExecScript(lcUseTable, lcClassLib)
				lbFileOpened = .T.
			Catch To loException
				lbFileOpened = .F.
				lcResult = lcResult	+ ccBottomDividerLine												;
					+ Strtran (ccLOC_ViewParentCode_File_Failed, '<FileName>', "'" + lcClassLib + "'")	;
					+ ccCRLF + loException.Message														;
					+ ccCRLF + ccCRLF
				lcClassLib			= '' && all done, can't even open file
				loClassDef.ErrorMsg	= lcResult 
			Endtry
		
			If lbFileOpened
				lcSearchName = Lower (lcPEM)
				If Empty (lcParent) && simple case ... this object defined here
					lcObjectPathName = lcClass
					Locate For Lower (OBJNAME) == lcClass And Lower (RESERVED1) = 'class'
					This.GetCodeOrValue (lcStyle, lcSearchName, loClassDef)
					lcBaseClass = VCX.BaseClass
		
				Else && this object inherited as object in parent class
		
					* (1)  have to back up through parentage to see where this object is defined in the class
					* (2)  for some objects, the method code may be saved farther back!
					lcObjectPathName = lcParent + '.' + lcObjectName
					lnRecno			 = 0
					lcTempObject	 = Lower (lcObjectPathName)
					lcCurrentParent	 = lcParent
					lcMethodCode	 = ''
					loClassDef.Class = GetWordNum(lcObjectPathName, 1, '.')
					loClassDef.Name  = lcObjectPathName
					Do While Not Empty (lcTempObject) And Empty (lcMethodCode)
						Locate For lcTempObject == Lower ( IIf (Empty (Parent), '', Parent + '.') + OBJNAME) ;
							And (Lower (RESERVED1) # 'class' Or Not '.' $ lcTempObject)
						If Found() And (lnRecno = 0 Or Inlist (Lower (BaseClass), 'pageframe', 'grid'))
							lcParent2 = Substr (lcCurrentParent, 2 + Len ( lcTempObject))
							If lnRecno = 0
								lnRecno = Recno()
								Do Case
									Case Len ( lcTempObject) > Len (lcCurrentParent)
										lcParent	 = ''
										lcSearchName = lcPEM
									Case Empty (lcParent2)
										lcParent	 = VCX.Class
										lcSearchName = lcObjectName + '.' + lcPEM
									Otherwise
										lcParent	 = VCX.Class + '.' + lcParent2
										lcSearchName = lcParent2 + '.' + lcObjectName + '.' + lcPEM
								Endcase
							Endif
							This.GetCodeOrValue (lcStyle, lcSearchName, loClassDef)
						Endif
		
						If '.' $ lcTempObject
							lcTempObject = Juststem (lcTempObject)
						Else
							lcTempObject = ''
						Endif
		
					Enddo
		
					If lnRecno # 0
						Goto (lnRecno)
					Endif
		
				Endif
		
				If Found()
					lcClass     = VCX.Class
					lcBaseClass = VCX.BaseClass
					Do Case
						Case lcStyle = 'Code' And (ccCRLF + '*' + Lower (lcPEM) + ' ') $ ccCRLF + Reserved3
							lcClassLib = .F. && custom in this class; don't go any further
						Case lcStyle = 'Value' And (ccCRLF + Lower (lcPEM) + ' ' ) $ ccCRLF + Strtran (Reserved3, ccCRLF, ' ' + ccCRLF)
							lcClassLib = .F. && custom in this class; don't go any further
						Case Empty (VCX.ClassLoc)
							lcClassLib = .F. && baseclass
						Otherwise
							*** DougHennig 12/06/2008: VCX.ClassLoc is relative to the open class library
							lcClassLib = This.GetClassFileName (VCX.ClassLoc, Addbs (Justpath (lcClassLib)))
					Endcase
		
				Else
					lcResult = lcResult	+ ccBottomDividerLine											;
						+ Strtran (Strtran (ccLOC_ViewParentCode_Class_Failed, '<FileName>', "'" + lcClassLib + "'"), '<ClassName>', lcObjectPathName ) ;
						+ ccCRLF + ccCRLF
					loClassDef.ErrorMsg	= lcResult
					lcClassLib			= ''
				Endif
		
			Endif
		
			loCollection.Add (loClassDef)
			Use
		
		Enddo
		
		Use In (Select ('VCX'))
		
		loResult = Createobject ('Empty')
		AddProperty (loResult, 'Result', 	loClassDef)
		AddProperty (loResult, 'Class', 	lcClass)
		AddProperty (loResult, 'BaseClass', lcBaseClass)
		AddProperty (loResult, 'ClassLib', 	lcClassLib)
		AddProperty (loResult, 'Parent', 	lcParent)
		
		Return loResult
		
	ENDPROC

	PROCEDURE gotodefthis
		Lparameters loObject, lcObjectName
		
		Local lcTarget, lnControlCount, lnI, loChild, loResult, loTarget
		lcTarget = 'loObject' + lcObjectName
		
		If 'O' = Type (lcTarget)
			loTarget		 = Evaluate (lcTarget)
			Return loTarget
		Endif
		
		lnControlCount = This.GetControlCount (loObject)
		
		If lnControlCount # 0 And 'O' = Type ('loObject.Objects(1)')
		
			For lnI = 1 To lnControlCount
				loChild	 = loObject.Objects (lnI)
				loResult = This.GoToDefThis (loChild, lcObjectName)
				If 'O' = Vartype (loResult)
					Return loResult
				Endif
			Endfor
		
		Endif
		
	ENDPROC

	PROCEDURE idetoolshelp
		Local loLink, lcLink 
		lcLink = [http://github.com/VFPX/PEMEditor]
		loLink = Newobject ('_ShellExecute', Home() + 'FFC\_Environ.vcx')
		loLink.ShellExecute (lcLink)
		
	ENDPROC

	HIDDEN PROCEDURE Init
		Lparameters  lcApplicationPath, loPrefs, loEditorWin
		
		With This
		
			.cApplicationPath = lcApplicationPath
			.oPrefs			  = loPrefs
			.oEditorWin		  = loEditorWin
		
			.cApplication = .cApplicationPath + 'PEMEditor.APP'
			.cSourcePath  = Addbs (.cApplicationPath + 'Source')
			.cSnippetPath = Addbs (.cApplicationPath + 'Dynamic Snippets')
			.cPlugInPath  = Addbs (.cApplicationPath + 'Live Plug-Ins')
		
			.oServer		 = Newobject ('PEMEditor_Server', 	'Source\PEME_Server.PRG', '')
		
			.oBeautifyX 	 = Newobject ('Beautify', 			'Source\PEME_Beautify.VCX', 		''	;
				  , This, .oPrefs, .oEditorWin, Filetostr (.cApplicationPath + 'Tables\SystemMemoryVariables.txt'))
		
			.oIDEx			 = Newobject ('PEMEditor_IDEx', 	'Source\PEME_IDEx.VCX', 			''	;
				  , This, .oPrefs, .oEditorWin, .cSnippetPath)
		
			****************************************************************
		
			.CreateTempFilesList()
		
			.OpenTables()
			
		Endwith
		
		Set Library To (Home() + 'FoxTools.fll') Additive
		
	ENDPROC

	PROCEDURE isnumber
		Lparameters tcString
		Local lcString, lcChar, lbDot, lbDigit, lnI
		
		lcString = Alltrim(tcString)
		For lnI = 1 To Len(lcString)
			lcChar = Substr(lcString,lnI,1)
			Do Case
				Case lcChar = '-'
					If lnI # 1
						Return .F.
					Endif
				Case lcChar = '.'
					If lbDot
						Return .F.
					Endif
					lbDot = .T.
				Case Isdigit(lcChar)
					lbDigit = .T.
				Otherwise
					Return .F.
			Endcase
		Next lnI
		Return lbDigit
		
	ENDPROC

	PROCEDURE isreadonly
		Lparameters loObject, lcPem
		
		Local lbResult
		
		Try
			lbResult = This.GetPEMStatus ( loObject, lcPem, 1 )
		Catch
			lbResult = .F.
		Endtry
		
		Return lbResult
		
	ENDPROC

	PROCEDURE justpem
		* Strip any index off the member name and convert it to lower case if necessary.
		
		Lparameters tcPEM, ;
			tlLowerCase
		Local lcPem
		lcPem = Trim(tcPEM)
		Do Case
			Case '[' $ lcPem
				lcPem = Left(lcPem, At('[', lcPem) - 1)
			Case '(' $ lcPem
				lcPem = Left(lcPem, At('(', lcPem) - 1)
		Endcase
		Return Iif(tlLowerCase, Lower(lcPem), lcPem)
		
	ENDPROC

	PROCEDURE movecontrolsincontainer
		Lparameters loControl
		
		Local loCollection As 'Collection'
		Local loItem As 'Empty'
		Local lnI, loChild
		loCollection = Createobject('Collection')
		For lnI = 1 To loControl.ControlCount
			loChild = loControl.Controls[lnI]
			If Pemstatus(loChild, 'Left', 5)
				loItem = Createobject('Empty')
				AddProperty(loItem, 'Object', loChild)
				AddProperty(loItem, 'Left', loChild.Left)
				AddProperty(loItem, 'NonDefault', Pemstatus(loChild, 'Left', 0))
				loCollection.Add(loItem)
		
				loChild.Left = 100 + loControl.Width
			Endif
		Endfor
		Return loCollection
		
	ENDPROC

	PROCEDURE opensearchresults
		Lparameters lcPEM, llSort, lcTitleCaption, loFound
		Local lcAppPath, lnI
		
		lcPEM = Evl (lcPEM, '')
		If '[' $ lcPEM
			lcPEM = Left (lcPEM, At ('[', lcPEM) - 1)
		Endif
		
		With This
			If 'O' # Vartype (This.oSearchResults)
				lcAppPath		= This.cApplicationPath + 'PEMEditor.app'
				.oSearchResults	= Newobject ('frmSearchResults', 'Source\EditProperty.vcx', lcAppPath, This)
			Endif
		
			With .oSearchResults
				.oPEMEditor	= This.oPEMEditor
				.oPrefs		= This.oPrefs
				.oUtils		= This
		
				.cApplicationPath	 = This.cApplicationPath
				.cPlugInPath		 = This.cPlugInPath
				.cSourceFileName	 = This.cSourceFileName
				.lAvoidBufferOverrun = This.oPrefs.lAvoidBufferOverrun
				.lClass				 = This.lClass
				.oTopOfForm			 = This.FindTopMostParent()
		
				If 'O' = Vartype (loFound)
					Dimension .ASelectedObjectNames (loFound.Count)
					For lnI = 1 To loFound.Count
						.ASelectedObjectNames (lnI) = loFound (lnI).FullObjectName
					Endfor
				Else
					Dimension .ASelectedObjectNames (This.oPEMEditor.nSelectedObjects)
					For lnI = 1 To This.oPEMEditor.nSelectedObjects
						.ASelectedObjectNames (lnI) = This.GetObjectPath (This.oPEMEditor.ASelectedObjects(lnI))
					Endfor
				Endif
		
				If 'C' = Vartype (lcTitleCaption)
					.Caption = Left (lcTitleCaption, 255)
				Endif
		
				.CreateGridRows (llSort)
				.RefreshForm()
		
				If Not Empty (lcPEM)
					.AddPEMs (lcPEM)
				Endif
		
				.Show()
		
			Endwith
		Endwith
		
	ENDPROC

	PROCEDURE opentables		&& Programmatically opens the tables and views associated with the data environment.
		
		Use (This.cApplicationPath + 'Tables\Property List') 				Alias PropertyList 				Again In 0 Shared Order Name
		Use (This.cApplicationPath + 'Tables\Default Native Properties') 	Alias DefaultNativeProperties	Again In 0 Shared
		
		Try
			Use (This.cPlugInPath + 'Buffer OverRun Avoidance List') 		Alias BufferOverrunList			Again In 0 Shared
		Catch
			Try
				Use (This.cApplicationPath + 'Buffer OverRun Avoidance List') 			Alias BufferOverrunList			Again In 0 Shared
			Catch
		
			Endtry
		Endtry
		
	ENDPROC

	PROCEDURE open_vfp_keywords
		If Not Used('VFP_Keywords')
			Try
				Use Home() + 'WIZARDS\FDKEYWRD' Order TOKEN Again Shared In 0 Alias Keywords
				Select TOKEN From Keywords Into Cursor VFP_Keywords Readwrite
				Index On Upper(TOKEN) Tag TOKEN
				Use In Keywords
			Catch
			Endtry
		Endif
		
	ENDPROC

	PROCEDURE parsesearchfor
		Lparameters lcText
		
		Local laWords[1], lcChar, lcMatchChar, lcResult, lcThisWord, lcUpper, lcWord, lnI, lnMatchPos
		Local lnWordCount
		
		lcResult	= ''
		lnWordCount	= 0
		lcThisWord	= ''
		*** JRN 2010-10-03 : collect list of words; text within quotes is kept as well, with leading '
		For lnI = 1 To Len (lcText)
			lcChar = Substr (lcText, lnI, 1)
			If lcChar $ NOTNAMECHARS
				If Not Empty (lcThisWord)
					lnWordCount = lnWordCount + 1
					Dimension laWords (lnWordCount)
					laWords (lnWordCount) = lcThisWord
				Endif
				lcThisWord = ''
		
				If lcChar $ ['"] + '['
					lcMatchChar	= IIf (lcChar = '[', ']', lcChar)
					lnMatchPos	= At (lcMatchChar, Substr (lcText, lnI + 1))
					If lnMatchPos = 0
						lnI = Len (lcText)
					Else
						lnWordCount = lnWordCount + 1
						Dimension laWords (lnWordCount)
						laWords (lnWordCount) = ['] + Substr (lcText, lnI + 1, lnMatchPos - 1)
						lnI = lnI + lnMatchPos
					Endif
				Endif
		
			Else
				lcThisWord = lcThisWord + lcChar
			Endif
		Endfor
		
		*** JRN 2010-10-03 : get the last word, if any
		If Not Empty (lcThisWord)
			lnWordCount = lnWordCount + 1
			Dimension laWords (lnWordCount)
			laWords (lnWordCount) = lcThisWord
		Endif
		
		*** JRN 2010-10-03 : result; special case for keywords followed by quoted text
		lcResult = ''
		For lnI = 1 To lnWordCount
			lcWord	= laWords (lnI)
			lcUpper	= Upper (lcWord)
			Do Case
				Case '.' $ lcWord
					lcResult = lcResult + IIf (Empty (lcResult), '', ', ') + Justext (lcWord)
				Case lnI = lnWordCount
		
				Case laWords (lnI + 1) = [']		;
						And (lcUpper == 'EXISTS' Or lcUpper == 'NONDEFAULT' Or lcUpper == 'HASCODE')
					lcResult = lcResult + IIf (Empty (lcResult), '', ', ') + Substr (laWords (lnI + 1), 2)
			Endcase
		Endfor
		Return lcResult
		
	ENDPROC

	PROCEDURE pasteobject
		Local loDestObject As Object
		Local loSourceObject As Object
		Local lbFailed, lcTempName1, loException, loObject, loTopOfForm
		
		If Alen (This.oServer.aCopiedProperties, 2) <= 1
			Messagebox('You must copy (for comparing and pasting) first')
			Return
		Endif
		
		loObject = This.GetOneSelectedObject()
		If 'O' # Vartype(loObject)
			Messagebox(ccLOC_SingleObject)
			Return
		Endif
		
		loTopOfForm = This.FindTopMostParent()
		
		Do Case
			Case This.GetPEMStatus (loObject, 'objects', 5)
				loSourceObject = loObject
			Case loObject # loTopOfForm
				loSourceObject = loObject.Parent
			Otherwise
				Return
		Endcase
		
		*** Create new object
		lcTempName1 = This.oServer.cCopyClassBaseClass + '_' + Sys(2015)
		
		Try
			loSourceObject.Newobject (lcTempName1, This.oServer.cCopyClass, This.oServer.cCopyClassLibrary)
			loDestObject = loSourceObject.&lcTempName1
		Catch To loException
			This.ShowErrorMsg (loException)
			lbFailed = .T.
		Endtry
		
		If lbFailed
			Return
		Endif
		
		With This
			If .SelectPastedProperties (loDestObject, '')
				.DoPasteProperties (loDestObject)
		
				If This.GetPEMStatus (loDestObject, 'Top', 5)
					If This.GetPEMStatus (loDestObject, 'Top', 0)
						loDestObject.Top = loDestObject.Top + 8
					Endif
		
					Do Case
						Case Lower(loDestObject.Parent.BaseClass) = 'column'
		
						Case Lower(loDestObject.Parent.BaseClass) = 'page'
							loDestObject.Top = Max(0, Min (loDestObject.Top, loDestObject.Parent.Parent.PageHeight - loDestObject.Height - 8))
						Otherwise
							loDestObject.Top = Max(0, Min (loDestObject.Top, loDestObject.Parent.Height - loDestObject.Height - 8))
					Endcase
				Endif
		
				If This.GetPEMStatus (loDestObject, 'Left', 5)
					If This.GetPEMStatus (loDestObject, 'Left', 0)
						loDestObject.Left = loDestObject.Left + 8
					Endif
		
					Do Case
						Case Lower(loDestObject.Parent.BaseClass) = 'column'
		
						Case Lower(loDestObject.Parent.BaseClass) = 'page'
							loDestObject.Left = Max(0, Min (loDestObject.Left, loDestObject.Parent.Parent.PageWidth - loDestObject.Width - 8))
						Otherwise
							loDestObject.Left = Max(0, Min (loDestObject.Left, loDestObject.Parent.Width - loDestObject.Width - 8))
					Endcase
				Endif
		
				.SetCurrentSelectedObject (loDestObject)
			Else
				Try
					loSourceObject.RemoveObject (lcTempName1)
				Catch
		
				Endtry
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE pasteproperties
		Local loObject
		
		If Alen (This.oServer.aCopiedProperties, 2) <= 1
			MessageBox('You must copy (for comparing and pasting) first')
			Return
		EndIf 
		
		loObject = This.GetOneSelectedObject()
		If 'O' # Vartype(loObject)
			MessageBox(ccLOC_SingleObject)
			Return
		Endif
		
		With This
			If .SelectPastedProperties (loObject, '')
				.DoPasteProperties(loObject)
				.SetCurrentSelectedObject (loObject)
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE peme_findtopmostparent
		* Find the top-most parent object for the specified object. The complication is
		* that the top level container is a Formset in the Form and Class Designers,
		* and even worse, one level down from the Formset is a Form for non-form
		* classes in the Class Designer. So, we need to be careful about finding the
		* top-most parent object.
		
		* Unfortunately, there's no way to distinguish between a FormSet and a Form
		* open in the Form Designer. In both cases, the FormSet is a baseclass. So,
		* this code just returns a reference to the form.
		
		Lparameters toObject,		;
			tlClass
		Local llClass, loObject1, loObject2
		
		* Determine if we're in the Class or Form Designer.
		
		llClass = IIf (Pcount() = 1, Upper (Wontop()) = 'CLASS DESIGNER', tlClass)
		Store toObject To loObject1, loObject2
		
		* Go up the containership hierarchy until we hit a form.
		
		Do While Type ('loObject1.Parent.Name') = 'C' And			;
				Not Upper (loObject1.BaseClass) == 'FORM' And		;
				Not Upper (loObject1.BaseClass) == 'TOOLBAR'
		
			loObject2 = loObject1
			loObject1 = loObject1.Parent
		Enddo While Type ('loObject1.Parent.Name') = 'C' ...
		Do Case
		
				* If the form's parent is a non-baseclass FormSet, we're modifying a FormSet in
				* the Class Designer, return a reference to the formset.
		
			Case Upper (loObject2.BaseClass) == 'FORMSET'
		
			Case Upper (loObject1.Parent.BaseClass) == 'FORMSET' And		;
					Not Empty (loObject1.Parent.ClassLibrary)
				loObject2 = loObject1.Parent
		
				*** JRN 2009-09-26 : Courtesy of Burkhart Stiller 
				* for a SCX based formset, the form does not have 'BufferMode'
			Case (Not llClass) And Upper (loObject1.Parent.BaseClass) == 'FORMSET'		;
					And Not This.GetPEMStatus (loObject1, 'BufferMode', 5)
				loObject2 = loObject1.Parent
		
				* If the form is a baseclass Form and we're in the Class Designer, we're
				* modifying a non-form class, so already have the correct object reference.
		
			Case llClass And Upper (loObject1.Class) == 'FORM'
		
				* For all other cases (a form class open in the Class Designer or a form open
				* in the Form Designer), return a reference to the form.
		
			Otherwise
				loObject2 = loObject1
		Endcase
		
		Return loObject2
		
	ENDPROC

	PROCEDURE refreshform
		If 'O' = Vartype (This.oPEMEditor)
			This.oPEMEditor.DoRefresh()
		Endif
	ENDPROC

	PROCEDURE refreshforms
		Local laForms(1), lcForm, lnI
		
		ALines(laForms, 'This.oPEMEditor,This.oDocTreeView', .T., ',')
		For lnI = 1 to 2
			lcForm = laForms(lnI)
			If 'O' = Type (lcForm) and 'O' = VarType(&lcForm)
				&lcForm..DoRefresh()
			EndIf
		EndFor
		
	ENDPROC

	PROCEDURE registerwiththor
		Lparameters llQuiet
		Local lcFolder
		
		Try
			lcFolder = Execscript(_Screen.cThorDispatcher, 'Tool Folder= ')
		Catch
			lcFolder = ''
		Endtry
		
		If Directory(lcFolder) And Not Empty(lcFolder)
			This.CreateThorTools(llQuiet)
			Execscript(_Screen.cThorDispatcher, 'Run')
			Return .T.
		Else
			Return .F.
		Endif
		
	ENDPROC

	PROCEDURE release
		DoDefault()
		
		Try
			This.ClearTempFilesList()
		Catch
		
		EndTry
	ENDPROC

	PROCEDURE restorecontrolsincontainer
		Lparameters loMovedControls
		Local llNonDefault, lnI, lnLeft, loItem, loObject
		For lnI = 1 To loMovedControls.Count
			loItem		 = loMovedControls.Item[lnI]
			loObject	 = loItem.Object
			lnLeft		 = loItem.Left
			llNonDefault = loItem.NonDefault
		*** DH 2019-02-26: fixed bug: the logic to reset to default vs setting Left was reversed
			If llNonDefault
		***		loObject.ResetToDefault('Left')
				loObject.Left = lnLeft
			Else
		***		loObject.Left = lnLeft
				loObject.ResetToDefault('Left')
			Endif
		Endfor && lnI = 1 to loMovedControls.Count
		
	ENDPROC

	PROCEDURE restoremywindowname
		Local loTopOfForm AS Object
		
		With This
			loTopOfForm = This.FindTopMostParent()
		
			If 															;
					'L' # VarType(.cOriginalCaption)					;
					and 'O' = Vartype (loTopOfForm)						;
					and 'form' = Lower (loTopOfForm.BaseClass)			;
					And (Not loTopOfForm.Caption == .cOriginalCaption)	;
		
				loTopOfForm.Caption = .cOriginalCaption
				.cOriginalCaption	= .F.
		
			Endif
		
		Endwith
		
	ENDPROC

	PROCEDURE selectcompareclass
		Lparameters loObject
		
		Local loObject As Object
		Local loPaste As 'EditPropertyDialog' Of  'Source\EditProperty.vcx'
		Local lbContinue, lcAppPath
		
		With This
			.DontDisablePEMEditor (.T.)
		
			loPaste = Newobject ('frmCompareClass', 'Source\EditProperty.vcx', '',		;
				  0,																	;
				  0)
			loPaste.Show()
		
			If 'O' = Vartype (loPaste)
				lbContinue = loPaste.lPasteIt
				loPaste.Release
			Else
				lbContinue = .F.
			Endif
		
			.DontDisablePEMEditor (.F.)
		Endwith
		
		Return lbContinue
		
	ENDPROC

	PROCEDURE selectpastedproperties
		Lparameters toObject, tcCaption
		
		Local loObject As Object
		Local loPaste As 'EditPropertyDialog' Of  'Source\EditProperty.vcx'
		Local lbContinue, lcAppPath, lcCaption, loTopOfForm
		
		loObject = toObject
		If 'C' = Vartype (tcCaption)
			lcCaption = tcCaption
		Else
			lcCaption = 'Change parent class to ' + toObject.Class + ' of ' + Justfname (toObject.ClassLibrary)
		Endif
		
		loTopOfForm = This.FindTopMostParent ()
		With This
			.DontDisablePEMEditor (.T.)
		
			loPaste = Newobject ('frmPasteProperties', 'Source\EditProperty.vcx', '',		;
				  loObject,																	;
				  loObject = loTopOfForm,													;
				  This.lClass,																;
				  ,																			;
				  ,																			;
				  lcCaption)
			loPaste.Show()
		
			If 'O' = Vartype (loPaste)
				lbContinue = loPaste.lPasteIt
				loPaste.Release
			Else
				lbContinue = .F.
			Endif
		
			.DontDisablePEMEditor (.F.)
		Endwith
		
		Return lbContinue
		
	ENDPROC

	PROCEDURE setcurrentselectedobject
		Lparameters loObject, tlWindowAlreadyActive
		
		With This
			If 'O' = Vartype (.oPEMEditor)
				.oPEMEditor.SetCurrentSelectedObject (loObject)
			Else
				.FocusOnControl(loObject, tlWindowAlreadyActive)
				Declare Sleep In kernel32 Integer dwMilliseconds
				Sleep (25)
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE setfocustocontrol
		Lparameters toObject
		
		Local laObjects[1], laProperties[1], lcBaseClass, llContinue, loFocusObject, loObject, loSibling
		
		*** JRN 2024-04-06 : Is this object already selected?
		If 0 # Aselobj(laObjects) Or 0 # Aselobj(laObjects, 1)
			If 1 = Alen(m.laObjects) And m.laObjects[1] = m.toObject
				Return .T.
			Endif
		Endif
		
		*** JRN 2024-04-06 : a direct SetFocus may be all we need
		If This.SimpleSetFocus(m.toObject)
			Return .T.
		Endif
		
		*** JRN 2024-04-06 : Curiously, there are instances (pageframes) where it is possible
		*	to SetFocus on a sibling object, which MAY cause the desired page to become visible
		*	and then later processing (click borders) may select it.
		*	(But don't ask what the conditions are where this occurs)
		If Pemstatus(m.toObject, 'Parent', 5)
			For Each m.loSibling In m.toObject.Parent.Objects FoxObject
				If This.SimpleSetFocus(m.loSibling)
					Exit
				Endif
			Endfor
		Endif
		
		*** JRN 2024-04-06 : from before
		loObject	  = m.toObject
		loFocusObject = .Null.
		llContinue	  = .T.
		
		Do While m.llContinue
			lcBaseClass = Lower(Getpem(m.loObject, 'BaseClass'))
			Do Case
				Case m.lcBaseClass = 'grid'
					loFocusObject = m.loObject
				Case m.lcBaseClass =  'column'
					loFocusObject = .Null.
				Case Not Isnull(m.loFocusObject)
		
				Case Pemstatus(m.loObject, 'SetFocus', 5)
					loFocusObject = m.loObject
			Endcase
		
			Try
				loObject   = m.loObject.Parent
				llContinue = .T.
			Catch
				llContinue = .F.
			Endtry
		Enddo
		
		If Not Isnull(m.loFocusObject)
			Try
				m.loFocusObject.SetFocus()
			Catch
		
			Endtry
		Endif
		
		If 0 # Aselobj(laObjects) Or 0 # Aselobj(laObjects, 1)
			Return 1 = Alen(m.laObjects) And m.laObjects[1] = m.toObject
		Else
			Return .F.
		Endif
		
		
	ENDPROC

	PROCEDURE setonkeylabel
		Lparameters lcKey, lcMethod, lcDoThis
		Local lcCommand
		
		Try
			Do Case
				Case Not Empty (lcDoThis)
					On Key Label &lcKey 	&lcDoThis
				Case Not Empty (lcMethod)
					lcCommand = "_oPEMEditor." + lcMethod
					On Key Label &lcKey   	Evaluate(Iif("O" = Vartype(_oPEMEditor),  "&lcCommand", "0"))
				Otherwise
					On Key Label &lcKey
			Endcase
		Catch
		
		Endtry
		
	ENDPROC

	PROCEDURE setrefreshtimer
		Lparameters lnInterval
		
		If 'O' = Vartype (This.oPEMEditor)
			This.oPEMEditor.RefreshTimer.Interval = lnInterval
		Endif
		
		
	ENDPROC

	PROCEDURE setupforparentobjectclasses
		Lparameters lcClass, lcClassLib, loObject, loTopOfForm
		Local loResult AS 'Empty'
		Local lcBaseClass, lcClassName, lcParent 
		
		loResult = Createobject ('Empty')
		
		lcBaseClass = loObject.BaseClass
		Do While .T.
		
			Do Case
				Case loObject = loTopOfForm
					Exit && obviously at top of class/form
				Case This.Isreadonly (loObject, 'Name')
					* if name is read-only, continue -- must be part of parent class
				Case Inlist (Lower (loObject.BaseClass) + '#', 'page#', 'column#', 'optionbutton#', 'header#')
					* any of these baseclasses must be part of parent class ... #'s because of pageframe match
				Otherwise && for all others, we must be done
					Exit
			Endcase
		
			lcParent   = loObject.Parent.Name + IIf ( Empty (lcParent), '', '.' + lcParent)
			loObject   = loObject.Parent
			lcClassLib = loObject.ClassLibrary
			lcBaseClass = loObject.BaseClass
		Enddo
		
		lcClassName = loObject.Class
		
		Do Case
			Case Empty (lcParent)
		
			Case Not '.' $ lcParent
				lcParent = lcClassName
		
			Otherwise
				lcParent = lcClassName  + Substr (lcParent, At ('.', lcParent))
		
		Endcase
		
		AddProperty (loResult, 'Class', 	lcClass)
		AddProperty (loResult, 'ClassLib', 	lcClassLib)
		AddProperty (loResult, 'Parent', 	lcParent)
		AddProperty (loResult, 'BaseClass',	lcBaseClass)
		
		Return loResult
		
	ENDPROC

	PROCEDURE setwindowtitle
		Lparameters lcNewTitle
		
		lxResult = This.oEditorWin.FindWindow()
		
		If lxResult = -1
			Return
		EndIf
		
		This.oEditorWin.SetTitle(lcNewTitle)
		
	ENDPROC

	PROCEDURE showform
		Lparameters txForm, llCloseIfOpen
		
		Local lcFolder
		
		Do Case
		
			Case Isnull (txForm)
		
			Case Empty (txForm)
				Do Case
					Case 'O' # Vartype (This.oPEMEditor)
		
						If This.oPrefs.lStartFormattingForm And 'O' # Vartype (This.oFormatMenu)
							This.ShowForm ('FormatMenu')
						Endif
		
						If This.oPrefs.lStartDocTreeView And 'O' # Vartype (This.oDocTreeview)
							This.ShowForm (2)
						Endif
		
						This.oPEMEditor = Newobject ('FrmPEMEditor', 'Source\EditProperty.VCX', ''		;
							  , 1																		;
							  , This																	;
							  , This.oServer															;
							  , This.oPrefs																;
							  )
		
						This.oPEMEditor.Show()
		
					Case llCloseIfOpen
						This.oPEMEditor.Release()
		
					Otherwise
						This.oPEMEditor.Show()
		
				Endcase
		
			*!* ******************** Removed 4/26/2014 *****************
			*!* Case Upper (Transform (txForm)) == 'FORMATMENU'
			*!* 	Do Case
			*!* 		Case 'O' # Vartype (This.oFormatMenu)
			*!* 			This.oFormat	 = Newobject ('PEMEditor_Format', 	'Source\PEME_Format.VCX', '')
			*!* 			This.oFormatMenu = Newobject ('FrmFormatMenu', 		'Source\PEME_FormatMenu.VCX', '' ;
			*!* 				  , This.oFormat															;
			*!* 				  )
			*!* 			This.oFormatMenu.Show()
		
			*!* 		Case llCloseIfOpen
			*!* 			This.oFormatMenu.Release()
		
			*!* 		Otherwise
			*!* 			This.oFormatMenu.Show()
		
			*!* 	Endcase
		
			Case Upper (Transform (txForm)) == 'THOR'
		
				If Not This.RegisterWithThor()
					Messagebox ('Thor not installed')
				Endif
		
			Otherwise
				Do Case
					Case 'O' # Vartype (This.oDocTreeview)
						This.oDocTreeview = Newobject ('FrmPEMEditor', 'Source\EditProperty.VCX', ''	;
							  , 2																		;
							  , This																	;
							  , This.oServer															;
							  , This.oPrefs																;
							  )
						This.oDocTreeview.Show()
		
					Case llCloseIfOpen
						This.oDocTreeview.Release()
		
					Otherwise
						This.oDocTreeview.Show()
		
				Endcase
		
		Endcase
		
		This.oIDEx.CreateSystemMenu()
		
		DoEvents
		
	ENDPROC

	PROCEDURE simplesetfocus
		Lparameters toObject
		
		Local laObjects[1]
		
		If Isnull(m.toObject)
			Return .F.
		Endif
		
		Try
			loFocusObject.SetFocus()
		Catch
		
		Endtry
		
		If 0 # Aselobj(laObjects) Or 0 # Aselobj(laObjects, 1)
			Return 1 = Alen(m.laObjects) And m.laObjects[1] = m.toObject
		Else
			Return .F.
		Endif
	ENDPROC

	PROCEDURE str2val
		Lparameters tcStr, tbIsNativeColor
		
		*** JRN 11/13/2008 : following lifted from NewProperty
		* The only apparent failing is that it doesn't provide for values beginning with '='
		* which must be assigned using "WriteExpression"  (aha!  Agnes brought this up)
		
		* tcStr 			is value in edit box
		* tbIsNativeColor	is .T. for those native colors (BackColor, ForeColor, etc.) which can
		*					be entered as 192, 192, 192 -- but are stored as integers.
		
		Local luDefault, lcStr
		luDefault 	= tcStr
		lcStr		= Alltrim(tcStr)
		
		Do Case
			Case Empty(tcStr)
		
			Case Upper(lcStr) == '.F.' Or Upper(lcStr) == '.T.' Or Upper(lcStr) == '.NULL.' Or This.IsNumber(tcStr)
				luDefault = Evaluate(lcStr)
		
			Case '{' = Left(lcStr,1) And '}' = Right(lcStr,1) and not (IsAlpha(Alltrim(Substr(lcStr,2))) or '=' $ lcStr) 
				Try
					luDefault = Evaluate(lcStr)
				Catch
		
				Endtry
		
			Otherwise
			
				If tbIsNativeColor
					Try
						luDefault = Rgb (&tcStr)
					Catch
		
					Endtry
				Endif
		
		Endcase
		
		Return luDefault
		
	ENDPROC

	PROCEDURE thiscontroldeletable
		Lparameters loControl
		
		local loTopOfForm
		loTopOfForm = This.FindTopMostParent()
		
		Do Case
			Case loControl = loTopOfForm
				Return .F.
			Case Upper(loControl.BaseClass) = Upper('DataEnvironment')
				Return .F.
			Case Inlist(Lower (loControl.BaseClass), 'column', 'pageframe', 'optionbutton') ;
					and loTopOfForm # loControl.Parent
				Return Not This.GetPEMStatus (loControl.Parent, 'Name', 1)
			Case Lower (loControl.Parent.BaseClass) = 'column' And loTopOfForm # loControl.Parent.Parent
				Return Not This.GetPEMStatus (loControl.Parent.Parent, 'Name', 1)
			Otherwise
				Return Not This.GetPEMStatus (loControl, 'Name', 1)
		Endcase
		
		
	ENDPROC

	PROCEDURE timestamptodate
		*	Procedure TimeStampToDate
			*  METHOD: TimeStamp2Date()
			*
			*  AUTHOR: Richard A. Schummer            September 1994
			*
			*  COPYRIGHT (c) 1994-2001    Richard A. Schummer
			*     42759 Flis Dr  
			*     Sterling Heights, MI  48314-2850
			*     RSchummer@CompuServe.com
			*
			*  METHOD DESCRIPTION: 
			*     This procedure handles the conversion of the FoxPro TIMESTAMP field to 
			*     a readable (and understandable) date and time.  The procedure will return
			*     the date/time in three formats based on the cStyle parameter.  Timestamp 
			*     field is a 32-bit (numeric compressed) system that the FoxPro development
			*     team created to save on file space in the projects, screens, reports, and
			*     label databases.  This field is used to determine if objects need to be 
			*     recompiled (project manager), or syncronized across platforms (screens,
			*     reports, and labels).
			* 
			*  CALLING SYNTAX: 
			*     <variable> = ctrMetaDecode.TimeStamp2Date(<nTimeStamp>,<cStyle>)
			*
			*     Sample:
			*     ltDateTime = ctrMetaDecode.TimeStamp2Date(TimeStamp,"DATETIME")
			* 
			*  INPUT PARAMETERS: 
			*     nTimeStamp = Required field, must be numeric, no check to verify the
			*                  data passed is valid FoxPro Timestamp, just be sure it is
			*     cStyle     = Not required (defaults to "DATETIME"), must be character, 
			*                  and must be one of the following:
			*                   "DATETIME" will return the date/time in MM/DD/YY HH:MM:SS
			*                   "DATE"     will return the date in MM/DD/YY format
			*                   "TIME"     will return the time in HH:MM:SS format
			*
			*  OUTPUT PARAMETERS:
			*     lcRetval    = The date/time (in requested format) is returned in 
			*                   character type.  Must be converted and parsed to be
			*                   used as date type.
			*
		
		
			*=============================================================
			* Tried to use this FFC class, but it sometimes gave an error:
			* This.oFrxCursor.GetTimeStampString(timestamp)
			*=============================================================
		
		
			Lparameter tnTimeStamp, tcStyle
		
			Local lcRetVal, lnDay, lnHour, lnMinute, lnMonth, lnSecond, lnYear
		
			If Type ('tnTimeStamp') # 'N'          &&  Timestamp must be numeric
				Wait Window 'Time stamp passed is not numeric'
				Return ''
			Endif
		
			If tnTimeStamp = 0                     &&  Timestamp is zero until built in project
				Return 'Not built into App'
			Endif
		
			If Type ('tcStyle') # 'C'              &&  Default return style to both date and time
				tcStyle = 'DATETIME'
			Endif
		
			If Not Inlist (Upper (tcStyle), 'DATE', 'TIME', 'DATETIME')
				Wait Window 'Style parameter must be DATE, TIME, or DATETIME'
				Return ''
			Endif
		
			lnYear	= ((tnTimeStamp / (2 ** 25) + 1980))
			lnMonth	= ((lnYear - Int (lnYear)    ) * (2 ** 25)) / (2 ** 21)
			lnDay	= ((lnMonth - Int (lnMonth)  ) * (2 ** 21)) / (2 ** 16)
		
			lnHour	 = ((lnDay - Int (lnDay)      ) * (2 ** 16)) / (2 ** 11)
			lnMinute = ((lnHour - Int (lnHour)    ) * (2 ** 11)) / (2 ** 05)
			lnSecond = ((lnMinute - Int (lnMinute)) * (2 ** 05)) * 2       &&  Multiply by two to correct
			&&  truncation problem built in
			&&  to the creation algorithm
			&&  (Source: Microsoft Tech Support)
		
			lcRetVal = ''
		
			If 'DATE' $ Upper (tcStyle)
				*< 4-Feb-2001 Fixed to display date in machine designated format (Regional Settings)
				*< lcRetVal = lcRetVal + RIGHT("0"+ALLTRIM(STR(INT(lnMonth))),2) + "/" +  ;
				*<                       RIGHT("0"+ALLTRIM(STR(INT(lnDay))),2)   + "/" +  ;
				*<                       RIGHT("0"+ALLTRIM(STR(INT(lnYear))), IIF(SET("CENTURY") = "ON", 4, 2))
		
				*< RAS 23-Nov-2004, change to work around behavior change in VFP 9.
				*< lcRetVal = lcRetVal + DTOC(DATE(lnYear, lnMonth, lnDay))
				lcRetVal = lcRetVal + Dtoc (Date (Int (lnYear), Int (lnMonth), Int (lnDay)))
			Endif
		
			If 'TIME' $ Upper (tcStyle)
				lcRetVal = lcRetVal + IIf ('DATE' $ Upper (tcStyle), ' ', '')
				lcRetVal = lcRetVal + Right ('0' + Alltrim (Str (Int (lnHour))), 2)   + ':' +  ;
					Right ('0' + Alltrim (Str (Int (lnMinute))), 2) + ':' +					   ;
					Right ('0' + Alltrim (Str (Int (lnSecond))), 2)
			Endif
		
			Return lcRetVal
		
		*Endproc
		
		
	ENDPROC

	PROCEDURE viewhtmltempfile
		Lparameters lcFileName
		
		Local lcWindowName
		lcWindowName = Juststem (Justfname (lcFileName))
		Insert Into crsr_TempFiles (FileName, WindowName) Values (lcFileName, lcWindowName)
		
		*** JRN 12/18/2008 : if already being shown ... close it
		If Wexist (lcWindowName)
			Release Windows (lcWindowName)
		Endif
		
		*	Modify Command (lcFileName) Nowait Noedit Range 1,1
		This.OpenURL (lcFileName)
		
	ENDPROC

	PROCEDURE viewparentcode
		Lparameters lcMethodName, loObject, tlParentage, tlDefaultOnly
		
		*** JRN 12/01/2008 : export list of pems
		Local  ;
			loTopOfForm As Object
		Local lcFileName, lcObjectName, lcText, lcWindowName
		
		lcText = This.GetAllCode(loObject, lcMethodName, '', tlParentage, tlDefaultOnly)
		
		loTopOfForm	= This.FindTopMostParent ()
		lcObjectName = This.GetObjectPath(loObject)
		
		lcWindowName = loTopOfForm.Name + lcObjectName + '.' + Sys(2015) + ".Procedures.PRG"
		lcFileName = Sys(2023) + "\" + lcWindowName
		
		Strtofile (lcText, lcFileName, 0)
		
		****************************************************************
		
		This.ViewTempFile(lcFileName)
		
	ENDPROC

	PROCEDURE viewtempfile
		Lparameters lcFileName
		
		Local lcWindowName
		lcWindowName = Justfname (lcFileName)
		Insert Into crsr_TempFiles (FileName, WindowName) Values (lcFileName, lcWindowName)
		
		*** JRN 12/18/2008 : if already being shown ... close it
		If Wexist (lcWindowName)
			Release Windows (lcWindowName)
		Endif
		
		*	Modify Command (lcFileName) Nowait Noedit Range 1,1
		Modify Command (lcFileName) Nowait Range 1, 1
		
		With This
			If .oPrefs.lAutoMoveWindow
				.oIDEx.MoveWindow()
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE viewtempfiletext
		Lparameters lcWindowName, lcText
		Local lcFileName 
		
		lcFileName = Sys(2023) + '\' + lcWindowName + IIF('PRG' == Upper(JustExt(lcWindowName)), '', '.PRG')
		
		lcWindowName = Justfname (lcFileName)
		*** JRN 12/18/2008 : if already being shown ... close it
		If Wexist (lcWindowName)
			Release Windows (lcWindowName)
		Endif
		
		If File (lcFileName)
			Erase(lcFileName)
		Endif
		
		Strtofile (lcText, lcFileName, 0)
		
		This.ViewTempFile(lcFileName)
		
		
	ENDPROC

	PROCEDURE writememberdata
		Lparameters loXML
		
		Local lcXML, loTopOfForm
		loTopOfForm = This.FindTopMostParent()
		
		With This
			* Put the XML into _MemberData as long as it doesn't exceed the maximum length.
			lcXML = loXML.XML
			If Right (lcXML, 2) = ccCR + ccLF
				lcXML = Left (lcXML, Len (lcXML) - 2)
			Endif
		
			If Len (lcXML) >= cnMAX_MEMBER_DATA_SIZE
				Messagebox (ccLOC_STRING_TOO_LONG, MB_OK + MB_ICONEXCLAMATION,		;
					  IIF(PemStatus(loTopOfForm, 'Caption', 5), loTopOfForm.Caption, ccLOC_STRING_TOO_LONG))
			Else
				If Not This.GetPEMStatus (loTopOfForm, '_MemberData', 5)
					loTopOfForm.AddProperty ('_MemberData', '')
				Endif
				loTopOfForm._MemberData = lcXML
			Endif Len (lcXML) >= cnMAX_MEMBER_DATA_SIZE
		Endwith
		
	ENDPROC

ENDDEFINE
